This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**
- Files matching these patterns are excluded: **/*.gz, **/*.json, test/**, **/*.svg, **/__snapshots__/**, **/*.snap, **/abi/**, **/*.test.*, **/CHANGELOG.md, **/abis.*, src/celo, src/linea, src/op-stack, src/ens, src/zksync, src/account-abstraction, src/experimental, src/node, src/siwe, src/actions/public/**, src/utils/abi/**, src/utils/blob/**, src/utils/ccip/**, src/utils/cursor/**, src/utils/data/**, src/utils/encoding/**, src/utils/hash/**, src/utils/kzg/**, src/utils/lru.ts, src/utils/regex.ts, src/utils/siwe/**, src/utils/stateOverride.ts, src/utils/unit/**, src/utils/uid.ts, src/utils/wait.ts, src/chains/definitions/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  accounts/
    utils/
      parseAccount.ts
      privateKeyToAddress.ts
      publicKeyToAddress.ts
      sign.ts
      signAuthorization.ts
      signMessage.ts
      signTransaction.bench.ts
      signTransaction.ts
      signTypedData.bench.ts
      signTypedData.ts
    generateMnemonic.ts
    generatePrivateKey.ts
    hdKeyToAccount.ts
    index.ts
    mnemonicToAccount.ts
    privateKeyToAccount.ts
    toAccount.ts
    types.ts
    wordlists.ts
  actions/
    ens/
      getEnsAddress.bench.ts
      getEnsAddress.ts
      getEnsAvatar.ts
      getEnsName.bench.ts
      getEnsName.ts
      getEnsResolver.ts
      getEnsText.ts
    siwe/
      verifySiweMessage.ts
    test/
      dropTransaction.ts
      dumpState.ts
      getAutomine.ts
      getTxpoolContent.ts
      getTxpoolStatus.ts
      impersonateAccount.ts
      increaseTime.ts
      inspectTxpool.ts
      loadState.ts
      mine.ts
      removeBlockTimestampInterval.ts
      reset.ts
      revert.ts
      sendUnsignedTransaction.ts
      setAutomine.ts
      setBalance.ts
      setBlockGasLimit.ts
      setBlockTimestampInterval.ts
      setCode.ts
      setCoinbase.ts
      setIntervalMining.ts
      setLoggingEnabled.ts
      setMinGasPrice.ts
      setNextBlockBaseFeePerGas.ts
      setNextBlockTimestamp.ts
      setNonce.ts
      setRpcUrl.ts
      setStorageAt.ts
      snapshot.ts
      stopImpersonatingAccount.ts
    wallet/
      addChain.ts
      deployContract.test-d.ts
      deployContract.ts
      getAddresses.ts
      getCallsStatus.ts
      getCapabilities.ts
      getPermissions.ts
      prepareAuthorization.ts
      prepareTransactionRequest.test-d.ts
      prepareTransactionRequest.ts
      requestAddresses.ts
      requestPermissions.ts
      sendCalls.ts
      sendRawTransaction.ts
      sendTransaction.bench.ts
      sendTransaction.test-d.ts
      sendTransaction.ts
      showCallsStatus.ts
      signAuthorization.ts
      signMessage.ts
      signTransaction.test-d.ts
      signTransaction.ts
      signTypedData.test-d.ts
      signTypedData.ts
      switchChain.ts
      waitForCallsStatus.ts
      watchAsset.ts
      writeContract.test-d.ts
      writeContract.ts
    getContract.bench.ts
    getContract.test-d.ts
    getContract.ts
    index.ts
  chains/
    index.ts
    utils.ts
  clients/
    decorators/
      public.ts
      test.ts
      wallet.ts
    transports/
      createTransport.ts
      custom.ts
      fallback.ts
      http.ts
      ipc.ts
      webSocket.ts
    createClient.test-d.ts
    createClient.ts
    createPublicClient.bench-d.ts
    createPublicClient.test-d.ts
    createPublicClient.ts
    createTestClient.bench-d.ts
    createTestClient.test-d.ts
    createTestClient.ts
    createWalletClient.bench-d.ts
    createWalletClient.test-d.ts
    createWalletClient.ts
  constants/
    address.ts
    blob.ts
    bytes.ts
    contract.ts
    contracts.ts
    kzg.ts
    number.ts
    solidity.ts
    strings.ts
    unit.ts
  errors/
    abi.ts
    account.ts
    address.ts
    base.ts
    blob.ts
    block.ts
    ccip.ts
    chain.ts
    contract.ts
    cursor.ts
    data.ts
    eip712.ts
    encoding.ts
    ens.ts
    estimateGas.ts
    fee.ts
    log.ts
    node.ts
    request.ts
    rpc.ts
    siwe.ts
    stateOverride.ts
    transaction.ts
    transport.ts
    typedData.ts
    unit.ts
    utils.ts
    version.ts
  nonce/
    index.ts
  types/
    account.ts
    authorization.ts
    block.ts
    calls.ts
    chain.test-d.ts
    chain.ts
    contract.test-d.ts
    contract.ts
    eip1193.test-d.ts
    eip1193.ts
    eip4844.ts
    ens.ts
    fee.ts
    filter.ts
    kzg.ts
    log.ts
    misc.ts
    multicall.ts
    proof.ts
    rpc.ts
    stateOverride.ts
    transaction.ts
    transport.test-d.ts
    transport.ts
    typedData.ts
    utils.test-d.ts
    utils.ts
    window.ts
    withdrawal.ts
  utils/
    address/
      getAddress.bench.ts
      getAddress.ts
      getContractAddress.bench.ts
      getContractAddress.ts
      isAddress.bench.ts
      isAddress.ts
      isAddressEqual.ts
    authorization/
      hashAuthorization.ts
      recoverAuthorizationAddress.ts
      serializeAuthorizationList.ts
      verifyAuthorization.ts
    chain/
      assertCurrentChain.ts
      defineChain.ts
      extractChain.ts
      getChainContractAddress.ts
    ens/
      avatar/
        parseAvatarRecord.ts
        utils.ts
      encodedLabelToLabelhash.ts
      encodeLabelhash.ts
      errors.ts
      labelhash.ts
      localBatchGatewayRequest.ts
      namehash.ts
      normalize.ts
      packetToBytes.ts
    errors/
      getCallError.ts
      getContractError.ts
      getEstimateGasError.ts
      getNodeError.ts
      getTransactionError.ts
    filters/
      createFilterRequestScope.ts
    formatters/
      block.ts
      extract.ts
      feeHistory.ts
      formatter.ts
      log.ts
      proof.ts
      transaction.ts
      transactionReceipt.ts
      transactionRequest.ts
    promise/
      createBatchScheduler.ts
      withCache.ts
      withDedupe.ts
      withResolvers.ts
      withRetry.ts
      withTimeout.ts
    rpc/
      compat.ts
      http.ts
      id.ts
      ipc.ts
      socket.ts
      webSocket.ts
    signature/
      compactSignatureToSignature.ts
      hashMessage.ts
      hashTypedData.ts
      isErc6492Signature.ts
      parseCompactSignature.ts
      parseErc6492Signature.ts
      parseSignature.ts
      recoverAddress.ts
      recoverMessageAddress.ts
      recoverPublicKey.ts
      recoverTransactionAddress.ts
      recoverTypedDataAddress.ts
      serializeCompactSignature.ts
      serializeErc6492Signature.ts
      serializeSignature.ts
      signatureToCompactSignature.ts
      toPrefixedMessage.ts
      verifyHash.ts
      verifyMessage.ts
      verifyTypedData.ts
    transaction/
      assertRequest.ts
      assertTransaction.ts
      getSerializedTransactionType.ts
      getTransactionType.test-d.ts
      getTransactionType.ts
      parseTransaction.bench.ts
      parseTransaction.ts
      serializeAccessList.ts
      serializeTransaction.bench.ts
      serializeTransaction.ts
    buildRequest.ts
    ccip.ts
    cursor.ts
    getAction.ts
    index.ts
    nonceManager.ts
    observe.ts
    poll.ts
    stringify.ts
    typedData.ts
  window/
    index.ts
  index.ts
  LICENSE
  README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/accounts/utils/parseAccount.ts">
import type { Address } from 'abitype'

import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../types.js'

export type ParseAccountErrorType = ErrorType

export function parseAccount<accountOrAddress extends Address | Account>(
  account: accountOrAddress,
): accountOrAddress extends Address ? Account : accountOrAddress {
  if (typeof account === 'string')
    return { address: account, type: 'json-rpc' } as any
  return account as any
}
</file>

<file path="src/accounts/utils/privateKeyToAddress.ts">
import { secp256k1 } from '@noble/curves/secp256k1'
import type { Address } from 'abitype'

import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import {
  type BytesToHexErrorType,
  bytesToHex,
} from '../../utils/encoding/toHex.js'
import {
  type PublicKeyToAddressErrorType,
  publicKeyToAddress,
} from './publicKeyToAddress.js'

export type PrivateKeyToAddressErrorType =
  | BytesToHexErrorType
  | PublicKeyToAddressErrorType
  | ErrorType

/**
 * @description Converts an ECDSA private key to an address.
 *
 * @param privateKey The private key to convert.
 *
 * @returns The address.
 */
export function privateKeyToAddress(privateKey: Hex): Address {
  const publicKey = bytesToHex(
    secp256k1.getPublicKey(privateKey.slice(2), false),
  )
  return publicKeyToAddress(publicKey)
}
</file>

<file path="src/accounts/utils/publicKeyToAddress.ts">
import type { Address } from 'abitype'

import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import {
  type ChecksumAddressErrorType,
  checksumAddress,
} from '../../utils/address/getAddress.js'
import {
  type Keccak256ErrorType,
  keccak256,
} from '../../utils/hash/keccak256.js'

export type PublicKeyToAddressErrorType =
  | ChecksumAddressErrorType
  | Keccak256ErrorType
  | ErrorType

/**
 * @description Converts an ECDSA public key to an address.
 *
 * @param publicKey The public key to convert.
 *
 * @returns The address.
 */
export function publicKeyToAddress(publicKey: Hex): Address {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26)
  return checksumAddress(`0x${address}`) as Address
}
</file>

<file path="src/accounts/utils/sign.ts">
// TODO(v3): Convert to sync.

import { secp256k1 } from '@noble/curves/secp256k1'

import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import {
  type NumberToHexErrorType,
  numberToHex,
} from '../../utils/encoding/toHex.js'
import { serializeSignature } from '../../utils/signature/serializeSignature.js'

type To = 'object' | 'bytes' | 'hex'

export type SignParameters<to extends To = 'object'> = {
  hash: Hex
  privateKey: Hex
  to?: to | To | undefined
}

export type SignReturnType<to extends To = 'object'> =
  | (to extends 'object' ? Signature : never)
  | (to extends 'bytes' ? ByteArray : never)
  | (to extends 'hex' ? Hex : never)

export type SignErrorType = NumberToHexErrorType | ErrorType

let extraEntropy: Hex | boolean = false

/**
 * Sets extra entropy for signing functions.
 */
export function setSignEntropy(entropy: true | Hex) {
  if (!entropy) throw new Error('must be a `true` or a hex value.')
  extraEntropy = entropy
}

/**
 * @description Signs a hash with a given private key.
 *
 * @param hash The hash to sign.
 * @param privateKey The private key to sign with.
 *
 * @returns The signature.
 */
export async function sign<to extends To = 'object'>({
  hash,
  privateKey,
  to = 'object',
}: SignParameters<to>): Promise<SignReturnType<to>> {
  const { r, s, recovery } = secp256k1.sign(
    hash.slice(2),
    privateKey.slice(2),
    { lowS: true, extraEntropy },
  )
  const signature = {
    r: numberToHex(r, { size: 32 }),
    s: numberToHex(s, { size: 32 }),
    v: recovery ? 28n : 27n,
    yParity: recovery,
  }
  return (() => {
    if (to === 'bytes' || to === 'hex')
      return serializeSignature({ ...signature, to })
    return signature
  })() as SignReturnType<to>
}
</file>

<file path="src/accounts/utils/signAuthorization.ts">
import type { ErrorType } from '../../errors/utils.js'
import type {
  AuthorizationRequest,
  SignedAuthorization,
} from '../../types/authorization.js'
import type { Hex, Signature } from '../../types/misc.js'
import type { Prettify } from '../../types/utils.js'
import {
  type HashAuthorizationErrorType,
  hashAuthorization,
} from '../../utils/authorization/hashAuthorization.js'
import {
  type SignErrorType,
  type SignParameters,
  type SignReturnType,
  sign,
} from './sign.js'

type To = 'object' | 'bytes' | 'hex'

export type SignAuthorizationParameters<to extends To = 'object'> =
  AuthorizationRequest & {
    /** The private key to sign with. */
    privateKey: Hex
    to?: SignParameters<to>['to'] | undefined
  }

export type SignAuthorizationReturnType<to extends To = 'object'> = Prettify<
  to extends 'object' ? SignedAuthorization : SignReturnType<to>
>

export type SignAuthorizationErrorType =
  | SignErrorType
  | HashAuthorizationErrorType
  | ErrorType

/**
 * Signs an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.
 */
export async function signAuthorization<to extends To = 'object'>(
  parameters: SignAuthorizationParameters<to>,
): Promise<SignAuthorizationReturnType<to>> {
  const { chainId, nonce, privateKey, to = 'object' } = parameters
  const address = parameters.contractAddress ?? parameters.address
  const signature = await sign({
    hash: hashAuthorization({ address, chainId, nonce }),
    privateKey,
    to,
  })
  if (to === 'object')
    return {
      address,
      chainId,
      nonce,
      ...(signature as Signature),
    } as any
  return signature as any
}
</file>

<file path="src/accounts/utils/signMessage.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Hex, SignableMessage } from '../../types/misc.js'
import {
  type HashMessageErrorType,
  hashMessage,
} from '../../utils/signature/hashMessage.js'

import { type SignErrorType, sign } from './sign.js'

export type SignMessageParameters = {
  /** The message to sign. */
  message: SignableMessage
  /** The private key to sign with. */
  privateKey: Hex
}

export type SignMessageReturnType = Hex

export type SignMessageErrorType =
  | SignErrorType
  | HashMessageErrorType
  | ErrorType

/**
 * @description Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):
 * `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * @returns The signature.
 */
export async function signMessage({
  message,
  privateKey,
}: SignMessageParameters): Promise<SignMessageReturnType> {
  return await sign({ hash: hashMessage(message), privateKey, to: 'hex' })
}
</file>

<file path="src/accounts/utils/signTransaction.bench.ts">
import { Wallet } from 'ethers'

import { bench, describe } from 'vitest'

import { accounts } from '~test/src/constants.js'
import type { TransactionSerializableBase } from '../../types/transaction.js'
import { parseEther } from '../../utils/unit/parseEther.js'

import { signTransaction } from './signTransaction.js'

const base = {
  to: accounts[1].address,
  nonce: 785,
  value: parseEther('1'),
} satisfies TransactionSerializableBase

const wallet = new Wallet(accounts[0].privateKey)

describe('Sign Transaction (Legacy)', () => {
  bench('viem: `serializeTransaction`', async () => {
    await signTransaction({
      transaction: { ...base, gasPrice: 1n },
      privateKey: accounts[0].privateKey,
    })
  })

  bench('ethers: `Wallet.signTransaction`', async () => {
    await wallet.signTransaction({ ...base, gasPrice: 1n, type: 0 })
  })
})

describe('Sign Transaction (EIP1559)', () => {
  bench('viem: `signTransaction`', async () => {
    await signTransaction({
      transaction: { ...base, chainId: 1, maxFeePerGas: 1n },
      privateKey: accounts[0].privateKey,
    })
  })

  bench('ethers: `Wallet.signTransaction`', async () => {
    await wallet.signTransaction({
      ...base,
      chainId: 1,
      maxFeePerGas: 1n,
      type: 2,
    })
  })
})

describe('Sign Transaction (EIP2930)', () => {
  bench('viem: `signTransaction`', async () => {
    await signTransaction({
      transaction: { ...base, chainId: 1, gasPrice: 1n, accessList: [] },
      privateKey: accounts[0].privateKey,
    })
  })

  bench('ethers: `Wallet.signTransaction`', async () => {
    await wallet.signTransaction({
      ...base,
      chainId: 1,
      maxFeePerGas: 1n,
      type: 2,
    })
  })
})
</file>

<file path="src/accounts/utils/signTransaction.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import type {
  TransactionSerializable,
  TransactionSerialized,
} from '../../types/transaction.js'
import {
  type Keccak256ErrorType,
  keccak256,
} from '../../utils/hash/keccak256.js'
import type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'
import {
  type SerializeTransactionFn,
  serializeTransaction,
} from '../../utils/transaction/serializeTransaction.js'

import { type SignErrorType, sign } from './sign.js'

export type SignTransactionParameters<
  serializer extends
    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,
  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],
> = {
  privateKey: Hex
  transaction: transaction
  serializer?: serializer | undefined
}

export type SignTransactionReturnType<
  serializer extends
    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,
  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],
> = TransactionSerialized<GetTransactionType<transaction>>

export type SignTransactionErrorType =
  | Keccak256ErrorType
  | SignErrorType
  | ErrorType

export async function signTransaction<
  serializer extends
    SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,
  transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],
>(
  parameters: SignTransactionParameters<serializer, transaction>,
): Promise<SignTransactionReturnType<serializer, transaction>> {
  const {
    privateKey,
    transaction,
    serializer = serializeTransaction,
  } = parameters

  const signableTransaction = (() => {
    // For EIP-4844 Transactions, we want to sign the transaction payload body (tx_payload_body) without the sidecars (ie. without the network wrapper).
    // See: https://github.com/ethereum/EIPs/blob/e00f4daa66bd56e2dbd5f1d36d09fd613811a48b/EIPS/eip-4844.md#networking
    if (transaction.type === 'eip4844')
      return {
        ...transaction,
        sidecars: false,
      }
    return transaction
  })()

  const signature = await sign({
    hash: keccak256(serializer(signableTransaction)),
    privateKey,
  })
  return serializer(transaction, signature) as SignTransactionReturnType<
    serializer,
    transaction
  >
}
</file>

<file path="src/accounts/utils/signTypedData.bench.ts">
import { Wallet } from 'ethers'
import { bench, describe } from 'vitest'

import { accounts, typedData } from '~test/src/constants.js'

import { signTypedData } from './signTypedData.js'

const wallet = new Wallet(accounts[0].privateKey)

describe('Sign Typed Data', () => {
  bench('viem: `signTypedData`', async () => {
    await signTypedData({
      ...typedData.complex,
      primaryType: 'Mail',
      privateKey: accounts[0].privateKey,
    })
  })

  bench('ethers: `Wallet.signTypedData`', async () => {
    await wallet.signTypedData(
      typedData.complex.domain,
      typedData.complex.types as any,
      typedData.complex.message,
    )
  })
})
</file>

<file path="src/accounts/utils/signTypedData.ts">
import type { TypedData } from 'abitype'

import type { Hex } from '../../types/misc.js'
import type { TypedDataDefinition } from '../../types/typedData.js'
import {
  type HashTypedDataErrorType,
  hashTypedData,
} from '../../utils/signature/hashTypedData.js'

import type { ErrorType } from '../../errors/utils.js'
import { type SignErrorType, sign } from './sign.js'

export type SignTypedDataParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
> = TypedDataDefinition<typedData, primaryType> & {
  /** The private key to sign with. */
  privateKey: Hex
}

export type SignTypedDataReturnType = Hex

export type SignTypedDataErrorType =
  | HashTypedDataErrorType
  | SignErrorType
  | ErrorType

/**
 * @description Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191):
 * `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * @returns The signature.
 */
export async function signTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  parameters: SignTypedDataParameters<typedData, primaryType>,
): Promise<SignTypedDataReturnType> {
  const { privateKey, ...typedData } =
    parameters as unknown as SignTypedDataParameters
  return await sign({
    hash: hashTypedData(typedData),
    privateKey,
    to: 'hex',
  })
}
</file>

<file path="src/accounts/generateMnemonic.ts">
import { generateMnemonic as generateMnemonic_ } from '@scure/bip39'
import type { ErrorType } from '../errors/utils.js'

export type GenerateMnemonicErrorType = ErrorType

/**
 * @description Generates a random mnemonic phrase with a given wordlist.
 *
 * @param wordlist The wordlist to use for generating the mnemonic phrase.
 * @param strength mnemonic strength 128-256 bits
 *
 * @returns A randomly generated mnemonic phrase.
 */
export function generateMnemonic(
  wordlist: string[],
  strength?: number | undefined,
): string {
  return generateMnemonic_(wordlist, strength)
}
</file>

<file path="src/accounts/generatePrivateKey.ts">
import { secp256k1 } from '@noble/curves/secp256k1'

import type { ErrorType } from '../errors/utils.js'
import type { Hex } from '../types/misc.js'
import { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'

export type GeneratePrivateKeyErrorType = ToHexErrorType | ErrorType

/**
 * @description Generates a random private key.
 *
 * @returns A randomly generated private key.
 */
export function generatePrivateKey(): Hex {
  return toHex(secp256k1.utils.randomPrivateKey())
}
</file>

<file path="src/accounts/hdKeyToAccount.ts">
import { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'

import type { ErrorType } from '../errors/utils.js'
import type { HDKey } from '../types/account.js'
import {
  type PrivateKeyToAccountErrorType,
  type PrivateKeyToAccountOptions,
  privateKeyToAccount,
} from './privateKeyToAccount.js'
import type { HDAccount, HDOptions } from './types.js'

export type HDKeyToAccountOptions = HDOptions & PrivateKeyToAccountOptions

export type HDKeyToAccountErrorType =
  | PrivateKeyToAccountErrorType
  | ToHexErrorType
  | ErrorType

/**
 * @description Creates an Account from a HD Key.
 *
 * @returns A HD Account.
 */
export function hdKeyToAccount(
  hdKey_: HDKey,
  {
    accountIndex = 0,
    addressIndex = 0,
    changeIndex = 0,
    path,
    ...options
  }: HDKeyToAccountOptions = {},
): HDAccount {
  const hdKey = hdKey_.derive(
    path || `m/44'/60'/${accountIndex}'/${changeIndex}/${addressIndex}`,
  )
  const account = privateKeyToAccount(toHex(hdKey.privateKey!), options)
  return {
    ...account,
    getHdKey: () => hdKey,
    source: 'hd',
  }
}
</file>

<file path="src/accounts/index.ts">
export type { Address } from 'abitype'

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export { HDKey } from '@scure/bip32'

export {
  czech,
  english,
  french,
  italian,
  japanese,
  korean,
  portuguese,
  simplifiedChinese,
  spanish,
  traditionalChinese,
} from './wordlists.js'

export {
  type GenerateMnemonicErrorType,
  generateMnemonic,
} from './generateMnemonic.js'
export {
  type GeneratePrivateKeyErrorType,
  generatePrivateKey,
} from './generatePrivateKey.js'
export {
  type HDKeyToAccountOptions,
  type HDKeyToAccountErrorType,
  hdKeyToAccount,
} from './hdKeyToAccount.js'
export {
  type MnemonicToAccountOptions,
  type MnemonicToAccountErrorType,
  mnemonicToAccount,
} from './mnemonicToAccount.js'
export {
  type PrivateKeyToAccountOptions,
  type PrivateKeyToAccountErrorType,
  privateKeyToAccount,
} from './privateKeyToAccount.js'
export { type ToAccountErrorType, toAccount } from './toAccount.js'

export type {
  Account,
  AccountSource,
  CustomSource,
  HDOptions,
  JsonRpcAccount,
  LocalAccount,
  HDAccount,
  PrivateKeyAccount,
} from './types.js'
export {
  type SignErrorType,
  type SignParameters,
  type SignReturnType,
  setSignEntropy,
  sign,
} from './utils/sign.js'
export {
  /** @deprecated Use `SignatureToHexErrorType` instead. */
  type SerializeSignatureErrorType as SignatureToHexErrorType,
  /** @deprecated Use `serializeSignature` instead. */
  serializeSignature as signatureToHex,
  type SerializeSignatureErrorType,
  serializeSignature,
} from '../utils/signature/serializeSignature.js'
export {
  type SignAuthorizationErrorType,
  type SignAuthorizationParameters,
  type SignAuthorizationReturnType,
  signAuthorization,
} from './utils/signAuthorization.js'
export {
  type SignMessageErrorType,
  type SignMessageParameters,
  type SignMessageReturnType,
  signMessage,
} from './utils/signMessage.js'
export {
  type SignTransactionErrorType,
  type SignTransactionParameters,
  type SignTransactionReturnType,
  signTransaction,
} from './utils/signTransaction.js'
export {
  type SignTypedDataErrorType,
  type SignTypedDataParameters,
  type SignTypedDataReturnType,
  signTypedData,
} from './utils/signTypedData.js'
export {
  type ParseAccountErrorType,
  parseAccount,
} from './utils/parseAccount.js'
export {
  type PublicKeyToAddressErrorType,
  publicKeyToAddress,
} from './utils/publicKeyToAddress.js'
export {
  type PrivateKeyToAddressErrorType,
  privateKeyToAddress,
} from './utils/privateKeyToAddress.js'
export {
  type CreateNonceManagerParameters,
  type NonceManager,
  type NonceManagerSource,
  createNonceManager,
  nonceManager,
} from '../utils/nonceManager.js'
</file>

<file path="src/accounts/mnemonicToAccount.ts">
import { HDKey } from '@scure/bip32'
import { mnemonicToSeedSync } from '@scure/bip39'

import type { ErrorType } from '../errors/utils.js'
import {
  type HDKeyToAccountErrorType,
  type HDKeyToAccountOptions,
  hdKeyToAccount,
} from './hdKeyToAccount.js'
import type { HDAccount } from './types.js'

export type MnemonicToAccountOptions = HDKeyToAccountOptions

export type MnemonicToAccountErrorType = HDKeyToAccountErrorType | ErrorType

/**
 * @description Creates an Account from a mnemonic phrase.
 *
 * @returns A HD Account.
 */
export function mnemonicToAccount(
  mnemonic: string,
  opts: MnemonicToAccountOptions = {},
): HDAccount {
  const seed = mnemonicToSeedSync(mnemonic)
  return hdKeyToAccount(HDKey.fromMasterSeed(seed), opts)
}
</file>

<file path="src/accounts/privateKeyToAccount.ts">
import { secp256k1 } from '@noble/curves/secp256k1'

import type { Hex } from '../types/misc.js'
import { type ToHexErrorType, toHex } from '../utils/encoding/toHex.js'

import type { ErrorType } from '../errors/utils.js'
import type { NonceManager } from '../utils/nonceManager.js'
import { type ToAccountErrorType, toAccount } from './toAccount.js'
import type { PrivateKeyAccount } from './types.js'
import {
  type PublicKeyToAddressErrorType,
  publicKeyToAddress,
} from './utils/publicKeyToAddress.js'
import { type SignErrorType, sign } from './utils/sign.js'
import { signAuthorization } from './utils/signAuthorization.js'
import { type SignMessageErrorType, signMessage } from './utils/signMessage.js'
import {
  type SignTransactionErrorType,
  signTransaction,
} from './utils/signTransaction.js'
import {
  type SignTypedDataErrorType,
  signTypedData,
} from './utils/signTypedData.js'

export type PrivateKeyToAccountOptions = {
  nonceManager?: NonceManager | undefined
}

export type PrivateKeyToAccountErrorType =
  | ToAccountErrorType
  | ToHexErrorType
  | PublicKeyToAddressErrorType
  | SignErrorType
  | SignMessageErrorType
  | SignTransactionErrorType
  | SignTypedDataErrorType
  | ErrorType

/**
 * @description Creates an Account from a private key.
 *
 * @returns A Private Key Account.
 */
export function privateKeyToAccount(
  privateKey: Hex,
  options: PrivateKeyToAccountOptions = {},
): PrivateKeyAccount {
  const { nonceManager } = options
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false))
  const address = publicKeyToAddress(publicKey)

  const account = toAccount({
    address,
    nonceManager,
    async sign({ hash }) {
      return sign({ hash, privateKey, to: 'hex' })
    },
    async signAuthorization(authorization) {
      return signAuthorization({ ...authorization, privateKey })
    },
    async signMessage({ message }) {
      return signMessage({ message, privateKey })
    },
    async signTransaction(transaction, { serializer } = {}) {
      return signTransaction({ privateKey, transaction, serializer })
    },
    async signTypedData(typedData) {
      return signTypedData({ ...typedData, privateKey } as any)
    },
  })

  return {
    ...account,
    publicKey,
    source: 'privateKey',
  } as PrivateKeyAccount
}
</file>

<file path="src/accounts/toAccount.ts">
// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).

import type { Address } from 'abitype'

import {
  InvalidAddressError,
  type InvalidAddressErrorType,
} from '../errors/address.js'
import {
  type IsAddressErrorType,
  isAddress,
} from '../utils/address/isAddress.js'

import type { ErrorType } from '../errors/utils.js'
import type {
  AccountSource,
  CustomSource,
  JsonRpcAccount,
  LocalAccount,
} from './types.js'

type GetAccountReturnType<accountSource extends AccountSource> =
  | (accountSource extends Address ? JsonRpcAccount : never)
  | (accountSource extends CustomSource ? LocalAccount : never)

export type ToAccountErrorType =
  | InvalidAddressErrorType
  | IsAddressErrorType
  | ErrorType

/**
 * @description Creates an Account from a custom signing implementation.
 *
 * @returns A Local Account.
 */
export function toAccount<accountSource extends AccountSource>(
  source: accountSource,
): GetAccountReturnType<accountSource> {
  if (typeof source === 'string') {
    if (!isAddress(source, { strict: false }))
      throw new InvalidAddressError({ address: source })
    return {
      address: source,
      type: 'json-rpc',
    } as GetAccountReturnType<accountSource>
  }

  if (!isAddress(source.address, { strict: false }))
    throw new InvalidAddressError({ address: source.address })
  return {
    address: source.address,
    nonceManager: source.nonceManager,
    sign: source.sign,
    signAuthorization: source.signAuthorization,
    signMessage: source.signMessage,
    signTransaction: source.signTransaction,
    signTypedData: source.signTypedData,
    source: 'custom',
    type: 'local',
  } as GetAccountReturnType<accountSource>
}
</file>

<file path="src/accounts/types.ts">
import type { Address, TypedData } from 'abitype'

import type { SmartAccount } from '../account-abstraction/accounts/types.js'
import type { HDKey } from '../types/account.js'
import type { AuthorizationRequest } from '../types/authorization.js'
import type { Hash, Hex, SignableMessage } from '../types/misc.js'
import type {
  TransactionSerializable,
  TransactionSerialized,
} from '../types/transaction.js'
import type { TypedDataDefinition } from '../types/typedData.js'
import type { IsNarrowable, OneOf, Prettify } from '../types/utils.js'
import type { NonceManager } from '../utils/nonceManager.js'
import type { GetTransactionType } from '../utils/transaction/getTransactionType.js'
import type { SerializeTransactionFn } from '../utils/transaction/serializeTransaction.js'
import type { SignAuthorizationReturnType } from './utils/signAuthorization.js'

export type Account<address extends Address = Address> = OneOf<
  JsonRpcAccount<address> | LocalAccount<string, address> | SmartAccount
>

///////////////////////////////////////////////////////////////////////////////////////////////////
// Sources
///////////////////////////////////////////////////////////////////////////////////////////////////

export type AccountSource = Address | CustomSource
export type CustomSource = {
  address: Address
  nonceManager?: NonceManager | undefined
  // TODO(v3): Make `sign` required.
  sign?: ((parameters: { hash: Hash }) => Promise<Hex>) | undefined
  signAuthorization?:
    | ((
        parameters: AuthorizationRequest,
      ) => Promise<SignAuthorizationReturnType>)
    | undefined
  signMessage: ({ message }: { message: SignableMessage }) => Promise<Hex>
  signTransaction: <
    serializer extends
      SerializeTransactionFn<TransactionSerializable> = SerializeTransactionFn<TransactionSerializable>,
    transaction extends Parameters<serializer>[0] = Parameters<serializer>[0],
  >(
    transaction: transaction,
    options?:
      | {
          serializer?: serializer | undefined
        }
      | undefined,
  ) => Promise<
    IsNarrowable<
      TransactionSerialized<GetTransactionType<transaction>>,
      Hex
    > extends true
      ? TransactionSerialized<GetTransactionType<transaction>>
      : Hex
  >
  signTypedData: <
    const typedData extends TypedData | Record<string, unknown>,
    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
  >(
    parameters: TypedDataDefinition<typedData, primaryType>,
  ) => Promise<Hex>
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// Accounts
///////////////////////////////////////////////////////////////////////////////////////////////////

export type JsonRpcAccount<address extends Address = Address> = {
  address: address
  type: 'json-rpc'
}

export type LocalAccount<
  source extends string = string,
  address extends Address = Address,
> = Prettify<
  CustomSource & {
    address: address
    publicKey: Hex
    source: source
    type: 'local'
  }
>

export type HDAccount = Prettify<
  LocalAccount<'hd'> & {
    getHdKey(): HDKey
    // TODO(v3): This will be redundant.
    sign: NonNullable<CustomSource['sign']>
  }
>

export type HDOptions =
  | {
      /** The account index to use in the path (`"m/44'/60'/${accountIndex}'/0/0"`). */
      accountIndex?: number | undefined
      /** The address index to use in the path (`"m/44'/60'/0'/0/${addressIndex}"`). */
      addressIndex?: number | undefined
      /** The change index to use in the path (`"m/44'/60'/0'/${changeIndex}/0"`). */
      changeIndex?: number | undefined
      path?: undefined
    }
  | {
      accountIndex?: undefined
      addressIndex?: undefined
      changeIndex?: undefined
      /** The HD path. */
      path: `m/44'/60'/${string}`
    }

export type PrivateKeyAccount = Prettify<
  LocalAccount<'privateKey'> & {
    // TODO(v3): This will be redundant.
    sign: NonNullable<CustomSource['sign']>
    signAuthorization: NonNullable<CustomSource['signAuthorization']>
  }
>
</file>

<file path="src/accounts/wordlists.ts">
// biome-ignore lint/performance/noBarrelFile:
export { wordlist as czech } from '@scure/bip39/wordlists/czech'
export { wordlist as english } from '@scure/bip39/wordlists/english'
export { wordlist as french } from '@scure/bip39/wordlists/french'
export { wordlist as italian } from '@scure/bip39/wordlists/italian'
export { wordlist as japanese } from '@scure/bip39/wordlists/japanese'
export { wordlist as korean } from '@scure/bip39/wordlists/korean'
export { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese'
export { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese'
export { wordlist as spanish } from '@scure/bip39/wordlists/spanish'
export { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese'
</file>

<file path="src/actions/ens/getEnsAddress.bench.ts">
import { beforeAll, bench, describe } from 'vitest'

import { ethersProvider } from '~test/src/bench.js'

import { anvilMainnet } from '../../../test/src/anvil.js'

import { reset } from '../test/reset.js'
import { getEnsAddress } from './getEnsAddress.js'

const client = anvilMainnet.getClient()

beforeAll(async () => {
  await reset(client, {
    blockNumber: 16773780n,
    jsonRpcUrl: anvilMainnet.forkUrl,
  })
})

describe('Get ENS Name', () => {
  bench('viem: `getEnsAddress`', async () => {
    await getEnsAddress(client, { name: 'awkweb.eth' })
  })

  bench('ethers: `resolveName`', async () => {
    await ethersProvider.resolveName('awkweb.eth')
  })
})
</file>

<file path="src/actions/ens/getEnsAddress.ts">
import type { Address } from 'abitype'

import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  addressResolverAbi,
  universalResolverResolveAbi,
} from '../../constants/abis.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { Prettify } from '../../types/utils.js'
import {
  type DecodeFunctionResultErrorType,
  decodeFunctionResult,
} from '../../utils/abi/decodeFunctionResult.js'
import {
  type EncodeFunctionDataErrorType,
  encodeFunctionData,
} from '../../utils/abi/encodeFunctionData.js'
import {
  type GetChainContractAddressErrorType,
  getChainContractAddress,
} from '../../utils/chain/getChainContractAddress.js'
import { type TrimErrorType, trim } from '../../utils/data/trim.js'
import { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'
import { isNullUniversalResolverError } from '../../utils/ens/errors.js'
import { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'
import { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'
import {
  type PacketToBytesErrorType,
  packetToBytes,
} from '../../utils/ens/packetToBytes.js'
import { getAction } from '../../utils/getAction.js'
import {
  type ReadContractParameters,
  readContract,
} from '../public/readContract.js'

export type GetEnsAddressParameters = Prettify<
  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** ENSIP-9 compliant coinType used to resolve addresses for other chains */
    coinType?: number | undefined
    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */
    gatewayUrls?: string[] | undefined
    /** Name to get the address for. */
    name: string
    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */
    strict?: boolean | undefined
    /** Address of ENS Universal Resolver Contract. */
    universalResolverAddress?: Address | undefined
  }
>

export type GetEnsAddressReturnType = Address | null

export type GetEnsAddressErrorType =
  | GetChainContractAddressErrorType
  | EncodeFunctionDataErrorType
  | NamehashErrorType
  | ToHexErrorType
  | PacketToBytesErrorType
  | DecodeFunctionResultErrorType
  | TrimErrorType
  | ErrorType

/**
 * Gets address for ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsAddressParameters}
 * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsAddress, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensAddress = await getEnsAddress(client, {
 *   name: normalize('wevm.eth'),
 * })
 * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'
 */
export async function getEnsAddress<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  parameters: GetEnsAddressParameters,
): Promise<GetEnsAddressReturnType> {
  const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } =
    parameters
  const { chain } = client

  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress
    if (!chain)
      throw new Error(
        'client chain not configured. universalResolverAddress is required.',
      )
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: 'ensUniversalResolver',
    })
  })()

  const tlds = chain?.ensTlds
  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null

  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: 'addr',
      ...(coinType != null
        ? { args: [namehash(name), BigInt(coinType)] }
        : { args: [namehash(name)] }),
    })

    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: 'resolve',
      args: [
        toHex(packetToBytes(name)),
        functionData,
        gatewayUrls ?? [localBatchGatewayUrl],
      ],
      blockNumber,
      blockTag,
    } as const

    const readContractAction = getAction(client, readContract, 'readContract')

    const res = await readContractAction(readContractParameters)

    if (res[0] === '0x') return null

    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,
      functionName: 'addr',
      data: res[0],
    })

    if (address === '0x') return null
    if (trim(address) === '0x00') return null
    return address
  } catch (err) {
    if (strict) throw err
    if (isNullUniversalResolverError(err, 'resolve')) return null
    throw err
  }
}
</file>

<file path="src/actions/ens/getEnsAvatar.ts">
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { AssetGatewayUrls } from '../../types/ens.js'
import type { Prettify } from '../../types/utils.js'
import {
  type ParseAvatarRecordErrorType,
  parseAvatarRecord,
} from '../../utils/ens/avatar/parseAvatarRecord.js'
import { getAction } from '../../utils/getAction.js'

import {
  type GetEnsTextErrorType,
  type GetEnsTextParameters,
  getEnsText,
} from './getEnsText.js'

export type GetEnsAvatarParameters = Prettify<
  Omit<GetEnsTextParameters, 'key'> & {
    /** Gateway urls to resolve IPFS and/or Arweave assets. */
    assetGatewayUrls?: AssetGatewayUrls | undefined
  }
>

export type GetEnsAvatarReturnType = string | null

export type GetEnsAvatarErrorType =
  | GetEnsTextErrorType
  | ParseAvatarRecordErrorType
  | ErrorType

/**
 * Gets the avatar of an ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsAvatarParameters}
 * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsAvatar, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensAvatar = await getEnsAvatar(client, {
 *   name: normalize('wevm.eth'),
 * })
 * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'
 */
export async function getEnsAvatar<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  {
    blockNumber,
    blockTag,
    assetGatewayUrls,
    name,
    gatewayUrls,
    strict,
    universalResolverAddress,
  }: GetEnsAvatarParameters,
): Promise<GetEnsAvatarReturnType> {
  const record = await getAction(
    client,
    getEnsText,
    'getEnsText',
  )({
    blockNumber,
    blockTag,
    key: 'avatar',
    name,
    universalResolverAddress,
    gatewayUrls,
    strict,
  })
  if (!record) return null
  try {
    return await parseAvatarRecord(client, {
      record,
      gatewayUrls: assetGatewayUrls,
    })
  } catch {
    return null
  }
}
</file>

<file path="src/actions/ens/getEnsName.bench.ts">
import { beforeAll, bench, describe } from 'vitest'

import { ethersProvider } from '~test/src/bench.js'

import { anvilMainnet } from '../../../test/src/anvil.js'

import { reset } from '../test/reset.js'
import { getEnsName } from './getEnsName.js'

const client = anvilMainnet.getClient()

beforeAll(async () => {
  await reset(client, {
    blockNumber: 16773780n,
    jsonRpcUrl: anvilMainnet.forkUrl,
  })
})

describe('Get ENS Name', () => {
  bench('viem: `getEnsName`', async () => {
    await getEnsName(client, {
      address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    })
  })

  bench('ethers: `lookupAddress`', async () => {
    await ethersProvider.lookupAddress(
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    )
  })
})
</file>

<file path="src/actions/ens/getEnsName.ts">
import type { Address } from 'abitype'

import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import { universalResolverReverseAbi } from '../../constants/abis.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { Prettify } from '../../types/utils.js'
import {
  type GetChainContractAddressErrorType,
  getChainContractAddress,
} from '../../utils/chain/getChainContractAddress.js'
import { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'
import { isNullUniversalResolverError } from '../../utils/ens/errors.js'
import {
  type PacketToBytesErrorType,
  packetToBytes,
} from '../../utils/ens/packetToBytes.js'
import { getAction } from '../../utils/getAction.js'
import {
  type ReadContractErrorType,
  type ReadContractParameters,
  readContract,
} from '../public/readContract.js'

export type GetEnsNameParameters = Prettify<
  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** Address to get ENS name for. */
    address: Address
    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */
    gatewayUrls?: string[] | undefined
    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */
    strict?: boolean | undefined
    /** Address of ENS Universal Resolver Contract. */
    universalResolverAddress?: Address | undefined
  }
>

export type GetEnsNameReturnType = string | null

export type GetEnsNameErrorType =
  | GetChainContractAddressErrorType
  | ReadContractErrorType
  | ToHexErrorType
  | PacketToBytesErrorType
  | ErrorType

/**
 * Gets primary name for specified address.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsName
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsNameParameters}
 * @returns Name or `null` if not found. {@link GetEnsNameReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsName } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensName = await getEnsName(client, {
 *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
 * })
 * // 'wevm.eth'
 */
export async function getEnsName<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  {
    address,
    blockNumber,
    blockTag,
    gatewayUrls,
    strict,
    universalResolverAddress: universalResolverAddress_,
  }: GetEnsNameParameters,
): Promise<GetEnsNameReturnType> {
  let universalResolverAddress = universalResolverAddress_
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error(
        'client chain not configured. universalResolverAddress is required.',
      )

    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: 'ensUniversalResolver',
    })
  }

  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: 'reverse',
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag,
    } as const

    const readContractAction = getAction(client, readContract, 'readContract')

    const [name, resolvedAddress] = gatewayUrls
      ? await readContractAction({
          ...readContractParameters,
          args: [...readContractParameters.args, gatewayUrls],
        })
      : await readContractAction(readContractParameters)

    if (address.toLowerCase() !== resolvedAddress.toLowerCase()) return null
    return name
  } catch (err) {
    if (strict) throw err
    if (isNullUniversalResolverError(err, 'reverse')) return null
    throw err
  }
}
</file>

<file path="src/actions/ens/getEnsResolver.ts">
import type { Address } from 'abitype'

import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { Prettify } from '../../types/utils.js'
import {
  type GetChainContractAddressErrorType,
  getChainContractAddress,
} from '../../utils/chain/getChainContractAddress.js'
import { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'
import {
  type PacketToBytesErrorType,
  packetToBytes,
} from '../../utils/ens/packetToBytes.js'
import { getAction } from '../../utils/getAction.js'
import {
  type ReadContractParameters,
  readContract,
} from '../public/readContract.js'

export type GetEnsResolverParameters = Prettify<
  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** Name to get the address for. */
    name: string
    /** Address of ENS Universal Resolver Contract. */
    universalResolverAddress?: Address | undefined
  }
>

export type GetEnsResolverReturnType = Address

export type GetEnsResolverErrorType =
  | GetChainContractAddressErrorType
  | ToHexErrorType
  | PacketToBytesErrorType
  | ErrorType

/**
 * Gets resolver for ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsResolverParameters}
 * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsResolver, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const resolverAddress = await getEnsResolver(client, {
 *   name: normalize('wevm.eth'),
 * })
 * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'
 */
export async function getEnsResolver<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  parameters: GetEnsResolverParameters,
): Promise<GetEnsResolverReturnType> {
  const { blockNumber, blockTag, name } = parameters
  const { chain } = client

  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress
    if (!chain)
      throw new Error(
        'client chain not configured. universalResolverAddress is required.',
      )
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: 'ensUniversalResolver',
    })
  })()

  const tlds = chain?.ensTlds
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    throw new Error(
      `${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain "${chain.name}" (id: ${chain.id}).`,
    )

  const [resolverAddress] = await getAction(
    client,
    readContract,
    'readContract',
  )({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: 'bytes' }],
        name: 'findResolver',
        outputs: [{ type: 'address' }, { type: 'bytes32' }],
        stateMutability: 'view',
        type: 'function',
      },
    ],
    functionName: 'findResolver',
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag,
  })
  return resolverAddress
}
</file>

<file path="src/actions/ens/getEnsText.ts">
import type { Address } from 'abitype'

import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  textResolverAbi,
  universalResolverResolveAbi,
} from '../../constants/abis.js'
import type { Chain } from '../../types/chain.js'
import type { Prettify } from '../../types/utils.js'
import {
  type DecodeFunctionResultErrorType,
  decodeFunctionResult,
} from '../../utils/abi/decodeFunctionResult.js'
import {
  type EncodeFunctionDataErrorType,
  encodeFunctionData,
} from '../../utils/abi/encodeFunctionData.js'
import {
  type GetChainContractAddressErrorType,
  getChainContractAddress,
} from '../../utils/chain/getChainContractAddress.js'
import { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'
import { isNullUniversalResolverError } from '../../utils/ens/errors.js'
import { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'
import { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'
import {
  type PacketToBytesErrorType,
  packetToBytes,
} from '../../utils/ens/packetToBytes.js'
import { getAction } from '../../utils/getAction.js'
import {
  type ReadContractErrorType,
  type ReadContractParameters,
  readContract,
} from '../public/readContract.js'

export type GetEnsTextParameters = Prettify<
  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {
    /** ENS name to get Text for. */
    name: string
    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */
    gatewayUrls?: string[] | undefined
    /** Text record to retrieve. */
    key: string
    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */
    strict?: boolean | undefined
    /** Address of ENS Universal Resolver Contract. */
    universalResolverAddress?: Address | undefined
  }
>

export type GetEnsTextReturnType = string | null

export type GetEnsTextErrorType =
  | GetChainContractAddressErrorType
  | ReadContractErrorType
  | ToHexErrorType
  | PacketToBytesErrorType
  | EncodeFunctionDataErrorType
  | NamehashErrorType
  | DecodeFunctionResultErrorType

/**
 * Gets a text record for specified ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsTextParameters}
 * @returns Address for ENS resolver. {@link GetEnsTextReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsText, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const twitterRecord = await getEnsText(client, {
 *   name: normalize('wevm.eth'),
 *   key: 'com.twitter',
 * })
 * // 'wevm_dev'
 */
export async function getEnsText<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  parameters: GetEnsTextParameters,
): Promise<GetEnsTextReturnType> {
  const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters
  const { chain } = client

  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress
    if (!chain)
      throw new Error(
        'client chain not configured. universalResolverAddress is required.',
      )
    return getChainContractAddress({
      blockNumber,
      chain,
      contract: 'ensUniversalResolver',
    })
  })()

  const tlds = chain?.ensTlds
  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null

  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: 'resolve',
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: 'text',
          args: [namehash(name), key],
        }),
        gatewayUrls ?? [localBatchGatewayUrl],
      ],
      blockNumber,
      blockTag,
    } as const

    const readContractAction = getAction(client, readContract, 'readContract')

    const res = await readContractAction(readContractParameters)

    if (res[0] === '0x') return null

    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: 'text',
      data: res[0],
    })

    return record === '' ? null : record
  } catch (err) {
    if (strict) throw err
    if (isNullUniversalResolverError(err, 'resolve')) return null
    throw err
  }
}
</file>

<file path="src/actions/siwe/verifySiweMessage.ts">
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { Hex } from '../../types/misc.js'
import type { Prettify } from '../../types/utils.js'
import { hashMessage } from '../../utils/signature/hashMessage.js'
import type { HashMessageErrorType } from '../../utils/signature/hashMessage.js'
import { parseSiweMessage } from '../../utils/siwe/parseSiweMessage.js'
import {
  type ValidateSiweMessageParameters,
  validateSiweMessage,
} from '../../utils/siwe/validateSiweMessage.js'
import {
  type VerifyHashErrorType,
  type VerifyHashParameters,
  verifyHash,
} from '../public/verifyHash.js'

export type VerifySiweMessageParameters = Prettify<
  Pick<VerifyHashParameters, 'blockNumber' | 'blockTag'> &
    Pick<
      ValidateSiweMessageParameters,
      'address' | 'domain' | 'nonce' | 'scheme' | 'time'
    > & {
      /**
       * EIP-4361 formatted message.
       */
      message: string
      /**
       * Signature to check against.
       */
      signature: Hex
    }
>

export type VerifySiweMessageReturnType = boolean

export type VerifySiweMessageErrorType =
  | HashMessageErrorType
  | VerifyHashErrorType
  | ErrorType

/**
 * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.
 *
 * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).
 *
 * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifySiweMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}
 */
export async function verifySiweMessage<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  parameters: VerifySiweMessageParameters,
): Promise<VerifySiweMessageReturnType> {
  const {
    address,
    domain,
    message,
    nonce,
    scheme,
    signature,
    time = new Date(),
    ...callRequest
  } = parameters

  const parsed = parseSiweMessage(message)
  if (!parsed.address) return false

  const isValid = validateSiweMessage({
    address,
    domain,
    message: parsed,
    nonce,
    scheme,
    time,
  })
  if (!isValid) return false

  const hash = hashMessage(message)
  return verifyHash(client, {
    address: parsed.address,
    hash,
    signature,
    ...callRequest,
  })
}
</file>

<file path="src/actions/test/dropTransaction.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hash } from '../../types/misc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type DropTransactionParameters = {
  /** The hash of the transaction to drop. */
  hash: Hash
}

export type DropTransactionErrorType = RequestErrorType | ErrorType

/**
 * Removes a transaction from the mempool.
 *
 * - Docs: https://viem.sh/docs/actions/test/dropTransaction
 *
 * @param client - Client to use
 * @param parameters - {@link DropTransactionParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { dropTransaction } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await dropTransaction(client, {
 *   hash: '0xe58dceb6b20b03965bb678e27d141e151d7d4efc2334c2d6a49b9fac523f7364'
 * })
 */
export async function dropTransaction<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { hash }: DropTransactionParameters,
) {
  await client.request({
    method: `${client.mode}_dropTransaction`,
    params: [hash],
  })
}
</file>

<file path="src/actions/test/dumpState.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hex } from '../../types/misc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type DumpStateReturnType = Hex
export type DumpStateErrorType = RequestErrorType | ErrorType

/**
 * Serializes the current state (including contracts code, contract's storage,
 * accounts properties, etc.) into a savable data blob.
 *
 * - Docs: https://viem.sh/docs/actions/test/dumpState
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { dumpState } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await dumpState(client)
 */
export async function dumpState<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
): Promise<DumpStateReturnType> {
  return client.request({
    method: `${client.mode}_dumpState`,
  })
}
</file>

<file path="src/actions/test/getAutomine.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type GetAutomineReturnType = boolean

export type GetAutomineErrorType = RequestErrorType | ErrorType

/**
 * Returns the automatic mining status of the node.
 *
 * - Docs: https://viem.sh/docs/actions/test/getAutomine
 *
 * @param client - Client to use
 * @returns Whether or not the node is auto mining. {@link GetAutomineReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { getAutomine } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const isAutomining = await getAutomine(client)
 */
export async function getAutomine<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
): Promise<GetAutomineReturnType> {
  if (client.mode === 'ganache')
    return await client.request({
      method: 'eth_mining',
    })
  return await client.request({
    method: `${client.mode}_getAutomine`,
  })
}
</file>

<file path="src/actions/test/getTxpoolContent.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RpcTransaction } from '../../types/rpc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type GetTxpoolContentReturnType = {
  /** Pending transactions in the pool */
  pending: Record<Address, Record<string, RpcTransaction>>
  /** Queued transactions in the pool */
  queued: Record<Address, Record<string, RpcTransaction>>
}

export type GetTxpoolContentErrorType = RequestErrorType | ErrorType

/**
 * Returns the details of all transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
 *
 * - Docs: https://viem.sh/docs/actions/test/getTxpoolContent
 *
 * @param client - Client to use
 * @returns Transaction pool content. {@link GetTxpoolContentReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { getTxpoolContent } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const content = await getTxpoolContent(client)
 */
export async function getTxpoolContent<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
): Promise<GetTxpoolContentReturnType> {
  return await client.request({
    method: 'txpool_content',
  })
}
</file>

<file path="src/actions/test/getTxpoolStatus.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { hexToNumber } from '../../utils/encoding/fromHex.js'

export type GetTxpoolStatusReturnType = {
  pending: number
  queued: number
}

export type GetTxpoolStatusErrorType = RequestErrorType | ErrorType

/**
 * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
 *
 * - Docs: https://viem.sh/docs/actions/test/getTxpoolStatus
 *
 * @param client - Client to use
 * @returns Transaction pool status. {@link GetTxpoolStatusReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { getTxpoolStatus } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const status = await getTxpoolStatus(client)
 */
export async function getTxpoolStatus<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
): Promise<GetTxpoolStatusReturnType> {
  const { pending, queued } = await client.request({
    method: 'txpool_status',
  })
  return {
    pending: hexToNumber(pending),
    queued: hexToNumber(queued),
  }
}
</file>

<file path="src/actions/test/impersonateAccount.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type ImpersonateAccountParameters = {
  /** The account to impersonate. */
  address: Address
}

export type ImpersonateAccountErrorType = RequestErrorType | ErrorType

/**
 * Impersonate an account or contract address. This lets you send transactions from that account even if you don't have access to its private key.
 *
 * - Docs: https://viem.sh/docs/actions/test/impersonateAccount
 *
 * @param client - Client to use
 * @param parameters - {@link ImpersonateAccountParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { impersonateAccount } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const content = await impersonateAccount(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */
export async function impersonateAccount<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { address }: ImpersonateAccountParameters,
) {
  await client.request({
    method: `${client.mode}_impersonateAccount`,
    params: [address],
  })
}
</file>

<file path="src/actions/test/increaseTime.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type IncreaseTimeParameters = {
  /** The amount of seconds to jump forward in time. */
  seconds: number
}

export type IncreaseTimeErrorType = RequestErrorType | ErrorType

/**
 * Jump forward in time by the given amount of time, in seconds.
 *
 * - Docs: https://viem.sh/docs/actions/test/increaseTime
 *
 * @param client - Client to use
 * @param parameters  {@link IncreaseTimeParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { increaseTime } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await increaseTime(client, {
 *   seconds: 420,
 * })
 */
export async function increaseTime<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { seconds }: IncreaseTimeParameters,
) {
  return await client.request({
    method: 'evm_increaseTime',
    params: [numberToHex(seconds)],
  })
}
</file>

<file path="src/actions/test/inspectTxpool.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type InspectTxpoolReturnType = {
  pending: Record<Address, Record<string, string>>
  queued: Record<Address, Record<string, string>>
}

export type InspectTxpoolErrorType = RequestErrorType | ErrorType

/**
 * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
 *
 * - Docs: https://viem.sh/docs/actions/test/inspectTxpool
 *
 * @param client - Client to use
 * @returns Transaction pool inspection data. {@link InspectTxpoolReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { inspectTxpool } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const data = await inspectTxpool(client)
 */
export async function inspectTxpool<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
): Promise<InspectTxpoolReturnType> {
  return await client.request({
    method: 'txpool_inspect',
  })
}
</file>

<file path="src/actions/test/loadState.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hex } from '../../types/misc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type LoadStateParameters = { state: Hex }
export type LoadStateReturnType = void
export type LoadStateErrorType = RequestErrorType | ErrorType

/**
 * Adds state previously dumped with `dumpState` to the current chain.
 *
 * - Docs: https://viem.sh/docs/actions/test/loadState
 *
 * @param client - Client to use
 * @param parameters - {@link LoadStateParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { loadState } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await loadState(client, { state: '0x...' })
 */
export async function loadState<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { state }: LoadStateParameters,
): Promise<LoadStateReturnType> {
  await client.request({
    method: `${client.mode}_loadState`,
    params: [state],
  })
}
</file>

<file path="src/actions/test/mine.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type MineParameters = {
  /** Number of blocks to mine. */
  blocks: number
  /** Interval between each block in seconds. */
  interval?: number | undefined
}

export type MineErrorType = RequestErrorType | ErrorType

/**
 * Mine a specified number of blocks.
 *
 * - Docs: https://viem.sh/docs/actions/test/mine
 *
 * @param client - Client to use
 * @param parameters  {@link MineParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { mine } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await mine(client, { blocks: 1 })
 */
export async function mine<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { blocks, interval }: MineParameters,
) {
  if (client.mode === 'ganache')
    await client.request({
      method: 'evm_mine',
      params: [{ blocks: numberToHex(blocks) }],
    })
  else
    await client.request({
      method: `${client.mode}_mine`,
      params: [numberToHex(blocks), numberToHex(interval || 0)],
    })
}
</file>

<file path="src/actions/test/removeBlockTimestampInterval.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type RemoveBlockTimestampIntervalErrorType = RequestErrorType | ErrorType

/**
 * Removes [`setBlockTimestampInterval`](https://viem.sh/docs/actions/test/setBlockTimestampInterval) if it exists.
 *
 * - Docs: https://viem.sh/docs/actions/test/removeBlockTimestampInterval
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { removeBlockTimestampInterval } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await removeBlockTimestampInterval(client)
 */
export async function removeBlockTimestampInterval<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(client: TestClient<TestClientMode, Transport, chain, account, false>) {
  await client.request({
    method: `${client.mode}_removeBlockTimestampInterval`,
  })
}
</file>

<file path="src/actions/test/reset.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type ResetParameters = {
  /** The block number to reset from. */
  blockNumber?: bigint | undefined
  /** The JSON RPC URL. */
  jsonRpcUrl?: string | undefined
}

export type ResetErrorType = RequestErrorType | ErrorType

/**
 * Resets fork back to its original state.
 *
 * - Docs: https://viem.sh/docs/actions/test/reset
 *
 * @param client - Client to use
 * @param parameters  {@link ResetParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { reset } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await reset(client, { blockNumber: 69420n })
 */
export async function reset<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { blockNumber, jsonRpcUrl }: ResetParameters = {},
) {
  await client.request({
    method: `${client.mode}_reset`,
    params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }],
  })
}
</file>

<file path="src/actions/test/revert.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Quantity } from '../../types/rpc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type RevertParameters = {
  /** The snapshot ID to revert to. */
  id: Quantity
}

export type RevertErrorType = RequestErrorType | ErrorType

/**
 * Revert the state of the blockchain at the current block.
 *
 * - Docs: https://viem.sh/docs/actions/test/revert
 *
 * @param client - Client to use
 * @param parameters  {@link RevertParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { revert } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await revert(client, { id: '0x' })
 */
export async function revert<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { id }: RevertParameters,
) {
  await client.request({
    method: 'evm_revert',
    params: [id],
  })
}
</file>

<file path="src/actions/test/sendUnsignedTransaction.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hash } from '../../types/misc.js'
import type { TransactionRequest } from '../../types/transaction.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { extract } from '../../utils/formatters/extract.js'
import {
  type FormattedTransactionRequest,
  formatTransactionRequest,
} from '../../utils/formatters/transactionRequest.js'

export type SendUnsignedTransactionParameters<
  chain extends Chain | undefined = Chain | undefined,
> = FormattedTransactionRequest<chain>

export type SendUnsignedTransactionReturnType = Hash

export type SendUnsignedTransactionErrorType = RequestErrorType | ErrorType

/**
 * Executes a transaction regardless of the signature.
 *
 * - Docs: https://viem.sh/docs/actions/test/sendUnsignedTransaction#sendunsignedtransaction
 *
 * @param client - Client to use
 * @param parameters  {@link SendUnsignedTransactionParameters}
 * @returns The transaction hash. {@link SendUnsignedTransactionReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { sendUnsignedTransaction } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const hash = await sendUnsignedTransaction(client, {
 *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 */
export async function sendUnsignedTransaction<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  args: SendUnsignedTransactionParameters<chain>,
): Promise<SendUnsignedTransactionReturnType> {
  const {
    accessList,
    data,
    from,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value,
    ...rest
  } = args

  const chainFormat = client.chain?.formatters?.transactionRequest?.format
  const format = chainFormat || formatTransactionRequest

  const request = format({
    // Pick out extra data that might exist on the chain's transaction request type.
    ...extract(rest, { format: chainFormat }),
    accessList,
    data,
    from,
    gas,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    to,
    value,
  } as TransactionRequest)
  const hash = await client.request({
    method: 'eth_sendUnsignedTransaction',
    params: [request],
  })
  return hash
}
</file>

<file path="src/actions/test/setAutomine.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SetAutomineErrorType = RequestErrorType | ErrorType

/**
 * Enables or disables the automatic mining of new blocks with each new transaction submitted to the network.
 *
 * - Docs: https://viem.sh/docs/actions/test/setAutomine
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setAutomine } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setAutomine(client)
 */
export async function setAutomine<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  enabled: boolean,
) {
  if (client.mode === 'ganache') {
    if (enabled) await client.request({ method: 'miner_start' })
    else await client.request({ method: 'miner_stop' })
  } else
    await client.request({
      method: 'evm_setAutomine',
      params: [enabled],
    })
}
</file>

<file path="src/actions/test/setBalance.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type SetBalanceParameters = {
  /** The account address. */
  address: Address
  /** Amount (in wei) to set */
  value: bigint
}

export type SetBalanceErrorType = RequestErrorType | ErrorType

/**
 * Modifies the balance of an account.
 *
 * - Docs: https://viem.sh/docs/actions/test/setBalance
 *
 * @param client - Client to use
 * @param parameters  {@link SetBalanceParameters}
 *
 * @example
 * import { createTestClient, http, parseEther } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setBalance } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setBalance(client, {
 *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 *   value: parseEther('1'),
 * })
 */
export async function setBalance<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { address, value }: SetBalanceParameters,
) {
  if (client.mode === 'ganache')
    await client.request({
      method: 'evm_setAccountBalance',
      params: [address, numberToHex(value)],
    })
  else
    await client.request({
      method: `${client.mode}_setBalance`,
      params: [address, numberToHex(value)],
    })
}
</file>

<file path="src/actions/test/setBlockGasLimit.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type SetBlockGasLimitParameters = {
  /** Gas limit (in wei). */
  gasLimit: bigint
}

export type SetBlockGasLimitErrorType = RequestErrorType | ErrorType

/**
 * Sets the block's gas limit.
 *
 * - Docs: https://viem.sh/docs/actions/test/setBlockGasLimit
 *
 * @param client - Client to use
 * @param parameters  {@link SetBlockGasLimitParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setBlockGasLimit } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setBlockGasLimit(client, { gasLimit: 420_000n })
 */
export async function setBlockGasLimit<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { gasLimit }: SetBlockGasLimitParameters,
) {
  await client.request({
    method: 'evm_setBlockGasLimit',
    params: [numberToHex(gasLimit)],
  })
}
</file>

<file path="src/actions/test/setBlockTimestampInterval.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SetBlockTimestampIntervalParameters = {
  /** The interval (in seconds). */
  interval: number
}

export type SetBlockTimestampIntervalErrorType = RequestErrorType | ErrorType

/**
 * Similar to [`increaseTime`](https://viem.sh/docs/actions/test/increaseTime), but sets a block timestamp `interval`. The timestamp of future blocks will be computed as `lastBlock_timestamp` + `interval`.
 *
 * - Docs: https://viem.sh/docs/actions/test/setBlockTimestampInterval
 *
 * @param client - Client to use
 * @param parameters  {@link SetBlockTimestampIntervalParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setBlockTimestampInterval } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setBlockTimestampInterval(client, { interval: 5 })
 */
export async function setBlockTimestampInterval<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { interval }: SetBlockTimestampIntervalParameters,
) {
  const interval_ = (() => {
    if (client.mode === 'hardhat') return interval * 1000
    return interval
  })()

  await client.request({
    method: `${client.mode}_setBlockTimestampInterval`,
    params: [interval_],
  })
}
</file>

<file path="src/actions/test/setCode.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hex } from '../../types/misc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SetCodeParameters = {
  /** The account address. */
  address: Address
  /** The bytecode to set */
  bytecode: Hex
}

export type SetCodeErrorType = RequestErrorType | ErrorType

/**
 * Modifies the bytecode stored at an account's address.
 *
 * - Docs: https://viem.sh/docs/actions/test/setCode
 *
 * @param client - Client to use
 * @param parameters  {@link SetCodeParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setCode } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setCode(client, {
 *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
 *   bytecode: '0x60806040526000600355600019600955600c80546001600160a01b031916737a250d5630b4cf539739df',
 * })
 */
export async function setCode<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { address, bytecode }: SetCodeParameters,
) {
  if (client.mode === 'ganache')
    await client.request({
      method: 'evm_setAccountCode',
      params: [address, bytecode],
    })
  else
    await client.request({
      method: `${client.mode}_setCode`,
      params: [address, bytecode],
    })
}
</file>

<file path="src/actions/test/setCoinbase.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SetCoinbaseParameters = {
  /** The coinbase address. */
  address: Address
}

export type SetCoinbaseErrorType = RequestErrorType | ErrorType

/**
 * Sets the coinbase address to be used in new blocks.
 *
 * - Docs: https://viem.sh/docs/actions/test/setCoinbase
 *
 * @param client - Client to use
 * @param parameters  {@link SetCoinbaseParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setCoinbase } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setCoinbase(client, {
 *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
 * })
 */
export async function setCoinbase<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { address }: SetCoinbaseParameters,
) {
  await client.request({
    method: `${client.mode}_setCoinbase`,
    params: [address],
  })
}
</file>

<file path="src/actions/test/setIntervalMining.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SetIntervalMiningParameters = {
  /** The mining interval. */
  interval: number
}

export type SetIntervalMiningErrorType = RequestErrorType | ErrorType

/**
 * Sets the automatic mining interval (in seconds) of blocks. Setting the interval to 0 will disable automatic mining.
 *
 * - Docs: https://viem.sh/docs/actions/test/setIntervalMining
 *
 * @param client - Client to use
 * @param parameters  {@link SetIntervalMiningParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setIntervalMining } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setIntervalMining(client, { interval: 5 })
 */
export async function setIntervalMining<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { interval }: SetIntervalMiningParameters,
) {
  const interval_ = (() => {
    if (client.mode === 'hardhat') return interval * 1000
    return interval
  })()

  await client.request({
    method: 'evm_setIntervalMining',
    params: [interval_],
  })
}
</file>

<file path="src/actions/test/setLoggingEnabled.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SetLoggingEnabledErrorType = RequestErrorType | ErrorType

/**
 * Enable or disable logging on the test node network.
 *
 * - Docs: https://viem.sh/docs/actions/test/setLoggingEnabled
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setLoggingEnabled } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setLoggingEnabled(client)
 */
export async function setLoggingEnabled<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  enabled: boolean,
) {
  await client.request({
    method: `${client.mode}_setLoggingEnabled`,
    params: [enabled],
  })
}
</file>

<file path="src/actions/test/setMinGasPrice.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type SetMinGasPriceParameters = {
  /** The gas price. */
  gasPrice: bigint
}

export type SetMinGasPriceErrorType = RequestErrorType | ErrorType

/**
 * Change the minimum gas price accepted by the network (in wei).
 *
 * - Docs: https://viem.sh/docs/actions/test/setMinGasPrice
 *
 * Note: `setMinGasPrice` can only be used on clients that do not have EIP-1559 enabled.
 *
 * @param client - Client to use
 * @param parameters  {@link SetBlockGasLimitParameters}
 *
 * @example
 * import { createTestClient, http, parseGwei } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setMinGasPrice } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setMinGasPrice(client, {
 *   gasPrice: parseGwei('20'),
 * })
 */
export async function setMinGasPrice<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { gasPrice }: SetMinGasPriceParameters,
) {
  await client.request({
    method: `${client.mode}_setMinGasPrice`,
    params: [numberToHex(gasPrice)],
  })
}
</file>

<file path="src/actions/test/setNextBlockBaseFeePerGas.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type SetNextBlockBaseFeePerGasParameters = {
  /** Base fee per gas (in wei). */
  baseFeePerGas: bigint
}

export type SetNextBlockBaseFeePerGasErrorType = RequestErrorType | ErrorType

/**
 * Sets the next block's base fee per gas.
 *
 * - Docs: https://viem.sh/docs/actions/test/setNextBlockBaseFeePerGas
 *
 * @param client - Client to use
 * @param parameters  {@link SetNextBlockBaseFeePerGasParameters}
 *
 * @example
 * import { createTestClient, http, parseGwei } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setNextBlockBaseFeePerGas } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setNextBlockBaseFeePerGas(client, {
 *   baseFeePerGas: parseGwei('20'),
 * })
 */
export async function setNextBlockBaseFeePerGas<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { baseFeePerGas }: SetNextBlockBaseFeePerGasParameters,
) {
  await client.request({
    method: `${client.mode}_setNextBlockBaseFeePerGas`,
    params: [numberToHex(baseFeePerGas)],
  })
}
</file>

<file path="src/actions/test/setNextBlockTimestamp.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type SetNextBlockTimestampParameters = {
  /** The timestamp (in seconds). */
  timestamp: bigint
}

export type SetNextBlockTimestampErrorType = RequestErrorType | ErrorType

/**
 * Sets the next block's timestamp.
 *
 * - Docs: https://viem.sh/docs/actions/test/setNextBlockTimestamp
 *
 * @param client - Client to use
 * @param parameters  {@link SetNextBlockTimestampParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setNextBlockTimestamp } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setNextBlockTimestamp(client, { timestamp: 1671744314n })
 */
export async function setNextBlockTimestamp<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { timestamp }: SetNextBlockTimestampParameters,
) {
  await client.request({
    method: 'evm_setNextBlockTimestamp',
    params: [numberToHex(timestamp)],
  })
}
</file>

<file path="src/actions/test/setNonce.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type SetNonceParameters = {
  /** The account address. */
  address: Address
  /** The nonce to set. */
  nonce: number
}

export type SetNonceErrorType = RequestErrorType | ErrorType

/**
 * Modifies (overrides) the nonce of an account.
 *
 * - Docs: https://viem.sh/docs/actions/test/setNonce
 *
 * @param client - Client to use
 * @param parameters  {@link SetNonceParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setNonce } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setNonce(client, {
 *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 *   nonce: 420,
 * })
 */
export async function setNonce<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { address, nonce }: SetNonceParameters,
) {
  await client.request({
    method: `${client.mode}_setNonce`,
    params: [address, numberToHex(nonce)],
  })
}
</file>

<file path="src/actions/test/setRpcUrl.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SetRpcUrlErrorType = RequestErrorType | ErrorType

/**
 * Sets the backend RPC URL.
 *
 * - Docs: https://viem.sh/docs/actions/test/setRpcUrl
 *
 * @param client - Client to use
 * @param jsonRpcUrl  RPC URL
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setRpcUrl } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setRpcUrl(client, 'https://eth-mainnet.g.alchemy.com/v2')
 */
export async function setRpcUrl<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  jsonRpcUrl: string,
) {
  await client.request({
    method: `${client.mode}_setRpcUrl`,
    params: [jsonRpcUrl],
  })
}
</file>

<file path="src/actions/test/setStorageAt.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hash, Hex } from '../../types/misc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type SetStorageAtParameters = {
  /** The account address. */
  address: Address
  /** The storage slot (index). Can either be a number or hash value. */
  index: number | Hash
  /** The value to store as a 32 byte hex string. */
  value: Hex
}

export type SetStorageAtErrorType = RequestErrorType | ErrorType

/**
 * Writes to a slot of an account's storage.
 *
 * - Docs: https://viem.sh/docs/actions/test/setStorageAt
 *
 * @param client - Client to use
 * @param parameters  {@link SetStorageAtParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setStorageAt } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setStorageAt(client, {
 *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
 *   index: 2,
 *   value: '0x0000000000000000000000000000000000000000000000000000000000000069',
 * })
 */
export async function setStorageAt<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { address, index, value }: SetStorageAtParameters,
) {
  await client.request({
    method: `${client.mode}_setStorageAt`,
    params: [
      address,
      typeof index === 'number' ? numberToHex(index) : index,
      value,
    ],
  })
}
</file>

<file path="src/actions/test/snapshot.ts">
import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SnapshotErrorType = RequestErrorType | ErrorType

/**
 * Snapshot the state of the blockchain at the current block.
 *
 * - Docs: https://viem.sh/docs/actions/test/snapshot
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { snapshot } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await snapshot(client)
 */
export async function snapshot<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(client: TestClient<TestClientMode, Transport, chain, account, false>) {
  return await client.request({
    method: 'evm_snapshot',
  })
}
</file>

<file path="src/actions/test/stopImpersonatingAccount.ts">
import type { Address } from 'abitype'

import type {
  TestClient,
  TestClientMode,
} from '../../clients/createTestClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type StopImpersonatingAccountParameters = {
  /** The account to impersonate. */
  address: Address
}

export type StopImpersonatingAccountErrorType = RequestErrorType | ErrorType

/**
 * Stop impersonating an account after having previously used [`impersonateAccount`](https://viem.sh/docs/actions/test/impersonateAccount).
 *
 * - Docs: https://viem.sh/docs/actions/test/stopImpersonatingAccount
 *
 * @param client - Client to use
 * @param parameters  {@link StopImpersonatingAccountParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { stopImpersonatingAccount } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await stopImpersonatingAccount(client, {
 *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 * })
 */
export async function stopImpersonatingAccount<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: TestClient<TestClientMode, Transport, chain, account, false>,
  { address }: StopImpersonatingAccountParameters,
) {
  await client.request({
    method: `${client.mode}_stopImpersonatingAccount`,
    params: [address],
  })
}
</file>

<file path="src/actions/wallet/addChain.ts">
import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import {
  type NumberToHexErrorType,
  numberToHex,
} from '../../utils/encoding/toHex.js'

export type AddChainParameters = {
  /** The chain to add to the wallet. */
  chain: Chain
}

export type AddChainErrorType =
  | RequestErrorType
  | NumberToHexErrorType
  | ErrorType

/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/addChain
 * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
 *
 * @param client - Client to use
 * @param parameters - {@link AddChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { optimism } from 'viem/chains'
 * import { addChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   transport: custom(window.ethereum),
 * })
 * await addChain(client, { chain: optimism })
 */
export async function addChain<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(client: Client<Transport, chain, account>, { chain }: AddChainParameters) {
  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain
  await client.request(
    {
      method: 'wallet_addEthereumChain',
      params: [
        {
          chainId: numberToHex(id),
          chainName: name,
          nativeCurrency,
          rpcUrls: rpcUrls.default.http,
          blockExplorerUrls: blockExplorers
            ? Object.values(blockExplorers).map(({ url }) => url)
            : undefined,
        },
      ],
    },
    { dedupe: true, retryCount: 0 },
  )
}
</file>

<file path="src/actions/wallet/deployContract.test-d.ts">
import { test } from 'vitest'

import { wagmiContractConfig } from '~test/src/abis.js'

import { type Abi, parseAbi } from 'abitype'
import { anvilMainnet } from '../../../test/src/anvil.js'
import { deployContract } from './deployContract.js'

const client = anvilMainnet.getClient()
const clientWithAccount = anvilMainnet.getClient({
  account: true,
})

const args = {
  ...wagmiContractConfig,
  account: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
  bytecode: '0x',
} as const

test('type: legacy', () => {
  deployContract(client, {
    ...args,
    gasPrice: 0n,
  })

  // @ts-expect-error
  deployContract(client, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  deployContract(client, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
  // @ts-expect-error
  deployContract(client, {
    ...args,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
})

test('type: eip1559', () => {
  deployContract(client, {
    ...args,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  deployContract(client, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  deployContract(client, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip1559',
  })
  // @ts-expect-error
  deployContract(client, {
    ...args,
    gasPrice: 0n,
    type: 'eip1559',
  })
})

test('type: eip2930', () => {
  deployContract(client, {
    ...args,
    gasPrice: 0n,
  })

  // @ts-expect-error
  deployContract(client, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  deployContract(client, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
  // @ts-expect-error
  deployContract(client, {
    ...args,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
})

test('default', () => {
  deployContract(clientWithAccount, {
    abi: parseAbi(['constructor(address to, uint256 tokenId)']),
    bytecode: '0x',
    args: ['0x', 123n],
  })
})

test('defined inline', () => {
  deployContract(clientWithAccount, {
    abi: [
      {
        type: 'constructor',
        stateMutability: 'nonpayable',
        inputs: [
          {
            type: 'address',
            name: 'to',
          },
          {
            type: 'uint256',
            name: 'tokenId',
          },
        ],
      },
    ],
    bytecode: '0x',
    args: ['0x', 123n],
  })
})

test('declared as Abi', () => {
  deployContract(clientWithAccount, {
    abi: wagmiContractConfig.abi as Abi,
    bytecode: '0x',
    args: ['0x'],
  })

  deployContract(clientWithAccount, {
    abi: wagmiContractConfig.abi as Abi,
    bytecode: '0x',
  })
})

test('no const assertion', () => {
  const abi = [
    {
      inputs: [
        { name: 'to', type: 'address' },
        { name: 'tokenId', type: 'uint256' },
      ],
      name: 'approve',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ]
  deployContract(clientWithAccount, {
    abi,
    bytecode: '0x',
    args: ['0x'],
  })

  deployContract(clientWithAccount, {
    abi,
    bytecode: '0x',
  })
})
</file>

<file path="src/actions/wallet/deployContract.ts">
import type { Abi } from 'abitype'

import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { Chain } from '../../types/chain.js'
import type { GetChainParameter } from '../../types/chain.js'
import type { ContractConstructorArgs } from '../../types/contract.js'
import type { Hex } from '../../types/misc.js'
import type { UnionEvaluate, UnionOmit } from '../../types/utils.js'
import { encodeDeployData } from '../../utils/abi/encodeDeployData.js'

import type { ErrorType } from '../../errors/utils.js'
import {
  type SendTransactionErrorType,
  type SendTransactionParameters,
  type SendTransactionReturnType,
  sendTransaction,
} from './sendTransaction.js'

export type DeployContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  ///
  allArgs = ContractConstructorArgs<abi>,
> = UnionOmit<
  SendTransactionParameters<chain, account, chainOverride>,
  'accessList' | 'chain' | 'to' | 'data'
> &
  GetChainParameter<chain, chainOverride> &
  UnionEvaluate<
    readonly [] extends allArgs
      ? { args?: allArgs | undefined }
      : { args: allArgs }
  > & {
    abi: abi
    bytecode: Hex
  }

export type DeployContractReturnType = SendTransactionReturnType

export type DeployContractErrorType = SendTransactionErrorType | ErrorType

/**
 * Deploys a contract to the network, given bytecode and constructor arguments.
 *
 * - Docs: https://viem.sh/docs/contract/deployContract
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts
 *
 * @param client - Client to use
 * @param parameters - {@link DeployContractParameters}
 * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}
 *
 * @example
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { deployContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const hash = await deployContract(client, {
 *   abi: [],
 *   account: '0x,
 *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
 * })
 */
export function deployContract<
  const abi extends Abi | readonly unknown[],
  chain extends Chain | undefined,
  account extends Account | undefined,
  chainOverride extends Chain | undefined,
>(
  walletClient: Client<Transport, chain, account>,
  parameters: DeployContractParameters<abi, chain, account, chainOverride>,
): Promise<DeployContractReturnType> {
  const { abi, args, bytecode, ...request } =
    parameters as DeployContractParameters
  const calldata = encodeDeployData({ abi, args, bytecode })
  return sendTransaction(walletClient, {
    ...request,
    ...(request.authorizationList ? { to: null } : {}),
    data: calldata,
  } as unknown as SendTransactionParameters<chain, account, chainOverride>)
}
</file>

<file path="src/actions/wallet/getAddresses.ts">
import type { Address } from 'abitype'

import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import {
  type ChecksumAddressErrorType,
  checksumAddress,
} from '../../utils/address/getAddress.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type GetAddressesReturnType = Address[]

export type GetAddressesErrorType =
  | RequestErrorType
  | ChecksumAddressErrorType
  | ErrorType

/**
 * Returns a list of account addresses owned by the wallet or client.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getAddresses
 * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)
 *
 * @param client - Client to use
 * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getAddresses } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const accounts = await getAddresses(client)
 */
export async function getAddresses<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(client: Client<Transport, chain, account>): Promise<GetAddressesReturnType> {
  if (client.account?.type === 'local') return [client.account.address]
  const addresses = await client.request(
    { method: 'eth_accounts' },
    { dedupe: true },
  )
  return addresses.map((address) => checksumAddress(address))
}
</file>

<file path="src/actions/wallet/getCallsStatus.ts">
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type {
  WalletCapabilities,
  WalletGetCallsStatusReturnType,
} from '../../types/eip1193.js'
import type { Prettify } from '../../types/utils.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js'
import { receiptStatuses } from '../../utils/formatters/transactionReceipt.js'

export type GetCallsStatusParameters = { id: string }

export type GetCallsStatusReturnType = Prettify<
  Omit<
    WalletGetCallsStatusReturnType<
      WalletCapabilities,
      number,
      bigint,
      'success' | 'reverted'
    >,
    'status'
  > & {
    statusCode: number
    status: 'pending' | 'success' | 'failure' | undefined
  }
>

export type GetCallsStatusErrorType = RequestErrorType | ErrorType

/**
 * Returns the status of a call batch that was sent via `sendCalls`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus
 * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns Status of the calls. {@link GetCallsStatusReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getCallsStatus } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })
 */
export async function getCallsStatus<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: GetCallsStatusParameters,
): Promise<GetCallsStatusReturnType> {
  const {
    atomic = false,
    chainId,
    receipts,
    version = '2.0.0',
    ...response
  } = await client.request({
    method: 'wallet_getCallsStatus',
    params: [parameters.id],
  })
  const [status, statusCode] = (() => {
    const statusCode = response.status
    if (statusCode >= 100 && statusCode < 200)
      return ['pending', statusCode] as const
    if (statusCode >= 200 && statusCode < 300)
      return ['success', statusCode] as const
    if (statusCode >= 300 && statusCode < 700)
      return ['failure', statusCode] as const
    // @ts-expect-error: for backwards compatibility
    if (statusCode === 'CONFIRMED') return ['success', 200] as const
    // @ts-expect-error: for backwards compatibility
    if (statusCode === 'PENDING') return ['pending', 100] as const
    return [undefined, statusCode]
  })()
  return {
    ...response,
    atomic,
    // @ts-expect-error: for backwards compatibility
    chainId: chainId ? hexToNumber(chainId) : undefined,
    receipts:
      receipts?.map((receipt) => ({
        ...receipt,
        blockNumber: hexToBigInt(receipt.blockNumber),
        gasUsed: hexToBigInt(receipt.gasUsed),
        status: receiptStatuses[receipt.status as '0x0' | '0x1'],
      })) ?? [],
    statusCode,
    status,
    version,
  }
}
</file>

<file path="src/actions/wallet/getCapabilities.ts">
import type { Address } from 'abitype'

import { parseAccount } from '../../accounts/utils/parseAccount.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type {
  WalletCapabilities,
  WalletCapabilitiesRecord,
} from '../../types/eip1193.js'
import type { Prettify } from '../../types/utils.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'

export type GetCapabilitiesParameters<
  chainId extends number | undefined = undefined,
> = {
  account?: Account | Address | undefined
  chainId?: chainId | number | undefined
}

export type GetCapabilitiesReturnType<
  chainId extends number | undefined = undefined,
> = Prettify<
  chainId extends number
    ? WalletCapabilities
    : WalletCapabilitiesRecord<WalletCapabilities, number>
>

export type GetCapabilitiesErrorType = RequestErrorType | ErrorType

/**
 * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities
 * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getCapabilities } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const capabilities = await getCapabilities(client)
 */
export async function getCapabilities<
  chainId extends number | undefined = undefined,
>(
  client: Client<Transport>,
  parameters: GetCapabilitiesParameters<chainId> = {},
): Promise<GetCapabilitiesReturnType<chainId>> {
  const { account = client.account, chainId } = parameters

  const account_ = account ? parseAccount(account) : undefined

  const params = chainId
    ? ([account_?.address, [numberToHex(chainId)]] as const)
    : ([account_?.address] as const)
  const capabilities_raw = await client.request({
    method: 'wallet_getCapabilities',
    params,
  })

  const capabilities = {} as WalletCapabilitiesRecord<
    WalletCapabilities,
    number
  >
  for (const [key, value] of Object.entries(capabilities_raw))
    capabilities[Number(key)] = value
  return (
    typeof chainId === 'number' ? capabilities[chainId] : capabilities
  ) as never
}
</file>

<file path="src/actions/wallet/getPermissions.ts">
import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { WalletPermission } from '../../types/eip1193.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type GetPermissionsReturnType = WalletPermission[]

export type GetPermissionsErrorType = RequestErrorType | ErrorType

/**
 * Gets the wallets current permissions.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getPermissions
 * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
 *
 * @param client - Client to use
 * @returns The wallet permissions. {@link GetPermissionsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getPermissions } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const permissions = await getPermissions(client)
 */
export async function getPermissions<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(client: Client<Transport, chain, account>) {
  const permissions = await client.request(
    { method: 'wallet_getPermissions' },
    { dedupe: true },
  )
  return permissions
}
</file>

<file path="src/actions/wallet/prepareAuthorization.ts">
import type { Address } from 'abitype'
import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  AccountNotFoundError,
  type AccountNotFoundErrorType,
} from '../../errors/account.js'
import type { ErrorType } from '../../errors/utils.js'
import type { GetAccountParameter } from '../../types/account.js'
import type {
  Authorization,
  AuthorizationRequest,
} from '../../types/authorization.js'
import type { Chain } from '../../types/chain.js'
import type { PartialBy } from '../../types/utils.js'
import { isAddressEqual } from '../../utils/address/isAddressEqual.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { getAction } from '../../utils/getAction.js'
import { getChainId } from '../public/getChainId.js'
import { getTransactionCount } from '../public/getTransactionCount.js'

export type PrepareAuthorizationParameters<
  account extends Account | undefined = Account | undefined,
> = GetAccountParameter<account> &
  PartialBy<AuthorizationRequest, 'chainId' | 'nonce'> & {
    /**
     * Whether the EIP-7702 Transaction will be executed by the EOA (signing this Authorization) or another Account.
     *
     * By default, it will be assumed that the EIP-7702 Transaction will
     * be executed by another Account.
     */
    executor?: 'self' | Account | Address | undefined
  }

export type PrepareAuthorizationReturnType = Authorization

export type PrepareAuthorizationErrorType =
  | ParseAccountErrorType
  | RequestErrorType
  | AccountNotFoundErrorType
  | ErrorType

/**
 * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.
 * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).
 *
 * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.
 *
 * @param client - Client to use
 * @param parameters - {@link PrepareAuthorizationParameters}
 * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const authorization = await prepareAuthorization(client, {
 *   account: privateKeyToAccount('0x..'),
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const authorization = await prepareAuthorization(client, {
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */
export async function prepareAuthorization<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: PrepareAuthorizationParameters<account>,
): Promise<PrepareAuthorizationReturnType> {
  const { account: account_ = client.account, chainId, nonce } = parameters

  if (!account_)
    throw new AccountNotFoundError({
      docsPath: '/docs/eip7702/prepareAuthorization',
    })
  const account = parseAccount(account_)

  const executor = (() => {
    if (!parameters.executor) return undefined
    if (parameters.executor === 'self') return parameters.executor
    return parseAccount(parameters.executor)
  })()

  const authorization = {
    address: parameters.contractAddress ?? parameters.address,
    chainId,
    nonce,
  } as Authorization

  if (typeof authorization.chainId === 'undefined')
    authorization.chainId =
      client.chain?.id ??
      (await getAction(client, getChainId, 'getChainId')({}))

  if (typeof authorization.nonce === 'undefined') {
    authorization.nonce = await getAction(
      client,
      getTransactionCount,
      'getTransactionCount',
    )({
      address: account.address,
      blockTag: 'pending',
    })
    if (
      executor === 'self' ||
      (executor?.address && isAddressEqual(executor.address, account.address))
    )
      authorization.nonce += 1
  }

  return authorization
}
</file>

<file path="src/actions/wallet/prepareTransactionRequest.test-d.ts">
import { expectTypeOf, test } from 'vitest'
import { kzg } from '~test/src/kzg.js'
import { anvilMainnet } from '../../../test/src/anvil.js'
import type { BlobSidecar, Hex, TransactionRequest } from '../../index.js'
import type { Kzg } from '../../types/kzg.js'
import type { ByteArray } from '../../types/misc.js'
import {
  defaultParameters,
  prepareTransactionRequest,
} from './prepareTransactionRequest.js'

const client = anvilMainnet.getClient()
const clientWithAccount = anvilMainnet.getClient({
  account: true,
})
const clientWithoutChain = anvilMainnet.getClient({
  chain: false,
})

test('default', async () => {
  const result_1 = await prepareTransactionRequest(client, {})
  expectTypeOf(result_1.account).toEqualTypeOf<undefined>()
  expectTypeOf(result_1.chain).toEqualTypeOf<typeof anvilMainnet.chain>()
  expectTypeOf(result_1.gas).toEqualTypeOf<bigint>()
  expectTypeOf(result_1.nonce).toEqualTypeOf<number>()
  expectTypeOf(result_1.type).toEqualTypeOf<
    'legacy' | 'eip2930' | 'eip1559' | 'eip4844' | 'eip7702'
  >()
  if (result_1.type === 'legacy' || result_1.type === 'eip2930') {
    expectTypeOf(result_1.gasPrice).toEqualTypeOf<bigint>()
    expectTypeOf(result_1.maxFeePerGas).toEqualTypeOf<never>()
    expectTypeOf(result_1.maxPriorityFeePerGas).toEqualTypeOf<never>()
  }
  if (result_1.type === 'eip1559' || result_1.type === 'eip4844') {
    expectTypeOf(result_1.gasPrice).toEqualTypeOf<never>()
    expectTypeOf(result_1.maxFeePerGas).toEqualTypeOf<bigint>()
    expectTypeOf(result_1.maxPriorityFeePerGas).toEqualTypeOf<bigint>()
  }

  const result_2 = await prepareTransactionRequest(clientWithAccount, {})
  expectTypeOf(result_2.account).toEqualTypeOf<{
    address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
    type: 'json-rpc'
  }>()

  // @ts-expect-error
  await prepareTransactionRequest(clientWithoutChain, {})
})

test('opaque', async () => {
  const result_generic = await prepareTransactionRequest(
    client,
    {} as TransactionRequest,
  )

  expectTypeOf(result_generic.gas).toEqualTypeOf<bigint>()
  expectTypeOf(result_generic.nonce).toEqualTypeOf<number>()
  expectTypeOf(result_generic.type).toEqualTypeOf<
    'legacy' | 'eip2930' | 'eip1559' | 'eip4844' | 'eip7702'
  >()
  if (result_generic.type === 'legacy' || result_generic.type === 'eip2930') {
    expectTypeOf(result_generic.gasPrice).toEqualTypeOf<bigint>()
    expectTypeOf(result_generic.maxFeePerGas).toEqualTypeOf<never>()
    expectTypeOf(result_generic.maxPriorityFeePerGas).toEqualTypeOf<never>()
  }
  if (result_generic.type === 'eip1559' || result_generic.type === 'eip4844') {
    expectTypeOf(result_generic.gasPrice).toEqualTypeOf<never>()
    expectTypeOf(result_generic.maxFeePerGas).toEqualTypeOf<bigint>()
    expectTypeOf(result_generic.maxPriorityFeePerGas).toEqualTypeOf<bigint>()
  }
})

test('args: type', async () => {
  const result_legacy = await prepareTransactionRequest(client, {
    type: 'legacy',
  })
  expectTypeOf(result_legacy.type).toEqualTypeOf<'legacy'>()
  expectTypeOf(result_legacy.gasPrice).toEqualTypeOf<bigint>()
  expectTypeOf(result_legacy.maxFeePerGas).toEqualTypeOf<never>()
  expectTypeOf(result_legacy.maxPriorityFeePerGas).toEqualTypeOf<never>()

  const result_eip2930 = await prepareTransactionRequest(client, {
    type: 'eip2930',
  })
  expectTypeOf(result_eip2930.type).toEqualTypeOf<'eip2930'>()
  expectTypeOf(result_eip2930.gasPrice).toEqualTypeOf<bigint>()
  expectTypeOf(result_eip2930.maxFeePerGas).toEqualTypeOf<never>()
  expectTypeOf(result_eip2930.maxPriorityFeePerGas).toEqualTypeOf<never>()

  const result_eip1559 = await prepareTransactionRequest(client, {
    type: 'eip1559',
  })
  expectTypeOf(result_eip1559.type).toEqualTypeOf<'eip1559'>()
  expectTypeOf(result_eip1559.gasPrice).toEqualTypeOf<never>()
  expectTypeOf(result_eip1559.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_eip1559.maxPriorityFeePerGas).toEqualTypeOf<bigint>()

  const result_eip4844 = await prepareTransactionRequest(client, {
    blobs: ['0x'],
    kzg,
    maxFeePerBlobGas: 1n,
    to: '0x0000000000000000000000000000000000000000',
    type: 'eip4844',
  })
  expectTypeOf(result_eip4844.blobVersionedHashes).toEqualTypeOf<
    readonly Hex[]
  >()
  expectTypeOf(result_eip4844.type).toEqualTypeOf<'eip4844'>()
  expectTypeOf(result_eip4844.blobs).toEqualTypeOf<
    readonly Hex[] | readonly ByteArray[]
  >()
  expectTypeOf(result_eip4844.sidecars).toEqualTypeOf<
    readonly BlobSidecar<`0x${string}`>[] | undefined
  >()
  expectTypeOf(result_eip4844.gasPrice).toEqualTypeOf<never>()
  expectTypeOf(result_eip4844.maxFeePerBlobGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_eip4844.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_eip4844.maxPriorityFeePerGas).toEqualTypeOf<bigint>()

  const result_eip4844_2 = await prepareTransactionRequest(client, {
    blobs: ['0x'],
    kzg,
    maxFeePerBlobGas: 1n,
    to: '0x0000000000000000000000000000000000000000',
    parameters: [...defaultParameters, 'sidecars'],
    type: 'eip4844',
  })
  expectTypeOf(result_eip4844_2.blobVersionedHashes).toEqualTypeOf<
    readonly Hex[]
  >()
  expectTypeOf(result_eip4844_2.type).toEqualTypeOf<'eip4844'>()
  expectTypeOf(result_eip4844_2.blobs).toEqualTypeOf<
    readonly Hex[] | readonly ByteArray[]
  >()
  expectTypeOf(result_eip4844_2.sidecars).toEqualTypeOf<
    readonly BlobSidecar<`0x${string}`>[]
  >()
  expectTypeOf(result_eip4844_2.gasPrice).toEqualTypeOf<never>()
  expectTypeOf(result_eip4844_2.maxFeePerBlobGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_eip4844_2.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_eip4844_2.maxPriorityFeePerGas).toEqualTypeOf<bigint>()
})

test('args: eip1559 attributes', async () => {
  const result_1 = await prepareTransactionRequest(client, {
    maxFeePerGas: 1n,
  })
  expectTypeOf(result_1.gasPrice).toEqualTypeOf<never>()
  expectTypeOf(result_1.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_1.maxPriorityFeePerGas).toEqualTypeOf<bigint>()

  const result_2 = await prepareTransactionRequest(client, {
    maxPriorityFeePerGas: 1n,
  })
  expectTypeOf(result_2.gasPrice).toEqualTypeOf<never>()
  expectTypeOf(result_2.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_2.maxPriorityFeePerGas).toEqualTypeOf<bigint>()
})

test('args: eip4844 attributes', async () => {
  const result_1 = await prepareTransactionRequest(client, {
    blobs: ['0x'],
    kzg,
    maxFeePerBlobGas: 1n,
    to: '0x0000000000000000000000000000000000000000',
  })
  expectTypeOf(result_1.type).toEqualTypeOf<'eip4844'>()
  expectTypeOf(result_1.blobs).toEqualTypeOf<
    readonly Hex[] | readonly ByteArray[]
  >()
  expectTypeOf(result_1.kzg).toEqualTypeOf<Kzg>()
  expectTypeOf(result_1.blobVersionedHashes).toEqualTypeOf<readonly Hex[]>()
  expectTypeOf(result_1.gasPrice).toEqualTypeOf<never>()
  expectTypeOf(result_1.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_1.maxPriorityFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_1.maxFeePerBlobGas).toEqualTypeOf<bigint>()

  const result_2 = await prepareTransactionRequest(client, {
    blobs: ['0x'],
    blobVersionedHashes: ['0x'],
    maxFeePerBlobGas: 1n,
    to: '0x0000000000000000000000000000000000000000',
  })
  expectTypeOf(result_2.type).toEqualTypeOf<'eip4844'>()
  expectTypeOf(result_2.blobs).toEqualTypeOf<
    readonly Hex[] | readonly ByteArray[]
  >()
  expectTypeOf(result_2.blobVersionedHashes).toEqualTypeOf<readonly Hex[]>()
  expectTypeOf(result_2.gasPrice).toEqualTypeOf<never>()
  expectTypeOf(result_2.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_2.maxPriorityFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_2.maxFeePerBlobGas).toEqualTypeOf<bigint>()
})

test('args: parameters', async () => {
  const result_1 = await prepareTransactionRequest(client, {
    parameters: ['gas'],
  })
  expectTypeOf(result_1.gas).toEqualTypeOf<bigint>()
  expectTypeOf(result_1.nonce).toEqualTypeOf<number | undefined>()
  expectTypeOf(result_1.gasPrice).toEqualTypeOf<bigint | undefined>()
  expectTypeOf(result_1.maxFeePerGas).toEqualTypeOf<bigint | undefined>()
  expectTypeOf(result_1.maxPriorityFeePerGas).toEqualTypeOf<
    bigint | undefined
  >()
  expectTypeOf(result_1.type).toEqualTypeOf<
    'legacy' | 'eip2930' | 'eip1559' | 'eip4844' | 'eip7702' | undefined
  >()

  const result_2 = await prepareTransactionRequest(client, {
    parameters: ['gas', 'nonce'],
  })
  expectTypeOf(result_2.gas).toEqualTypeOf<bigint>()
  expectTypeOf(result_2.nonce).toEqualTypeOf<number>()
  expectTypeOf(result_2.gasPrice).toEqualTypeOf<bigint | undefined>()
  expectTypeOf(result_2.maxFeePerGas).toEqualTypeOf<bigint | undefined>()
  expectTypeOf(result_2.maxPriorityFeePerGas).toEqualTypeOf<
    bigint | undefined
  >()
  expectTypeOf(result_2.type).toEqualTypeOf<
    'legacy' | 'eip2930' | 'eip1559' | 'eip4844' | 'eip7702' | undefined
  >()

  const result_3 = await prepareTransactionRequest(client, {
    parameters: ['gas', 'nonce', 'fees'],
  })
  expectTypeOf(result_3.gas).toEqualTypeOf<bigint>()
  expectTypeOf(result_3.nonce).toEqualTypeOf<number>()
  expectTypeOf(result_3.gasPrice).toEqualTypeOf<bigint>()
  expectTypeOf(result_3.maxFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_3.maxPriorityFeePerGas).toEqualTypeOf<bigint>()
  expectTypeOf(result_3.type).toEqualTypeOf<
    'legacy' | 'eip2930' | 'eip1559' | 'eip4844' | 'eip7702' | undefined
  >()
})
</file>

<file path="src/actions/wallet/prepareTransactionRequest.ts">
import type { Address } from 'abitype'
import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import {
  type EstimateFeesPerGasErrorType,
  internal_estimateFeesPerGas,
} from '../../actions/public/estimateFeesPerGas.js'
import {
  type EstimateGasErrorType,
  type EstimateGasParameters,
  estimateGas,
} from '../../actions/public/estimateGas.js'
import {
  type GetBlockErrorType,
  getBlock as getBlock_,
} from '../../actions/public/getBlock.js'
import {
  type GetTransactionCountErrorType,
  getTransactionCount,
} from '../../actions/public/getTransactionCount.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { AccountNotFoundErrorType } from '../../errors/account.js'
import {
  Eip1559FeesNotSupportedError,
  MaxFeePerGasTooLowError,
} from '../../errors/fee.js'
import type { DeriveAccount, GetAccountParameter } from '../../types/account.js'
import type { Block } from '../../types/block.js'
import type { Chain, DeriveChain } from '../../types/chain.js'
import type { GetChainParameter } from '../../types/chain.js'
import type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'
import type {
  TransactionRequest,
  TransactionRequestEIP1559,
  TransactionRequestEIP2930,
  TransactionRequestEIP4844,
  TransactionRequestEIP7702,
  TransactionRequestLegacy,
  TransactionSerializable,
} from '../../types/transaction.js'
import type {
  ExactPartial,
  IsNever,
  Prettify,
  UnionOmit,
  UnionRequiredBy,
} from '../../types/utils.js'
import { blobsToCommitments } from '../../utils/blob/blobsToCommitments.js'
import { blobsToProofs } from '../../utils/blob/blobsToProofs.js'
import { commitmentsToVersionedHashes } from '../../utils/blob/commitmentsToVersionedHashes.js'
import { toBlobSidecars } from '../../utils/blob/toBlobSidecars.js'
import type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'
import { getAction } from '../../utils/getAction.js'
import type { NonceManager } from '../../utils/nonceManager.js'
import {
  type AssertRequestErrorType,
  type AssertRequestParameters,
  assertRequest,
} from '../../utils/transaction/assertRequest.js'
import {
  type GetTransactionType,
  getTransactionType,
} from '../../utils/transaction/getTransactionType.js'
import { getChainId as getChainId_ } from '../public/getChainId.js'

export const defaultParameters = [
  'blobVersionedHashes',
  'chainId',
  'fees',
  'gas',
  'nonce',
  'type',
] as const

/** @internal */
export const eip1559NetworkCache = /*#__PURE__*/ new Map<string, boolean>()

export type PrepareTransactionRequestParameterType =
  | 'blobVersionedHashes'
  | 'chainId'
  | 'fees'
  | 'gas'
  | 'nonce'
  | 'sidecars'
  | 'type'
type ParameterTypeToParameters<
  parameterType extends PrepareTransactionRequestParameterType,
> = parameterType extends 'fees'
  ? 'maxFeePerGas' | 'maxPriorityFeePerGas' | 'gasPrice'
  : parameterType

export type PrepareTransactionRequestRequest<
  chain extends Chain | undefined = Chain | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  ///
  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,
> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &
  GetTransactionRequestKzgParameter & {
    /**
     * Nonce manager to use for the transaction request.
     */
    nonceManager?: NonceManager | undefined
    /**
     * Parameters to prepare for the transaction request.
     *
     * @default ['blobVersionedHashes', 'chainId', 'fees', 'gas', 'nonce', 'type']
     */
    parameters?: readonly PrepareTransactionRequestParameterType[] | undefined
  }

export type PrepareTransactionRequestParameters<
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  accountOverride extends Account | Address | undefined =
    | Account
    | Address
    | undefined,
  request extends PrepareTransactionRequestRequest<
    chain,
    chainOverride
  > = PrepareTransactionRequestRequest<chain, chainOverride>,
> = request &
  GetAccountParameter<account, accountOverride, false, true> &
  GetChainParameter<chain, chainOverride> &
  GetTransactionRequestKzgParameter<request> & { chainId?: number | undefined }

export type PrepareTransactionRequestReturnType<
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  accountOverride extends Account | Address | undefined =
    | Account
    | Address
    | undefined,
  request extends PrepareTransactionRequestRequest<
    chain,
    chainOverride
  > = PrepareTransactionRequestRequest<chain, chainOverride>,
  ///
  _derivedAccount extends Account | Address | undefined = DeriveAccount<
    account,
    accountOverride
  >,
  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,
  _transactionType = request['type'] extends string | undefined
    ? request['type']
    : GetTransactionType<request> extends 'legacy'
      ? unknown
      : GetTransactionType<request>,
  _transactionRequest extends TransactionRequest =
    | (_transactionType extends 'legacy' ? TransactionRequestLegacy : never)
    | (_transactionType extends 'eip1559' ? TransactionRequestEIP1559 : never)
    | (_transactionType extends 'eip2930' ? TransactionRequestEIP2930 : never)
    | (_transactionType extends 'eip4844' ? TransactionRequestEIP4844 : never)
    | (_transactionType extends 'eip7702' ? TransactionRequestEIP7702 : never),
> = Prettify<
  UnionRequiredBy<
    Extract<
      UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &
        (_derivedChain extends Chain
          ? { chain: _derivedChain }
          : { chain?: undefined }) &
        (_derivedAccount extends Account
          ? { account: _derivedAccount; from: Address }
          : { account?: undefined; from?: undefined }),
      IsNever<_transactionRequest> extends true
        ? unknown
        : ExactPartial<_transactionRequest>
    > & { chainId?: number | undefined },
    ParameterTypeToParameters<
      request['parameters'] extends readonly PrepareTransactionRequestParameterType[]
        ? request['parameters'][number]
        : (typeof defaultParameters)[number]
    >
  > &
    (unknown extends request['kzg'] ? {} : Pick<request, 'kzg'>)
>

export type PrepareTransactionRequestErrorType =
  | AccountNotFoundErrorType
  | AssertRequestErrorType
  | ParseAccountErrorType
  | GetBlockErrorType
  | GetTransactionCountErrorType
  | EstimateGasErrorType
  | EstimateFeesPerGasErrorType

/**
 * Prepares a transaction request for signing.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest
 *
 * @param args - {@link PrepareTransactionRequestParameters}
 * @returns The transaction request. {@link PrepareTransactionRequestReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 */
export async function prepareTransactionRequest<
  chain extends Chain | undefined,
  account extends Account | undefined,
  const request extends PrepareTransactionRequestRequest<chain, chainOverride>,
  accountOverride extends Account | Address | undefined = undefined,
  chainOverride extends Chain | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
  args: PrepareTransactionRequestParameters<
    chain,
    account,
    chainOverride,
    accountOverride,
    request
  >,
): Promise<
  PrepareTransactionRequestReturnType<
    chain,
    account,
    chainOverride,
    accountOverride,
    request
  >
> {
  const {
    account: account_ = client.account,
    blobs,
    chain,
    gas,
    kzg,
    nonce,
    nonceManager,
    parameters = defaultParameters,
    type,
  } = args
  const account = account_ ? parseAccount(account_) : account_

  const request = { ...args, ...(account ? { from: account?.address } : {}) }

  let block: Block | undefined
  async function getBlock(): Promise<Block> {
    if (block) return block
    block = await getAction(
      client,
      getBlock_,
      'getBlock',
    )({ blockTag: 'latest' })
    return block
  }

  let chainId: number | undefined
  async function getChainId(): Promise<number> {
    if (chainId) return chainId
    if (chain) return chain.id
    if (typeof args.chainId !== 'undefined') return args.chainId
    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})
    chainId = chainId_
    return chainId
  }

  if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {
    if (nonceManager) {
      const chainId = await getChainId()
      request.nonce = await nonceManager.consume({
        address: account.address,
        chainId,
        client,
      })
    } else {
      request.nonce = await getAction(
        client,
        getTransactionCount,
        'getTransactionCount',
      )({
        address: account.address,
        blockTag: 'pending',
      })
    }
  }

  if (
    (parameters.includes('blobVersionedHashes') ||
      parameters.includes('sidecars')) &&
    blobs &&
    kzg
  ) {
    const commitments = blobsToCommitments({ blobs, kzg })

    if (parameters.includes('blobVersionedHashes')) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: 'hex',
      })
      request.blobVersionedHashes = versionedHashes
    }
    if (parameters.includes('sidecars')) {
      const proofs = blobsToProofs({ blobs, commitments, kzg })
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: 'hex',
      })
      request.sidecars = sidecars
    }
  }

  if (parameters.includes('chainId')) request.chainId = await getChainId()

  if (
    (parameters.includes('fees') || parameters.includes('type')) &&
    typeof type === 'undefined'
  ) {
    try {
      request.type = getTransactionType(
        request as TransactionSerializable,
      ) as any
    } catch {
      let isEip1559Network = eip1559NetworkCache.get(client.uid)
      if (typeof isEip1559Network === 'undefined') {
        const block = await getBlock()
        isEip1559Network = typeof block?.baseFeePerGas === 'bigint'
        eip1559NetworkCache.set(client.uid, isEip1559Network)
      }
      request.type = isEip1559Network ? 'eip1559' : 'legacy'
    }
  }

  if (parameters.includes('fees')) {
    // TODO(4844): derive blob base fees once https://github.com/ethereum/execution-apis/pull/486 is merged.

    if (request.type !== 'legacy' && request.type !== 'eip2930') {
      // EIP-1559 fees
      if (
        typeof request.maxFeePerGas === 'undefined' ||
        typeof request.maxPriorityFeePerGas === 'undefined'
      ) {
        const block = await getBlock()
        const { maxFeePerGas, maxPriorityFeePerGas } =
          await internal_estimateFeesPerGas(client, {
            block: block as Block,
            chain,
            request: request as PrepareTransactionRequestParameters,
          })

        if (
          typeof args.maxPriorityFeePerGas === 'undefined' &&
          args.maxFeePerGas &&
          args.maxFeePerGas < maxPriorityFeePerGas
        )
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas,
          })

        request.maxPriorityFeePerGas = maxPriorityFeePerGas
        request.maxFeePerGas = maxFeePerGas
      }
    } else {
      // Legacy fees
      if (
        typeof args.maxFeePerGas !== 'undefined' ||
        typeof args.maxPriorityFeePerGas !== 'undefined'
      )
        throw new Eip1559FeesNotSupportedError()

      if (typeof args.gasPrice === 'undefined') {
        const block = await getBlock()
        const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(
          client,
          {
            block: block as Block,
            chain,
            request: request as PrepareTransactionRequestParameters,
            type: 'legacy',
          },
        )
        request.gasPrice = gasPrice_
      }
    }
  }

  if (parameters.includes('gas') && typeof gas === 'undefined')
    request.gas = await getAction(
      client,
      estimateGas,
      'estimateGas',
    )({
      ...request,
      account: account
        ? { address: account.address, type: 'json-rpc' }
        : account,
    } as EstimateGasParameters)

  assertRequest(request as AssertRequestParameters)

  delete request.parameters

  return request as any
}
</file>

<file path="src/actions/wallet/requestAddresses.ts">
import type { Address } from 'abitype'

import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import { getAddress } from '../../utils/address/getAddress.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type RequestAddressesReturnType = Address[]

export type RequestAddressesErrorType = RequestErrorType | ErrorType

/**
 * Requests a list of accounts managed by a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses
 * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)
 *
 * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).
 *
 * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.
 *
 * @param client - Client to use
 * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { requestAddresses } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const accounts = await requestAddresses(client)
 */
export async function requestAddresses<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
): Promise<RequestAddressesReturnType> {
  const addresses = await client.request(
    { method: 'eth_requestAccounts' },
    { dedupe: true, retryCount: 0 },
  )
  return addresses.map((address) => getAddress(address))
}
</file>

<file path="src/actions/wallet/requestPermissions.ts">
import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { WalletPermission } from '../../types/eip1193.js'
import type { Prettify } from '../../types/utils.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type RequestPermissionsParameters = Prettify<
  {
    eth_accounts: Record<string, any>
  } & {
    [key: string]: Record<string, any>
  }
>
export type RequestPermissionsReturnType = WalletPermission[]

export type RequestPermissionsErrorType = RequestErrorType | ErrorType

/**
 * Requests permissions for a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions
 * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
 *
 * @param client - Client to use
 * @param parameters - {@link RequestPermissionsParameters}
 * @returns The wallet permissions. {@link RequestPermissionsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { requestPermissions } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const permissions = await requestPermissions(client, {
 *   eth_accounts: {}
 * })
 */
export async function requestPermissions<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
  permissions: RequestPermissionsParameters,
) {
  return client.request(
    {
      method: 'wallet_requestPermissions',
      params: [permissions],
    },
    { retryCount: 0 },
  )
}
</file>

<file path="src/actions/wallet/sendCalls.ts">
import type { Address, Narrow } from 'abitype'
import { parseAccount } from '../../accounts/utils/parseAccount.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import { AccountNotFoundError } from '../../errors/account.js'
import type { BaseError } from '../../errors/base.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account, GetAccountParameter } from '../../types/account.js'
import type { Call, Calls } from '../../types/calls.js'
import type { Chain, DeriveChain } from '../../types/chain.js'
import type {
  WalletCapabilities,
  WalletSendCallsParameters,
} from '../../types/eip1193.js'
import { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import { numberToHex } from '../../utils/encoding/toHex.js'
import { getTransactionError } from '../../utils/errors/getTransactionError.js'

export type SendCallsParameters<
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  calls extends readonly unknown[] = readonly unknown[],
  //
  _chain extends Chain | undefined = DeriveChain<chain, chainOverride>,
> = {
  chain?: chainOverride | Chain | undefined
  calls: Calls<Narrow<calls>>
  capabilities?: WalletCapabilities | undefined
  forceAtomic?: boolean | undefined
  id?: string | undefined
  version?: WalletSendCallsParameters[number]['version'] | undefined
} & GetAccountParameter<account, Account | Address, true, true>

export type SendCallsReturnType = {
  capabilities?: WalletCapabilities | undefined
  id: string
}

export type SendCallsErrorType = RequestErrorType | ErrorType

/**
 * Requests the connected wallet to send a batch of calls.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/sendCalls
 * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns Transaction identifier. {@link SendCallsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { sendCalls } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const id = await sendCalls(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   calls: [
 *     {
 *       data: '0xdeadbeef',
 *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *     },
 *     {
 *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *       value: 69420n,
 *     },
 *   ],
 * })
 */
export async function sendCalls<
  const calls extends readonly unknown[],
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
  chainOverride extends Chain | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: SendCallsParameters<chain, account, chainOverride, calls>,
): Promise<SendCallsReturnType> {
  const {
    account: account_ = client.account,
    capabilities,
    chain = client.chain,
    forceAtomic = false,
    id,
    version = '2.0.0',
  } = parameters

  if (typeof account_ === 'undefined')
    throw new AccountNotFoundError({
      docsPath: '/docs/actions/wallet/sendCalls',
    })
  const account = account_ ? parseAccount(account_) : null

  const calls = parameters.calls.map((call_: unknown) => {
    const call = call_ as Call

    const data = call.abi
      ? encodeFunctionData({
          abi: call.abi,
          functionName: call.functionName,
          args: call.args,
        })
      : call.data

    return {
      data,
      to: call.to,
      value: call.value ? numberToHex(call.value) : undefined,
    }
  })

  try {
    const response = await client.request(
      {
        method: 'wallet_sendCalls',
        params: [
          {
            atomicRequired: forceAtomic,
            calls,
            capabilities,
            chainId: numberToHex(chain!.id),
            from: account?.address,
            id,
            version,
          },
        ],
      },
      { retryCount: 0 },
    )
    if (typeof response === 'string') return { id: response }
    return response
  } catch (err) {
    throw getTransactionError(err as BaseError, {
      ...parameters,
      account,
      chain: parameters.chain!,
    })
  }
}
</file>

<file path="src/actions/wallet/sendRawTransaction.ts">
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { Hash } from '../../types/misc.js'
import type { TransactionSerializedGeneric } from '../../types/transaction.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type SendRawTransactionParameters = {
  /** The signed serialized transaction. */
  serializedTransaction: TransactionSerializedGeneric
}

export type SendRawTransactionReturnType = Hash

export type SendRawTransactionErrorType = RequestErrorType | ErrorType

/**
 * Sends a **signed** transaction to the network
 *
 * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction
 * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)
 *
 * @param client - Client to use
 * @param parameters - {@link SendRawTransactionParameters}
 * @returns The transaction hash. {@link SendRawTransactionReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { sendRawTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 *
 * const hash = await sendRawTransaction(client, {
 *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'
 * })
 */
export async function sendRawTransaction<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  { serializedTransaction }: SendRawTransactionParameters,
): Promise<SendRawTransactionReturnType> {
  return client.request(
    {
      method: 'eth_sendRawTransaction',
      params: [serializedTransaction],
    },
    { retryCount: 0 },
  )
}
</file>

<file path="src/actions/wallet/sendTransaction.bench.ts">
import { JsonRpcSigner } from 'ethers'

import { bench, describe } from 'vitest'

import { ethersProvider } from '~test/src/bench.js'
import { accounts } from '~test/src/constants.js'
import { parseEther } from '../../utils/unit/parseEther.js'

import { anvilMainnet } from '../../../test/src/anvil.js'
import { sendTransaction } from './sendTransaction.js'

const client = anvilMainnet.getClient()

describe('Send Transaction', () => {
  bench('viem: `sendTransaction`', async () => {
    await sendTransaction(client, {
      account: accounts[0].address,
      to: accounts[1].address,
      value: parseEther('1'),
    })
  })

  bench('ethers: `sendTransaction`', async () => {
    const signer = new JsonRpcSigner(ethersProvider, accounts[2].address)
    await signer.sendTransaction({
      to: accounts[1].address,
      value: parseEther('1'),
    })
  })
})
</file>

<file path="src/actions/wallet/sendTransaction.test-d.ts">
import type { Address } from 'abitype'

import { test } from 'vitest'

import { anvilMainnet } from '../../../test/src/anvil.js'
import type { Account } from '../../accounts/types.js'
import { createWalletClient } from '../../clients/createWalletClient.js'
import { http } from '../../clients/transports/http.js'
import type { Chain } from '../../types/chain.js'

import { sendTransaction } from './sendTransaction.js'

const walletClient = createWalletClient({
  account: '0x',
  chain: anvilMainnet.chain,
  transport: http(anvilMainnet.rpcUrl.http),
})
const walletClientWithoutAccount = createWalletClient({
  chain: anvilMainnet.chain,
  transport: http(anvilMainnet.rpcUrl.http),
})
const walletClientWithoutChain = createWalletClient({
  account: '0x',
  transport: http(anvilMainnet.rpcUrl.http),
})

test('with and without `account`', () => {
  sendTransaction(walletClient, {
    account: '0x' as Account | Address | undefined,
    // ^?
  })
  sendTransaction(walletClientWithoutAccount, {
    account: '0x' as Account | Address,
    // ^?
  })
})

test('with and without `chain`', () => {
  sendTransaction(walletClient, {
    chain: anvilMainnet.chain as Chain | undefined,
    // ^?
  })
  sendTransaction(walletClientWithoutChain, {
    chain: anvilMainnet.chain as Chain,
    // ^?
  })
})

test('legacy', () => {
  sendTransaction(walletClient, {
    gasPrice: 0n,
  })

  // @ts-expect-error
  sendTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  sendTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
  // @ts-expect-error
  sendTransaction(walletClient, {
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
})

test('eip1559', () => {
  sendTransaction(walletClient, {
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  sendTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  sendTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip1559',
  })
  // @ts-expect-error
  sendTransaction(walletClient, {
    gasPrice: 0n,
    type: 'eip1559',
  })
})

test('eip2930', () => {
  sendTransaction(walletClient, {
    accessList: [],
    gasPrice: 0n,
  })

  // @ts-expect-error
  sendTransaction(walletClient, {
    accessList: [],
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  sendTransaction(walletClient, {
    accessList: [],
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
  // @ts-expect-error
  sendTransaction(walletClient, {
    accessList: [],
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
})
</file>

<file path="src/actions/wallet/sendTransaction.ts">
import type { Address } from 'abitype'

import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  AccountNotFoundError,
  type AccountNotFoundErrorType,
  AccountTypeNotSupportedError,
  type AccountTypeNotSupportedErrorType,
} from '../../errors/account.js'
import { BaseError } from '../../errors/base.js'
import type { ErrorType } from '../../errors/utils.js'
import type { GetAccountParameter } from '../../types/account.js'
import type {
  Chain,
  DeriveChain,
  GetChainParameter,
} from '../../types/chain.js'
import type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'
import type { Hash } from '../../types/misc.js'
import type { TransactionRequest } from '../../types/transaction.js'
import type { UnionOmit } from '../../types/utils.js'
import {
  type RecoverAuthorizationAddressErrorType,
  recoverAuthorizationAddress,
} from '../../utils/authorization/recoverAuthorizationAddress.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import {
  type AssertCurrentChainErrorType,
  assertCurrentChain,
} from '../../utils/chain/assertCurrentChain.js'
import {
  type GetTransactionErrorReturnType,
  getTransactionError,
} from '../../utils/errors/getTransactionError.js'
import { extract } from '../../utils/formatters/extract.js'
import {
  type FormattedTransactionRequest,
  formatTransactionRequest,
} from '../../utils/formatters/transactionRequest.js'
import { getAction } from '../../utils/getAction.js'
import { LruMap } from '../../utils/lru.js'
import {
  type AssertRequestErrorType,
  type AssertRequestParameters,
  assertRequest,
} from '../../utils/transaction/assertRequest.js'
import { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'
import {
  type PrepareTransactionRequestErrorType,
  defaultParameters,
  prepareTransactionRequest,
} from './prepareTransactionRequest.js'
import {
  type SendRawTransactionErrorType,
  sendRawTransaction,
} from './sendRawTransaction.js'

const supportsWalletNamespace = new LruMap<boolean>(128)

export type SendTransactionRequest<
  chain extends Chain | undefined = Chain | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  ///
  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,
> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &
  GetTransactionRequestKzgParameter

export type SendTransactionParameters<
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  request extends SendTransactionRequest<
    chain,
    chainOverride
  > = SendTransactionRequest<chain, chainOverride>,
> = request &
  GetAccountParameter<account, Account | Address, true, true> &
  GetChainParameter<chain, chainOverride> &
  GetTransactionRequestKzgParameter<request>

export type SendTransactionReturnType = Hash

export type SendTransactionErrorType =
  | ParseAccountErrorType
  | GetTransactionErrorReturnType<
      | AccountNotFoundErrorType
      | AccountTypeNotSupportedErrorType
      | AssertCurrentChainErrorType
      | AssertRequestErrorType
      | GetChainIdErrorType
      | PrepareTransactionRequestErrorType
      | SendRawTransactionErrorType
      | RecoverAuthorizationAddressErrorType
      | SignTransactionErrorType
      | RequestErrorType
    >
  | ErrorType

/**
 * Creates, signs, and sends a new transaction to the network.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)
 *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)
 *
 * @param client - Client to use
 * @param parameters - {@link SendTransactionParameters}
 * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { sendTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const hash = await sendTransaction(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { sendTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const hash = await sendTransaction(client, {
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 */
export async function sendTransaction<
  chain extends Chain | undefined,
  account extends Account | undefined,
  const request extends SendTransactionRequest<chain, chainOverride>,
  chainOverride extends Chain | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: SendTransactionParameters<chain, account, chainOverride, request>,
): Promise<SendTransactionReturnType> {
  const {
    account: account_ = client.account,
    chain = client.chain,
    accessList,
    authorizationList,
    blobs,
    data,
    gas,
    gasPrice,
    maxFeePerBlobGas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    type,
    value,
    ...rest
  } = parameters

  if (typeof account_ === 'undefined')
    throw new AccountNotFoundError({
      docsPath: '/docs/actions/wallet/sendTransaction',
    })
  const account = account_ ? parseAccount(account_) : null

  try {
    assertRequest(parameters as AssertRequestParameters)

    const to = await (async () => {
      // If `to` exists on the parameters, use that.
      if (parameters.to) return parameters.to

      // If `to` is null, we are sending a deployment transaction.
      if (parameters.to === null) return undefined

      // If no `to` exists, and we are sending a EIP-7702 transaction, use the
      // address of the first authorization in the list.
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0],
        }).catch(() => {
          throw new BaseError(
            '`to` is required. Could not infer from `authorizationList`.',
          )
        })

      // Otherwise, we are sending a deployment transaction.
      return undefined
    })()

    if (account?.type === 'json-rpc' || account === null) {
      let chainId: number | undefined
      if (chain !== null) {
        chainId = await getAction(client, getChainId, 'getChainId')({})
        assertCurrentChain({
          currentChainId: chainId,
          chain,
        })
      }

      const chainFormat = client.chain?.formatters?.transactionRequest?.format
      const format = chainFormat || formatTransactionRequest

      const request = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data,
        from: account?.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        type,
        value,
      } as TransactionRequest)

      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)
      const method = isWalletNamespaceSupported
        ? 'wallet_sendTransaction'
        : 'eth_sendTransaction'

      try {
        return await client.request(
          {
            method,
            params: [request],
          },
          { retryCount: 0 },
        )
      } catch (e) {
        if (isWalletNamespaceSupported === false) throw e

        const error = e as BaseError
        // If the transport does not support the method or input, attempt to use the
        // `wallet_sendTransaction` method.
        if (
          error.name === 'InvalidInputRpcError' ||
          error.name === 'InvalidParamsRpcError' ||
          error.name === 'MethodNotFoundRpcError' ||
          error.name === 'MethodNotSupportedRpcError'
        ) {
          return await client
            .request(
              {
                method: 'wallet_sendTransaction',
                params: [request],
              },
              { retryCount: 0 },
            )
            .then((hash) => {
              supportsWalletNamespace.set(client.uid, true)
              return hash
            })
            .catch((e) => {
              const walletNamespaceError = e as BaseError
              if (
                walletNamespaceError.name === 'MethodNotFoundRpcError' ||
                walletNamespaceError.name === 'MethodNotSupportedRpcError'
              ) {
                supportsWalletNamespace.set(client.uid, false)
                throw error
              }

              throw walletNamespaceError
            })
        }

        throw error
      }
    }

    if (account?.type === 'local') {
      // Prepare the request for signing (assign appropriate fees, etc.)
      const request = await getAction(
        client,
        prepareTransactionRequest,
        'prepareTransactionRequest',
      )({
        account,
        accessList,
        authorizationList,
        blobs,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account.nonceManager,
        parameters: [...defaultParameters, 'sidecars'],
        type,
        value,
        ...rest,
        to,
      } as any)

      const serializer = chain?.serializers?.transaction
      const serializedTransaction = (await account.signTransaction(request, {
        serializer,
      })) as Hash
      return await getAction(
        client,
        sendRawTransaction,
        'sendRawTransaction',
      )({
        serializedTransaction,
      })
    }

    if (account?.type === 'smart')
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          'Consider using the `sendUserOperation` Action instead.',
        ],
        docsPath: '/docs/actions/bundler/sendUserOperation',
        type: 'smart',
      })

    throw new AccountTypeNotSupportedError({
      docsPath: '/docs/actions/wallet/sendTransaction',
      type: (account as any)?.type,
    })
  } catch (err) {
    if (err instanceof AccountTypeNotSupportedError) throw err
    throw getTransactionError(err as BaseError, {
      ...parameters,
      account,
      chain: parameters.chain || undefined,
    })
  }
}
</file>

<file path="src/actions/wallet/showCallsStatus.ts">
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type ShowCallsStatusParameters = { id: string }

export type ShowCallsStatusReturnType = void

export type ShowCallsStatusErrorType = RequestErrorType | ErrorType

/**
 * Requests for the wallet to show information about a call batch
 * that was sent via `sendCalls`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/showCallsStatus
 * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns Status of the calls. {@link ShowCallsStatusReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { showCallsStatus } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * await showCallsStatus(client, { id: '0xdeadbeef' })
 */
export async function showCallsStatus<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: ShowCallsStatusParameters,
): Promise<ShowCallsStatusReturnType> {
  const { id } = parameters
  await client.request({
    method: 'wallet_showCallsStatus',
    params: [id],
  })
  return
}
</file>

<file path="src/actions/wallet/signAuthorization.ts">
import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type {
  SignAuthorizationErrorType as SignAuthorizationErrorType_account,
  SignAuthorizationReturnType as SignAuthorizationReturnType_account,
} from '../../accounts/utils/signAuthorization.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  AccountNotFoundError,
  type AccountNotFoundErrorType,
  AccountTypeNotSupportedError,
  type AccountTypeNotSupportedErrorType,
} from '../../errors/account.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import {
  type PrepareAuthorizationErrorType,
  type PrepareAuthorizationParameters,
  prepareAuthorization,
} from './prepareAuthorization.js'

export type SignAuthorizationParameters<
  account extends Account | undefined = Account | undefined,
> = PrepareAuthorizationParameters<account>

export type SignAuthorizationReturnType = SignAuthorizationReturnType_account

export type SignAuthorizationErrorType =
  | ParseAccountErrorType
  | AccountNotFoundErrorType
  | AccountTypeNotSupportedErrorType
  | PrepareAuthorizationErrorType
  | SignAuthorizationErrorType_account
  | ErrorType

/**
 * Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object.
 *
 * With the calculated signature, you can:
 * - use [`verifyAuthorization`](https://viem.sh/docs/eip7702/verifyAuthorization) to verify the signed Authorization object,
 * - use [`recoverAuthorizationAddress`](https://viem.sh/docs/eip7702/recoverAuthorizationAddress) to recover the signing address from the signed Authorization object.
 *
 * @param client - Client to use
 * @param parameters - {@link SignAuthorizationParameters}
 * @returns The signed Authorization object. {@link SignAuthorizationReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signAuthorization(client, {
 *   account: privateKeyToAccount('0x..'),
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signAuthorization(client, {
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */
export async function signAuthorization<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: SignAuthorizationParameters<account>,
): Promise<SignAuthorizationReturnType> {
  const { account: account_ = client.account } = parameters

  if (!account_)
    throw new AccountNotFoundError({
      docsPath: '/docs/eip7702/signAuthorization',
    })
  const account = parseAccount(account_)

  if (!account.signAuthorization)
    throw new AccountTypeNotSupportedError({
      docsPath: '/docs/eip7702/signAuthorization',
      metaMessages: [
        'The `signAuthorization` Action does not support JSON-RPC Accounts.',
      ],
      type: account.type,
    })

  const authorization = await prepareAuthorization(client, parameters)
  return account.signAuthorization(authorization)
}
</file>

<file path="src/actions/wallet/signMessage.ts">
import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type { SignMessageErrorType as SignMessageErrorType_account } from '../../accounts/utils/signMessage.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import { AccountNotFoundError } from '../../errors/account.js'
import type { ErrorType } from '../../errors/utils.js'
import type { GetAccountParameter } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hex, SignableMessage } from '../../types/misc.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import {
  type ToHexErrorType,
  stringToHex,
  toHex,
} from '../../utils/encoding/toHex.js'

export type SignMessageParameters<
  account extends Account | undefined = Account | undefined,
> = GetAccountParameter<account> & {
  message: SignableMessage
}

export type SignMessageReturnType = Hex

export type SignMessageErrorType =
  | ParseAccountErrorType
  | RequestErrorType
  | SignMessageErrorType_account
  | ToHexErrorType
  | ErrorType

/**
 * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signMessage
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * With the calculated signature, you can:
 * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,
 * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.
 *
 * @param client - Client to use
 * @param parameters - {@link SignMessageParameters}
 * @returns The signed message. {@link SignMessageReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   message: 'hello world',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, custom } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   message: 'hello world',
 * })
 */
export async function signMessage<
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: Client<Transport, chain, account>,
  {
    account: account_ = client.account,
    message,
  }: SignMessageParameters<account>,
): Promise<SignMessageReturnType> {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: '/docs/actions/wallet/signMessage',
    })
  const account = parseAccount(account_)

  if (account.signMessage) return account.signMessage({ message })

  const message_ = (() => {
    if (typeof message === 'string') return stringToHex(message)
    if (message.raw instanceof Uint8Array) return toHex(message.raw)
    return message.raw
  })()

  return client.request(
    {
      method: 'personal_sign',
      params: [message_, account.address],
    },
    { retryCount: 0 },
  )
}
</file>

<file path="src/actions/wallet/signTransaction.test-d.ts">
import type { Address } from 'abitype'

import { expectTypeOf, test } from 'vitest'

import { anvilMainnet } from '../../../test/src/anvil.js'
import type { Account } from '../../accounts/types.js'
import { createWalletClient } from '../../clients/createWalletClient.js'
import { http } from '../../clients/transports/http.js'
import type { Chain } from '../../types/chain.js'

import type {
  TransactionSerializedEIP1559,
  TransactionSerializedEIP2930,
  TransactionSerializedEIP4844,
  TransactionSerializedEIP7702,
  TransactionSerializedLegacy,
} from '~viem/index.js'
import { signTransaction } from './signTransaction.js'

const walletClient = createWalletClient({
  account: '0x',
  chain: anvilMainnet.chain,
  transport: http(anvilMainnet.rpcUrl.http),
})
const walletClientWithoutAccount = createWalletClient({
  chain: anvilMainnet.chain,
  transport: http(anvilMainnet.rpcUrl.http),
})
const walletClientWithoutChain = createWalletClient({
  account: '0x',
  transport: http(anvilMainnet.rpcUrl.http),
})

test('with and without `account`', () => {
  signTransaction(walletClient, {
    account: '0x' as Account | Address | undefined,
    // ^?
  })
  signTransaction(walletClientWithoutAccount, {
    account: '0x' as Account | Address,
    // ^?
  })
})

test('with and without `chain`', () => {
  signTransaction(walletClient, {
    chain: anvilMainnet.chain as Chain | undefined,
    // ^?
  })
  signTransaction(walletClientWithoutChain, {
    chain: anvilMainnet.chain as Chain,
    // ^?
  })
})

test('legacy', () => {
  const signature1 = signTransaction(walletClient, {
    gasPrice: 0n,
  })
  const signature2 = signTransaction(walletClient, {
    type: 'legacy',
  })

  expectTypeOf(signature1).toEqualTypeOf<Promise<TransactionSerializedLegacy>>()
  expectTypeOf(signature2).toEqualTypeOf<Promise<TransactionSerializedLegacy>>()

  // @ts-expect-error
  signTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  signTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
  // @ts-expect-error
  signTransaction(walletClient, {
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
})

test('eip7702', () => {
  const signature1 = signTransaction(walletClient, {
    authorizationList: [],
  })
  const signature2 = signTransaction(walletClient, {
    authorizationList: [],
    type: 'eip7702',
  })

  expectTypeOf(signature1).toEqualTypeOf<
    Promise<TransactionSerializedEIP7702>
  >()
  expectTypeOf(signature2).toEqualTypeOf<
    Promise<TransactionSerializedEIP7702>
  >()
})

test('eip4844', () => {
  const signature1 = signTransaction(walletClient, {
    blobs: [],
    maxFeePerBlobGas: 0n,
    to: '0x0000000000000000000000000000000000000000',
  })
  const signature2 = signTransaction(walletClient, {
    blobs: [],
    maxFeePerBlobGas: 0n,
    to: '0x0000000000000000000000000000000000000000',
    type: 'eip4844',
  })

  expectTypeOf(signature1).toEqualTypeOf<
    Promise<TransactionSerializedEIP4844>
  >()
  expectTypeOf(signature2).toEqualTypeOf<
    Promise<TransactionSerializedEIP4844>
  >()
})

test('eip1559', () => {
  const signature1 = signTransaction(walletClient, {
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })
  const signature2 = signTransaction(walletClient, {
    type: 'eip1559',
  })

  expectTypeOf(signature1).toEqualTypeOf<
    Promise<TransactionSerializedEIP1559>
  >()
  expectTypeOf(signature2).toEqualTypeOf<
    Promise<TransactionSerializedEIP1559>
  >()

  // @ts-expect-error
  signTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  signTransaction(walletClient, {
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip1559',
  })
  // @ts-expect-error
  signTransaction(walletClient, {
    gasPrice: 0n,
    type: 'eip1559',
  })
})

test('eip2930', () => {
  const signature1 = signTransaction(walletClient, {
    accessList: [],
    gasPrice: 0n,
  })

  const signature2 = signTransaction(walletClient, {
    type: 'eip2930',
  })

  expectTypeOf(signature1).toEqualTypeOf<
    Promise<TransactionSerializedEIP2930>
  >()
  expectTypeOf(signature2).toEqualTypeOf<
    Promise<TransactionSerializedEIP2930>
  >()

  // @ts-expect-error
  signTransaction(walletClient, {
    accessList: [],
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  signTransaction(walletClient, {
    accessList: [],
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
  // @ts-expect-error
  signTransaction(walletClient, {
    accessList: [],
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
})
</file>

<file path="src/actions/wallet/signTransaction.ts">
import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type { SignTransactionErrorType as SignTransactionErrorType_account } from '../../accounts/utils/signTransaction.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import { AccountNotFoundError } from '../../errors/account.js'
import type { ErrorType } from '../../errors/utils.js'
import type { GetAccountParameter } from '../../types/account.js'
import type {
  Chain,
  DeriveChain,
  GetChainParameter,
} from '../../types/chain.js'
import type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'
import type { RpcTransactionRequest } from '../../types/rpc.js'
import type {
  TransactionRequest,
  TransactionSerializable,
  TransactionSerialized,
} from '../../types/transaction.js'
import type { UnionOmit } from '../../types/utils.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import {
  type AssertCurrentChainErrorType,
  assertCurrentChain,
} from '../../utils/chain/assertCurrentChain.js'
import { numberToHex } from '../../utils/encoding/toHex.js'
import type { NumberToHexErrorType } from '../../utils/encoding/toHex.js'
import {
  type FormattedTransactionRequest,
  formatTransactionRequest,
} from '../../utils/formatters/transactionRequest.js'
import { getAction } from '../../utils/getAction.js'
import {
  type AssertRequestErrorType,
  assertRequest,
} from '../../utils/transaction/assertRequest.js'
import type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'
import { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'

export type SignTransactionRequest<
  chain extends Chain | undefined = Chain | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  ///
  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,
> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'>

export type SignTransactionParameters<
  chain extends Chain | undefined,
  account extends Account | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  request extends SignTransactionRequest<
    chain,
    chainOverride
  > = SignTransactionRequest<chain, chainOverride>,
> = request &
  GetAccountParameter<account> &
  GetChainParameter<chain, chainOverride> &
  GetTransactionRequestKzgParameter<request>

export type SignTransactionReturnType<
  request extends SignTransactionRequest = SignTransactionRequest,
> = TransactionSerialized<GetTransactionType<request>>

export type SignTransactionErrorType =
  | ParseAccountErrorType
  | AssertRequestErrorType
  | GetChainIdErrorType
  | AssertCurrentChainErrorType
  | SignTransactionErrorType_account
  | NumberToHexErrorType
  | RequestErrorType
  | ErrorType

/**
 * Signs a transaction.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signTransaction
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * @param args - {@link SignTransactionParameters}
 * @returns The signed serialized transaction. {@link SignTransactionReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signTransaction } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTransaction(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signTransaction } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTransaction(client, {
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 */
export async function signTransaction<
  chain extends Chain | undefined,
  account extends Account | undefined,
  chainOverride extends Chain | undefined = undefined,
  const request extends SignTransactionRequest<
    chain,
    chainOverride
  > = SignTransactionRequest<chain, chainOverride>,
>(
  client: Client<Transport, chain, account>,
  parameters: SignTransactionParameters<chain, account, chainOverride, request>,
): Promise<SignTransactionReturnType<request>> {
  const {
    account: account_ = client.account,
    chain = client.chain,
    ...transaction
  } = parameters

  if (!account_)
    throw new AccountNotFoundError({
      docsPath: '/docs/actions/wallet/signTransaction',
    })
  const account = parseAccount(account_)

  assertRequest({
    account,
    ...parameters,
  })

  const chainId = await getAction(client, getChainId, 'getChainId')({})
  if (chain !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain,
    })

  const formatters = chain?.formatters || client.chain?.formatters
  const format =
    formatters?.transactionRequest?.format || formatTransactionRequest

  if (account.signTransaction)
    return account.signTransaction(
      {
        ...transaction,
        chainId,
      } as TransactionSerializable,
      { serializer: client.chain?.serializers?.transaction },
    ) as Promise<SignTransactionReturnType<request>>

  return await client.request(
    {
      method: 'eth_signTransaction',
      params: [
        {
          ...format(transaction as unknown as TransactionRequest),
          chainId: numberToHex(chainId),
          from: account.address,
        } as unknown as RpcTransactionRequest,
      ],
    },
    { retryCount: 0 },
  )
}
</file>

<file path="src/actions/wallet/signTypedData.test-d.ts">
import type { TypedData } from 'abitype'
import { expectTypeOf, test } from 'vitest'

import { anvilMainnet } from '../../../test/src/anvil.js'
import { walletActions } from '../../clients/decorators/wallet.js'
import { type SignTypedDataParameters, signTypedData } from './signTypedData.js'

const client = anvilMainnet.getClient().extend(walletActions)

const types = {
  Name: [
    { name: 'first', type: 'string' },
    { name: 'last', type: 'string' },
  ],
  Person: [
    { name: 'name', type: 'Name' },
    { name: 'wallet', type: 'address' },
    { name: 'favoriteColors', type: 'string[3]' },
    { name: 'age', type: 'uint8' },
    { name: 'isCool', type: 'bool' },
  ],
  Mail: [
    { name: 'timestamp', type: 'uint256' },
    { name: 'from', type: 'Person' },
    { name: 'to', type: 'Person' },
    { name: 'contents', type: 'string' },
    { name: 'hash', type: 'bytes' },
  ],
} as const
const account = {
  address: '0x',
  type: 'json-rpc',
} as const
const domain = {
  name: 'Ether Mail',
  version: '1',
  chainId: 1,
  verifyingContract: '0x0000000000000000000000000000000000000000',
} as const

test('SignTypedDataParameters', () => {
  type Result = SignTypedDataParameters<typeof types, 'Mail'>
  expectTypeOf<Result['primaryType']>().toEqualTypeOf<
    'Mail' | 'Person' | 'Name'
  >()
  expectTypeOf<Result['message']>().toEqualTypeOf<{
    timestamp: bigint
    from: {
      name: { first: string; last: string }
      wallet: `0x${string}`
      favoriteColors: readonly [string, string, string]
      age: number
      isCool: boolean
    }
    to: {
      name: { first: string; last: string }
      wallet: `0x${string}`
      favoriteColors: readonly [string, string, string]
      age: number
      isCool: boolean
    }
    contents: string
    hash: `0x${string}`
  }>()
  expectTypeOf<Result['message']>().not.toEqualTypeOf<{
    name: { first: string; last: string }
    wallet: `0x${string}`
    favoriteColors: readonly [string, string, string]
    age: number
    isCool: boolean
  }>()
  expectTypeOf<Result['message']>().not.toEqualTypeOf<{
    first: string
    last: string
  }>()
})

test('using client', () => {
  const primaryType = 'Name'
  client.signTypedData({
    account,
    domain,
    types,
    primaryType,
    message: {
      first: 'Cow',
      last: 'Burns',
    },
  })
  type Result = Parameters<
    typeof client.signTypedData<typeof types, typeof primaryType>
  >[0]
  expectTypeOf<Result['message']>().toEqualTypeOf<{
    first: string
    last: string
  }>()
  expectTypeOf<Result['message']>().not.toEqualTypeOf<{
    name: { first: string; last: string }
    wallet: `0x${string}`
    favoriteColors: readonly [string, string, string]
    age: number
    isCool: boolean
  }>()
})

test('using function', () => {
  const primaryType = 'Name'
  signTypedData(client, {
    account,
    domain,
    types,
    primaryType,
    message: {
      first: 'Cow',
      last: 'Burns',
    },
  })
  type Result = Parameters<
    typeof client.signTypedData<typeof types, typeof primaryType>
  >[0]
  expectTypeOf<Result['message']>().toEqualTypeOf<{
    first: string
    last: string
  }>()
  expectTypeOf<Result['message']>().not.toEqualTypeOf<{
    name: { first: string; last: string }
    wallet: `0x${string}`
    favoriteColors: readonly [string, string, string]
    age: number
    isCool: boolean
  }>()
})

test('`types` not const asserted', () => {
  const primaryType = 'Name'
  const types_ = {
    Name: [
      { name: 'first', type: 'string' },
      { name: 'last', type: 'string' },
    ],
  }
  signTypedData(client, {
    account,
    domain,
    types: types_,
    primaryType,
    message: {
      first: 'Cow',
      last: 'Burns',
    },
  })
  type Result = Parameters<
    typeof client.signTypedData<typeof types_, typeof primaryType>
  >[0]
  expectTypeOf<Result['message']>().toEqualTypeOf<Record<string, unknown>>()
})

test('`types` declared as `TypedData`', () => {
  const primaryType = 'Name'
  const types_: TypedData = {
    Name: [
      { name: 'first', type: 'string' },
      { name: 'last', type: 'string' },
    ],
  }
  signTypedData(client, {
    account,
    domain,
    types: types_,
    primaryType,
    message: {
      first: 'Cow',
      last: 'Burns',
    },
  })
  type Result = Parameters<
    typeof client.signTypedData<typeof types_, typeof primaryType>
  >[0]
  expectTypeOf<Result['message']>().toEqualTypeOf<Record<string, unknown>>()
})
</file>

<file path="src/actions/wallet/signTypedData.ts">
import type { TypedData } from 'abitype'

import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type { SignTypedDataErrorType as SignTypedDataErrorType_account } from '../../accounts/utils/signTypedData.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  AccountNotFoundError,
  type AccountNotFoundErrorType,
} from '../../errors/account.js'
import type { ErrorType } from '../../errors/utils.js'
import type { GetAccountParameter } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Hex } from '../../types/misc.js'
import type { TypedDataDefinition } from '../../types/typedData.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import type { IsHexErrorType } from '../../utils/data/isHex.js'
import type { StringifyErrorType } from '../../utils/stringify.js'
import {
  type GetTypesForEIP712DomainErrorType,
  type SerializeTypedDataErrorType,
  type ValidateTypedDataErrorType,
  getTypesForEIP712Domain,
  serializeTypedData,
  validateTypedData,
} from '../../utils/typedData.js'

export type SignTypedDataParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
  account extends Account | undefined = undefined,
  ///
  primaryTypes = typedData extends TypedData ? keyof typedData : string,
> = TypedDataDefinition<typedData, primaryType, primaryTypes> &
  GetAccountParameter<account>

export type SignTypedDataReturnType = Hex

export type SignTypedDataErrorType =
  | AccountNotFoundErrorType
  | ParseAccountErrorType
  | GetTypesForEIP712DomainErrorType
  | ValidateTypedDataErrorType
  | StringifyErrorType
  | SignTypedDataErrorType_account
  | IsHexErrorType
  | RequestErrorType
  | SerializeTypedDataErrorType
  | ErrorType

/**
 * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01"  domainSeparator  hashStruct(message)))`
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signTypedData
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * @param client - Client to use
 * @param parameters - {@link SignTypedDataParameters}
 * @returns The signed data. {@link SignTypedDataReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTypedData(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signTypedData(client, {
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 */
export async function signTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
  chain extends Chain | undefined,
  account extends Account | undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: SignTypedDataParameters<typedData, primaryType, account>,
): Promise<SignTypedDataReturnType> {
  const {
    account: account_ = client.account,
    domain,
    message,
    primaryType,
  } = parameters as unknown as SignTypedDataParameters

  if (!account_)
    throw new AccountNotFoundError({
      docsPath: '/docs/actions/wallet/signTypedData',
    })
  const account = parseAccount(account_)

  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types,
  }

  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
  // as we can't statically check this with TypeScript.
  validateTypedData({ domain, message, primaryType, types })

  if (account.signTypedData)
    return account.signTypedData({ domain, message, primaryType, types })

  const typedData = serializeTypedData({ domain, message, primaryType, types })
  return client.request(
    {
      method: 'eth_signTypedData_v4',
      params: [account.address, typedData],
    },
    { retryCount: 0 },
  )
}
</file>

<file path="src/actions/wallet/switchChain.ts">
import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'
import {
  type NumberToHexErrorType,
  numberToHex,
} from '../../utils/encoding/toHex.js'

export type SwitchChainParameters = {
  /** ID of Chain to switch to */
  id: Chain['id']
}

export type SwitchChainErrorType =
  | NumberToHexErrorType
  | RequestErrorType
  | ErrorType

/**
 * Switch the target chain in a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/switchChain
 * - JSON-RPC Methods: [`wallet_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)
 *
 * @param client - Client to use
 * @param parameters - {@link SwitchChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet, optimism } from 'viem/chains'
 * import { switchChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * await switchChain(client, { id: optimism.id })
 */
export async function switchChain<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(client: Client<Transport, chain, account>, { id }: SwitchChainParameters) {
  await client.request(
    {
      method: 'wallet_switchEthereumChain',
      params: [
        {
          chainId: numberToHex(id),
        },
      ],
    },
    { retryCount: 0 },
  )
}
</file>

<file path="src/actions/wallet/waitForCallsStatus.ts">
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import { BaseError } from '../../errors/base.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import { type ObserveErrorType, observe } from '../../utils/observe.js'
import { type PollErrorType, poll } from '../../utils/poll.js'
import { withResolvers } from '../../utils/promise/withResolvers.js'
import { stringify } from '../../utils/stringify.js'
import {
  type GetCallsStatusErrorType,
  type GetCallsStatusReturnType,
  getCallsStatus,
} from './getCallsStatus.js'

export type WaitForCallsStatusParameters = {
  /**
   * The id of the call batch to wait for.
   */
  id: string
  /**
   * Polling frequency (in ms). Defaults to the client's pollingInterval config.
   *
   * @default client.pollingInterval
   */
  pollingInterval?: number | undefined
  /**
   * The status range to wait for.
   *
   * @default (status) => status >= 200
   */
  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined
  /**
   * Optional timeout (in milliseconds) to wait before stopping polling.
   *
   * @default 60_000
   */
  timeout?: number | undefined
}

export type WaitForCallsStatusReturnType = GetCallsStatusReturnType

export type WaitForCallsStatusErrorType =
  | ObserveErrorType
  | PollErrorType
  | GetCallsStatusErrorType
  | WaitForCallsStatusTimeoutError
  | ErrorType

/**
 * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus
 * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @param parameters - {@link WaitForCallsStatusParameters}
 * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { waitForCallsStatus } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 *
 * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })
 */
export async function waitForCallsStatus<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  parameters: WaitForCallsStatusParameters,
): Promise<WaitForCallsStatusReturnType> {
  const {
    id,
    pollingInterval = client.pollingInterval,
    status = ({ statusCode }) => statusCode >= 200,
    timeout = 60_000,
  } = parameters
  const observerId = stringify(['waitForCallsStatus', client.uid, id])

  const { promise, resolve, reject } =
    withResolvers<WaitForCallsStatusReturnType>()

  let timer: Timer | undefined = undefined

  const unobserve = observe(observerId, { resolve, reject }, (emit) => {
    const unpoll = poll(
      async () => {
        const done = (fn: () => void) => {
          clearTimeout(timer)
          unpoll()
          fn()
          unobserve()
        }

        try {
          const result = await getCallsStatus(client, { id })
          if (!status(result)) return
          done(() => emit.resolve(result))
        } catch (error) {
          done(() => emit.reject(error))
        }
      },
      {
        interval: pollingInterval,
        emitOnBegin: true,
      },
    )

    return unpoll
  })

  timer = timeout
    ? setTimeout(() => {
        unobserve()
        clearTimeout(timer)
        reject(new WaitForCallsStatusTimeoutError({ id }))
      }, timeout)
    : undefined

  return await promise
}

export type WaitForCallsStatusTimeoutErrorType =
  WaitForCallsStatusTimeoutError & {
    name: 'WaitForCallsStatusTimeoutError'
  }
export class WaitForCallsStatusTimeoutError extends BaseError {
  constructor({ id }: { id: string }) {
    super(
      `Timed out while waiting for call bundle with id "${id}" to be confirmed.`,
      { name: 'WaitForCallsStatusTimeoutError' },
    )
  }
}
</file>

<file path="src/actions/wallet/watchAsset.ts">
import type { Account } from '../../accounts/types.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { WatchAssetParams } from '../../types/eip1193.js'
import type { RequestErrorType } from '../../utils/buildRequest.js'

export type WatchAssetParameters = WatchAssetParams
export type WatchAssetReturnType = boolean
export type WatchAssetErrorType = RequestErrorType | ErrorType

/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/watchAsset
 * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)
 *
 * @param client - Client to use
 * @param parameters - {@link WatchAssetParameters}
 * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchAsset } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const success = await watchAsset(client, {
 *   type: 'ERC20',
 *   options: {
 *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
 *     decimals: 18,
 *     symbol: 'WETH',
 *   },
 * })
 */
export async function watchAsset<
  chain extends Chain | undefined,
  account extends Account | undefined = undefined,
>(
  client: Client<Transport, chain, account>,
  params: WatchAssetParameters,
): Promise<WatchAssetReturnType> {
  const added = await client.request(
    {
      method: 'wallet_watchAsset',
      params,
    },
    { retryCount: 0 },
  )
  return added
}
</file>

<file path="src/actions/wallet/writeContract.test-d.ts">
import { seaportAbi } from 'abitype/abis'
import { assertType, expectTypeOf, test } from 'vitest'

import { type Address, parseAbi } from 'abitype'
import { baycContractConfig, wagmiContractConfig } from '~test/src/abis.js'
import { accounts } from '~test/src/constants.js'
import { anvilMainnet } from '../../../test/src/anvil.js'
import { mainnet } from '../../chains/definitions/mainnet.js'
import { createWalletClient } from '../../clients/createWalletClient.js'
import { custom } from '../../clients/transports/custom.js'
import { http } from '../../clients/transports/http.js'
import { type WriteContractParameters, writeContract } from './writeContract.js'

const clientWithAccount = anvilMainnet.getClient({
  account: true,
})

test('WriteContractParameters', async () => {
  type Result = WriteContractParameters<typeof seaportAbi, 'cancel'>
  expectTypeOf<Result['functionName']>().toEqualTypeOf<
    | 'cancel'
    | 'fulfillAdvancedOrder'
    | 'fulfillAvailableAdvancedOrders'
    | 'fulfillAvailableOrders'
    | 'fulfillBasicOrder'
    | 'fulfillBasicOrder_efficient_6GL6yc'
    | 'fulfillOrder'
    | 'incrementCounter'
    | 'matchAdvancedOrders'
    | 'matchOrders'
    | 'validate'
  >()

  const address = '0x' as const
  assertType<WriteContractParameters<typeof seaportAbi, 'cancel'>>({
    abi: seaportAbi,
    account: address,
    address,
    functionName: 'cancel',
    // ^?
    chain: null,
    args: [
      [
        {
          offerer: address,
          zone: address,
          offer: [
            {
              itemType: 1,
              token: address,
              identifierOrCriteria: 1n,
              startAmount: 1n,
              endAmount: 1n,
            },
          ],
          consideration: [
            {
              itemType: 1,
              token: address,
              identifierOrCriteria: 1n,
              startAmount: 1n,
              endAmount: 1n,
              recipient: address,
            },
          ],
          counter: 1n,
          orderType: 1,
          startTime: 1n,
          endTime: 1n,
          salt: 1n,
          conduitKey: address,
          zoneHash: address,
        },
      ],
    ],
  })
})

const args = {
  ...wagmiContractConfig,
  functionName: 'mint',
  args: [69420n],
} as const

test('infers args', () => {
  const client = createWalletClient({
    account: accounts[0].address,
    chain: mainnet,
    transport: custom(window.ethereum!),
  })
  const abi = parseAbi([
    'function foo(address) payable returns (int8)',
    'function bar(address, uint256) returns (int8)',
  ])

  type Result1 = WriteContractParameters<typeof abi, 'foo'>
  type Result2 = Parameters<
    typeof writeContract<
      (typeof client)['chain'],
      (typeof client)['account'],
      typeof abi,
      'foo',
      readonly [Address],
      (typeof client)['chain']
    >
  >[1]
  expectTypeOf<Result1['functionName']>().toEqualTypeOf<'foo' | 'bar'>()
  expectTypeOf<Result1['args']>().toEqualTypeOf<readonly [Address]>()
  expectTypeOf<Result2['functionName']>().toEqualTypeOf<'foo' | 'bar'>()

  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
    args: ['0x'],
  })
  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
    // @ts-expect-error
    args: [],
  })
  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
    // @ts-expect-error
    args: [123n],
  })
})

test('with and without chain', () => {
  const client = createWalletClient({
    account: accounts[0].address,
    transport: custom(window.ethereum!),
  })
  // @ts-expect-error `chain` is required
  writeContract(client, { ...args })
  writeContract(clientWithAccount, {
    ...args,
    chain: undefined,
  })
})

test('type: legacy', () => {
  writeContract(clientWithAccount, {
    ...args,
    gasPrice: 0n,
  })

  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'legacy',
  })
})

test('type: eip1559', () => {
  writeContract(clientWithAccount, {
    ...args,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip1559',
  })
  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    gasPrice: 0n,
    type: 'eip1559',
  })
})

test('type: eip2930', () => {
  writeContract(clientWithAccount, {
    ...args,
    accessList: [],
    gasPrice: 0n,
  })

  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    accessList: [],
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
  })

  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    accessList: [],
    gasPrice: 0n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
  // @ts-expect-error
  writeContract(clientWithAccount, {
    ...args,
    accessList: [],
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    type: 'eip2930',
  })
})

test('args: value', () => {
  // payable function
  writeContract(clientWithAccount, {
    abi: baycContractConfig.abi,
    address: '0x',
    functionName: 'mintApe',
    args: [69n],
    value: 5n,
  })

  // payable function (undefined)
  writeContract(clientWithAccount, {
    abi: baycContractConfig.abi,
    address: '0x',
    functionName: 'mintApe',
    args: [69n],
  })

  // nonpayable function
  writeContract(clientWithAccount, {
    abi: baycContractConfig.abi,
    address: '0x',
    functionName: 'approve',
    // @ts-expect-error
    value: 5n,
  })
})

test('overloads', async () => {
  const client = createWalletClient({
    account: '0x',
    chain: mainnet,
    transport: http(),
  })
  const abi = parseAbi([
    'function foo() returns (int8)',
    'function foo(address) returns (string)',
    'function foo(address, address) returns ((address foo, address bar))',
    'function bar() returns (int8)',
  ])

  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
  })

  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
    args: ['0x'],
  })
  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
    // @ts-expect-error
    args: [123n],
  })

  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
    args: ['0x', '0x'],
  })
  writeContract(client, {
    address: '0x',
    abi,
    functionName: 'foo',
    // @ts-expect-error
    args: ['0x', 123n],
  })
})
</file>

<file path="src/actions/wallet/writeContract.ts">
import type { Abi, Address } from 'abitype'

import type { Account } from '../../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import {
  AccountNotFoundError,
  type AccountNotFoundErrorType,
} from '../../errors/account.js'
import type { BaseError } from '../../errors/base.js'
import type { ErrorType } from '../../errors/utils.js'
import type { GetAccountParameter } from '../../types/account.js'
import type {
  Chain,
  DeriveChain,
  GetChainParameter,
} from '../../types/chain.js'
import type {
  ContractFunctionArgs,
  ContractFunctionName,
  ContractFunctionParameters,
} from '../../types/contract.js'
import type { Hex } from '../../types/misc.js'
import type { Prettify, UnionEvaluate, UnionOmit } from '../../types/utils.js'
import {
  type EncodeFunctionDataErrorType,
  type EncodeFunctionDataParameters,
  encodeFunctionData,
} from '../../utils/abi/encodeFunctionData.js'
import {
  type GetContractErrorReturnType,
  getContractError,
} from '../../utils/errors/getContractError.js'
import type { FormattedTransactionRequest } from '../../utils/formatters/transactionRequest.js'
import { getAction } from '../../utils/getAction.js'
import type { GetMutabilityAwareValue } from '../public/simulateContract.js'
import {
  type SendTransactionErrorType,
  type SendTransactionReturnType,
  sendTransaction,
} from './sendTransaction.js'

export type WriteContractParameters<
  abi extends Abi | readonly unknown[] = Abi,
  functionName extends ContractFunctionName<
    abi,
    'nonpayable' | 'payable'
  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
  ///
  allFunctionNames = ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,
> = ContractFunctionParameters<
  abi,
  'nonpayable' | 'payable',
  functionName,
  args,
  false,
  allFunctionNames
> &
  GetChainParameter<chain, chainOverride> &
  Prettify<
    GetAccountParameter<account, Account | Address, true, true> &
      GetMutabilityAwareValue<
        abi,
        'nonpayable' | 'payable',
        functionName,
        FormattedTransactionRequest<derivedChain>['value'],
        args
      > & {
        /** Data to append to the end of the calldata. Useful for adding a ["domain" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */
        dataSuffix?: Hex | undefined
      }
  > &
  UnionEvaluate<
    UnionOmit<
      FormattedTransactionRequest<derivedChain>,
      'data' | 'from' | 'to' | 'value'
    >
  >

export type WriteContractReturnType = SendTransactionReturnType

export type WriteContractErrorType =
  | EncodeFunctionDataErrorType
  | AccountNotFoundErrorType
  | ParseAccountErrorType
  | GetContractErrorReturnType<SendTransactionErrorType>
  | ErrorType

/**
 * Executes a write function on a contract.
 *
 * - Docs: https://viem.sh/docs/contract/writeContract
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts
 *
 * A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.
 *
 * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
 *
 * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__
 *
 * @param client - Client to use
 * @param parameters - {@link WriteContractParameters}
 * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}
 *
 * @example
 * import { createWalletClient, custom, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { writeContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const hash = await writeContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
 *   functionName: 'mint',
 *   args: [69420],
 * })
 *
 * @example
 * // With Validation
 * import { createWalletClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { simulateContract, writeContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const { request } = await simulateContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
 *   functionName: 'mint',
 *   args: [69420],
 * }
 * const hash = await writeContract(client, request)
 */
export async function writeContract<
  chain extends Chain | undefined,
  account extends Account | undefined,
  const abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  >,
  chainOverride extends Chain | undefined,
>(
  client: Client<Transport, chain, account>,
  parameters: WriteContractParameters<
    abi,
    functionName,
    args,
    chain,
    account,
    chainOverride
  >,
): Promise<WriteContractReturnType> {
  const {
    abi,
    account: account_ = client.account,
    address,
    args,
    dataSuffix,
    functionName,
    ...request
  } = parameters as WriteContractParameters

  if (typeof account_ === 'undefined')
    throw new AccountNotFoundError({
      docsPath: '/docs/contract/writeContract',
    })
  const account = account_ ? parseAccount(account_) : null

  const data = encodeFunctionData({
    abi,
    args,
    functionName,
  } as EncodeFunctionDataParameters)

  try {
    return await getAction(
      client,
      sendTransaction,
      'sendTransaction',
    )({
      data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
      to: address,
      account,
      ...request,
    })
  } catch (error) {
    throw getContractError(error as BaseError, {
      abi,
      address,
      args,
      docsPath: '/docs/contract/writeContract',
      functionName,
      sender: account?.address,
    })
  }
}
</file>

<file path="src/actions/getContract.bench.ts">
import { Contract } from 'ethers'

import { bench, describe } from 'vitest'

import { wagmiContractConfig } from '~test/src/abis.js'
import { ethersProvider } from '~test/src/bench.js'

import { anvilMainnet } from '../../test/src/anvil.js'
import { getContract } from './getContract.js'

const client = anvilMainnet.getClient()

describe('Create contract instance', () => {
  bench('viem: `getContract`', async () => {
    getContract({
      ...wagmiContractConfig,
      client,
    })
  })

  bench('ethers: `new Contract`', async () => {
    new Contract(
      wagmiContractConfig.address,
      wagmiContractConfig.abi,
      ethersProvider,
    )
  })
})

const viemContract = getContract({
  ...wagmiContractConfig,
  client,
})
const ethersContract = new Contract(
  wagmiContractConfig.address,
  wagmiContractConfig.abi,
  ethersProvider,
)

describe('Call contract read function', () => {
  bench('viem: `contract.read.balanceOf`', async () => {
    await viemContract.read.balanceOf([
      '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
    ])
  })

  bench('ethers: `contract.balanceOf`', async () => {
    await ethersContract.balanceOf('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')
  })
})
</file>

<file path="src/actions/getContract.test-d.ts">
import {
  type Abi,
  type Address,
  type ExtractAbiEventNames,
  type ExtractAbiFunctionNames,
  type ResolvedRegister,
  parseAbi,
} from 'abitype'

import { expectTypeOf, test } from 'vitest'

import { wagmiContractConfig } from '~test/src/abis.js'
import { anvilMainnet } from '../../test/src/anvil.js'
import type { Account } from '../accounts/types.js'
import { celo } from '../chains/index.js'

import { createPublicClient } from '../clients/createPublicClient.js'
import { createWalletClient } from '../clients/createWalletClient.js'
import { http } from '../clients/transports/http.js'
import type { Chain } from '../types/chain.js'

import { getContract } from './getContract.js'

const publicClient = anvilMainnet.getClient()
const walletClient = createWalletClient({
  account: '0x',
  chain: anvilMainnet.chain,
  transport: http(anvilMainnet.rpcUrl.http),
})
const walletClientWithoutAccount = createWalletClient({
  chain: anvilMainnet.chain,
  transport: http(anvilMainnet.rpcUrl.http),
})
const walletClientWithoutChain = createWalletClient({
  account: '0x',
  transport: http(anvilMainnet.rpcUrl.http),
})

test('generic client', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    client: walletClient,
  })

  expectTypeOf<keyof typeof contract>().toEqualTypeOf<
    | 'address'
    | 'createEventFilter'
    | 'estimateGas'
    | 'watchEvent'
    | 'read'
    | 'simulate'
    | 'getEvents'
    | 'write'
    | 'abi'
  >()
})

test('public and wallet client', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClient },
  })

  expectTypeOf<keyof typeof contract>().toEqualTypeOf<
    | 'createEventFilter'
    | 'estimateGas'
    | 'read'
    | 'simulate'
    | 'getEvents'
    | 'watchEvent'
    | 'write'
    | 'address'
    | 'abi'
  >()
})

test('no wallet client', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient },
  })

  expectTypeOf<keyof typeof contract>().toEqualTypeOf<
    | 'createEventFilter'
    | 'estimateGas'
    | 'read'
    | 'simulate'
    | 'getEvents'
    | 'watchEvent'
    | 'address'
    | 'abi'
  >()
})

test('no public client', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    client: { wallet: walletClient },
  })

  expectTypeOf<keyof typeof contract>().toEqualTypeOf<
    'estimateGas' | 'write' | 'address' | 'abi'
  >()
})

test('without const assertion on `abi`', () => {
  const abi = [
    {
      inputs: [{ name: 'owner', type: 'address' }],
      name: 'balanceOf',
      outputs: [{ name: '', type: 'uint256' }],
      stateMutability: 'view',
      type: 'function',
    },
  ]
  const contract = getContract({
    ...wagmiContractConfig,
    abi,
    client: { public: publicClient, wallet: walletClient },
  })

  expectTypeOf(contract).toMatchTypeOf<{
    createEventFilter: {
      [_ in string]: Function
    }
    estimateGas: {
      [_1: string]: Function
    }
    read: {
      [_2: string]: Function
    }
    simulate: {
      [_3: string]: Function
    }
    watchEvent: {
      [_4: string]: Function
    }
    write: {
      [_5: string]: Function
    }
  }>()
})

test('`abi` declared as `Abi` type', () => {
  const abi: Abi = []
  const contract = getContract({
    ...wagmiContractConfig,
    abi,
    client: { public: publicClient, wallet: walletClient },
  })

  contract.createEventFilter.Transfer({ from: '0x' })

  expectTypeOf(contract).toMatchTypeOf<{
    createEventFilter: {
      [_ in string]: Function
    }
    estimateGas: {
      [_1: string]: Function
    }
    read: {
      [_2: string]: Function
    }
    simulate: {
      [_3: string]: Function
    }
    watchEvent: {
      [_4: string]: Function
    }
    write: {
      [_5: string]: Function
    }
  }>()
})

test('`abi` defined inline', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    abi: [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: 'from',
            type: 'address',
          },
          { indexed: true, name: 'to', type: 'address' },
          {
            indexed: true,
            name: 'tokenId',
            type: 'uint256',
          },
        ],
        name: 'Transfer',
        type: 'event',
      },
      {
        inputs: [{ name: 'owner', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [
          { name: 'from', type: 'address' },
          { name: 'to', type: 'address' },
          { name: 'tokenId', type: 'uint256' },
        ],
        name: 'safeTransferFrom',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
      },
    ],
    client: { public: publicClient, wallet: walletClient },
  })
  type Abi_ = [
    {
      anonymous: false
      inputs: [
        {
          indexed: true
          name: 'from'
          type: 'address'
        },
        { indexed: true; name: 'to'; type: 'address' },
        {
          indexed: true
          name: 'tokenId'
          type: 'uint256'
        },
      ]
      name: 'Transfer'
      type: 'event'
    },
    {
      inputs: [{ name: 'owner'; type: 'address' }]
      name: 'balanceOf'
      outputs: [{ name: ''; type: 'uint256' }]
      stateMutability: 'view'
      type: 'function'
    },
    {
      inputs: [
        { name: 'from'; type: 'address' },
        { name: 'to'; type: 'address' },
        { name: 'tokenId'; type: 'uint256' },
      ]
      name: 'safeTransferFrom'
      outputs: []
      stateMutability: 'nonpayable'
      type: 'function'
    },
  ]
  type ReadFunctionNames = ExtractAbiFunctionNames<Abi_, 'pure' | 'view'>
  type WriteFunctionNames = ExtractAbiFunctionNames<
    Abi_,
    'nonpayable' | 'payable'
  >
  type EventNames = ExtractAbiEventNames<Abi_>

  expectTypeOf(contract).toMatchTypeOf<{
    createEventFilter: {
      [_ in string]: Function
    }
    estimateGas: {
      [_ in WriteFunctionNames]: Function
    }
    read: {
      [_ in ReadFunctionNames]: Function
    }
    simulate: {
      [_ in WriteFunctionNames]: Function
    }
    watchEvent: {
      [_ in EventNames]: Function
    }
    write: {
      [_ in WriteFunctionNames]: Function
    }
  }>()
})

test('overloaded function', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClient },
  })
  expectTypeOf(contract.write.safeTransferFrom)
    .parameter(0)
    .toEqualTypeOf<
      | readonly [
          ResolvedRegister['AddressType'],
          ResolvedRegister['AddressType'],
          ResolvedRegister['BigIntType'],
        ]
      | readonly [
          ResolvedRegister['AddressType'],
          ResolvedRegister['AddressType'],
          ResolvedRegister['BigIntType'],
          ResolvedRegister['AddressType'],
        ]
    >()
  expectTypeOf(contract.write.safeTransferFrom).toBeCallableWith([
    '0x',
    '0x',
    123n,
  ])
  expectTypeOf(contract.write.safeTransferFrom).toBeCallableWith([
    '0x',
    '0x',
    123n,
    '0x',
  ])
})

test('with and without wallet client `account`', () => {
  const contractWithAccount = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClient },
  })
  const contractWithoutAccount = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClientWithoutAccount },
  })

  expectTypeOf(contractWithAccount.write.approve)
    .parameter(1)
    .extract<{ account?: Account | Address | null | undefined }>()
    // @ts-expect-error
    .toBeNever()
  expectTypeOf(contractWithoutAccount.write.approve)
    .parameter(1)
    .extract<{ account: Account | Address | null }>()
    // @ts-expect-error
    .toBeNever()
})

test('with and without wallet client `chain`', () => {
  const contractWithChain = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClient },
  })
  const contractWithoutChain = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClientWithoutChain },
  })

  expectTypeOf(contractWithChain.write.approve)
    .parameter(1)
    .extract<{ chain?: Chain | null | undefined }>()
    // @ts-expect-error
    .toBeNever()
  expectTypeOf(contractWithoutChain.write.approve)
    .parameter(1)
    .extract<{ chain: Chain | null | undefined }>()
    // @ts-expect-error
    .toBeNever()
})

test('no read functions', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    abi: [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: 'from',
            type: 'address',
          },
          { indexed: true, name: 'to', type: 'address' },
          {
            indexed: true,
            name: 'tokenId',
            type: 'uint256',
          },
        ],
        name: 'Transfer',
        type: 'event',
      },
      {
        inputs: [
          { name: 'from', type: 'address' },
          { name: 'to', type: 'address' },
          { name: 'tokenId', type: 'uint256' },
        ],
        name: 'safeTransferFrom',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
      },
    ],
    client: { public: publicClient, wallet: walletClient },
  })
  type Abi_ = [
    {
      anonymous: false
      inputs: [
        {
          indexed: true
          name: 'from'
          type: 'address'
        },
        { indexed: true; name: 'to'; type: 'address' },
        {
          indexed: true
          name: 'tokenId'
          type: 'uint256'
        },
      ]
      name: 'Transfer'
      type: 'event'
    },
    {
      inputs: [
        { name: 'from'; type: 'address' },
        { name: 'to'; type: 'address' },
        { name: 'tokenId'; type: 'uint256' },
      ]
      name: 'safeTransferFrom'
      outputs: []
      stateMutability: 'nonpayable'
      type: 'function'
    },
  ]
  type WriteFunctionNames = ExtractAbiFunctionNames<
    Abi_,
    'nonpayable' | 'payable'
  >
  type EventNames = ExtractAbiEventNames<Abi_>

  expectTypeOf(contract).toMatchTypeOf<{
    createEventFilter: {
      [_ in EventNames]: Function
    }
    estimateGas: {
      [_ in WriteFunctionNames]: Function
    }
    simulate: {
      [_ in WriteFunctionNames]: Function
    }
    watchEvent: {
      [_ in EventNames]: Function
    }
    write: {
      [_ in WriteFunctionNames]: Function
    }
  }>()
})

test('no write functions', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    abi: [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: 'from',
            type: 'address',
          },
          { indexed: true, name: 'to', type: 'address' },
          {
            indexed: true,
            name: 'tokenId',
            type: 'uint256',
          },
        ],
        name: 'Transfer',
        type: 'event',
      },
      {
        inputs: [{ name: 'owner', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
    ],
    client: { public: publicClient, wallet: walletClient },
  })
  type Abi_ = [
    {
      anonymous: false
      inputs: [
        {
          indexed: true
          name: 'from'
          type: 'address'
        },
        { indexed: true; name: 'to'; type: 'address' },
        {
          indexed: true
          name: 'tokenId'
          type: 'uint256'
        },
      ]
      name: 'Transfer'
      type: 'event'
    },
    {
      inputs: [{ name: 'owner'; type: 'address' }]
      name: 'balanceOf'
      outputs: [{ name: ''; type: 'uint256' }]
      stateMutability: 'view'
      type: 'function'
    },
  ]
  type ReadFunctionNames = ExtractAbiFunctionNames<Abi_, 'pure' | 'view'>
  type EventNames = ExtractAbiEventNames<Abi_>

  expectTypeOf(contract).toMatchTypeOf<{
    createEventFilter: {
      [_ in EventNames]: Function
    }
    read: {
      [_ in ReadFunctionNames]: Function
    }
    watchEvent: {
      [_ in EventNames]: Function
    }
  }>()
})

test('no events', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    abi: [
      {
        inputs: [{ name: 'owner', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [
          { name: 'from', type: 'address' },
          { name: 'to', type: 'address' },
          { name: 'tokenId', type: 'uint256' },
        ],
        name: 'safeTransferFrom',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
      },
    ],
    client: { public: publicClient, wallet: walletClient },
  })
  type Abi_ = [
    {
      inputs: [{ name: 'owner'; type: 'address' }]
      name: 'balanceOf'
      outputs: [{ name: ''; type: 'uint256' }]
      stateMutability: 'view'
      type: 'function'
    },
    {
      inputs: [
        { name: 'from'; type: 'address' },
        { name: 'to'; type: 'address' },
        { name: 'tokenId'; type: 'uint256' },
      ]
      name: 'safeTransferFrom'
      outputs: []
      stateMutability: 'nonpayable'
      type: 'function'
    },
  ]
  type ReadFunctionNames = ExtractAbiFunctionNames<Abi_, 'pure' | 'view'>
  type WriteFunctionNames = ExtractAbiFunctionNames<
    Abi_,
    'nonpayable' | 'payable'
  >

  expectTypeOf(contract).toMatchTypeOf<{
    estimateGas: {
      [_ in WriteFunctionNames]: Function
    }
    read: {
      [_ in ReadFunctionNames]: Function
    }
    simulate: {
      [_ in WriteFunctionNames]: Function
    }
    write: {
      [_ in WriteFunctionNames]: Function
    }
  }>()
})

test('empty abi', () => {
  const contract = getContract({
    ...wagmiContractConfig,
    abi: [],
    client: { public: publicClient, wallet: walletClient },
  })
  expectTypeOf<keyof typeof contract>().toEqualTypeOf<'address' | 'abi'>()
  expectTypeOf(contract.abi).toEqualTypeOf<readonly []>()
  expectTypeOf(
    contract.address,
  ).toEqualTypeOf<'0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'>()
})

test('argument permutations', async () => {
  const abi = parseAbi([
    // functions
    'function nonpayableWithoutArgs()',
    'function nonpayableWithArgs(string x, uint256 y)',
    'function payableWithoutArgs() payable',
    'function payableWithArgs(string x, uint256 y) payable',
    'function pureWithoutArgs() pure returns (string)',
    'function pureWithArgs(string x, uint256 y) pure returns (string)',
    'function viewWithoutArgs() view returns (string)',
    'function viewWithArgs(string x, uint256 y) view returns (string)',

    'function overloadedNonpayable()',
    'function overloadedNonpayable(string x)',
    'function overloadedNonpayable(string x, uint256 y)',
    'function overloadedNonpayable2(string x)',
    'function overloadedNonpayable2(string x, uint256 y)',

    'function overloadedView() view returns (string)',
    'function overloadedView(string x) view returns (string)',
    'function overloadedView(string x, uint256 y) view returns (string)',
    'function overloadedView2(string x) view returns (string)',
    'function overloadedView2(string x, uint256 y) view returns (string)',

    // events
    'event WithoutInputs()',
    'event WithIndexedNamedInputs(string indexed x, uint256 indexed y)',
    'event WithIndexedUnnamedInputs(string indexed, uint256 indexed)',
    'event WithUnindexedInputs(string x, uint256 y)',
    'event WithMixedNamedInputs(string indexed x, uint256 y)',
    'event WithMixedUnnamedInputs(string indexed, uint256 y)',
  ])
  const contract = getContract({
    ...wagmiContractConfig,
    abi,
    client: { public: publicClient, wallet: walletClient },
  })

  // estimateGas
  contract.estimateGas.nonpayableWithoutArgs({ account: '0x' })
  contract.estimateGas.nonpayableWithArgs(['foo', 69n], { account: '0x' })
  contract.estimateGas.payableWithoutArgs({ account: '0x', value: 1n })
  contract.estimateGas.payableWithArgs(['foo', 69n], {
    account: '0x',
    value: 1n,
  })

  contract.estimateGas.overloadedNonpayable({ account: '0x' })
  contract.estimateGas.overloadedNonpayable(['foo'], { account: '0x' })
  contract.estimateGas.overloadedNonpayable2(['foo'], { account: '0x' })
  contract.estimateGas.overloadedNonpayable2(['foo', 69n], { account: '0x' })

  // read
  contract.read.pureWithoutArgs()
  contract.read.pureWithoutArgs({ blockNumber: 123n })
  contract.read.pureWithArgs(['foo', 69n])
  contract.read.pureWithArgs(['foo', 69n], { blockNumber: 123n })
  contract.read.viewWithoutArgs()
  contract.read.viewWithoutArgs({ blockNumber: 123n })
  contract.read.viewWithArgs(['foo', 69n])
  contract.read.viewWithArgs(['foo', 69n], { blockNumber: 123n })

  contract.read.overloadedView()
  contract.read.overloadedView(['foo'])
  contract.read.overloadedView2(['foo'])
  contract.read.overloadedView2(['foo', 69n])

  const read_1 = await contract.read.viewWithArgs(['foo', 69n])
  expectTypeOf(read_1).toEqualTypeOf<string>()

  // simulate
  contract.simulate.nonpayableWithoutArgs({ account: '0x' })
  contract.simulate.nonpayableWithArgs(['foo', 69n], { account: '0x' })
  contract.simulate.payableWithoutArgs({ account: '0x', value: 1n })
  contract.simulate.payableWithArgs(['foo', 69n], { account: '0x', value: 1n })

  contract.simulate.overloadedNonpayable({ account: '0x' })
  contract.simulate.overloadedNonpayable(['foo'], { account: '0x' })
  contract.simulate.overloadedNonpayable2(['foo'], { account: '0x' })
  contract.simulate.overloadedNonpayable2(['foo', 69n], { account: '0x' })

  // write
  contract.write.nonpayableWithoutArgs()
  contract.write.nonpayableWithoutArgs({ nonce: 123 })
  contract.write.nonpayableWithArgs(['foo', 69n])
  contract.write.nonpayableWithArgs(['foo', 69n], { nonce: 123 })
  contract.write.payableWithoutArgs()
  contract.write.payableWithoutArgs({ nonce: 123, value: 123n })
  contract.write.payableWithArgs(['foo', 69n])
  contract.write.payableWithArgs(['foo', 69n], {
    nonce: 123,
    value: 123n,
  })

  contract.write.overloadedNonpayable()
  contract.write.overloadedNonpayable(['foo'])
  contract.write.overloadedNonpayable2(['foo'])
  contract.write.overloadedNonpayable2(['foo', 69n])

  // createEventFilter
  contract.createEventFilter.WithoutInputs()
  contract.createEventFilter.WithoutInputs({ fromBlock: 123n })

  contract.createEventFilter.WithIndexedNamedInputs({
    x: 'foo',
    y: null,
  })
  contract.createEventFilter.WithIndexedNamedInputs({ x: 'foo' })
  contract.createEventFilter.WithIndexedNamedInputs(
    { x: 'foo' },
    { fromBlock: 123n },
  )

  contract.createEventFilter.WithIndexedUnnamedInputs([])
  contract.createEventFilter.WithIndexedUnnamedInputs(['foo'])
  contract.createEventFilter.WithIndexedUnnamedInputs(['foo'], {
    fromBlock: 123n,
  })

  contract.createEventFilter.WithUnindexedInputs({
    fromBlock: 123n,
  })

  contract.createEventFilter.WithMixedNamedInputs({})
  contract.createEventFilter.WithMixedNamedInputs({ x: 'foo ' })
  contract.createEventFilter.WithMixedNamedInputs(
    { x: 'foo' },
    { fromBlock: 123n },
  )

  contract.createEventFilter.WithMixedUnnamedInputs([])
  contract.createEventFilter.WithMixedUnnamedInputs(['foo'])
  contract.createEventFilter.WithMixedUnnamedInputs(['foo'], {
    fromBlock: 123n,
  })

  const createEventFilter_1 =
    await contract.createEventFilter.WithIndexedNamedInputs({
      x: 'foo',
      y: null,
    })
  expectTypeOf(createEventFilter_1.eventName)
    .toEqualTypeOf<'WithIndexedNamedInputs'>
  expectTypeOf(createEventFilter_1.args.x).toEqualTypeOf<'foo'>()
  expectTypeOf(createEventFilter_1.args.y).toEqualTypeOf<null>()
  const createEventFilter_2 =
    await contract.createEventFilter.WithIndexedUnnamedInputs(['foo'])
  expectTypeOf(createEventFilter_2.eventName)
    .toEqualTypeOf<'WithIndexedUnnamedInputs'>
  expectTypeOf(createEventFilter_2.args[0]).toEqualTypeOf<'foo'>()

  const createEventFilter_loose =
    await contract.createEventFilter.WithMixedNamedInputs({
      x: 'foo',
    })
  expectTypeOf(createEventFilter_loose.strict).toEqualTypeOf<undefined>()

  const createEventFilter_lax =
    await contract.createEventFilter.WithMixedNamedInputs({
      x: 'foo',
    })
  expectTypeOf(createEventFilter_lax.strict).toEqualTypeOf<undefined>()

  const createEventFilter_strict =
    await contract.createEventFilter.WithMixedNamedInputs(
      {
        x: 'foo',
      },
      { strict: true },
    )
  expectTypeOf(createEventFilter_strict.strict).toEqualTypeOf<true>()

  // watchEvent
  // @ts-expect-error
  contract.watchEvent.WithoutInputs()
  contract.watchEvent.WithoutInputs({ onLogs, pollingInterval: 4_000 })

  contract.watchEvent.WithIndexedNamedInputs({}, { onLogs })
  contract.watchEvent.WithIndexedNamedInputs({ x: 'foo' }, { onLogs })
  contract.watchEvent.WithIndexedNamedInputs({ x: 'foo' }, { onLogs })

  contract.watchEvent.WithIndexedUnnamedInputs([], { onLogs })
  contract.watchEvent.WithIndexedUnnamedInputs(['foo'], { onLogs })
  contract.watchEvent.WithIndexedUnnamedInputs(['foo'], { onLogs })

  contract.watchEvent.WithUnindexedInputs({ onLogs })

  contract.watchEvent.WithMixedNamedInputs({}, { onLogs })
  contract.watchEvent.WithMixedNamedInputs({ x: 'foo ' }, { onLogs })
  contract.watchEvent.WithMixedNamedInputs({ x: 'foo' }, { onLogs })

  contract.watchEvent.WithMixedUnnamedInputs([], { onLogs })
  contract.watchEvent.WithMixedUnnamedInputs(['foo'], { onLogs })
  contract.watchEvent.WithMixedUnnamedInputs(['foo'], { onLogs })

  function onLogs() {}
})

test('estimateGas', () => {
  const contract1 = getContract({
    ...wagmiContractConfig,
    client: publicClient,
  })
  // `account` required
  contract1.estimateGas.mint({ account: '0x' })
  contract1.estimateGas.approve(['0x', 123n], { account: '0x' })

  const contract2 = getContract({
    ...wagmiContractConfig,
    client: walletClient,
  })
  // `account` inherited from `walletClient`
  contract2.estimateGas.mint()
  contract2.estimateGas.approve(['0x', 123n])

  const contract3 = getContract({
    ...wagmiContractConfig,
    client: walletClientWithoutAccount,
  })
  // `account` required
  contract3.estimateGas.mint({ account: '0x' })
  contract3.estimateGas.approve(['0x', 123n], { account: '0x' })

  const contract4 = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClient },
  })
  // `account` inherited from `walletClient`
  contract4.estimateGas.mint()
  contract4.estimateGas.approve(['0x', 123n])
})

test('simulate', async () => {
  const contract1 = getContract({
    ...wagmiContractConfig,
    client: publicClient,
  })
  const result1 = await contract1.simulate.mint()
  expectTypeOf<Pick<(typeof result1)['request'], 'account'>>().toEqualTypeOf<{
    account?: undefined
  }>()

  const contract2 = getContract({
    ...wagmiContractConfig,
    client: walletClient,
  })
  const result2 = await contract2.simulate.mint()
  expectTypeOf<Pick<(typeof result2)['request'], 'account'>>().toEqualTypeOf<{
    account: {
      address: '0x'
      type: 'json-rpc'
    }
  }>()

  const contract3 = getContract({
    ...wagmiContractConfig,
    client: publicClient,
  })
  const result3 = await contract3.simulate.mint({ account: '0x' })
  expectTypeOf<Pick<(typeof result3)['request'], 'account'>>().toEqualTypeOf<{
    account: {
      address: '0x'
      type: 'json-rpc'
    }
  }>()
})

test('chain w/ formatter', () => {
  const publicClient = createPublicClient({
    chain: celo,
    transport: http(),
  })
  const walletClient = createWalletClient({
    account: '0x',
    chain: celo,
    transport: http(),
  })

  const contract = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient, wallet: walletClient },
  })
  const contract_public = getContract({
    ...wagmiContractConfig,
    client: { public: publicClient },
  })
  const contract_wallet = getContract({
    ...wagmiContractConfig,
    client: { wallet: walletClient },
  })

  expectTypeOf<keyof typeof contract>().toEqualTypeOf<
    | 'createEventFilter'
    | 'estimateGas'
    | 'read'
    | 'simulate'
    | 'getEvents'
    | 'watchEvent'
    | 'write'
    | 'address'
    | 'abi'
  >()
  expectTypeOf<keyof typeof contract_public>().toEqualTypeOf<
    | 'createEventFilter'
    | 'estimateGas'
    | 'read'
    | 'simulate'
    | 'getEvents'
    | 'watchEvent'
    | 'address'
    | 'abi'
  >()
  expectTypeOf<keyof typeof contract_wallet>().toEqualTypeOf<
    'estimateGas' | 'write' | 'address' | 'abi'
  >()

  contract.estimateGas.mint([1n], {
    feeCurrency: '0x',
  })
})
</file>

<file path="src/actions/getContract.ts">
import type {
  Abi,
  AbiEvent,
  AbiFunction,
  AbiParametersToPrimitiveTypes,
  Address,
  ExtractAbiEvent,
  ExtractAbiEventNames,
  ExtractAbiFunction,
  ExtractAbiFunctionNames,
} from 'abitype'

import type { Account } from '../accounts/types.js'
import type { Client } from '../clients/createClient.js'
import type { Transport } from '../clients/transports/createTransport.js'
import type { Chain } from '../types/chain.js'
import type {
  AbiEventParametersToPrimitiveTypes,
  ContractEventName,
  ContractFunctionArgs,
  ContractFunctionName,
  MaybeExtractEventArgsFromAbi,
} from '../types/contract.js'
import type {
  IsNarrowable,
  IsNever,
  IsUndefined,
  Or,
  Prettify,
  UnionOmit,
} from '../types/utils.js'

import type { ErrorType } from '../errors/utils.js'
import { getAction } from '../utils/getAction.js'
import {
  type CreateContractEventFilterParameters,
  type CreateContractEventFilterReturnType,
  createContractEventFilter,
} from './public/createContractEventFilter.js'
import {
  type EstimateContractGasParameters,
  type EstimateContractGasReturnType,
  estimateContractGas,
} from './public/estimateContractGas.js'
import {
  type GetContractEventsParameters,
  type GetContractEventsReturnType,
  getContractEvents,
} from './public/getContractEvents.js'
import {
  type ReadContractParameters,
  type ReadContractReturnType,
  readContract,
} from './public/readContract.js'
import {
  type SimulateContractParameters,
  type SimulateContractReturnType,
  simulateContract,
} from './public/simulateContract.js'
import {
  type WatchContractEventParameters,
  type WatchContractEventReturnType,
  watchContractEvent,
} from './public/watchContractEvent.js'
import {
  type WriteContractParameters,
  type WriteContractReturnType,
  writeContract,
} from './wallet/writeContract.js'

type KeyedClient<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
> =
  | {
      public?: Client<transport, chain> | undefined
      wallet: Client<transport, chain, account>
    }
  | {
      public: Client<transport, chain>
      wallet?: Client<transport, chain, account> | undefined
    }

export type GetContractParameters<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  abi extends Abi | readonly unknown[] = Abi,
  client extends
    | Client<transport, chain, account>
    | KeyedClient<transport, chain, account> =
    | Client<transport, chain, account>
    | KeyedClient<transport, chain, account>,
  address extends Address = Address,
> = {
  /** Contract ABI */
  abi: abi
  /** Contract address */
  address: address
  /** The Client.
   *
   * If you pass in a [`publicClient`](https://viem.sh/docs/clients/public), the following methods are available:
   *
   * - [`createEventFilter`](https://viem.sh/docs/contract/createContractEventFilter)
   * - [`estimateGas`](https://viem.sh/docs/contract/estimateContractGas)
   * - [`getEvents`](https://viem.sh/docs/contract/getContractEvents)
   * - [`read`](https://viem.sh/docs/contract/readContract)
   * - [`simulate`](https://viem.sh/docs/contract/simulateContract)
   * - [`watchEvent`](https://viem.sh/docs/contract/watchContractEvent)
   *
   * If you pass in a [`walletClient`](https://viem.sh/docs/clients/wallet), the following methods are available:
   *
   * - [`estimateGas`](https://viem.sh/docs/contract/estimateContractGas)
   * - [`write`](https://viem.sh/docs/contract/writeContract)
   */
  client: client
}

export type GetContractReturnType<
  abi extends Abi | readonly unknown[] = Abi,
  client extends Client | KeyedClient = Client | KeyedClient,
  address extends Address = Address,
  //
  _eventNames extends string = abi extends Abi
    ? Abi extends abi
      ? string
      : ExtractAbiEventNames<abi>
    : string,
  _readFunctionNames extends string = abi extends Abi
    ? Abi extends abi
      ? string
      : ExtractAbiFunctionNames<abi, 'pure' | 'view'>
    : string,
  _writeFunctionNames extends string = abi extends Abi
    ? Abi extends abi
      ? string
      : ExtractAbiFunctionNames<abi, 'nonpayable' | 'payable'>
    : string,
  _narrowable extends boolean = IsNarrowable<abi, Abi>,
  _publicClient extends Client | unknown = client extends {
    public: Client
  }
    ? client['public']
    : client,
  _walletClient extends Client | unknown = client extends {
    wallet: Client
  }
    ? client['wallet']
    : client,
> = Prettify<
  Prettify<
    (_publicClient extends Client
      ? (IsNever<_readFunctionNames> extends true
          ? unknown
          : {
              /**
               * Calls a read-only function on a contract, and returns the response.
               *
               * A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.
               *
               * Internally, `read` uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
               *
               * @example
               * import { createPublicClient, getContract, http, parseAbi } from 'viem'
               * import { mainnet } from 'viem/chains'
               *
               * const publicClient = createPublicClient({
               *   chain: mainnet,
               *   transport: http(),
               * })
               * const contract = getContract({
               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
               *   abi: parseAbi([
               *     'function balanceOf(address owner) view returns (uint256)',
               *   ]),
               *   client: publicClient,
               * })
               * const result = await contract.read.balanceOf(['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'])
               * // 424122n
               */
              read: {
                [functionName in _readFunctionNames]: GetReadFunction<
                  _narrowable,
                  abi,
                  functionName extends ContractFunctionName<
                    abi,
                    'pure' | 'view'
                  >
                    ? functionName
                    : never
                >
              }
            }) &
          (IsNever<_writeFunctionNames> extends true
            ? unknown
            : {
                /**
                 * Estimates the gas necessary to complete a transaction without submitting it to the network.
                 *
                 * @example
                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
                 * import { mainnet } from 'viem/chains'
                 *
                 * const publicClient = createPublicClient({
                 *   chain: mainnet,
                 *   transport: http(),
                 * })
                 * const contract = getContract({
                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
                 *   abi: parseAbi(['function mint() public']),
                 *   client: publicClient,
                 * })
                 * const gas = await contract.estimateGas.mint({
                 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
                 * })
                 */
                estimateGas: {
                  [functionName in _writeFunctionNames]: GetEstimateFunction<
                    _narrowable,
                    _publicClient['chain'],
                    undefined,
                    abi,
                    functionName extends ContractFunctionName<
                      abi,
                      'nonpayable' | 'payable'
                    >
                      ? functionName
                      : never
                  >
                }
                /**
                 * Simulates/validates a contract interaction. This is useful for retrieving return data and revert reasons of contract write functions.
                 *
                 * This function does not require gas to execute and does not change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.
                 *
                 * Internally, `simulate` uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
                 *
                 * @example
                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
                 * import { mainnet } from 'viem/chains'
                 *
                 * const publicClient = createPublicClient({
                 *   chain: mainnet,
                 *   transport: http(),
                 * })
                 * const contract = getContract({
                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
                 *   abi: parseAbi(['function mint() public']),
                 *   client: publicClient,
                 * })
                 * const result = await contract.simulate.mint({
                 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
                 * })
                 */
                simulate: {
                  [functionName in _writeFunctionNames]: GetSimulateFunction<
                    _narrowable,
                    _publicClient['chain'],
                    _walletClient extends Client
                      ? _walletClient['account']
                      : _publicClient['account'],
                    abi,
                    functionName extends ContractFunctionName<
                      abi,
                      'nonpayable' | 'payable'
                    >
                      ? functionName
                      : never
                  >
                }
              }) &
          (IsNever<_eventNames> extends true
            ? unknown
            : {
                /**
                 * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).
                 *
                 * @example
                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
                 * import { mainnet } from 'viem/chains'
                 *
                 * const publicClient = createPublicClient({
                 *   chain: mainnet,
                 *   transport: http(),
                 * })
                 * const contract = getContract({
                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
                 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
                 *   client: publicClient,
                 * })
                 * const filter = await contract.createEventFilter.Transfer()
                 */
                createEventFilter: {
                  [EventName in _eventNames]: GetEventFilter<
                    _narrowable,
                    abi,
                    EventName extends ContractEventName<abi> ? EventName : never
                  >
                }
                /**
                 * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).
                 *
                 * @example
                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
                 * import { mainnet } from 'viem/chains'
                 *
                 * const publicClient = createPublicClient({
                 *   chain: mainnet,
                 *   transport: http(),
                 * })
                 * const contract = getContract({
                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
                 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
                 *   client: publicClient,
                 * })
                 * const filter = await contract.createEventFilter.Transfer()
                 */
                getEvents: {
                  [EventName in _eventNames]: GetEventsFunction<
                    _narrowable,
                    abi,
                    EventName extends ContractEventName<abi> ? EventName : never
                  >
                }
                /**
                 * Watches and returns emitted contract event logs.
                 *
                 * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).
                 *
                 * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.
                 *
                 * @example
                 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
                 * import { mainnet } from 'viem/chains'
                 *
                 * const publicClient = createPublicClient({
                 *   chain: mainnet,
                 *   transport: http(),
                 * })
                 * const contract = getContract({
                 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
                 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
                 *   client: publicClient,
                 * })
                 * const filter = await contract.createEventFilter.Transfer()
                 * const unwatch = contract.watchEvent.Transfer(
                 *   { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },
                 *   { onLogs: (logs) => console.log(logs) },
                 * )
                 */
                watchEvent: {
                  [EventName in _eventNames]: GetWatchEvent<
                    _narrowable,
                    abi,
                    EventName extends ContractEventName<abi> ? EventName : never
                  >
                }
              })
      : unknown) &
      (_walletClient extends Client
        ? IsNever<_writeFunctionNames> extends true
          ? unknown
          : {
              /**
               * Estimates the gas necessary to complete a transaction without submitting it to the network.
               *
               * @example
               * import { createWalletClient, getContract, http, parseAbi } from 'viem'
               * import { mainnet } from 'viem/chains'
               *
               * const walletClient = createWalletClient({
               *   chain: mainnet,
               *   transport: http(),
               * })
               * const contract = getContract({
               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
               *   abi: parseAbi(['function mint() public']),
               *   client: walletClient,
               * })
               * const gas = await contract.estimateGas.mint({
               *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
               * })
               */
              estimateGas: {
                [functionName in _writeFunctionNames]: GetEstimateFunction<
                  _narrowable,
                  _walletClient['chain'],
                  _walletClient['account'],
                  abi,
                  functionName extends ContractFunctionName<
                    abi,
                    'nonpayable' | 'payable'
                  >
                    ? functionName
                    : never
                >
              }
              /**
               * Executes a write function on a contract.
               *
               * A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.
               *
               * Internally, `write` uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
               *
               * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__
               *
               * @example
               * import { createWalletClient, getContract, http, parseAbi } from 'viem'
               * import { mainnet } from 'viem/chains'
               *
               * const walletClient = createWalletClient({
               *   chain: mainnet,
               *   transport: http(),
               * })
               * const contract = getContract({
               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
               *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
               *   client: walletClient,
               * })
               * const hash = await contract.write.min([69420], {
               *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
               * })
               */
              write: {
                [functionName in _writeFunctionNames]: GetWriteFunction<
                  _narrowable,
                  _walletClient['chain'],
                  _walletClient['account'],
                  abi,
                  functionName extends ContractFunctionName<
                    abi,
                    'nonpayable' | 'payable'
                  >
                    ? functionName
                    : never
                >
              }
            }
        : unknown)
  > & { address: address; abi: abi }
>

export type GetContractErrorType = ErrorType

/**
 * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.
 *
 * - Docs https://viem.sh/docs/contract/getContract
 *
 * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properties every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract), [`writeContract`](https://viem.sh/docs/contract/writeContract), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas), etc.
 *
 * @example
 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const publicClient = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const contract = getContract({
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi([
 *     'function balanceOf(address owner) view returns (uint256)',
 *     'function ownerOf(uint256 tokenId) view returns (address)',
 *     'function totalSupply() view returns (uint256)',
 *   ]),
 *   client: publicClient,
 * })
 */
export function getContract<
  transport extends Transport,
  address extends Address,
  const abi extends Abi | readonly unknown[],
  const client extends
    | Client<transport, chain, account>
    | KeyedClient<transport, chain, account>,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>({
  abi,
  address,
  client: client_,
}: GetContractParameters<
  transport,
  chain,
  account,
  abi,
  client,
  address
>): GetContractReturnType<abi, client, address> {
  const client = client_ as
    | Client<transport, chain, account>
    | KeyedClient<transport, chain, account>

  const [publicClient, walletClient] = (() => {
    if (!client) return [undefined, undefined]
    if ('public' in client && 'wallet' in client)
      return [client.public as Client, client.wallet as Client]
    if ('public' in client) return [client.public as Client, undefined]
    if ('wallet' in client) return [undefined, client.wallet as Client]
    return [client, client]
  })()

  const hasPublicClient = publicClient !== undefined && publicClient !== null
  const hasWalletClient = walletClient !== undefined && walletClient !== null

  const contract: {
    [_ in
      | 'abi'
      | 'address'
      | 'createEventFilter'
      | 'estimateGas'
      | 'getEvents'
      | 'read'
      | 'simulate'
      | 'watchEvent'
      | 'write']?: unknown
  } = {}

  let hasReadFunction = false
  let hasWriteFunction = false
  let hasEvent = false
  for (const item of abi as Abi) {
    if (item.type === 'function')
      if (item.stateMutability === 'view' || item.stateMutability === 'pure')
        hasReadFunction = true
      else hasWriteFunction = true
    else if (item.type === 'event') hasEvent = true
    // Exit early if all flags are `true`
    if (hasReadFunction && hasWriteFunction && hasEvent) break
  }

  if (hasPublicClient) {
    if (hasReadFunction)
      contract.read = new Proxy(
        {},
        {
          get(_, functionName: string) {
            return (
              ...parameters: [
                args?: readonly unknown[] | undefined,
                options?: UnionOmit<
                  ReadContractParameters,
                  'abi' | 'address' | 'functionName' | 'args'
                >,
              ]
            ) => {
              const { args, options } = getFunctionParameters(parameters)
              return getAction(
                publicClient,
                readContract,
                'readContract',
              )({
                abi,
                address,
                functionName,
                args,
                ...options,
              } as ReadContractParameters)
            }
          },
        },
      )

    if (hasWriteFunction)
      contract.simulate = new Proxy(
        {},
        {
          get(_, functionName: string) {
            return (
              ...parameters: [
                args?: readonly unknown[],
                options?: UnionOmit<
                  SimulateContractParameters,
                  'abi' | 'address' | 'functionName' | 'args'
                >,
              ]
            ) => {
              const { args, options } = getFunctionParameters(parameters)
              return getAction(
                publicClient,
                simulateContract,
                'simulateContract',
              )({
                abi,
                address,
                functionName,
                args,
                ...options,
              } as SimulateContractParameters)
            }
          },
        },
      )

    if (hasEvent) {
      contract.createEventFilter = new Proxy(
        {},
        {
          get(_, eventName: string) {
            return (
              ...parameters: [
                args?: readonly unknown[] | object,
                options?: Omit<
                  CreateContractEventFilterParameters,
                  'abi' | 'address' | 'eventName' | 'args'
                >,
              ]
            ) => {
              const abiEvent = (abi as readonly AbiEvent[]).find(
                (x: AbiEvent) => x.type === 'event' && x.name === eventName,
              )
              const { args, options } = getEventParameters(
                parameters,
                abiEvent!,
              )
              return getAction(
                publicClient,
                createContractEventFilter,
                'createContractEventFilter',
              )({
                abi,
                address,
                eventName,
                args,
                ...options,
              } as CreateContractEventFilterParameters)
            }
          },
        },
      )
      contract.getEvents = new Proxy(
        {},
        {
          get(_, eventName: string) {
            return (
              ...parameters: [
                args?: readonly unknown[] | object,
                options?: Omit<
                  GetContractEventsParameters,
                  'abi' | 'address' | 'eventName'
                >,
              ]
            ) => {
              const abiEvent = (abi as readonly AbiEvent[]).find(
                (x: AbiEvent) => x.type === 'event' && x.name === eventName,
              )
              const { args, options } = getEventParameters(
                parameters,
                abiEvent!,
              )
              return getAction(
                publicClient,
                getContractEvents,
                'getContractEvents',
              )({
                abi,
                address,
                eventName,
                args,
                ...options,
              } as unknown as GetContractEventsParameters)
            }
          },
        },
      )
      contract.watchEvent = new Proxy(
        {},
        {
          get(_, eventName: string) {
            return (
              ...parameters: [
                args?: readonly unknown[] | object,
                options?: Omit<
                  WatchContractEventParameters,
                  'abi' | 'address' | 'eventName'
                >,
              ]
            ) => {
              const abiEvent = (abi as readonly AbiEvent[]).find(
                (x: AbiEvent) => x.type === 'event' && x.name === eventName,
              )
              const { args, options } = getEventParameters(
                parameters,
                abiEvent!,
              )
              return getAction(
                publicClient,
                watchContractEvent,
                'watchContractEvent',
              )({
                abi,
                address,
                eventName,
                args,
                ...options,
              } as unknown as WatchContractEventParameters)
            }
          },
        },
      )
    }
  }

  if (hasWalletClient) {
    if (hasWriteFunction)
      contract.write = new Proxy(
        {},
        {
          get(_, functionName: string) {
            return (
              ...parameters: [
                args?: readonly unknown[],
                options?: UnionOmit<
                  WriteContractParameters,
                  'abi' | 'address' | 'functionName' | 'args'
                >,
              ]
            ) => {
              const { args, options } = getFunctionParameters(parameters)
              return getAction(
                walletClient,
                writeContract,
                'writeContract',
              )({
                abi,
                address,
                functionName,
                args,
                ...(options as any),
              })
            }
          },
        },
      )
  }

  if (hasPublicClient || hasWalletClient)
    if (hasWriteFunction)
      contract.estimateGas = new Proxy(
        {},
        {
          get(_, functionName: string) {
            return (
              ...parameters: [
                args?: readonly unknown[],
                options?: UnionOmit<
                  EstimateContractGasParameters,
                  'abi' | 'address' | 'functionName' | 'args'
                >,
              ]
            ) => {
              const { args, options } = getFunctionParameters(parameters)
              const client = (publicClient ?? walletClient)!
              return getAction(
                client,
                estimateContractGas,
                'estimateContractGas',
              )({
                abi,
                address,
                functionName,
                args,
                ...options,
                account:
                  (options as EstimateContractGasParameters).account ??
                  (walletClient as unknown as Client).account,
              } as any)
            }
          },
        },
      )
  contract.address = address
  contract.abi = abi

  return contract as unknown as GetContractReturnType<abi, client, address>
}

/**
 * @internal exporting for testing only
 */
export function getFunctionParameters(
  values: [args?: readonly unknown[] | undefined, options?: object | undefined],
) {
  const hasArgs = values.length && Array.isArray(values[0])
  const args = hasArgs ? values[0]! : []
  const options = (hasArgs ? values[1] : values[0]) ?? {}
  return { args, options }
}

/**
 * @internal exporting for testing only
 */
export function getEventParameters(
  values: [args?: object | unknown[], options?: object],
  abiEvent: AbiEvent,
) {
  let hasArgs = false
  // If first item is array, must be `args`
  if (Array.isArray(values[0])) hasArgs = true
  // Check if first item is `args` or `options`
  else if (values.length === 1) {
    // if event has indexed inputs, must have `args`
    hasArgs = abiEvent.inputs.some((x) => x.indexed)
    // If there are two items in array, must have `args`
  } else if (values.length === 2) {
    hasArgs = true
  }

  const args = hasArgs ? values[0]! : undefined
  const options = (hasArgs ? values[1] : values[0]) ?? {}
  return { args, options }
}

type GetReadFunction<
  narrowable extends boolean,
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
  args extends ContractFunctionArgs<
    abi,
    'pure' | 'view',
    functionName
  > = ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  abiFunction extends AbiFunction = abi extends Abi
    ? ExtractAbiFunction<abi, functionName>
    : AbiFunction,
  //
  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs']>,
  _options = Prettify<
    UnionOmit<
      ReadContractParameters<abi, functionName, args>,
      'abi' | 'address' | 'args' | 'functionName'
    >
  >,
> = narrowable extends true
  ? (
      ...parameters: _args extends readonly []
        ? [options?: _options]
        : [args: _args, options?: _options]
    ) => Promise<ReadContractReturnType<abi, functionName, args>>
  : (
      ...parameters:
        | [options?: _options]
        | [args: readonly unknown[], options?: _options]
    ) => Promise<ReadContractReturnType>

type GetEstimateFunction<
  narrowable extends boolean,
  chain extends Chain | undefined,
  account extends Account | undefined,
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  abiFunction extends AbiFunction = abi extends Abi
    ? ExtractAbiFunction<abi, functionName>
    : AbiFunction,
  //
  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs']>,
  _options = Prettify<
    UnionOmit<
      EstimateContractGasParameters<abi, functionName, args, chain>,
      'abi' | 'address' | 'args' | 'functionName'
    >
  >,
  // For making `options` parameter required if `account`
  IsOptionsRequired = IsUndefined<account>,
> = narrowable extends true
  ? (
      ...parameters: _args extends readonly []
        ? IsOptionsRequired extends true
          ? [options: _options]
          : [options?: _options]
        : [
            args: _args,
            ...parameters: IsOptionsRequired extends true
              ? [options: _options]
              : [options?: _options],
          ]
    ) => Promise<EstimateContractGasReturnType>
  : (
      ...parameters:
        | (IsOptionsRequired extends true
            ? [options: _options]
            : [options?: _options])
        | [
            args: readonly unknown[],
            ...parameters: IsOptionsRequired extends true
              ? [options: _options]
              : [options?: _options],
          ]
    ) => Promise<EstimateContractGasReturnType>

type GetSimulateFunction<
  narrowable extends boolean,
  chain extends Chain | undefined,
  account extends Account | undefined,
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  abiFunction extends AbiFunction = abi extends Abi
    ? ExtractAbiFunction<abi, functionName>
    : AbiFunction,
  //
  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs']>,
> = narrowable extends true
  ? <
      chainOverride extends Chain | undefined = undefined,
      accountOverride extends Account | Address | undefined = undefined,
    >(
      ...parameters: _args extends readonly []
        ? [
            options?: Omit<
              SimulateContractParameters<
                abi,
                functionName,
                args,
                chain,
                chainOverride,
                accountOverride
              >,
              'abi' | 'address' | 'args' | 'functionName'
            >,
          ]
        : [
            args: _args,
            options?: Omit<
              SimulateContractParameters<
                abi,
                functionName,
                args,
                chain,
                chainOverride,
                accountOverride
              >,
              'abi' | 'address' | 'args' | 'functionName'
            >,
          ]
    ) => Promise<
      SimulateContractReturnType<
        abi,
        functionName,
        args,
        chain,
        account,
        chainOverride,
        accountOverride
      >
    >
  : <
      chainOverride extends Chain | undefined = undefined,
      accountOverride extends Account | Address | undefined = undefined,
    >(
      ...parameters:
        | [
            options?: Omit<
              SimulateContractParameters<
                abi,
                functionName,
                args,
                chain,
                chainOverride,
                accountOverride
              >,
              'abi' | 'address' | 'args' | 'functionName'
            >,
          ]
        | [
            args: readonly unknown[],
            options?: Omit<
              SimulateContractParameters<
                abi,
                functionName,
                args,
                chain,
                chainOverride,
                accountOverride
              >,
              'abi' | 'address' | 'args' | 'functionName'
            >,
          ]
    ) => Promise<SimulateContractReturnType>

type GetWriteFunction<
  narrowable extends boolean,
  chain extends Chain | undefined,
  account extends Account | undefined,
  abi extends Abi | readonly unknown[],
  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
  args extends ContractFunctionArgs<
    abi,
    'nonpayable' | 'payable',
    functionName
  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,
  abiFunction extends AbiFunction = abi extends Abi
    ? ExtractAbiFunction<abi, functionName>
    : AbiFunction,
  //
  _args = AbiParametersToPrimitiveTypes<abiFunction['inputs']>,
  // For making `options` parameter required if `account` or `chain` is undefined
  _isOptionsRequired = Or<[IsUndefined<account>, IsUndefined<chain>]>,
> = narrowable extends true
  ? <
      chainOverride extends Chain | undefined,
      options extends Prettify<
        UnionOmit<
          WriteContractParameters<
            abi,
            functionName,
            args,
            chain,
            account,
            chainOverride
          >,
          'abi' | 'address' | 'args' | 'functionName'
        >
      >,
    >(
      ...parameters: _args extends readonly []
        ? _isOptionsRequired extends true
          ? [options: options]
          : [options?: options]
        : [
            args: _args,
            ...parameters: _isOptionsRequired extends true
              ? [options: options]
              : [options?: options],
          ]
    ) => Promise<WriteContractReturnType>
  : <
      chainOverride extends Chain | undefined,
      options extends Prettify<
        UnionOmit<
          WriteContractParameters<
            abi,
            functionName,
            args,
            chain,
            account,
            chainOverride
          >,
          'abi' | 'address' | 'args' | 'functionName'
        >
      >,
      Rest extends unknown[] = _isOptionsRequired extends true
        ? [options: options]
        : [options?: options],
    >(
      ...parameters: Rest | [args: readonly unknown[], ...parameters: Rest]
    ) => Promise<WriteContractReturnType>

type GetEventFilter<
  narrowable extends boolean,
  abi extends Abi | readonly unknown[],
  eventName extends ContractEventName<abi>,
  abiEvent extends AbiEvent = abi extends Abi
    ? ExtractAbiEvent<abi, eventName>
    : AbiEvent,
  //
  _args = AbiEventParametersToPrimitiveTypes<abiEvent['inputs']>,
  _options = Prettify<
    Omit<
      CreateContractEventFilterParameters<abi, eventName>,
      'abi' | 'address' | 'args' | 'eventName' | 'strict'
    >
  >,
  IndexedInputs = Extract<abiEvent['inputs'][number], { indexed: true }>,
> = narrowable extends true
  ? <
      const args extends
        | MaybeExtractEventArgsFromAbi<abi, eventName>
        | undefined,
      strict extends boolean | undefined = undefined,
    >(
      ...parameters: IsNever<IndexedInputs> extends true
        ? [options?: _options & { strict?: strict }]
        : [
            args: _args | (_args extends args ? Readonly<args> : never),
            options?: _options & { strict?: strict },
          ]
    ) => Promise<
      CreateContractEventFilterReturnType<abi, eventName, args, strict>
    >
  : <strict extends boolean | undefined = undefined>(
      ...parameters:
        | [options?: _options & { strict?: strict }]
        | [
            args: readonly unknown[] | CreateContractFilterOptions,
            options?: _options & { strict?: strict },
          ]
    ) => Promise<CreateContractEventFilterReturnType>

type GetEventsFunction<
  narrowable extends boolean,
  abi extends Abi | readonly unknown[],
  eventName extends ContractEventName<abi>,
  abiEvent extends AbiEvent = abi extends Abi
    ? ExtractAbiEvent<abi, eventName>
    : AbiEvent,
  //
  _args = AbiEventParametersToPrimitiveTypes<abiEvent['inputs']>,
  _options = Prettify<
    Omit<
      GetContractEventsParameters<abi, eventName>,
      'abi' | 'address' | 'args' | 'eventName'
    >
  >,
  IndexedInputs = Extract<abiEvent['inputs'][number], { indexed: true }>,
> = narrowable extends true
  ? (
      ...parameters: IsNever<IndexedInputs> extends true
        ? [options?: _options]
        : [args?: _args, options?: _options]
    ) => Promise<GetContractEventsReturnType<abi, eventName>>
  : (
      ...parameters:
        | [options?: _options]
        | [
            args?: readonly unknown[] | WatchContractEventOptions,
            options?: _options,
          ]
    ) => Promise<GetContractEventsReturnType<abi, eventName>>

type GetWatchEvent<
  narrowable extends boolean,
  abi extends Abi | readonly unknown[],
  eventName extends ContractEventName<abi>,
  abiEvent extends AbiEvent = abi extends Abi
    ? ExtractAbiEvent<abi, eventName>
    : AbiEvent,
  //
  _args = AbiEventParametersToPrimitiveTypes<abiEvent['inputs']>,
  _options = Prettify<
    Omit<
      WatchContractEventParameters<abi, eventName>,
      'abi' | 'address' | 'args' | 'eventName'
    >
  >,
  _indexedInputs = Extract<abiEvent['inputs'][number], { indexed: true }>,
> = narrowable extends true
  ? (
      ...parameters: IsNever<_indexedInputs> extends true
        ? [options: _options]
        : [args: _args, options: _options]
    ) => WatchContractEventReturnType
  : (
      ...parameters:
        | [options?: _options]
        | [
            args: readonly unknown[] | WatchContractEventOptions,
            options?: _options,
          ]
    ) => WatchContractEventReturnType

type CreateContractFilterOptions =
  RemoveProperties<CreateContractEventFilterParameters>
type WatchContractEventOptions = RemoveProperties<WatchContractEventParameters>

type RemoveProperties<T extends object> = Prettify<
  {
    [key: string]: unknown
  } & {
    [_ in keyof T]?: never
  }
>
</file>

<file path="src/actions/index.ts">
// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type AddChainErrorType,
  type AddChainParameters,
  addChain,
} from './wallet/addChain.js'
export {
  type DeployContractErrorType,
  type DeployContractParameters,
  type DeployContractReturnType,
  deployContract,
} from './wallet/deployContract.js'
export {
  type GetEnsAddressErrorType,
  type GetEnsAddressParameters,
  type GetEnsAddressReturnType,
  getEnsAddress,
} from './ens/getEnsAddress.js'
export {
  type GetEnsAvatarErrorType,
  type GetEnsAvatarParameters,
  type GetEnsAvatarReturnType,
  getEnsAvatar,
} from './ens/getEnsAvatar.js'
export {
  type GetEnsNameErrorType,
  type GetEnsNameParameters,
  type GetEnsNameReturnType,
  getEnsName,
} from './ens/getEnsName.js'
export {
  type GetEnsResolverErrorType,
  type GetEnsResolverParameters,
  type GetEnsResolverReturnType,
  getEnsResolver,
} from './ens/getEnsResolver.js'
export {
  type GetEnsTextErrorType,
  type GetEnsTextParameters,
  type GetEnsTextReturnType,
  getEnsText,
} from './ens/getEnsText.js'
export {
  type CallErrorType,
  type CallParameters,
  type CallReturnType,
  call,
} from './public/call.js'
export {
  type CreateAccessListErrorType,
  type CreateAccessListParameters,
  type CreateAccessListReturnType,
  createAccessList,
} from './public/createAccessList.js'
export {
  type CreateBlockFilterErrorType,
  type CreateBlockFilterReturnType,
  createBlockFilter,
} from './public/createBlockFilter.js'
export {
  type CreateContractEventFilterErrorType,
  type CreateContractEventFilterParameters,
  type CreateContractEventFilterReturnType,
  createContractEventFilter,
} from './public/createContractEventFilter.js'
export {
  type CreateEventFilterErrorType,
  type CreateEventFilterParameters,
  type CreateEventFilterReturnType,
  createEventFilter,
} from './public/createEventFilter.js'
export {
  type CreatePendingTransactionFilterErrorType,
  type CreatePendingTransactionFilterReturnType,
  createPendingTransactionFilter,
} from './public/createPendingTransactionFilter.js'
export {
  type DumpStateErrorType,
  type DumpStateReturnType,
  dumpState,
} from './test/dumpState.js'
export {
  type EstimateContractGasErrorType,
  type EstimateContractGasParameters,
  type EstimateContractGasReturnType,
  estimateContractGas,
} from './public/estimateContractGas.js'
export {
  type EstimateFeesPerGasErrorType,
  type EstimateFeesPerGasParameters,
  type EstimateFeesPerGasReturnType,
  estimateFeesPerGas,
} from './public/estimateFeesPerGas.js'
export {
  type EstimateMaxPriorityFeePerGasErrorType,
  type EstimateMaxPriorityFeePerGasParameters,
  type EstimateMaxPriorityFeePerGasReturnType,
  estimateMaxPriorityFeePerGas,
} from './public/estimateMaxPriorityFeePerGas.js'
export {
  type EstimateGasErrorType,
  type EstimateGasParameters,
  type EstimateGasReturnType,
  estimateGas,
} from './public/estimateGas.js'
export {
  type GetBalanceErrorType,
  type GetBalanceParameters,
  type GetBalanceReturnType,
  getBalance,
} from './public/getBalance.js'
export {
  type GetBlobBaseFeeErrorType,
  type GetBlobBaseFeeReturnType,
  getBlobBaseFee,
} from './public/getBlobBaseFee.js'
export {
  type GetBlockErrorType,
  type GetBlockParameters,
  type GetBlockReturnType,
  getBlock,
} from './public/getBlock.js'
export {
  type GetBlockNumberErrorType,
  type GetBlockNumberParameters,
  type GetBlockNumberReturnType,
  getBlockNumber,
} from './public/getBlockNumber.js'
export {
  type GetBlockTransactionCountErrorType,
  type GetBlockTransactionCountParameters,
  type GetBlockTransactionCountReturnType,
  getBlockTransactionCount,
} from './public/getBlockTransactionCount.js'
export {
  type GetChainIdErrorType,
  type GetChainIdReturnType,
  getChainId,
} from './public/getChainId.js'
export {
  /** @deprecated Use `GetCodeErrorType` instead */
  type GetCodeErrorType as GetBytecodeErrorType,
  /** @deprecated Use `GetCodeParameters` instead */
  type GetCodeParameters as GetBytecodeParameters,
  /** @deprecated Use `GetCodeReturnType` instead  */
  type GetCodeReturnType as GetBytecodeReturnType,
  /** @deprecated Use `getCode` instead  */
  getCode as getBytecode,
  type GetCodeErrorType,
  type GetCodeParameters,
  type GetCodeReturnType,
  getCode,
} from './public/getCode.js'
export {
  type GetContractEventsErrorType,
  type GetContractEventsParameters,
  type GetContractEventsReturnType,
  getContractEvents,
} from './public/getContractEvents.js'
export {
  type GetEip712DomainErrorType,
  type GetEip712DomainParameters,
  type GetEip712DomainReturnType,
  getEip712Domain,
} from './public/getEip712Domain.js'
export {
  type GetFeeHistoryErrorType,
  type GetFeeHistoryParameters,
  type GetFeeHistoryReturnType,
  getFeeHistory,
} from './public/getFeeHistory.js'
export {
  type GetFilterChangesErrorType,
  type GetFilterChangesParameters,
  type GetFilterChangesReturnType,
  getFilterChanges,
} from './public/getFilterChanges.js'
export {
  type GetFilterLogsErrorType,
  type GetFilterLogsParameters,
  type GetFilterLogsReturnType,
  getFilterLogs,
} from './public/getFilterLogs.js'
export {
  type GetGasPriceErrorType,
  type GetGasPriceReturnType,
  getGasPrice,
} from './public/getGasPrice.js'
export {
  type GetLogsErrorType,
  type GetLogsParameters,
  type GetLogsReturnType,
  getLogs,
} from './public/getLogs.js'
export {
  type GetStorageAtErrorType,
  type GetStorageAtParameters,
  type GetStorageAtReturnType,
  getStorageAt,
} from './public/getStorageAt.js'
export {
  type GetTransactionConfirmationsErrorType,
  type GetTransactionConfirmationsParameters,
  type GetTransactionConfirmationsReturnType,
  getTransactionConfirmations,
} from './public/getTransactionConfirmations.js'
export {
  type GetTransactionCountErrorType,
  type GetTransactionCountParameters,
  type GetTransactionCountReturnType,
  getTransactionCount,
} from './public/getTransactionCount.js'
export {
  type GetTransactionErrorType,
  type GetTransactionParameters,
  type GetTransactionReturnType,
  getTransaction,
} from './public/getTransaction.js'
export {
  type GetTransactionReceiptErrorType,
  type GetTransactionReceiptParameters,
  type GetTransactionReceiptReturnType,
  getTransactionReceipt,
} from './public/getTransactionReceipt.js'
export {
  type ImpersonateAccountErrorType,
  type ImpersonateAccountParameters,
  impersonateAccount,
} from './test/impersonateAccount.js'
export {
  type IncreaseTimeErrorType,
  type IncreaseTimeParameters,
  increaseTime,
} from './test/increaseTime.js'
export {
  type LoadStateErrorType,
  type LoadStateParameters,
  type LoadStateReturnType,
  loadState,
} from './test/loadState.js'
export {
  type MineErrorType,
  type MineParameters,
  mine,
} from './test/mine.js'
export {
  type MulticallErrorType,
  type MulticallParameters,
  type MulticallReturnType,
  multicall,
} from './public/multicall.js'
export {
  type SimulateBlocksErrorType,
  type SimulateBlocksParameters,
  type SimulateBlocksReturnType,
  simulateBlocks,
  /** @deprecated Use `SimulateBlocksErrorType` instead */
  type SimulateBlocksErrorType as SimulateErrorType,
  /** @deprecated Use `SimulateBlocksParameters` instead */
  type SimulateBlocksParameters as SimulateParameters,
  /** @deprecated Use `SimulateBlocksReturnType` instead */
  type SimulateBlocksReturnType as SimulateReturnType,
  /** @deprecated Use `simulateBlocks` instead */
  simulateBlocks as simulate,
} from './public/simulateBlocks.js'
export {
  type SimulateCallsErrorType,
  type SimulateCallsParameters,
  type SimulateCallsReturnType,
  simulateCalls,
} from './public/simulateCalls.js'
export {
  type OnBlock,
  type OnBlockParameter,
  type WatchBlocksErrorType,
  type WatchBlocksParameters,
  type WatchBlocksReturnType,
  watchBlocks,
} from './public/watchBlocks.js'
export {
  type OnBlockNumberFn,
  type OnBlockNumberParameter,
  type WatchBlockNumberErrorType,
  type WatchBlockNumberParameters,
  type WatchBlockNumberReturnType,
  watchBlockNumber,
} from './public/watchBlockNumber.js'
export {
  type WatchEventOnLogsFn,
  type WatchEventOnLogsParameter,
  type WatchEventParameters,
  type WatchEventReturnType,
  watchEvent,
} from './public/watchEvent.js'
export {
  type OnTransactionsFn,
  type OnTransactionsParameter,
  type WatchPendingTransactionsErrorType,
  type WatchPendingTransactionsParameters,
  type WatchPendingTransactionsReturnType,
  watchPendingTransactions,
} from './public/watchPendingTransactions.js'
export {
  type ReadContractErrorType,
  type ReadContractParameters,
  type ReadContractReturnType,
  readContract,
} from './public/readContract.js'
export {
  type GetAddressesErrorType,
  type GetAddressesReturnType,
  getAddresses,
} from './wallet/getAddresses.js'
export {
  type GetPermissionsErrorType,
  type GetPermissionsReturnType,
  getPermissions,
} from './wallet/getPermissions.js'
export {
  type GetCapabilitiesParameters,
  type GetCapabilitiesErrorType,
  type GetCapabilitiesReturnType,
  getCapabilities,
} from './wallet/getCapabilities.js'
export {
  type SendCallsErrorType,
  type SendCallsParameters,
  type SendCallsReturnType,
  sendCalls,
} from './wallet/sendCalls.js'
export {
  type GetCallsStatusErrorType,
  type GetCallsStatusParameters,
  type GetCallsStatusReturnType,
  getCallsStatus,
} from './wallet/getCallsStatus.js'
export {
  type ShowCallsStatusErrorType,
  type ShowCallsStatusParameters,
  type ShowCallsStatusReturnType,
  showCallsStatus,
} from './wallet/showCallsStatus.js'
export {
  type WaitForCallsStatusErrorType,
  type WaitForCallsStatusParameters,
  type WaitForCallsStatusReturnType,
  type WaitForCallsStatusTimeoutErrorType,
  waitForCallsStatus,
} from './wallet/waitForCallsStatus.js'
export {
  type GetProofErrorType,
  type GetProofParameters,
  type GetProofReturnType,
  getProof,
} from './public/getProof.js'
export {
  type ReplacementReason,
  type ReplacementReturnType,
  type WaitForTransactionReceiptErrorType,
  type WaitForTransactionReceiptParameters,
  type WaitForTransactionReceiptReturnType,
  waitForTransactionReceipt,
} from './public/waitForTransactionReceipt.js'
export {
  type RequestAddressesErrorType,
  type RequestAddressesReturnType,
  requestAddresses,
} from './wallet/requestAddresses.js'
export {
  type RequestPermissionsErrorType,
  type RequestPermissionsReturnType,
  type RequestPermissionsParameters,
  requestPermissions,
} from './wallet/requestPermissions.js'
export {
  type DropTransactionParameters,
  dropTransaction,
} from './test/dropTransaction.js'
export {
  type GetAutomineErrorType,
  type GetAutomineReturnType,
  getAutomine,
} from './test/getAutomine.js'
export {
  type GetTxpoolContentErrorType,
  type GetTxpoolContentReturnType,
  getTxpoolContent,
} from './test/getTxpoolContent.js'
export {
  type GetTxpoolStatusErrorType,
  type GetTxpoolStatusReturnType,
  getTxpoolStatus,
} from './test/getTxpoolStatus.js'
export {
  type InspectTxpoolErrorType,
  type InspectTxpoolReturnType,
  inspectTxpool,
} from './test/inspectTxpool.js'
export {
  type RemoveBlockTimestampIntervalErrorType,
  removeBlockTimestampInterval,
} from './test/removeBlockTimestampInterval.js'
export {
  type ResetErrorType,
  type ResetParameters,
  reset,
} from './test/reset.js'
export {
  type RevertErrorType,
  type RevertParameters,
  revert,
} from './test/revert.js'
export {
  type PrepareAuthorizationErrorType,
  type PrepareAuthorizationParameters,
  type PrepareAuthorizationReturnType,
  prepareAuthorization,
} from './wallet/prepareAuthorization.js'
export {
  type PrepareTransactionRequestErrorType,
  type PrepareTransactionRequestParameters,
  type PrepareTransactionRequestReturnType,
  prepareTransactionRequest,
  defaultParameters as defaultPrepareTransactionRequestParameters,
} from './wallet/prepareTransactionRequest.js'
export {
  type SendTransactionErrorType,
  type SendTransactionParameters,
  type SendTransactionReturnType,
  sendTransaction,
} from './wallet/sendTransaction.js'
export {
  type SignAuthorizationErrorType,
  type SignAuthorizationParameters,
  type SignAuthorizationReturnType,
  signAuthorization,
} from './wallet/signAuthorization.js'
export {
  type SignTransactionErrorType,
  type SignTransactionParameters,
  type SignTransactionReturnType,
  signTransaction,
} from './wallet/signTransaction.js'
export {
  type SendRawTransactionErrorType,
  type SendRawTransactionParameters,
  type SendRawTransactionReturnType,
  sendRawTransaction,
} from './wallet/sendRawTransaction.js'
export {
  type SendUnsignedTransactionErrorType,
  type SendUnsignedTransactionParameters,
  type SendUnsignedTransactionReturnType,
  sendUnsignedTransaction,
} from './test/sendUnsignedTransaction.js'
export {
  type SetBalanceErrorType,
  type SetBalanceParameters,
  setBalance,
} from './test/setBalance.js'
export { type SetAutomineErrorType, setAutomine } from './test/setAutomine.js'
export {
  type SetBlockGasLimitErrorType,
  type SetBlockGasLimitParameters,
  setBlockGasLimit,
} from './test/setBlockGasLimit.js'
export {
  type SetBlockTimestampIntervalErrorType,
  type SetBlockTimestampIntervalParameters,
  setBlockTimestampInterval,
} from './test/setBlockTimestampInterval.js'
export {
  type SetCodeErrorType,
  type SetCodeParameters,
  setCode,
} from './test/setCode.js'
export {
  type SetCoinbaseErrorType,
  type SetCoinbaseParameters,
  setCoinbase,
} from './test/setCoinbase.js'
export {
  type SetIntervalMiningErrorType,
  type SetIntervalMiningParameters,
  setIntervalMining,
} from './test/setIntervalMining.js'
export {
  type SetLoggingEnabledErrorType,
  setLoggingEnabled,
} from './test/setLoggingEnabled.js'
export {
  type SetMinGasPriceErrorType,
  type SetMinGasPriceParameters,
  setMinGasPrice,
} from './test/setMinGasPrice.js'
export {
  type SetNextBlockBaseFeePerGasErrorType,
  type SetNextBlockBaseFeePerGasParameters,
  setNextBlockBaseFeePerGas,
} from './test/setNextBlockBaseFeePerGas.js'
export {
  type SetNextBlockTimestampErrorType,
  type SetNextBlockTimestampParameters,
  setNextBlockTimestamp,
} from './test/setNextBlockTimestamp.js'
export {
  type SetNonceErrorType,
  type SetNonceParameters,
  setNonce,
} from './test/setNonce.js'
export { type SetRpcUrlErrorType, setRpcUrl } from './test/setRpcUrl.js'
export {
  type SetStorageAtErrorType,
  type SetStorageAtParameters,
  setStorageAt,
} from './test/setStorageAt.js'
export { type SnapshotErrorType, snapshot } from './test/snapshot.js'
export {
  type SignMessageErrorType,
  type SignMessageParameters,
  type SignMessageReturnType,
  signMessage,
} from './wallet/signMessage.js'
export {
  type SignTypedDataErrorType,
  type SignTypedDataParameters,
  type SignTypedDataReturnType,
  signTypedData,
} from './wallet/signTypedData.js'
export {
  type SimulateContractErrorType,
  type SimulateContractParameters,
  type SimulateContractReturnType,
  simulateContract,
} from './public/simulateContract.js'
export {
  type StopImpersonatingAccountErrorType,
  type StopImpersonatingAccountParameters,
  stopImpersonatingAccount,
} from './test/stopImpersonatingAccount.js'
export {
  type SwitchChainErrorType,
  type SwitchChainParameters,
  switchChain,
} from './wallet/switchChain.js'
export {
  type UninstallFilterErrorType,
  type UninstallFilterParameters,
  type UninstallFilterReturnType,
  uninstallFilter,
} from './public/uninstallFilter.js'
export {
  type VerifyHashErrorType,
  type VerifyHashParameters,
  type VerifyHashReturnType,
  verifyHash,
} from './public/verifyHash.js'
export {
  type VerifyMessageErrorType,
  type VerifyMessageParameters,
  type VerifyMessageReturnType,
  verifyMessage,
} from './public/verifyMessage.js'
export {
  type VerifyTypedDataErrorType,
  type VerifyTypedDataParameters,
  type VerifyTypedDataReturnType,
  verifyTypedData,
} from './public/verifyTypedData.js'
export {
  type WatchAssetErrorType,
  type WatchAssetParameters,
  type WatchAssetReturnType,
  watchAsset,
} from './wallet/watchAsset.js'
export {
  type WatchContractEventErrorType,
  type WatchContractEventParameters,
  type WatchContractEventReturnType,
  watchContractEvent,
} from './public/watchContractEvent.js'
export {
  type WriteContractErrorType,
  type WriteContractParameters,
  type WriteContractReturnType,
  writeContract,
} from './wallet/writeContract.js'
</file>

<file path="src/chains/index.ts">
export type { Chain } from '../types/chain.js'

// biome-ignore lint/performance/noBarrelFile: entrypoint module
export { abey } from './definitions/abey.js'
export { abstract } from './definitions/abstract.js'
export { abstractTestnet } from './definitions/abstractTestnet.js'
export { acala } from './definitions/acala.js'
export { acria } from './definitions/acria.js'
export { adf } from './definitions/adf.js'
export { aioz } from './definitions/aioz.js'
export { alephZero } from './definitions/alephZero.js'
export { alephZeroTestnet } from './definitions/alephZeroTestnet.js'
export { alienx } from './definitions/alienX.js'
export { alienxHalTestnet } from './definitions/alienXHalTestnet.js'
export { ancient8 } from './definitions/ancient8.js'
export { ancient8Sepolia } from './definitions/ancient8Sepolia.js'
export { anvil } from './definitions/anvil.js'
export { apeChain } from './definitions/apeChain.js'
export { apexTestnet } from './definitions/apexTestnet.js'
export { arbitrum } from './definitions/arbitrum.js'
export { arbitrumGoerli } from './definitions/arbitrumGoerli.js'
export { arbitrumNova } from './definitions/arbitrumNova.js'
export { arbitrumSepolia } from './definitions/arbitrumSepolia.js'
export { areonNetwork } from './definitions/areonNetwork.js'
export { areonNetworkTestnet } from './definitions/areonNetworkTestnet.js'
export { artelaTestnet } from './definitions/artelaTestnet.js'
export { arthera } from './definitions/arthera.js'
export { artheraTestnet } from './definitions/artheraTestnet.js'
export { assetChain } from './definitions/assetChain.js'
export { assetChainTestnet } from './definitions/assetChainTestnet.js'
export { astar } from './definitions/astar.js'
export { astarZkEVM } from './definitions/astarZkEVM.js'
export { astarZkyoto } from './definitions/astarZkyoto.js'
export { atletaOlympia } from './definitions/atletaOlympia.js'
export { aurora } from './definitions/aurora.js'
export { auroraTestnet } from './definitions/auroraTestnet.js'
export { auroria } from './definitions/auroria.js'
export { avalanche } from './definitions/avalanche.js'
export { avalancheFuji } from './definitions/avalancheFuji.js'
export { b3 } from './definitions/b3.js'
export { b3Sepolia } from './definitions/b3Sepolia.js'
export { bahamut } from './definitions/bahamut.js'
export { base } from './definitions/base.js'
export { basecampTestnet } from './definitions/basecampTestnet.js'
export { baseGoerli } from './definitions/baseGoerli.js'
export { baseSepolia } from './definitions/baseSepolia.js'
export { beam } from './definitions/beam.js'
export { beamTestnet } from './definitions/beamTestnet.js'
export { bearNetworkChainMainnet } from './definitions/bearNetworkChainMainnet.js'
export { bearNetworkChainTestnet } from './definitions/bearNetworkChainTestnet.js'
export { berachain } from './definitions/berachain.js'
export { berachainBepolia } from './definitions/berachainBepolia.js'
export { berachainTestnet } from './definitions/berachainTestnet.js'
export { berachainTestnetbArtio } from './definitions/berachainTestnetbArtio.js'
export { bevmMainnet } from './definitions/bevmMainnet.js'
export { bifrost } from './definitions/bifrost.js'
export { bitgert } from './definitions/bitgert.js'
export { bitkub } from './definitions/bitkub.js'
export { bitkubTestnet } from './definitions/bitkubTestnet.js'
export { bitlayer } from './definitions/bitlayer.js'
export { bitlayerTestnet } from './definitions/bitlayerTestnet.js'
export { bitrock } from './definitions/bitrock.js'
export { bitTorrent } from './definitions/bitTorrent.js'
export { bitTorrentTestnet } from './definitions/bitTorrentTestnet.js'
export { birdlayer } from './definitions/birdlayer.js'
export { blast } from './definitions/blast.js'
export { blastSepolia } from './definitions/blastSepolia.js'
export { bob } from './definitions/bob.js'
export { boba } from './definitions/boba.js'
export { bobaSepolia } from './definitions/bobaSepolia.js'
export { bobSepolia } from './definitions/bobSepolia.js'
export { boolBetaMainnet } from './definitions/boolBetaMainnet.js'
export { botanixTestnet } from './definitions/botanixTestnet.js'
export { bounceBit } from './definitions/bounceBit.js'
export { bounceBitTestnet } from './definitions/bounceBitTestnet.js'
export { bronos } from './definitions/bronos.js'
export { bronosTestnet } from './definitions/bronosTestnet.js'
export { bsc } from './definitions/bsc.js'
export { bscGreenfield } from './definitions/bscGreenfield.js'
export { bscTestnet } from './definitions/bscTestnet.js'
export { bsquared } from './definitions/bsquared.js'
export { bsquaredTestnet } from './definitions/bsquaredTestnet.js'
export { btr } from './definitions/btr.js'
export { btrTestnet } from './definitions/btrTestnet.js'
export { bxn } from './definitions/bxn.js'
export { bxnTestnet } from './definitions/bxnTestnet.js'
export { cannon } from './definitions/cannon.js'
export { canto } from './definitions/canto.js'
export { celo } from './definitions/celo.js'
export { celoAlfajores } from './definitions/celoAlfajores.js'
export { chang } from './definitions/chang.js'
export { chiliz } from './definitions/chiliz.js'
export { chips } from './definitions/chips.js'
export { citreaTestnet } from './definitions/citreaTestnet.js'
export { classic } from './definitions/classic.js'
export { coinbit } from './definitions/coinbit.js'
export { coinex } from './definitions/coinex.js'
export { confluxESpace } from './definitions/confluxESpace.js'
export { confluxESpaceTestnet } from './definitions/confluxESpaceTestnet.js'
export { coreDao } from './definitions/coreDao.js'
export { coreTestnet1 } from './definitions/coreTestnet1.js'
export { coreTestnet2 } from './definitions/coreTestnet2.js'
export { corn } from './definitions/corn.js'
export { cornTestnet } from './definitions/cornTestnet.js'
export { crab } from './definitions/crab.js'
export { creatorTestnet } from './definitions/creatorTestnet.js'
export { creditCoin3Mainnet } from './definitions/creditCoin3Mainnet.js'
export { creditCoin3Testnet } from './definitions/creditCoin3Testnet.js'
export { cronos } from './definitions/cronos.js'
export { cronosTestnet } from './definitions/cronosTestnet.js'
export { cronoszkEVM } from './definitions/cronoszkEVM.js'
export { cronoszkEVMTestnet } from './definitions/cronoszkEVMTestnet.js'
export { crossbell } from './definitions/crossbell.js'
export { curtis } from './definitions/curtis.js'
export { cyber } from './definitions/cyber.js'
export { cyberTestnet } from './definitions/cyberTestnet.js'
export { dailyNetwork } from './definitions/dailyNetwork.js'
export { dailyNetworkTestnet } from './definitions/dailyNetworkTestnet.js'
export { darwinia } from './definitions/darwinia.js'
export { dbkchain } from './definitions/dbkchain.js'
export { dchain } from './definitions/dchain.js'
export { dchainTestnet } from './definitions/dchainTestnet.js'
export { defichainEvm } from './definitions/defichainEvm.js'
export { defichainEvmTestnet } from './definitions/defichainEvmTestnet.js'
export { degen } from './definitions/degen.js'
export { dfk } from './definitions/dfk.js'
export { diode } from './definitions/diode.js'
export { disChain } from './definitions/disChain.js'
export { dodochainTestnet } from './definitions/dodochainTestnet.js'
export { dogechain } from './definitions/dogechain.js'
export { donatuz } from './definitions/donatuz.js'
export { dosChain } from './definitions/dosChain.js'
export { dosChainTestnet } from './definitions/dosChainTestnet.js'
export { dreyerxMainnet } from './definitions/dreyerxMainnet.js'
export { dreyerxTestnet } from './definitions/dreyerxTestnet.js'
export { dustboyIoT } from './definitions/dustboyIoT.js'
export { dymension } from './definitions/dymension.js'
export { edexaTestnet } from './definitions/edexaTestnet.js'
export { edexa } from './definitions/edexa.js'
export { edgeless } from './definitions/edgeless.js'
export { edgelessTestnet } from './definitions/edgelessTestnet.js'
export { edgeware } from './definitions/edgeware.js'
export { edgewareTestnet } from './definitions/edgewareTestnet.js'
export { eduChain } from './definitions/eduChain.js'
export { eduChainTestnet } from './definitions/eduChainTestnet.js'
export { ekta } from './definitions/ekta.js'
export { ektaTestnet } from './definitions/ektaTestnet.js'
export { elastos } from './definitions/elastos.js'
export { elastosTestnet } from './definitions/elastosTestnet.js'
export { electroneum } from './definitions/electroneum.js'
export { electroneumTestnet } from './definitions/electroneumTestnet.js'
export { elysiumTestnet } from './definitions/elysiumTestnet.js'
export { energy } from './definitions/energy.js'
export { enuls } from './definitions/enuls.js'
export { eon } from './definitions/eon.js'
export { eos } from './definitions/eos.js'
export { eosTestnet } from './definitions/eosTestnet.js'
export { etherlink } from './definitions/etherlink.js'
export { etherlinkTestnet } from './definitions/etherlinkTestnet.js'
export { ethernity } from './definitions/ethernity.js'
export { etp } from './definitions/etp.js'
export { evmos } from './definitions/evmos.js'
export { evmosTestnet } from './definitions/evmosTestnet.js'
export { excelonMainnet } from './definitions/excelonMainnet.js'
export { expanse } from './definitions/expanse.js'
export { exsat } from './definitions/exSat.js'
export { exsatTestnet } from './definitions/exSatTestnet.js'
export { fantom } from './definitions/fantom.js'
/** @deprecated Use `sonicTestnet` instead. */
export { fantomSonicTestnet } from './definitions/fantomSonicTestnet.js'
export { fantomTestnet } from './definitions/fantomTestnet.js'
export { fibo } from './definitions/fibo.js'
export { filecoin } from './definitions/filecoin.js'
export { filecoinCalibration } from './definitions/filecoinCalibration.js'
export { filecoinHyperspace } from './definitions/filecoinHyperspace.js'
export { fireChain } from './definitions/5ireChain.js'
export { flare } from './definitions/flare.js'
export { flareTestnet } from './definitions/flareTestnet.js'
export { flowMainnet } from './definitions/flowMainnet.js'
/** @deprecated */
export { flowPreviewnet } from './definitions/flowPreviewnet.js'
export { flowTestnet } from './definitions/flowTestnet.js'
export { fluence } from './definitions/fluence.js'
export { fluenceStage } from './definitions/fluenceStage.js'
export { fluenceTestnet } from './definitions/fluenceTestnet.js'
export { fluentTestnet } from './definitions/fluentTestnet.js'
export { forma } from './definitions/forma.js'
export { form } from './definitions/form.js'
export { formicarium } from './definitions/memecoreFormicariumTestnet.js'
export { formTestnet } from './definitions/formTestnet.js'
export { forta } from './definitions/forta.js'
/** @deprecated Use `anvil` instead. */
export { foundry } from './definitions/foundry.js'
export { fraxtal } from './definitions/fraxtal.js'
export { fraxtalTestnet } from './definitions/fraxtalTestnet.js'
export { funkiMainnet } from './definitions/funkiMainnet.js'
export { funkiSepolia } from './definitions/funkiSepolia.js'
export { fuse } from './definitions/fuse.js'
export { fuseSparknet } from './definitions/fuseSparknet.js'
export { fusion } from './definitions/fusion.js'
export { fusionTestnet } from './definitions/fusionTestnet.js'
export { garnet } from './definitions/garnet.js'
export { geist } from './definitions/geist.js'
export { genesys } from './definitions/genesys.js'
export { glideL1Protocol } from './definitions/glideL1Protocol.js'
export { glideL2Protocol } from './definitions/glideL2Protocol.js'
export { gnosis } from './definitions/gnosis.js'
export { gnosisChiado } from './definitions/gnosisChiado.js'
export { goat } from './definitions/goat.js'
export { gobi } from './definitions/gobi.js'
export { goChain } from './definitions/goChain.js'
export { godwoken } from './definitions/godwoken.js'
export { goerli } from './definitions/goerli.js'
export { gravity } from './definitions/gravity.js'
export { gunz } from './definitions/gunz.js'
export { guruNetwork } from './definitions/guruNetwork.js'
export { guruTestnet } from './definitions/guruTestnet.js'
export { ham } from './definitions/ham.js'
export { happychainTestnet } from './definitions/happychainTestnet.js'
export { haqqMainnet } from './definitions/haqqMainnet.js'
export { haqqTestedge2 } from './definitions/haqqTestedge2.js'
export { hardhat } from './definitions/hardhat.js'
export { harmonyOne } from './definitions/harmonyOne.js'
export { hashkey } from './definitions/hashKeyChain.js'
export { hashkeyTestnet } from './definitions/hashkeyChainTestnet.js'
export { haustTestnet } from './definitions/haustTestnet.js'
export { hedera } from './definitions/hedera.js'
export { hederaPreviewnet } from './definitions/hederaPreviewnet.js'
export { hederaTestnet } from './definitions/hederaTestnet.js'
export { hela } from './definitions/hela.js'
export { hemi } from './definitions/hemi.js'
export { hemiSepolia } from './definitions/hemiSepolia.js'
export { holesky } from './definitions/holesky.js'
export { hoodi } from './definitions/hoodi.js'
export { hpb } from './definitions/hpb.js'
export { huddle01Mainnet } from './definitions/huddle01Mainnet.js'
export { huddle01Testnet } from './definitions/huddle01Testnet.js'
export { humanode } from './definitions/humanode.js'
export { humanodeTestnet5 } from './definitions/humanodeTestnet5.js'
export { hychain } from './definitions/hychain.js'
export { hychainTestnet } from './definitions/hychainTestnet.js'
export { idchain } from './definitions/idchain.js'
export { immutableZkEvm } from './definitions/immutableZkEvm.js'
export { immutableZkEvmTestnet } from './definitions/immutableZkEvmTestnet.js'
export { inEVM } from './definitions/inEVM.js'
export { initVerse } from './definitions/initVerse.js'
export { initVerseGenesis } from './definitions/initVerseGenesis.js'
export { ink } from './definitions/ink.js'
export { inkSepolia } from './definitions/inkSepolia.js'
export { iota } from './definitions/iota.js'
export { iotaTestnet } from './definitions/iotaTestnet.js'
export { iotex } from './definitions/iotex.js'
export { iotexTestnet } from './definitions/iotexTestnet.js'
export { iSunCoin } from './definitions/iSunCoin.js'
export { jbc } from './definitions/jbc.js'
export { jbcTestnet } from './definitions/jbcTestnet.js'
export { juneo } from './definitions/juneo.js'
export { juneoBCH1Chain } from './definitions/juneoBCH1Chain.js'
export { juneoDAI1Chain } from './definitions/juneoDAI1Chain.js'
export { juneoDOGE1Chain } from './definitions/juneoDOGE1Chain.js'
export { juneoEUR1Chain } from './definitions/juneoEUR1Chain.js'
export { juneoGLD1Chain } from './definitions/juneoGLD1Chain.js'
export { juneoLINK1Chain } from './definitions/juneoLINK1Chain.js'
export { juneoLTC1Chain } from './definitions/juneoLTC1Chain.js'
export { juneomBTC1Chain } from './definitions/juneomBTC1Chain.js'
export { juneoSGD1Chain } from './definitions/juneoSGD1Chain.js'
export { juneoSocotraTestnet } from './definitions/juneoSocotraTestnet.js'
export { juneoUSD1Chain } from './definitions/juneoUSD1Chain.js'
export { juneoUSDT1Chain } from './definitions/juneoUSDT1Chain.js'
export { karura } from './definitions/karura.js'
/** @deprecated Use `kakarotStarknetSepolia` instead. */
export { kakarotSepolia } from './definitions/kakarotSepolia.js'
export { kakarotStarknetSepolia } from './definitions/kakarotStarknetSepolia.js'
export { kardiaChain } from './definitions/kardiaChain.js'
export { kava } from './definitions/kava.js'
export { kavaTestnet } from './definitions/kavaTestnet.js'
export { kcc } from './definitions/kcc.js'
export { kinto } from './definitions/kinto.js'
/** @deprecated Use `kaia` instead. */
export { klaytn } from './definitions/klaytn.js'
export { kaia } from './definitions/kaia.js'
export { kairos } from './definitions/kairos.js'
/** @deprecated Use `kairos` instead. */
export { klaytnBaobab } from './definitions/klaytnBaobab.js'
export { koi } from './definitions/koi.js'
export { kroma } from './definitions/kroma.js'
export { kromaSepolia } from './definitions/kromaSepolia.js'
export { l3x } from './definitions/l3x.js'
export { l3xTestnet } from './definitions/l3xTestnet.js'
export { lavita } from './definitions/lavita.js'
export { lens } from './definitions/lens.js'
export { lensTestnet } from './definitions/lensTestnet.js'
export { lestnet } from './definitions/lestnet.js'
export { lightlinkPegasus } from './definitions/lightlinkPegasus.js'
export { lightlinkPhoenix } from './definitions/lightlinkPhoenix.js'
export { linea } from './definitions/linea.js'
/** @deprecated Use `lineaSepolia` instead. */
export { lineaGoerli } from './definitions/lineaGoerli.js'
export { lineaSepolia } from './definitions/lineaSepolia.js'
/** @deprecated Use `lineaSepolia` instead. */
export { lineaTestnet } from './definitions/lineaTestnet.js'
export { lisk } from './definitions/lisk.js'
export { liskSepolia } from './definitions/liskSepolia.js'
export { localhost } from './definitions/localhost.js'
export { loop } from './definitions/loop.js'
export { lukso } from './definitions/lukso.js'
export { luksoTestnet } from './definitions/luksoTestnet.js'
export { lumiaMainnet } from './definitions/lumiaMainnet.js'
export { lumiaTestnet } from './definitions/lumiaTestnet.js'
export { lumoz } from './definitions/lumoz.js'
export { lumozTestnet } from './definitions/lumozTestnet.js'
export { lycan } from './definitions/lycan.js'
export { lyra } from './definitions/lyra.js'
export { mainnet } from './definitions/mainnet.js'
export { mandala } from './definitions/mandala.js'
export { manta } from './definitions/manta.js'
export { mantaSepoliaTestnet } from './definitions/mantaSepoliaTestnet.js'
export { mantaTestnet } from './definitions/mantaTestnet.js'
export { mantle } from './definitions/mantle.js'
export { mantleSepoliaTestnet } from './definitions/mantleSepoliaTestnet.js'
export { mantleTestnet } from './definitions/mantleTestnet.js'
export { mapProtocol } from './definitions/mapProtocol.js'
export { matchain } from './definitions/matchain.js'
export { matchainTestnet } from './definitions/matchainTestnet.js'
export { mchVerse } from './definitions/mchVerse.js'
export { megaethTestnet } from './definitions/megaethTestnet.js'
export { mekong } from './definitions/mekong.js'
export { meld } from './definitions/meld.js'
export { memecore } from './definitions/memecore.js'
export { merlin } from './definitions/merlin.js'
export { merlinErigonTestnet } from './definitions/merlinErigonTestnet.js'
export { metachain } from './definitions/metachain.js'
export { metachainIstanbul } from './definitions/metachainIstanbul.js'
export { metadium } from './definitions/metadium.js'
export { metalL2 } from './definitions/metalL2.js'
export { meter } from './definitions/meter.js'
export { meterTestnet } from './definitions/meterTestnet.js'
export { metis } from './definitions/metis.js'
export { metisSepolia } from './definitions/metisSepolia.js'
/** @deprecated Use `metisSepolia` instead. */
export { metisGoerli } from './definitions/metisGoerli.js'
export { mev } from './definitions/mev.js'
export { mevTestnet } from './definitions/mevTestnet.js'
export { mint } from './definitions/mint.js'
export { mintSepoliaTestnet } from './definitions/mintSepoliaTestnet.js'
export { mitosisTestnet } from './definitions/mitosisTestnet.js'
export { mode } from './definitions/mode.js'
export { modeTestnet } from './definitions/modeTestnet.js'
export { monadTestnet } from './definitions/monadTestnet.js'
export { moonbaseAlpha } from './definitions/moonbaseAlpha.js'
export { moonbeam } from './definitions/moonbeam.js'
export { moonbeamDev } from './definitions/moonbeamDev.js'
export { moonriver } from './definitions/moonriver.js'
export { morph } from './definitions/morph.js'
export { morphHolesky } from './definitions/morphHolesky.js'
export { morphSepolia } from './definitions/morphSepolia.js'
export { nahmii } from './definitions/nahmii.js'
export { nautilus } from './definitions/nautilus.js'
export { near } from './definitions/near.js'
export { nearTestnet } from './definitions/nearTestnet.js'
export { neonDevnet } from './definitions/neonDevnet.js'
export { neonMainnet } from './definitions/neonMainnet.js'
export { neoxMainnet } from './definitions/neoxMainnet.js'
export { neoxT4 } from './definitions/neoxT4.js'
export { newton } from './definitions/newton.js'
export { nexi } from './definitions/nexi.js'
export { nexilix } from './definitions/nexilix.js'
export { nibiru } from './definitions/nibiru.js'
export { oasisTestnet } from './definitions/oasisTestnet.js'
export { oasys } from './definitions/oasys.js'
export { odysseyTestnet } from './definitions/odysseyTestnet.js'
export { okc } from './definitions/okc.js'
export { omax } from './definitions/omax.js'
export { oneWorld } from './definitions/oneWorld.js'
export { oortMainnetDev } from './definitions/oortmainnetDev.js'
export { opBNB } from './definitions/opBNB.js'
export { opBNBTestnet } from './definitions/opBNBTestnet.js'
export { optimism } from './definitions/optimism.js'
export { optimismGoerli } from './definitions/optimismGoerli.js'
export { optimismSepolia } from './definitions/optimismSepolia.js'
export { optopia } from './definitions/optopia.js'
export { optopiaTestnet } from './definitions/optopiaTestnet.js'
export { orderly } from './definitions/orderly.js'
export { orderlySepolia } from './definitions/orderlySepolia.js'
export { otimDevnet } from './definitions/otimDevnet.js'
export { palm } from './definitions/palm.js'
export { palmTestnet } from './definitions/palmTestnet.js'
export { peaq } from './definitions/peaq.js'
export { pgn } from './definitions/pgn.js'
export { pgnTestnet } from './definitions/pgnTestnet.js'
export { phoenix } from './definitions/phoenix.js'
export { planq } from './definitions/planq.js'
export { playfiAlbireo } from './definitions/playfiAlbireo.js'
export { plinga } from './definitions/plinga.js'
/** @deprecated Use `plumeMainnet` instead. */
export { plume } from './definitions/plume.js'
/** @deprecated Use `plumeSepolia` instead. */
export { plumeDevnet } from './definitions/plumeDevnet.js'
export { plumeMainnet } from './definitions/plumeMainnet.js'
export { plumeSepolia } from './definitions/plumeSepolia.js'
/** @deprecated Use `plumeSepolia` instead. */
export { plumeTestnet } from './definitions/plumeTestnet.js'
export { polterTestnet } from './definitions/polterTestnet.js'
export { polygon } from './definitions/polygon.js'
export { polygonAmoy } from './definitions/polygonAmoy.js'
export { polygonMumbai } from './definitions/polygonMumbai.js'
export { polygonZkEvm } from './definitions/polygonZkEvm.js'
export { polygonZkEvmCardona } from './definitions/polygonZkEvmCardona.js'
/** @deprecated Use `polygonZkEvmCardona` instead. */
export { polygonZkEvmTestnet } from './definitions/polygonZkEvmTestnet.js'
export { polynomial } from './definitions/polynomial.js'
export { polynomialSepolia } from './definitions/polynomialSepolia.js'
export { premiumBlockTestnet } from './definitions/premiumBlock.js'
export { pulsechain } from './definitions/pulsechain.js'
export { pulsechainV4 } from './definitions/pulsechainV4.js'
export { pumpfiTestnet } from './definitions/pumpfiTestnet.js'
export { pyrope } from './definitions/pyrope.js'
export { ql1 } from './definitions/ql1.js'
export { qMainnet } from './definitions/qMainnet.js'
export { qTestnet } from './definitions/qTestnet.js'
export { real } from './definitions/real.js'
export { redbellyMainnet } from './definitions/redbellyMainnet.js'
export { redbellyTestnet } from './definitions/redbellyTestnet.js'
export { redstone } from './definitions/redstone.js'
export { rei } from './definitions/rei.js'
export { reyaNetwork } from './definitions/reyaNetwork.js'
export { reddioSepolia } from './definitions/reddioSepolia.js'
export { rivalz } from './definitions/rivalz.js'
export { rollux } from './definitions/rollux.js'
export { rolluxTestnet } from './definitions/rolluxTestnet.js'
export { ronin } from './definitions/ronin.js'
export { root } from './definitions/root.js'
export { rootPorcini } from './definitions/rootPorcini.js'
export { rootstock } from './definitions/rootstock.js'
export { rootstockTestnet } from './definitions/rootstockTestnet.js'
export { rss3 } from './definitions/rss3.js'
export { rss3Sepolia } from './definitions/rss3Sepolia.js'
export { saakuru } from './definitions/saakuru.js'
export { saga } from './definitions/saga.js'
export { saigon } from './definitions/saigon.js'
export { sanko } from './definitions/sanko.js'
export { sapphire } from './definitions/sapphire.js'
export { sapphireTestnet } from './definitions/sapphireTestnet.js'
export { satoshiVM } from './definitions/satoshivm.js'
export { satoshiVMTestnet } from './definitions/satoshivmTestnet.js'
export { scroll } from './definitions/scroll.js'
export { scrollSepolia } from './definitions/scrollSepolia.js'
export { sei } from './definitions/sei.js'
export { seiDevnet } from './definitions/seiDevnet.js'
export { seismicDevnet } from './definitions/seismicDevnet.js'
export { seiTestnet } from './definitions/seiTestnet.js'
export { sepolia } from './definitions/sepolia.js'
export { shape } from './definitions/shape.js'
export { shapeSepolia } from './definitions/shapeSepolia.js'
export { shardeum } from './definitions/shardeum.js'
export { shardeumSphinx } from './definitions/shardeumSphinx.js'
export { shibarium } from './definitions/shibarium.js'
export { shibariumTestnet } from './definitions/shibariumTestnet.js'
export { shiden } from './definitions/shiden.js'
export { shimmer } from './definitions/shimmer.js'
export { shimmerTestnet } from './definitions/shimmerTestnet.js'
export { sidraChain } from './definitions/sidra.js'
export { silicon } from './definitions/silicon.js'
export { siliconSepolia } from './definitions/siliconSepolia.js'
export { sixProtocol } from './definitions/sixProtocol.js'
export { skaleBlockBrawlers } from './definitions/skale/brawl.js'
export { skaleCalypso } from './definitions/skale/calypso.js'
export { skaleCalypsoTestnet } from './definitions/skale/calypsoTestnet.js'
export { skaleCryptoBlades } from './definitions/skale/cryptoBlades.js'
/** @deprecated */
export { skaleCryptoColosseum } from './definitions/skale/cryptoColosseum.js'
export { skaleEuropa } from './definitions/skale/europa.js'
export { skaleEuropaTestnet } from './definitions/skale/europaTestnet.js'
export { skaleExorde } from './definitions/skale/exorde.js'
/** @deprecated */
export { skaleHumanProtocol } from './definitions/skale/humanProtocol.js'
export { skaleNebula } from './definitions/skale/nebula.js'
export { skaleNebulaTestnet } from './definitions/skale/nebulaTestnet.js'
/** @deprecated Use `skaleEuropa` instead.*/
export { skaleRazor } from './definitions/skale/razor.js'
export { skaleTitan } from './definitions/skale/titan.js'
export { skaleTitanTestnet } from './definitions/skale/titanTestnet.js'
export { sketchpad } from './definitions/sketchpad.js'
export { snax } from './definitions/snax.js'
export { snaxTestnet } from './definitions/snaxTestnet.js'
export { somniaTestnet } from './definitions/somniaTestnet.js'
export { soneium } from './definitions/soneium.js'
export { soneiumMinato } from './definitions/soneiumMinato.js'
export { sonic } from './definitions/sonic.js'
/** @deprecated Use `sonicBlazeTestnet` instead. */
export { sonicTestnet } from './definitions/sonicTestnet.js'
export { sonicBlazeTestnet } from './definitions/sonicBlazeTestnet.js'
export { songbird } from './definitions/songbird.js'
export { songbirdTestnet } from './definitions/songbirdTestnet.js'
export { sophon } from './definitions/sophon.js'
export { sophonTestnet } from './definitions/sophonTestnet.js'
export { spicy } from './definitions/spicy.js'
export {
  statusSepolia,
  statusSepolia as statusNetworkSepolia,
} from './definitions/statusNetworkSepolia.js'
export { step } from './definitions/step.js'
export { story } from './definitions/story.js'
export { storyAeneid } from './definitions/storyAeneid.js'
/** @deprecated Use `storyAeneid` instead. */
export { storyOdyssey } from './definitions/storyOdyssey.js'
/** @deprecated Use `storyAeneid` instead. */
export { storyTestnet } from './definitions/storyTestnet.js'
export { stratis } from './definitions/stratis.js'
export { superlumio } from './definitions/superlumio.js'
export { superposition } from './definitions/superposition.js'
export { superseed } from './definitions/superseed.js'
export { superseedSepolia } from './definitions/superseedSepolia.js'
export { swan } from './definitions/swan.js'
export { swanProximaTestnet } from './definitions/swanProximaTestnet.js'
export { swanSaturnTestnet } from './definitions/swanSaturnTestnet.js'
export { swellchain } from './definitions/swellchain.js'
export { swellchainTestnet } from './definitions/swellchainTestnet.js'
export { swissdlt } from './definitions/swissdlt.js'
export { syscoin } from './definitions/syscoin.js'
export { syscoinTestnet } from './definitions/syscoinTestnet.js'
export { taiko } from './definitions/taiko.js'
export { taikoHekla } from './definitions/taikoHekla.js'
export { taikoJolnir } from './definitions/taikoJolnir.js'
export { taikoKatla } from './definitions/taikoKatla.js'
export { taikoTestnetSepolia } from './definitions/taikoTestnetSepolia.js'
export { taraxa } from './definitions/taraxa.js'
export { taraxaTestnet } from './definitions/taraxaTestnet.js'
export { telcoinTestnet } from './definitions/telcoinTestnet.js'
export { telos } from './definitions/telos.js'
export { telosTestnet } from './definitions/telosTestnet.js'
export { tenet } from './definitions/tenet.js'
export { ternoa } from './definitions/ternoa.js'
export { thaiChain } from './definitions/thaiChain.js'
export { that } from './definitions/that.js'
export { theta } from './definitions/theta.js'
export { thetaTestnet } from './definitions/thetaTestnet.js'
export { thunderCore } from './definitions/thunderCore.js'
export { thunderTestnet } from './definitions/thunderTestnet.js'
export { tiktrixTestnet } from './definitions/tiktrixTestnet.js'
export { tomb } from './definitions/tomb.js'
export { treasure } from './definitions/treasure.js'
export { treasureTopaz } from './definitions/treasureTopaz.js'
export { tron } from './definitions/tron.js'
export { tronShasta } from './definitions/tronShasta.js'
export { ubiq } from './definitions/ubiq.js'
export { ultra } from './definitions/ultra.js'
export { ultraTestnet } from './definitions/ultraTestnet.js'
export { ultron } from './definitions/ultron.js'
export { ultronTestnet } from './definitions/ultronTestnet.js'
export { unichain } from './definitions/unichain.js'
export { unichainSepolia } from './definitions/unichainSepolia.js'
export { unique } from './definitions/unique.js'
export { uniqueOpal } from './definitions/uniqueOpal.js'
export { uniqueQuartz } from './definitions/uniqueQuartz.js'
export { unreal } from './definitions/unreal.js'
export { vanar } from './definitions/vanar.js'
export { vechain } from './definitions/vechain.js'
export { velas } from './definitions/velas.js'
export { viction } from './definitions/viction.js'
export { victionTestnet } from './definitions/victionTestnet.js'
export { vision } from './definitions/vision.js'
export { visionTestnet } from './definitions/visionTestnet.js'
export { wanchain } from './definitions/wanchain.js'
export { wanchainTestnet } from './definitions/wanchainTestnet.js'
export { weaveVMAlphanet } from './definitions/weavevmAlphanet.js'
export { wemix } from './definitions/wemix.js'
export { wemixTestnet } from './definitions/wemixTestnet.js'
export { westendAssetHub } from './definitions/westendAssetHub.js'
export { whitechain } from './definitions/whitechain.js'
export { whitechainTestnet } from './definitions/whitechainTestnet.js'
export { wmcTestnet } from './definitions/wmcTestnet.js'
export { worldchain } from './definitions/worldchain.js'
export { worldchainSepolia } from './definitions/worldchainSepolia.js'
export { worldLand } from './definitions/worldLand.js'
export { xai } from './definitions/xai.js'
export { xaiTestnet } from './definitions/xaiTestnet.js'
export { xdc } from './definitions/xdc.js'
export { xdcTestnet } from './definitions/xdcTestnet.js'
export { xLayer } from './definitions/xLayer.js'
export {
  /** @deprecated Use `xLayerTestnet` */
  x1Testnet,
  xLayerTestnet,
} from './definitions/xLayerTestnet.js'
export { xrOne } from './definitions/xrOne.js'
export { xrplevmDevnet } from './definitions/xrplevmDevnet.js'
export { xrplevmTestnet } from './definitions/xrplevmTestnet.js'
export { xrSepolia } from './definitions/xrSepolia.js'
export { yooldoVerse } from './definitions/yooldoVerse.js'
export { yooldoVerseTestnet } from './definitions/yooldoVerseTestnet.js'
export { zenchainTestnet } from './definitions/zenchainTestnet.js'
export { zeniq } from './definitions/zeniq.js'
export { zeroG } from './definitions/0g.js'
export { zeroNetwork } from './definitions/zeroNetwork.js'
export { zetachain } from './definitions/zetachain.js'
export { zetachainAthensTestnet } from './definitions/zetachainAthensTestnet.js'
export { zhejiang } from './definitions/zhejiang.js'
export { zilliqa } from './definitions/zilliqa.js'
export { zilliqaTestnet } from './definitions/zilliqaTestnet.js'
export { zircuit } from './definitions/zircuit.js'
export { zircuitGarfieldTestnet } from './definitions/zircuitGarfieldTestnet.js'
export { zircuitTestnet } from './definitions/zircuitTestnet.js'
export { zkFair } from './definitions/zkFair.js'
export { zkFairTestnet } from './definitions/zkFairTestnet.js'
export { zkLinkNova } from './definitions/zkLinkNova.js'
export { zkLinkNovaSepoliaTestnet } from './definitions/zkLinkNovaSepoliaTestnet.js'
export {
  /** @deprecated Use `zksync` instead */
  zksync as zkSync,
  zksync,
} from './definitions/zksync.js'
export {
  /** @deprecated Use `zksync` instead */
  zksyncInMemoryNode as zkSyncInMemoryNode,
  zksyncInMemoryNode,
} from './definitions/zksyncInMemoryNode.js'
export { zksyncLocalCustomHyperchain } from './definitions/zksyncLocalCustomHyperchain.js'
export { zksyncLocalHyperchain } from './definitions/zksyncLocalHyperchain.js'
export { zksyncLocalHyperchainL1 } from './definitions/zksyncLocalHyperchainL1.js'
export {
  /** @deprecated Use `zksync` instead */
  zksyncLocalNode as zkSyncLocalNode,
  zksyncLocalNode,
} from './definitions/zksyncLocalNode.js'
export {
  /** @deprecated Use `zksync` instead */
  zksyncSepoliaTestnet as zkSyncSepoliaTestnet,
  zksyncSepoliaTestnet,
} from './definitions/zksyncSepoliaTestnet.js'
export { zora } from './definitions/zora.js'
export { zoraSepolia } from './definitions/zoraSepolia.js'
export { zoraTestnet } from './definitions/zoraTestnet.js'

//////////////////////////////////////////////////////////////////////////////////////
// Required type exports to prevent TypeScript error "TS2742".

export type {
  SerializeTransactionCIP64ReturnType,
  assertTransactionCIP42 as assertTransactionCIP42Celo,
  assertTransactionCIP64 as assertTransactionCIP64Celo,
  serializeTransaction as serializeTransactionCelo,
  serializers as serializersCelo,
} from '../celo/serializers.js'
export type {
  CeloBlock,
  CeloRpcBlock,
  CeloRpcTransaction,
  CeloRpcTransactionRequest,
  CeloTransaction,
  CeloTransactionRequest,
  CeloTransactionSerializable,
  CeloTransactionSerialized,
  CeloTransactionType,
  RpcTransactionCIP42,
  RpcTransactionCIP64,
  RpcTransactionRequestCIP64,
  TransactionCIP42,
  TransactionCIP64,
  TransactionRequestCIP64,
  TransactionSerializableCIP42,
  TransactionSerializableCIP64,
  TransactionSerializedCIP42,
  TransactionSerializedCIP64,
} from '../celo/types.js'
export type {
  SerializeTransactionDepositReturnType,
  SerializeTransactionErrorType,
  SerializeTransactionReturnType,
  assertTransactionDeposit as assertTransactionDepositOpStack,
  serializeTransaction as serializeTransactionOpStack,
  serializers as serializersOpStack,
} from '../op-stack/serializers.js'
export type {
  OpStackBlock,
  OpStackBlockOverrides,
  OpStackRpcBlock,
  OpStackRpcBlockOverrides,
} from '../op-stack/types/block.js'
export type {
  OpStackDepositTransaction,
  OpStackRpcDepositTransaction,
  OpStackRpcTransaction,
  OpStackRpcTransactionReceipt,
  OpStackRpcTransactionReceiptOverrides,
  OpStackTransaction,
  OpStackTransactionReceipt,
  OpStackTransactionReceiptOverrides,
  OpStackTransactionSerializable,
  OpStackTransactionSerialized,
  OpStackTransactionType,
  TransactionSerializableDeposit,
  TransactionSerializedDeposit,
} from '../op-stack/types/transaction.js'
export type {
  Assign,
  Omit,
  PartialBy,
  Prettify,
  UnionLooseOmit,
} from '../types/utils.js'
export type {
  /** @deprecated Use `ZksyncBlock` instead */
  ZksyncBlock as ZkSyncBlock,
  /** @deprecated Use `ZksyncRpcBlock` instead */
  ZksyncRpcBlock as ZkSyncRpcBlock,
  ZksyncBlock,
  ZksyncRpcBlock,
} from '../zksync/types/block.js'
export type { ChainEIP712 } from '../zksync/types/chain.js'
export type {
  /** @deprecated Use `ZksyncEip712Meta` instead */
  ZksyncEip712Meta as ZkSyncEip712Meta,
  ZksyncEip712Meta,
} from '../zksync/types/eip712.js'
export type {
  /** @deprecated Use `ZksyncFeeValues` instead */
  ZksyncFeeValues as ZkSyncFeeValues,
  ZksyncFeeValues,
} from '../zksync/types/fee.js'
export type {
  /** @deprecated Use `ZksyncL2ToL1Log` instead */
  ZksyncL2ToL1Log as ZkSyncL2ToL1Log,
  /** @deprecated Use `ZksyncLog` instead */
  ZksyncLog as ZkSyncLog,
  /** @deprecated Use `ZksyncRpcL2ToL1Log` instead */
  ZksyncRpcL2ToL1Log as ZkSyncRpcL2ToL1Log,
  /** @deprecated Use `ZkSyncRpcLog` instead */
  ZksyncRpcLog as ZkSyncRpcLog,
  ZksyncL2ToL1Log,
  ZksyncLog,
  ZksyncRpcL2ToL1Log,
  ZksyncRpcLog,
} from '../zksync/types/log.js'
export type {
  TransactionRequestEIP712,
  /** @deprecated Use `ZksyncEIP712TransactionSignable` instead */
  ZksyncEIP712TransactionSignable as ZkSyncEIP712TransactionSignable,
  /** @deprecated Use `ZksyncRawBlockTransactions` instead */
  ZksyncRawBlockTransactions as ZkSyncRawBlockTransactions,
  /** @deprecated Use `ZksyncRpcTransaction` instead */
  ZksyncRpcTransaction as ZkSyncRpcTransaction,
  /** @deprecated Use `ZksyncRpcTransactionEIP712` instead */
  ZksyncRpcTransactionEIP712 as ZkSyncRpcTransactionEIP712,
  /** @deprecated Use `ZksyncRpcTransactionPriority` instead */
  ZksyncRpcTransactionPriority as ZkSyncRpcTransactionPriority,
  /** @deprecated Use `ZksyncRpcTransactionReceipt` instead */
  ZksyncRpcTransactionReceipt as ZkSyncRpcTransactionReceipt,
  /** @deprecated Use `ZksyncRpcTransactionReceiptOverrides` instead */
  ZksyncRpcTransactionReceiptOverrides as ZkSyncRpcTransactionReceiptOverrides,
  /** @deprecated Use `ZksyncRpcTransactionRequest` instead */
  ZksyncRpcTransactionRequest as ZkSyncRpcTransactionRequest,
  /** @deprecated Use `ZksyncRpcTransactionRequestEIP712` instead */
  ZksyncRpcTransactionRequestEIP712 as ZkSyncRpcTransactionRequestEIP712,
  /** @deprecated Use `ZksyncTransaction` instead */
  ZksyncTransaction as ZkSyncTransaction,
  /** @deprecated Use `ZksyncTransactionDetails` instead */
  ZksyncTransactionDetails as ZkSyncTransactionDetails,
  /** @deprecated Use `ZksyncTransactionEIP712` instead */
  ZksyncTransactionEIP712 as ZkSyncTransactionEIP712,
  /** @deprecated Use `ZksyncTransactionReceipt` instead */
  ZksyncTransactionReceipt as ZkSyncTransactionReceipt,
  /** @deprecated Use `ZksyncTransactionReceiptOverrides` instead */
  ZksyncTransactionReceiptOverrides as ZkSyncTransactionReceiptOverrides,
  /** @deprecated Use `ZksyncTransactionRequest` instead */
  ZksyncTransactionRequest as ZkSyncTransactionRequest,
  /** @deprecated Use `ZksyncTransactionRequestEIP712` instead */
  ZksyncTransactionRequestEIP712 as ZkSyncTransactionRequestEIP712,
  /** @deprecated Use `ZksyncTransactionRequest_internal` instead */
  TransactionRequest as ZkSyncTransactionRequest_internal,
  /** @deprecated Use `ZksyncTransactionSerializable` instead */
  ZksyncTransactionSerializable as ZkSyncTransactionSerializable,
  /** @deprecated Use `ZksyncTransactionSerializableEIP712` instead */
  ZksyncTransactionSerializableEIP712 as ZkSyncTransactionSerializableEIP712,
  /** @deprecated Use `ZksyncTransactionSerialized` instead */
  ZksyncTransactionSerialized as ZkSyncTransactionSerialized,
  /** @deprecated Use `ZksyncTransactionSerializedEIP712` instead */
  ZksyncTransactionSerializedEIP712 as ZkSyncTransactionSerializedEIP712,
  /** @deprecated Use `ZksyncTransactionType` instead */
  ZksyncTransactionType as ZkSyncTransactionType,
  ZksyncEIP712TransactionSignable,
  ZksyncRawBlockTransactions,
  ZksyncRpcTransaction,
  ZksyncRpcTransactionEIP712,
  ZksyncRpcTransactionPriority,
  ZksyncRpcTransactionReceipt,
  ZksyncRpcTransactionReceiptOverrides,
  ZksyncRpcTransactionRequest,
  ZksyncRpcTransactionRequestEIP712,
  ZksyncTransaction,
  ZksyncTransactionDetails,
  ZksyncTransactionEIP712,
  ZksyncTransactionReceipt,
  ZksyncTransactionReceiptOverrides,
  ZksyncTransactionRequest,
  ZksyncTransactionRequestEIP712,
  TransactionRequest as ZksyncTransactionRequest_internal,
  ZksyncTransactionSerializable,
  ZksyncTransactionSerializableEIP712,
  ZksyncTransactionSerialized,
  ZksyncTransactionSerializedEIP712,
  ZksyncTransactionType,
} from '../zksync/types/transaction.js'
</file>

<file path="src/chains/utils.ts">
// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type AssertCurrentChainErrorType,
  type AssertCurrentChainParameters,
  assertCurrentChain,
} from '../utils/chain/assertCurrentChain.js'
export { defineChain } from '../utils/chain/defineChain.js'
export {
  type ExtractChainErrorType,
  type ExtractChainParameters,
  type ExtractChainReturnType,
  extractChain,
} from '../utils/chain/extractChain.js'
export {
  type GetChainContractAddressErrorType,
  getChainContractAddress,
} from '../utils/chain/getChainContractAddress.js'
</file>

<file path="src/clients/decorators/public.ts">
import type { Abi, AbiEvent, Address } from 'abitype'

import {
  type GetEnsAddressParameters,
  type GetEnsAddressReturnType,
  getEnsAddress,
} from '../../actions/ens/getEnsAddress.js'
import {
  type GetEnsAvatarParameters,
  type GetEnsAvatarReturnType,
  getEnsAvatar,
} from '../../actions/ens/getEnsAvatar.js'
import {
  type GetEnsNameParameters,
  type GetEnsNameReturnType,
  getEnsName,
} from '../../actions/ens/getEnsName.js'
import {
  type GetEnsResolverParameters,
  type GetEnsResolverReturnType,
  getEnsResolver,
} from '../../actions/ens/getEnsResolver.js'
import {
  type GetEnsTextParameters,
  type GetEnsTextReturnType,
  getEnsText,
} from '../../actions/ens/getEnsText.js'
import {
  type CallParameters,
  type CallReturnType,
  call,
} from '../../actions/public/call.js'
import {
  type CreateAccessListParameters,
  type CreateAccessListReturnType,
  createAccessList,
} from '../../actions/public/createAccessList.js'
import {
  type CreateBlockFilterReturnType,
  createBlockFilter,
} from '../../actions/public/createBlockFilter.js'
import {
  type CreateContractEventFilterParameters,
  type CreateContractEventFilterReturnType,
  createContractEventFilter,
} from '../../actions/public/createContractEventFilter.js'
import {
  type CreateEventFilterParameters,
  type CreateEventFilterReturnType,
  createEventFilter,
} from '../../actions/public/createEventFilter.js'
import {
  type CreatePendingTransactionFilterReturnType,
  createPendingTransactionFilter,
} from '../../actions/public/createPendingTransactionFilter.js'
import {
  type EstimateContractGasParameters,
  type EstimateContractGasReturnType,
  estimateContractGas,
} from '../../actions/public/estimateContractGas.js'
import {
  type EstimateFeesPerGasParameters,
  type EstimateFeesPerGasReturnType,
  estimateFeesPerGas,
} from '../../actions/public/estimateFeesPerGas.js'
import {
  type EstimateGasParameters,
  type EstimateGasReturnType,
  estimateGas,
} from '../../actions/public/estimateGas.js'
import {
  type EstimateMaxPriorityFeePerGasParameters,
  type EstimateMaxPriorityFeePerGasReturnType,
  estimateMaxPriorityFeePerGas,
} from '../../actions/public/estimateMaxPriorityFeePerGas.js'
import {
  type GetBalanceParameters,
  type GetBalanceReturnType,
  getBalance,
} from '../../actions/public/getBalance.js'
import {
  type GetBlobBaseFeeReturnType,
  getBlobBaseFee,
} from '../../actions/public/getBlobBaseFee.js'
import {
  type GetBlockParameters,
  type GetBlockReturnType,
  getBlock,
} from '../../actions/public/getBlock.js'
import {
  type GetBlockNumberParameters,
  type GetBlockNumberReturnType,
  getBlockNumber,
} from '../../actions/public/getBlockNumber.js'
import {
  type GetBlockTransactionCountParameters,
  type GetBlockTransactionCountReturnType,
  getBlockTransactionCount,
} from '../../actions/public/getBlockTransactionCount.js'
import {
  type GetChainIdReturnType,
  getChainId,
} from '../../actions/public/getChainId.js'
import {
  type GetCodeParameters,
  type GetCodeReturnType,
  getCode,
} from '../../actions/public/getCode.js'
import {
  type GetContractEventsParameters,
  type GetContractEventsReturnType,
  getContractEvents,
} from '../../actions/public/getContractEvents.js'
import {
  type GetEip712DomainParameters,
  type GetEip712DomainReturnType,
  getEip712Domain,
} from '../../actions/public/getEip712Domain.js'
import {
  type GetFeeHistoryParameters,
  type GetFeeHistoryReturnType,
  getFeeHistory,
} from '../../actions/public/getFeeHistory.js'
import {
  type GetFilterChangesParameters,
  type GetFilterChangesReturnType,
  getFilterChanges,
} from '../../actions/public/getFilterChanges.js'
import {
  type GetFilterLogsParameters,
  type GetFilterLogsReturnType,
  getFilterLogs,
} from '../../actions/public/getFilterLogs.js'
import {
  type GetGasPriceReturnType,
  getGasPrice,
} from '../../actions/public/getGasPrice.js'
import {
  type GetLogsParameters,
  type GetLogsReturnType,
  getLogs,
} from '../../actions/public/getLogs.js'
import {
  type GetProofParameters,
  type GetProofReturnType,
  getProof,
} from '../../actions/public/getProof.js'
import {
  type GetStorageAtParameters,
  type GetStorageAtReturnType,
  getStorageAt,
} from '../../actions/public/getStorageAt.js'
import {
  type GetTransactionParameters,
  type GetTransactionReturnType,
  getTransaction,
} from '../../actions/public/getTransaction.js'
import {
  type GetTransactionConfirmationsParameters,
  type GetTransactionConfirmationsReturnType,
  getTransactionConfirmations,
} from '../../actions/public/getTransactionConfirmations.js'
import {
  type GetTransactionCountParameters,
  type GetTransactionCountReturnType,
  getTransactionCount,
} from '../../actions/public/getTransactionCount.js'
import {
  type GetTransactionReceiptParameters,
  type GetTransactionReceiptReturnType,
  getTransactionReceipt,
} from '../../actions/public/getTransactionReceipt.js'
import {
  type MulticallParameters,
  type MulticallReturnType,
  multicall,
} from '../../actions/public/multicall.js'
import {
  type ReadContractParameters,
  type ReadContractReturnType,
  readContract,
} from '../../actions/public/readContract.js'
import {
  type SimulateBlocksParameters,
  type SimulateBlocksReturnType,
  simulateBlocks,
} from '../../actions/public/simulateBlocks.js'
import {
  type SimulateCallsParameters,
  type SimulateCallsReturnType,
  simulateCalls,
} from '../../actions/public/simulateCalls.js'
import {
  type SimulateContractParameters,
  type SimulateContractReturnType,
  simulateContract,
} from '../../actions/public/simulateContract.js'
import {
  type UninstallFilterParameters,
  type UninstallFilterReturnType,
  uninstallFilter,
} from '../../actions/public/uninstallFilter.js'
import {
  type VerifyMessageParameters,
  type VerifyMessageReturnType,
  verifyMessage,
} from '../../actions/public/verifyMessage.js'
import {
  type VerifyTypedDataParameters,
  type VerifyTypedDataReturnType,
  verifyTypedData,
} from '../../actions/public/verifyTypedData.js'
import {
  type WaitForTransactionReceiptParameters,
  type WaitForTransactionReceiptReturnType,
  waitForTransactionReceipt,
} from '../../actions/public/waitForTransactionReceipt.js'
import {
  type WatchBlockNumberParameters,
  type WatchBlockNumberReturnType,
  watchBlockNumber,
} from '../../actions/public/watchBlockNumber.js'
import {
  type WatchBlocksParameters,
  type WatchBlocksReturnType,
  watchBlocks,
} from '../../actions/public/watchBlocks.js'
import {
  type WatchContractEventParameters,
  type WatchContractEventReturnType,
  watchContractEvent,
} from '../../actions/public/watchContractEvent.js'
import {
  type WatchEventParameters,
  type WatchEventReturnType,
  watchEvent,
} from '../../actions/public/watchEvent.js'
import {
  type WatchPendingTransactionsParameters,
  type WatchPendingTransactionsReturnType,
  watchPendingTransactions,
} from '../../actions/public/watchPendingTransactions.js'
import {
  type VerifySiweMessageParameters,
  type VerifySiweMessageReturnType,
  verifySiweMessage,
} from '../../actions/siwe/verifySiweMessage.js'
import {
  type PrepareTransactionRequestParameters,
  type PrepareTransactionRequestRequest,
  type PrepareTransactionRequestReturnType,
  prepareTransactionRequest,
} from '../../actions/wallet/prepareTransactionRequest.js'
import {
  type SendRawTransactionParameters,
  type SendRawTransactionReturnType,
  sendRawTransaction,
} from '../../actions/wallet/sendRawTransaction.js'
import type { Account } from '../../types/account.js'
import type { BlockNumber, BlockTag } from '../../types/block.js'
import type { Chain } from '../../types/chain.js'
import type {
  ContractEventName,
  ContractFunctionArgs,
  ContractFunctionName,
  MaybeAbiEventName,
  MaybeExtractEventArgsFromAbi,
} from '../../types/contract.js'
import type { FeeValuesType } from '../../types/fee.js'
import type { FilterType } from '../../types/filter.js'
import type { Client } from '../createClient.js'
import type { Transport } from '../transports/createTransport.js'

export type PublicActions<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
> = {
  /**
   * Executes a new message call immediately without submitting a transaction to the network.
   *
   * - Docs: https://viem.sh/docs/actions/public/call
   * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)
   *
   * @param args - {@link CallParameters}
   * @returns The call data. {@link CallReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const data = await client.call({
   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
   *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   * })
   */
  call: (parameters: CallParameters<chain>) => Promise<CallReturnType>
  /**
   * Creates an EIP-2930 access list that you can include in a transaction.
   *
   * - Docs: https://viem.sh/docs/actions/public/createAccessList
   * - JSON-RPC Methods: `eth_createAccessList`
   *
   * @param args - {@link CreateAccessListParameters}
   * @returns The call data. {@link CreateAccessListReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const data = await client.createAccessList({
   *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   * })
   */
  createAccessList: (
    parameters: CreateAccessListParameters<chain>,
  ) => Promise<CreateAccessListReturnType>
  /**
   * Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).
   *
   * - Docs: https://viem.sh/docs/actions/public/createBlockFilter
   * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)
   *
   * @returns Filter. {@link CreateBlockFilterReturnType}
   *
   * @example
   * import { createPublicClient, createBlockFilter, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await createBlockFilter(client)
   * // { id: "0x345a6572337856574a76364e457a4366", type: 'block' }
   */
  createBlockFilter: () => Promise<CreateBlockFilterReturnType>
  /**
   * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).
   *
   * - Docs: https://viem.sh/docs/contract/createContractEventFilter
   *
   * @param args - {@link CreateContractEventFilterParameters}
   * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateContractEventFilterReturnType}
   *
   * @example
   * import { createPublicClient, http, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createContractEventFilter({
   *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
   * })
   */
  createContractEventFilter: <
    const abi extends Abi | readonly unknown[],
    eventName extends ContractEventName<abi> | undefined,
    args extends MaybeExtractEventArgsFromAbi<abi, eventName> | undefined,
    strict extends boolean | undefined = undefined,
    fromBlock extends BlockNumber | BlockTag | undefined = undefined,
    toBlock extends BlockNumber | BlockTag | undefined = undefined,
  >(
    args: CreateContractEventFilterParameters<
      abi,
      eventName,
      args,
      strict,
      fromBlock,
      toBlock
    >,
  ) => Promise<
    CreateContractEventFilterReturnType<
      abi,
      eventName,
      args,
      strict,
      fromBlock,
      toBlock
    >
  >
  /**
   * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).
   *
   * - Docs: https://viem.sh/docs/actions/public/createEventFilter
   * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)
   *
   * @param args - {@link CreateEventFilterParameters}
   * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createEventFilter({
   *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
   * })
   */
  createEventFilter: <
    const abiEvent extends AbiEvent | undefined = undefined,
    const abiEvents extends
      | readonly AbiEvent[]
      | readonly unknown[]
      | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,
    strict extends boolean | undefined = undefined,
    fromBlock extends BlockNumber | BlockTag | undefined = undefined,
    toBlock extends BlockNumber | BlockTag | undefined = undefined,
    _EventName extends string | undefined = MaybeAbiEventName<abiEvent>,
    _Args extends
      | MaybeExtractEventArgsFromAbi<abiEvents, _EventName>
      | undefined = undefined,
  >(
    args?:
      | CreateEventFilterParameters<
          abiEvent,
          abiEvents,
          strict,
          fromBlock,
          toBlock,
          _EventName,
          _Args
        >
      | undefined,
  ) => Promise<
    CreateEventFilterReturnType<
      abiEvent,
      abiEvents,
      strict,
      fromBlock,
      toBlock,
      _EventName,
      _Args
    >
  >
  /**
   * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).
   *
   * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter
   * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)
   *
   * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createPendingTransactionFilter()
   * // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' }
   */
  createPendingTransactionFilter: () => Promise<CreatePendingTransactionFilterReturnType>
  /**
   * Estimates the gas required to successfully execute a contract write function call.
   *
   * - Docs: https://viem.sh/docs/contract/estimateContractGas
   *
   * @remarks
   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
   *
   * @param args - {@link EstimateContractGasParameters}
   * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}
   *
   * @example
   * import { createPublicClient, http, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const gas = await client.estimateContractGas({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *   abi: parseAbi(['function mint() public']),
   *   functionName: 'mint',
   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
   * })
   */
  estimateContractGas: <
    chain extends Chain | undefined,
    const abi extends Abi | readonly unknown[],
    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
    args extends ContractFunctionArgs<
      abi,
      'nonpayable' | 'payable',
      functionName
    >,
  >(
    args: EstimateContractGasParameters<abi, functionName, args, chain>,
  ) => Promise<EstimateContractGasReturnType>
  /**
   * Estimates the gas necessary to complete a transaction without submitting it to the network.
   *
   * - Docs: https://viem.sh/docs/actions/public/estimateGas
   * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)
   *
   * @param args - {@link EstimateGasParameters}
   * @returns The gas estimate (in wei). {@link EstimateGasReturnType}
   *
   * @example
   * import { createPublicClient, http, parseEther } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const gasEstimate = await client.estimateGas({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *   value: parseEther('1'),
   * })
   */
  estimateGas: (
    args: EstimateGasParameters<chain>,
  ) => Promise<EstimateGasReturnType>
  /**
   * Returns the balance of an address in wei.
   *
   * - Docs: https://viem.sh/docs/actions/public/getBalance
   * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)
   *
   * @remarks
   * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).
   *
   * ```ts
   * const balance = await getBalance(client, {
   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   blockTag: 'safe'
   * })
   * const balanceAsEther = formatEther(balance)
   * // "6.942"
   * ```
   *
   * @param args - {@link GetBalanceParameters}
   * @returns The balance of the address in wei. {@link GetBalanceReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const balance = await client.getBalance({
   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   * // 10000000000000000000000n (wei)
   */
  getBalance: (args: GetBalanceParameters) => Promise<GetBalanceReturnType>
  /**
   * Returns the base fee per blob gas in wei.
   *
   * - Docs: https://viem.sh/docs/actions/public/getBlobBaseFee
   * - JSON-RPC Methods: [`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blobBaseFee)
   *
   * @param client - Client to use
   * @returns The blob base fee (in wei). {@link GetBlobBaseFeeReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { getBlobBaseFee } from 'viem/public'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const blobBaseFee = await client.getBlobBaseFee()
   */
  getBlobBaseFee: () => Promise<GetBlobBaseFeeReturnType>
  /**
   * Returns information about a block at a block number, hash, or tag.
   *
   * - Docs: https://viem.sh/docs/actions/public/getBlock
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks
   * - JSON-RPC Methods:
   *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.
   *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.
   *
   * @param args - {@link GetBlockParameters}
   * @returns Information about the block. {@link GetBlockReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const block = await client.getBlock()
   */
  getBlock: <
    includeTransactions extends boolean = false,
    blockTag extends BlockTag = 'latest',
  >(
    args?: GetBlockParameters<includeTransactions, blockTag> | undefined,
  ) => Promise<GetBlockReturnType<chain, includeTransactions, blockTag>>
  /**
   * Returns the number of the most recent block seen.
   *
   * - Docs: https://viem.sh/docs/actions/public/getBlockNumber
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks
   * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)
   *
   * @param args - {@link GetBlockNumberParameters}
   * @returns The number of the block. {@link GetBlockNumberReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const blockNumber = await client.getBlockNumber()
   * // 69420n
   */
  getBlockNumber: (
    args?: GetBlockNumberParameters | undefined,
  ) => Promise<GetBlockNumberReturnType>
  /**
   * Returns the number of Transactions at a block number, hash, or tag.
   *
   * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount
   * - JSON-RPC Methods:
   *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.
   *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.
   *
   * @param args - {@link GetBlockTransactionCountParameters}
   * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const count = await client.getBlockTransactionCount()
   */
  getBlockTransactionCount: (
    args?: GetBlockTransactionCountParameters | undefined,
  ) => Promise<GetBlockTransactionCountReturnType>
  /** @deprecated Use `getCode` instead. */
  getBytecode: (args: GetCodeParameters) => Promise<GetCodeReturnType>
  /**
   * Returns the chain ID associated with the current network.
   *
   * - Docs: https://viem.sh/docs/actions/public/getChainId
   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)
   *
   * @returns The current chain ID. {@link GetChainIdReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const chainId = await client.getChainId()
   * // 1
   */
  getChainId: () => Promise<GetChainIdReturnType>
  /**
   * Retrieves the bytecode at an address.
   *
   * - Docs: https://viem.sh/docs/contract/getCode
   * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)
   *
   * @param args - {@link GetBytecodeParameters}
   * @returns The contract's bytecode. {@link GetBytecodeReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const code = await client.getCode({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   * })
   */
  getCode: (args: GetCodeParameters) => Promise<GetCodeReturnType>
  /**
   * Returns a list of event logs emitted by a contract.
   *
   * - Docs: https://viem.sh/docs/actions/public/getContractEvents
   * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
   *
   * @param client - Client to use
   * @param parameters - {@link GetContractEventsParameters}
   * @returns A list of event logs. {@link GetContractEventsReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { wagmiAbi } from './abi'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const logs = await client.getContractEvents(client, {
   *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *  abi: wagmiAbi,
   *  eventName: 'Transfer'
   * })
   */
  getContractEvents: <
    const abi extends Abi | readonly unknown[],
    eventName extends ContractEventName<abi> | undefined = undefined,
    strict extends boolean | undefined = undefined,
    fromBlock extends BlockNumber | BlockTag | undefined = undefined,
    toBlock extends BlockNumber | BlockTag | undefined = undefined,
  >(
    args: GetContractEventsParameters<
      abi,
      eventName,
      strict,
      fromBlock,
      toBlock
    >,
  ) => Promise<
    GetContractEventsReturnType<abi, eventName, strict, fromBlock, toBlock>
  >
  /**
   * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.
   *
   * @param client - A {@link Client} instance.
   * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}
   * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}
   *
   * @example
   * ```ts
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const domain = await client.getEip712Domain({
   *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
   * })
   * // {
   * //   domain: {
   * //     name: 'ExampleContract',
   * //     version: '1',
   * //     chainId: 1,
   * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
   * //   },
   * //   fields: '0x0f',
   * //   extensions: [],
   * // }
   * ```
   */
  getEip712Domain: (
    args: GetEip712DomainParameters,
  ) => Promise<GetEip712DomainReturnType>
  /**
   * Gets address for ENS name.
   *
   * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
   *
   * @remarks
   * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
   *
   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
   *
   * @param args - {@link GetEnsAddressParameters}
   * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { normalize } from 'viem/ens'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const ensAddress = await client.getEnsAddress({
   *   name: normalize('wevm.eth'),
   * })
   * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'
   */
  getEnsAddress: (
    args: GetEnsAddressParameters,
  ) => Promise<GetEnsAddressReturnType>
  /**
   * Gets the avatar of an ENS name.
   *
   * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
   *
   * @remarks
   * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.
   *
   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
   *
   * @param args - {@link GetEnsAvatarParameters}
   * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { normalize } from 'viem/ens'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const ensAvatar = await client.getEnsAvatar({
   *   name: normalize('wevm.eth'),
   * })
   * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'
   */
  getEnsAvatar: (
    args: GetEnsAvatarParameters,
  ) => Promise<GetEnsAvatarReturnType>
  /**
   * Gets primary name for specified address.
   *
   * - Docs: https://viem.sh/docs/ens/actions/getEnsName
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
   *
   * @remarks
   * Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name.
   *
   * @param args - {@link GetEnsNameParameters}
   * @returns Name or `null` if not found. {@link GetEnsNameReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const ensName = await client.getEnsName({
   *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
   * })
   * // 'wevm.eth'
   */
  getEnsName: (args: GetEnsNameParameters) => Promise<GetEnsNameReturnType>
  /**
   * Gets resolver for ENS name.
   *
   * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
   *
   * @remarks
   * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.
   *
   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
   *
   * @param args - {@link GetEnsResolverParameters}
   * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { normalize } from 'viem/ens'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const resolverAddress = await client.getEnsResolver({
   *   name: normalize('wevm.eth'),
   * })
   * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'
   */
  getEnsResolver: (
    args: GetEnsResolverParameters,
  ) => Promise<GetEnsResolverReturnType>
  /**
   * Gets a text record for specified ENS name.
   *
   * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
   *
   * @remarks
   * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
   *
   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
   *
   * @param args - {@link GetEnsTextParameters}
   * @returns Address for ENS resolver. {@link GetEnsTextReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { normalize } from 'viem/ens'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const twitterRecord = await client.getEnsText({
   *   name: normalize('wevm.eth'),
   *   key: 'com.twitter',
   * })
   * // 'wevm_dev'
   */
  getEnsText: (args: GetEnsTextParameters) => Promise<GetEnsTextReturnType>
  /**
   * Returns a collection of historical gas information.
   *
   * - Docs: https://viem.sh/docs/actions/public/getFeeHistory
   * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)
   *
   * @param args - {@link GetFeeHistoryParameters}
   * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const feeHistory = await client.getFeeHistory({
   *   blockCount: 4,
   *   rewardPercentiles: [25, 75],
   * })
   */
  getFeeHistory: (
    args: GetFeeHistoryParameters,
  ) => Promise<GetFeeHistoryReturnType>
  /**
   * Returns an estimate for the fees per gas for a transaction to be included
   * in the next block.
   *
   * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas
   *
   * @param client - Client to use
   * @param parameters - {@link EstimateFeesPerGasParameters}
   * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const maxPriorityFeePerGas = await client.estimateFeesPerGas()
   * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }
   */
  estimateFeesPerGas: <
    chainOverride extends Chain | undefined = undefined,
    type extends FeeValuesType = 'eip1559',
  >(
    args?: EstimateFeesPerGasParameters<chain, chainOverride, type> | undefined,
  ) => Promise<EstimateFeesPerGasReturnType<type>>
  /**
   * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.
   *
   * - Docs: https://viem.sh/docs/actions/public/getFilterChanges
   * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)
   *
   * @remarks
   * A Filter can be created from the following actions:
   *
   * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)
   * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter)
   * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)
   * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)
   *
   * Depending on the type of filter, the return value will be different:
   *
   * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.
   * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.
   * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.
   *
   * @param args - {@link GetFilterChangesParameters}
   * @returns Logs or hashes. {@link GetFilterChangesReturnType}
   *
   * @example
   * // Blocks
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createBlockFilter()
   * const hashes = await client.getFilterChanges({ filter })
   *
   * @example
   * // Contract Events
   * import { createPublicClient, http, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createContractEventFilter({
   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
   *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
   *   eventName: 'Transfer',
   * })
   * const logs = await client.getFilterChanges({ filter })
   *
   * @example
   * // Raw Events
   * import { createPublicClient, http, parseAbiItem } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createEventFilter({
   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
   *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
   * })
   * const logs = await client.getFilterChanges({ filter })
   *
   * @example
   * // Transactions
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createPendingTransactionFilter()
   * const hashes = await client.getFilterChanges({ filter })
   */
  getFilterChanges: <
    filterType extends FilterType,
    const abi extends Abi | readonly unknown[] | undefined,
    eventName extends string | undefined,
    strict extends boolean | undefined = undefined,
    fromBlock extends BlockNumber | BlockTag | undefined = undefined,
    toBlock extends BlockNumber | BlockTag | undefined = undefined,
  >(
    args: GetFilterChangesParameters<
      filterType,
      abi,
      eventName,
      strict,
      fromBlock,
      toBlock
    >,
  ) => Promise<
    GetFilterChangesReturnType<
      filterType,
      abi,
      eventName,
      strict,
      fromBlock,
      toBlock
    >
  >
  /**
   * Returns a list of event logs since the filter was created.
   *
   * - Docs: https://viem.sh/docs/actions/public/getFilterLogs
   * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)
   *
   * @remarks
   * `getFilterLogs` is only compatible with **event filters**.
   *
   * @param args - {@link GetFilterLogsParameters}
   * @returns A list of event logs. {@link GetFilterLogsReturnType}
   *
   * @example
   * import { createPublicClient, http, parseAbiItem } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const filter = await client.createEventFilter({
   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
   *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
   * })
   * const logs = await client.getFilterLogs({ filter })
   */
  getFilterLogs: <
    const abi extends Abi | readonly unknown[] | undefined,
    eventName extends string | undefined,
    strict extends boolean | undefined = undefined,
    fromBlock extends BlockNumber | BlockTag | undefined = undefined,
    toBlock extends BlockNumber | BlockTag | undefined = undefined,
  >(
    args: GetFilterLogsParameters<abi, eventName, strict, fromBlock, toBlock>,
  ) => Promise<
    GetFilterLogsReturnType<abi, eventName, strict, fromBlock, toBlock>
  >
  /**
   * Returns the current price of gas (in wei).
   *
   * - Docs: https://viem.sh/docs/actions/public/getGasPrice
   * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)
   *
   * @returns The gas price (in wei). {@link GetGasPriceReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const gasPrice = await client.getGasPrice()
   */
  getGasPrice: () => Promise<GetGasPriceReturnType>
  /**
   * Returns a list of event logs matching the provided parameters.
   *
   * - Docs: https://viem.sh/docs/actions/public/getLogs
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs
   * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
   *
   * @param args - {@link GetLogsParameters}
   * @returns A list of event logs. {@link GetLogsReturnType}
   *
   * @example
   * import { createPublicClient, http, parseAbiItem } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const logs = await client.getLogs()
   */
  getLogs: <
    const abiEvent extends AbiEvent | undefined = undefined,
    const abiEvents extends
      | readonly AbiEvent[]
      | readonly unknown[]
      | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,
    strict extends boolean | undefined = undefined,
    fromBlock extends BlockNumber | BlockTag | undefined = undefined,
    toBlock extends BlockNumber | BlockTag | undefined = undefined,
  >(
    args?:
      | GetLogsParameters<abiEvent, abiEvents, strict, fromBlock, toBlock>
      | undefined,
  ) => Promise<
    GetLogsReturnType<abiEvent, abiEvents, strict, fromBlock, toBlock>
  >
  /**
   * Returns the account and storage values of the specified account including the Merkle-proof.
   *
   * - Docs: https://viem.sh/docs/actions/public/getProof
   * - JSON-RPC Methods:
   *   - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)
   *
   * @param client - Client to use
   * @param parameters - {@link GetProofParameters}
   * @returns Proof data. {@link GetProofReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const block = await client.getProof({
   *  address: '0x...',
   *  storageKeys: ['0x...'],
   * })
   */
  getProof: (args: GetProofParameters) => Promise<GetProofReturnType>
  /**
   * Returns an estimate for the max priority fee per gas (in wei) for a transaction
   * to be included in the next block.
   *
   * - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas
   *
   * @param client - Client to use
   * @returns An estimate (in wei) for the max priority fee per gas. {@link EstimateMaxPriorityFeePerGasReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas()
   * // 10000000n
   */
  estimateMaxPriorityFeePerGas: <
    chainOverride extends Chain | undefined = undefined,
  >(
    args?:
      | EstimateMaxPriorityFeePerGasParameters<chain, chainOverride>
      | undefined,
  ) => Promise<EstimateMaxPriorityFeePerGasReturnType>
  /**
   * Returns the value from a storage slot at a given address.
   *
   * - Docs: https://viem.sh/docs/contract/getStorageAt
   * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)
   *
   * @param args - {@link GetStorageAtParameters}
   * @returns The value of the storage slot. {@link GetStorageAtReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { getStorageAt } from 'viem/contract'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const code = await client.getStorageAt({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *   slot: toHex(0),
   * })
   */
  getStorageAt: (
    args: GetStorageAtParameters,
  ) => Promise<GetStorageAtReturnType>
  /**
   * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms#transaction) given a hash or block identifier.
   *
   * - Docs: https://viem.sh/docs/actions/public/getTransaction
   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions
   * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)
   *
   * @param args - {@link GetTransactionParameters}
   * @returns The transaction information. {@link GetTransactionReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const transaction = await client.getTransaction({
   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
   * })
   */
  getTransaction: <blockTag extends BlockTag = 'latest'>(
    args: GetTransactionParameters<blockTag>,
  ) => Promise<GetTransactionReturnType<chain, blockTag>>
  /**
   * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.
   *
   * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations
   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions
   * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)
   *
   * @param args - {@link GetTransactionConfirmationsParameters}
   * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const confirmations = await client.getTransactionConfirmations({
   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
   * })
   */
  getTransactionConfirmations: (
    args: GetTransactionConfirmationsParameters<chain>,
  ) => Promise<GetTransactionConfirmationsReturnType>
  /**
   * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has broadcast / sent.
   *
   * - Docs: https://viem.sh/docs/actions/public/getTransactionCount
   * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)
   *
   * @param args - {@link GetTransactionCountParameters}
   * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const transactionCount = await client.getTransactionCount({
   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   */
  getTransactionCount: (
    args: GetTransactionCountParameters,
  ) => Promise<GetTransactionCountReturnType>
  /**
   * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash.
   *
   * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt
   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions
   * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt)
   *
   * @param args - {@link GetTransactionReceiptParameters}
   * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const transactionReceipt = await client.getTransactionReceipt({
   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
   * })
   */
  getTransactionReceipt: (
    args: GetTransactionReceiptParameters,
  ) => Promise<GetTransactionReceiptReturnType<chain>>
  /**
   * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).
   *
   * - Docs: https://viem.sh/docs/contract/multicall
   *
   * @param args - {@link MulticallParameters}
   * @returns An array of results with accompanying status. {@link MulticallReturnType}
   *
   * @example
   * import { createPublicClient, http, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const abi = parseAbi([
   *   'function balanceOf(address) view returns (uint256)',
   *   'function totalSupply() view returns (uint256)',
   * ])
   * const result = await client.multicall({
   *   contracts: [
   *     {
   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *       abi,
   *       functionName: 'balanceOf',
   *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
   *     },
   *     {
   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *       abi,
   *       functionName: 'totalSupply',
   *     },
   *   ],
   * })
   * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]
   */
  multicall: <
    const contracts extends readonly unknown[],
    allowFailure extends boolean = true,
  >(
    args: MulticallParameters<contracts, allowFailure>,
  ) => Promise<MulticallReturnType<contracts, allowFailure>>
  /**
   * Prepares a transaction request for signing.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest
   *
   * @param args - {@link PrepareTransactionRequestParameters}
   * @returns The transaction request. {@link PrepareTransactionRequestReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const request = await client.prepareTransactionRequest({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   to: '0x0000000000000000000000000000000000000000',
   *   value: 1n,
   * })
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const request = await client.prepareTransactionRequest({
   *   to: '0x0000000000000000000000000000000000000000',
   *   value: 1n,
   * })
   */
  prepareTransactionRequest: <
    const request extends PrepareTransactionRequestRequest<
      chain,
      chainOverride
    >,
    chainOverride extends Chain | undefined = undefined,
    accountOverride extends Account | Address | undefined = undefined,
  >(
    args: PrepareTransactionRequestParameters<
      chain,
      account,
      chainOverride,
      accountOverride,
      request
    >,
  ) => Promise<
    PrepareTransactionRequestReturnType<
      chain,
      account,
      chainOverride,
      accountOverride,
      request
    >
  >
  /**
   * Calls a read-only function on a contract, and returns the response.
   *
   * - Docs: https://viem.sh/docs/contract/readContract
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts
   *
   * @remarks
   * A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.
   *
   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
   *
   * @param args - {@link ReadContractParameters}
   * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}
   *
   * @example
   * import { createPublicClient, http, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { readContract } from 'viem/contract'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const result = await client.readContract({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
   *   functionName: 'balanceOf',
   *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
   * })
   * // 424122n
   */
  readContract: <
    const abi extends Abi | readonly unknown[],
    functionName extends ContractFunctionName<abi, 'pure' | 'view'>,
    const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,
  >(
    args: ReadContractParameters<abi, functionName, args>,
  ) => Promise<ReadContractReturnType<abi, functionName, args>>
  /**
   * Sends a **signed** transaction to the network
   *
   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction
   * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)
   *
   * @param client - Client to use
   * @param parameters - {@link SendRawTransactionParameters}
   * @returns The transaction hash. {@link SendRawTransactionReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { sendRawTransaction } from 'viem/wallet'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   *
   * const hash = await client.sendRawTransaction({
   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'
   * })
   */
  sendRawTransaction: (
    args: SendRawTransactionParameters,
  ) => Promise<SendRawTransactionReturnType>
  /**
   * @deprecated Use `simulateBlocks` instead.
   */
  simulate: <const calls extends readonly unknown[]>(
    args: SimulateBlocksParameters<calls>,
  ) => Promise<SimulateBlocksReturnType<calls>>
  /**
   * Simulates a set of calls on block(s) with optional block and state overrides.
   *
   * @example
   * ```ts
   * import { createPublicClient, http, parseEther } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const result = await client.simulateBlocks({
   *   blocks: [{
   *     blockOverrides: {
   *       number: 69420n,
   *     },
   *     calls: [{
   *       {
   *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
   *         data: '0xdeadbeef',
   *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *       },
   *       {
   *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
   *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *         value: parseEther('1'),
   *       },
   *     }],
   *     stateOverrides: [{
   *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
   *       balance: parseEther('10'),
   *     }],
   *   }]
   * })
   * ```
   *
   * @param client - Client to use.
   * @param parameters - {@link SimulateParameters}
   * @returns Simulated blocks. {@link SimulateReturnType}
   */
  simulateBlocks: <const calls extends readonly unknown[]>(
    args: SimulateBlocksParameters<calls>,
  ) => Promise<SimulateBlocksReturnType<calls>>
  /**
   * Simulates a set of calls.
   *
   * @example
   * ```ts
   * import { createPublicClient, http, parseEther } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const result = await client.simulateCalls({
   *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
   *   calls: [{
   *     {
   *       data: '0xdeadbeef',
   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *     },
   *     {
   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *       value: parseEther('1'),
   *     },
   *   ]
   * })
   * ```
   *
   * @param client - Client to use.
   * @param parameters - {@link SimulateCallsParameters}
   * @returns Results. {@link SimulateCallsReturnType}
   */
  simulateCalls: <const calls extends readonly unknown[]>(
    args: SimulateCallsParameters<calls>,
  ) => Promise<SimulateCallsReturnType<calls>>
  /**
   * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.
   *
   * - Docs: https://viem.sh/docs/contract/simulateContract
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts
   *
   * @remarks
   * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.
   *
   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
   *
   * @param args - {@link SimulateContractParameters}
   * @returns The simulation result and write request. {@link SimulateContractReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const result = await client.simulateContract({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),
   *   functionName: 'mint',
   *   args: ['69420'],
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   */
  simulateContract: <
    const abi extends Abi | readonly unknown[],
    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,
    const args extends ContractFunctionArgs<
      abi,
      'nonpayable' | 'payable',
      functionName
    >,
    chainOverride extends Chain | undefined,
    accountOverride extends Account | Address | undefined = undefined,
  >(
    args: SimulateContractParameters<
      abi,
      functionName,
      args,
      chain,
      chainOverride,
      accountOverride
    >,
  ) => Promise<
    SimulateContractReturnType<
      abi,
      functionName,
      args,
      chain,
      account,
      chainOverride,
      accountOverride
    >
  >
  /**
   * Verify that a message was signed by the provided address.
   *
   * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).
   *
   * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage}
   *
   * @param parameters - {@link VerifyMessageParameters}
   * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
   */
  verifyMessage: (
    args: VerifyMessageParameters,
  ) => Promise<VerifyMessageReturnType>
  /**
   * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.
   *
   * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).
   *
   * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}
   *
   * @param parameters - {@link VerifySiweMessageParameters}
   * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}
   */
  verifySiweMessage: (
    args: VerifySiweMessageParameters,
  ) => Promise<VerifySiweMessageReturnType>
  /**
   * Verify that typed data was signed by the provided address.
   *
   * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData}
   *
   * @param parameters - {@link VerifyTypedDataParameters}
   * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}
   */
  verifyTypedData: (
    args: VerifyTypedDataParameters,
  ) => Promise<VerifyTypedDataReturnType>
  /**
   * Destroys a Filter that was created from one of the following Actions:
   *
   * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)
   * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)
   * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)
   *
   * - Docs: https://viem.sh/docs/actions/public/uninstallFilter
   * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)
   *
   * @param args - {@link UninstallFilterParameters}
   * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'
   *
   * const filter = await client.createPendingTransactionFilter()
   * const uninstalled = await client.uninstallFilter({ filter })
   * // true
   */
  uninstallFilter: (
    args: UninstallFilterParameters,
  ) => Promise<UninstallFilterReturnType>
  /**
   * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt). If the Transaction reverts, then the action will throw an error.
   *
   * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt
   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions
   * - JSON-RPC Methods:
   *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.
   *   - If a Transaction has been replaced:
   *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions
   *     - Checks if one of the Transactions is a replacement
   *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).
   *
   * @remarks
   * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).
   *
   * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.
   *
   * There are 3 types of Transaction Replacement reasons:
   *
   * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)
   * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)
   * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)
   *
   * @param args - {@link WaitForTransactionReceiptParameters}
   * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const transactionReceipt = await client.waitForTransactionReceipt({
   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
   * })
   */
  waitForTransactionReceipt: (
    args: WaitForTransactionReceiptParameters<chain>,
  ) => Promise<WaitForTransactionReceiptReturnType<chain>>
  /**
   * Watches and returns incoming block numbers.
   *
   * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks
   * - JSON-RPC Methods:
   *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.
   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
   *
   * @param args - {@link WatchBlockNumberParameters}
   * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const unwatch = await client.watchBlockNumber({
   *   onBlockNumber: (blockNumber) => console.log(blockNumber),
   * })
   */
  watchBlockNumber: (
    args: WatchBlockNumberParameters,
  ) => WatchBlockNumberReturnType
  /**
   * Watches and returns information for incoming blocks.
   *
   * - Docs: https://viem.sh/docs/actions/public/watchBlocks
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks
   * - JSON-RPC Methods:
   *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.
   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
   *
   * @param args - {@link WatchBlocksParameters}
   * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const unwatch = await client.watchBlocks({
   *   onBlock: (block) => console.log(block),
   * })
   */
  watchBlocks: <
    includeTransactions extends boolean = false,
    blockTag extends BlockTag = 'latest',
  >(
    args: WatchBlocksParameters<
      transport,
      chain,
      includeTransactions,
      blockTag
    >,
  ) => WatchBlocksReturnType
  /**
   * Watches and returns emitted contract event logs.
   *
   * - Docs: https://viem.sh/docs/contract/watchContractEvent
   *
   * @remarks
   * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).
   *
   * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.
   *
   * @param args - {@link WatchContractEventParameters}
   * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}
   *
   * @example
   * import { createPublicClient, http, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const unwatch = client.watchContractEvent({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),
   *   eventName: 'Transfer',
   *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },
   *   onLogs: (logs) => console.log(logs),
   * })
   */
  watchContractEvent: <
    const abi extends Abi | readonly unknown[],
    eventName extends ContractEventName<abi>,
    strict extends boolean | undefined = undefined,
  >(
    args: WatchContractEventParameters<abi, eventName, strict, transport>,
  ) => WatchContractEventReturnType
  /**
   * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).
   *
   * - Docs: https://viem.sh/docs/actions/public/watchEvent
   * - JSON-RPC Methods:
   *   - **RPC Provider supports `eth_newFilter`:**
   *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).
   *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).
   *   - **RPC Provider does not support `eth_newFilter`:**
   *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.
   *
   * @remarks
   * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).
   *
   * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.
   *
   * @param args - {@link WatchEventParameters}
   * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const unwatch = client.watchEvent({
   *   onLogs: (logs) => console.log(logs),
   * })
   */
  watchEvent: <
    const abiEvent extends AbiEvent | undefined = undefined,
    const abiEvents extends
      | readonly AbiEvent[]
      | readonly unknown[]
      | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,
    strict extends boolean | undefined = undefined,
  >(
    args: WatchEventParameters<abiEvent, abiEvents, strict, transport>,
  ) => WatchEventReturnType
  /**
   * Watches and returns pending transaction hashes.
   *
   * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions
   * - JSON-RPC Methods:
   *   - When `poll: true`
   *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.
   *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.
   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event.
   *
   * @remarks
   * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions#ontransactions).
   *
   * @param args - {@link WatchPendingTransactionsParameters}
   * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}
   *
   * @example
   * import { createPublicClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createPublicClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const unwatch = await client.watchPendingTransactions({
   *   onTransactions: (hashes) => console.log(hashes),
   * })
   */
  watchPendingTransactions: (
    args: WatchPendingTransactionsParameters<transport>,
  ) => WatchPendingTransactionsReturnType
}

export function publicActions<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>(
  client: Client<transport, chain, account>,
): PublicActions<transport, chain, account> {
  return {
    call: (args) => call(client, args),
    createAccessList: (args) => createAccessList(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) =>
      createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () =>
      createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args as any),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlobBaseFee: () => getBlobBaseFee(client),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getCode(client, args),
    getChainId: () => getChainId(client),
    getCode: (args) => getCode(client, args),
    getContractEvents: (args) => getContractEvents(client, args),
    getEip712Domain: (args) => getEip712Domain(client, args),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args as any),
    getProof: (args) => getProof(client, args),
    estimateMaxPriorityFeePerGas: (args) =>
      estimateMaxPriorityFeePerGas(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) =>
      getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    prepareTransactionRequest: (args) =>
      prepareTransactionRequest(client as any, args as any) as any,
    readContract: (args) => readContract(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    simulate: (args) => simulateBlocks(client, args),
    simulateBlocks: (args) => simulateBlocks(client, args),
    simulateCalls: (args) => simulateCalls(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage(client, args),
    verifySiweMessage: (args) => verifySiweMessage(client, args),
    verifyTypedData: (args) => verifyTypedData(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) =>
      waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args),
  }
}
</file>

<file path="src/clients/decorators/test.ts">
import {
  type DropTransactionParameters,
  dropTransaction,
} from '../../actions/test/dropTransaction.js'
import {
  type DumpStateReturnType,
  dumpState,
} from '../../actions/test/dumpState.js'
import {
  type GetAutomineReturnType,
  getAutomine,
} from '../../actions/test/getAutomine.js'
import {
  type GetTxpoolContentReturnType,
  getTxpoolContent,
} from '../../actions/test/getTxpoolContent.js'
import {
  type GetTxpoolStatusReturnType,
  getTxpoolStatus,
} from '../../actions/test/getTxpoolStatus.js'
import {
  type ImpersonateAccountParameters,
  impersonateAccount,
} from '../../actions/test/impersonateAccount.js'
import {
  type IncreaseTimeParameters,
  increaseTime,
} from '../../actions/test/increaseTime.js'
import {
  type InspectTxpoolReturnType,
  inspectTxpool,
} from '../../actions/test/inspectTxpool.js'
import {
  type LoadStateParameters,
  type LoadStateReturnType,
  loadState,
} from '../../actions/test/loadState.js'
import { type MineParameters, mine } from '../../actions/test/mine.js'
import { removeBlockTimestampInterval } from '../../actions/test/removeBlockTimestampInterval.js'
import { type ResetParameters, reset } from '../../actions/test/reset.js'
import { type RevertParameters, revert } from '../../actions/test/revert.js'
import {
  type SendUnsignedTransactionParameters,
  type SendUnsignedTransactionReturnType,
  sendUnsignedTransaction,
} from '../../actions/test/sendUnsignedTransaction.js'
import { setAutomine } from '../../actions/test/setAutomine.js'
import {
  type SetBalanceParameters,
  setBalance,
} from '../../actions/test/setBalance.js'
import {
  type SetBlockGasLimitParameters,
  setBlockGasLimit,
} from '../../actions/test/setBlockGasLimit.js'
import {
  type SetBlockTimestampIntervalParameters,
  setBlockTimestampInterval,
} from '../../actions/test/setBlockTimestampInterval.js'
import { type SetCodeParameters, setCode } from '../../actions/test/setCode.js'
import {
  type SetCoinbaseParameters,
  setCoinbase,
} from '../../actions/test/setCoinbase.js'
import {
  type SetIntervalMiningParameters,
  setIntervalMining,
} from '../../actions/test/setIntervalMining.js'
import { setLoggingEnabled } from '../../actions/test/setLoggingEnabled.js'
import {
  type SetMinGasPriceParameters,
  setMinGasPrice,
} from '../../actions/test/setMinGasPrice.js'
import {
  type SetNextBlockBaseFeePerGasParameters,
  setNextBlockBaseFeePerGas,
} from '../../actions/test/setNextBlockBaseFeePerGas.js'
import {
  type SetNextBlockTimestampParameters,
  setNextBlockTimestamp,
} from '../../actions/test/setNextBlockTimestamp.js'
import {
  type SetNonceParameters,
  setNonce,
} from '../../actions/test/setNonce.js'
import { setRpcUrl } from '../../actions/test/setRpcUrl.js'
import {
  type SetStorageAtParameters,
  setStorageAt,
} from '../../actions/test/setStorageAt.js'
import { snapshot } from '../../actions/test/snapshot.js'
import {
  type StopImpersonatingAccountParameters,
  stopImpersonatingAccount,
} from '../../actions/test/stopImpersonatingAccount.js'
import type { Account } from '../../types/account.js'
import type { Chain } from '../../types/chain.js'
import type { Quantity } from '../../types/rpc.js'
import type { Client } from '../createClient.js'
import type { TestClientMode } from '../createTestClient.js'
import type { Transport } from '../transports/createTransport.js'

export type TestActions = {
  /**
   * Removes a transaction from the mempool.
   *
   * - Docs: https://viem.sh/docs/actions/test/dropTransaction
   *
   * @param args - {@link DropTransactionParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.dropTransaction({
   *   hash: '0xe58dceb6b20b03965bb678e27d141e151d7d4efc2334c2d6a49b9fac523f7364'
   * })
   */
  dropTransaction: (args: DropTransactionParameters) => Promise<void>
  /**
   * Serializes the current state (including contracts code, contract's storage,
   * accounts properties, etc.) into a savable data blob.
   *
   * - Docs: https://viem.sh/docs/actions/test/dumpState
   *
   * @param client - Client to use
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.dumpState()
   */
  dumpState: () => Promise<DumpStateReturnType>
  /**
   * Returns the automatic mining status of the node.
   *
   * - Docs: https://viem.sh/docs/actions/test/getAutomine
   *
   * @returns Whether or not the node is auto mining. {@link GetAutomineReturnType}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * const isAutomining = await client.getAutomine()
   */
  getAutomine: () => Promise<GetAutomineReturnType>
  /**
   * Returns the details of all transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
   *
   * - Docs: https://viem.sh/docs/actions/test/getTxpoolContent
   *
   * @returns Transaction pool content. {@link GetTxpoolContentReturnType}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * const content = await client.getTxpoolContent()
   */
  getTxpoolContent: () => Promise<GetTxpoolContentReturnType>
  /**
   * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
   *
   * - Docs: https://viem.sh/docs/actions/test/getTxpoolStatus
   *
   * @returns Transaction pool status. {@link GetTxpoolStatusReturnType}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * const status = await client.getTxpoolStatus()
   */
  getTxpoolStatus: () => Promise<GetTxpoolStatusReturnType>
  /**
   * Impersonate an account or contract address. This lets you send transactions from that account even if you don't have access to its private key.
   *
   * - Docs: https://viem.sh/docs/actions/test/impersonateAccount
   *
   * @param args - {@link ImpersonateAccountParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.impersonateAccount({
   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   */
  impersonateAccount: (args: ImpersonateAccountParameters) => Promise<void>
  /**
   * Jump forward in time by the given amount of time, in seconds.
   *
   * - Docs: https://viem.sh/docs/actions/test/increaseTime
   *
   * @param args  {@link IncreaseTimeParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.increaseTime({
   *   seconds: 420,
   * })
   */
  increaseTime: (args: IncreaseTimeParameters) => Promise<Quantity>
  /**
   * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
   *
   * - Docs: https://viem.sh/docs/actions/test/inspectTxpool
   *
   * @returns Transaction pool inspection data. {@link InspectTxpoolReturnType}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * const data = await client.inspectTxpool()
   */
  inspectTxpool: () => Promise<InspectTxpoolReturnType>
  /**
   * Adds state previously dumped with `dumpState` to the current chain.
   *
   * - Docs: https://viem.sh/docs/actions/test/loadState
   *
   * @param client - Client to use
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.loadState({ state: '0x...' })
   */
  loadState: (args: LoadStateParameters) => Promise<LoadStateReturnType>
  /**
   * Mine a specified number of blocks.
   *
   * - Docs: https://viem.sh/docs/actions/test/mine
   *
   * @param client - Client to use
   * @param args  {@link MineParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.mine({ blocks: 1 })
   */
  mine: (args: MineParameters) => Promise<void>
  /**
   * Removes [`setBlockTimestampInterval`](https://viem.sh/docs/actions/test/setBlockTimestampInterval) if it exists.
   *
   * - Docs: https://viem.sh/docs/actions/test/removeBlockTimestampInterval
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   * import { removeBlockTimestampInterval } from 'viem/test'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.removeBlockTimestampInterval()
   */
  removeBlockTimestampInterval: () => Promise<void>
  /**
   * Resets fork back to its original state.
   *
   * - Docs: https://viem.sh/docs/actions/test/reset
   *
   * @param args  {@link ResetParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.reset({ blockNumber: 69420n })
   */
  reset: (args?: ResetParameters | undefined) => Promise<void>
  /**
   * Revert the state of the blockchain at the current block.
   *
   * - Docs: https://viem.sh/docs/actions/test/revert
   *
   * @param args  {@link RevertParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.revert({ id: '0x' })
   */
  revert: (args: RevertParameters) => Promise<void>
  /**
   * Executes a transaction regardless of the signature.
   *
   * - Docs: https://viem.sh/docs/actions/test/sendUnsignedTransaction
   *
   * @param args  {@link SendUnsignedTransactionParameters}
   * @returns The transaction hash. {@link SendUnsignedTransactionReturnType}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * const hash = await client.sendUnsignedTransaction({
   *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *   value: 1000000000000000000n,
   * })
   */
  sendUnsignedTransaction: <chain extends Chain | undefined>(
    args: SendUnsignedTransactionParameters<chain>,
  ) => Promise<SendUnsignedTransactionReturnType>
  /**
   * Enables or disables the automatic mining of new blocks with each new transaction submitted to the network.
   *
   * - Docs: https://viem.sh/docs/actions/test/setAutomine
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setAutomine()
   */
  setAutomine: (args: boolean) => Promise<void>
  /**
   * Modifies the balance of an account.
   *
   * - Docs: https://viem.sh/docs/actions/test/setBalance
   *
   * @param args  {@link SetBalanceParameters}
   *
   * @example
   * import { createTestClient, http, parseEther } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setBalance({
   *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
   *   value: parseEther('1'),
   * })
   */
  setBalance: (args: SetBalanceParameters) => Promise<void>
  /**
   * Sets the block's gas limit.
   *
   * - Docs: https://viem.sh/docs/actions/test/setBlockGasLimit
   *
   * @param args  {@link SetBlockGasLimitParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setBlockGasLimit({ gasLimit: 420_000n })
   */
  setBlockGasLimit: (args: SetBlockGasLimitParameters) => Promise<void>
  /**
   * Similar to [`increaseTime`](https://viem.sh/docs/actions/test/increaseTime), but sets a block timestamp `interval`. The timestamp of future blocks will be computed as `lastBlock_timestamp` + `interval`.
   *
   * - Docs: https://viem.sh/docs/actions/test/setBlockTimestampInterval
   *
   * @param args  {@link SetBlockTimestampIntervalParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setBlockTimestampInterval({ interval: 5 })
   */
  setBlockTimestampInterval: (
    args: SetBlockTimestampIntervalParameters,
  ) => Promise<void>
  /**
   * Modifies the bytecode stored at an account's address.
   *
   * - Docs: https://viem.sh/docs/actions/test/setCode
   *
   * @param args  {@link SetCodeParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setCode({
   *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
   *   bytecode: '0x60806040526000600355600019600955600c80546001600160a01b031916737a250d5630b4cf539739df',
   * })
   */
  setCode: (args: SetCodeParameters) => Promise<void>
  /**
   * Sets the coinbase address to be used in new blocks.
   *
   * - Docs: https://viem.sh/docs/actions/test/setCoinbase
   *
   * @param args  {@link SetCoinbaseParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setCoinbase({
   *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
   * })
   */
  setCoinbase: (args: SetCoinbaseParameters) => Promise<void>
  /**
   * Sets the automatic mining interval (in seconds) of blocks. Setting the interval to 0 will disable automatic mining.
   *
   * - Docs: https://viem.sh/docs/actions/test/setIntervalMining
   *
   * @param args  {@link SetIntervalMiningParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setIntervalMining({ interval: 5 })
   */
  setIntervalMining: (args: SetIntervalMiningParameters) => Promise<void>
  /**
   * Enable or disable logging on the test node network.
   *
   * - Docs: https://viem.sh/docs/actions/test/setLoggingEnabled
   *
   * @param client - Client to use
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setLoggingEnabled()
   */
  setLoggingEnabled: (args: boolean) => Promise<void>
  /**
   * Change the minimum gas price accepted by the network (in wei).
   *
   * - Docs: https://viem.sh/docs/actions/test/setMinGasPrice
   *
   * Note: `setMinGasPrice` can only be used on clients that do not have EIP-1559 enabled.
   *
   * @param args  {@link SetBlockGasLimitParameters}
   *
   * @example
   * import { createTestClient, http, parseGwei } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setMinGasPrice({
   *   gasPrice: parseGwei('20'),
   * })
   */
  setMinGasPrice: (args: SetMinGasPriceParameters) => Promise<void>
  /**
   * Sets the next block's base fee per gas.
   *
   * - Docs: https://viem.sh/docs/actions/test/setNextBlockBaseFeePerGas
   *
   * @param args  {@link SetNextBlockBaseFeePerGasParameters}
   *
   * @example
   * import { createTestClient, http, parseGwei } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setNextBlockBaseFeePerGas({
   *   baseFeePerGas: parseGwei('20'),
   * })
   */
  setNextBlockBaseFeePerGas: (
    args: SetNextBlockBaseFeePerGasParameters,
  ) => Promise<void>
  /**
   * Sets the next block's timestamp.
   *
   * - Docs: https://viem.sh/docs/actions/test/setNextBlockTimestamp
   *
   * @param args  {@link SetNextBlockTimestampParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setNextBlockTimestamp({ timestamp: 1671744314n })
   */
  setNextBlockTimestamp: (
    args: SetNextBlockTimestampParameters,
  ) => Promise<void>
  /**
   * Modifies (overrides) the nonce of an account.
   *
   * - Docs: https://viem.sh/docs/actions/test/setNonce
   *
   * @param args  {@link SetNonceParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setNonce({
   *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
   *   nonce: 420,
   * })
   */
  setNonce: (args: SetNonceParameters) => Promise<void>
  /**
   * Sets the backend RPC URL.
   *
   * - Docs: https://viem.sh/docs/actions/test/setRpcUrl
   *
   * @param jsonRpcUrl  RPC URL
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setRpcUrl('https://eth-mainnet.g.alchemy.com/v2')
   */
  setRpcUrl: (args: string) => Promise<void>
  /**
   * Writes to a slot of an account's storage.
   *
   * - Docs: https://viem.sh/docs/actions/test/setStorageAt
   *
   * @param args  {@link SetStorageAtParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.setStorageAt({
   *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
   *   index: 2,
   *   value: '0x0000000000000000000000000000000000000000000000000000000000000069',
   * })
   */
  setStorageAt: (args: SetStorageAtParameters) => Promise<void>
  /**
   * Snapshot the state of the blockchain at the current block.
   *
   * - Docs: https://viem.sh/docs/actions/test/snapshot
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   * import { snapshot } from 'viem/test'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.snapshot()
   */
  snapshot: () => Promise<Quantity>
  /**
   * Stop impersonating an account after having previously used [`impersonateAccount`](https://viem.sh/docs/actions/test/impersonateAccount).
   *
   * - Docs: https://viem.sh/docs/actions/test/stopImpersonatingAccount
   *
   * @param args  {@link StopImpersonatingAccountParameters}
   *
   * @example
   * import { createTestClient, http } from 'viem'
   * import { foundry } from 'viem/chains'
   * import { stopImpersonatingAccount } from 'viem/test'
   *
   * const client = createTestClient({
   *   mode: 'anvil',
   *   chain: 'foundry',
   *   transport: http(),
   * })
   * await client.stopImpersonatingAccount({
   *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
   * })
   */
  stopImpersonatingAccount: (
    args: StopImpersonatingAccountParameters,
  ) => Promise<void>
}

export function testActions<mode extends TestClientMode>({
  mode,
}: { mode: mode }): <
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>(
  client: Client<transport, chain, account>,
) => TestActions {
  return <
    transport extends Transport = Transport,
    chain extends Chain | undefined = Chain | undefined,
    account extends Account | undefined = Account | undefined,
  >(
    client_: Client<transport, chain, account>,
  ): TestActions => {
    const client = client_.extend(() => ({
      mode,
    }))
    return {
      dropTransaction: (args) => dropTransaction(client, args),
      dumpState: () => dumpState(client),
      getAutomine: () => getAutomine(client),
      getTxpoolContent: () => getTxpoolContent(client),
      getTxpoolStatus: () => getTxpoolStatus(client),
      impersonateAccount: (args) => impersonateAccount(client, args),
      increaseTime: (args) => increaseTime(client, args),
      inspectTxpool: () => inspectTxpool(client),
      loadState: (args) => loadState(client, args),
      mine: (args) => mine(client, args),
      removeBlockTimestampInterval: () => removeBlockTimestampInterval(client),
      reset: (args) => reset(client, args),
      revert: (args) => revert(client, args),
      sendUnsignedTransaction: (args) =>
        sendUnsignedTransaction(client, args as any),
      setAutomine: (args) => setAutomine(client, args),
      setBalance: (args) => setBalance(client, args),
      setBlockGasLimit: (args) => setBlockGasLimit(client, args),
      setBlockTimestampInterval: (args) =>
        setBlockTimestampInterval(client, args),
      setCode: (args) => setCode(client, args),
      setCoinbase: (args) => setCoinbase(client, args),
      setIntervalMining: (args) => setIntervalMining(client, args),
      setLoggingEnabled: (args) => setLoggingEnabled(client, args),
      setMinGasPrice: (args) => setMinGasPrice(client, args),
      setNextBlockBaseFeePerGas: (args) =>
        setNextBlockBaseFeePerGas(client, args),
      setNextBlockTimestamp: (args) => setNextBlockTimestamp(client, args),
      setNonce: (args) => setNonce(client, args),
      setRpcUrl: (args) => setRpcUrl(client, args),
      setStorageAt: (args) => setStorageAt(client, args),
      snapshot: () => snapshot(client),
      stopImpersonatingAccount: (args) =>
        stopImpersonatingAccount(client, args),
    }
  }
}
</file>

<file path="src/clients/decorators/wallet.ts">
import type { Abi, Address, TypedData } from 'abitype'

import type { Account } from '../../accounts/types.js'
import {
  type GetChainIdReturnType,
  getChainId,
} from '../../actions/public/getChainId.js'
import {
  type AddChainParameters,
  addChain,
} from '../../actions/wallet/addChain.js'
import {
  type DeployContractParameters,
  type DeployContractReturnType,
  deployContract,
} from '../../actions/wallet/deployContract.js'
import {
  type GetAddressesReturnType,
  getAddresses,
} from '../../actions/wallet/getAddresses.js'
import {
  type GetCallsStatusParameters,
  type GetCallsStatusReturnType,
  getCallsStatus,
} from '../../actions/wallet/getCallsStatus.js'
import {
  type GetCapabilitiesParameters,
  type GetCapabilitiesReturnType,
  getCapabilities,
} from '../../actions/wallet/getCapabilities.js'
import {
  type GetPermissionsReturnType,
  getPermissions,
} from '../../actions/wallet/getPermissions.js'
import {
  type PrepareAuthorizationParameters,
  type PrepareAuthorizationReturnType,
  prepareAuthorization,
} from '../../actions/wallet/prepareAuthorization.js'
import {
  type PrepareTransactionRequestParameters,
  type PrepareTransactionRequestRequest,
  type PrepareTransactionRequestReturnType,
  prepareTransactionRequest,
} from '../../actions/wallet/prepareTransactionRequest.js'
import {
  type RequestAddressesReturnType,
  requestAddresses,
} from '../../actions/wallet/requestAddresses.js'
import {
  type RequestPermissionsParameters,
  type RequestPermissionsReturnType,
  requestPermissions,
} from '../../actions/wallet/requestPermissions.js'
import {
  type SendCallsParameters,
  type SendCallsReturnType,
  sendCalls,
} from '../../actions/wallet/sendCalls.js'
import {
  type SendRawTransactionParameters,
  type SendRawTransactionReturnType,
  sendRawTransaction,
} from '../../actions/wallet/sendRawTransaction.js'
import {
  type SendTransactionParameters,
  type SendTransactionRequest,
  type SendTransactionReturnType,
  sendTransaction,
} from '../../actions/wallet/sendTransaction.js'
import {
  type ShowCallsStatusParameters,
  type ShowCallsStatusReturnType,
  showCallsStatus,
} from '../../actions/wallet/showCallsStatus.js'
import {
  type SignAuthorizationParameters,
  type SignAuthorizationReturnType,
  signAuthorization,
} from '../../actions/wallet/signAuthorization.js'
import {
  type SignMessageParameters,
  type SignMessageReturnType,
  signMessage,
} from '../../actions/wallet/signMessage.js'
import {
  type SignTransactionParameters,
  type SignTransactionRequest,
  type SignTransactionReturnType,
  signTransaction,
} from '../../actions/wallet/signTransaction.js'
import {
  type SignTypedDataParameters,
  type SignTypedDataReturnType,
  signTypedData,
} from '../../actions/wallet/signTypedData.js'
import {
  type SwitchChainParameters,
  switchChain,
} from '../../actions/wallet/switchChain.js'
import {
  type WaitForCallsStatusParameters,
  type WaitForCallsStatusReturnType,
  waitForCallsStatus,
} from '../../actions/wallet/waitForCallsStatus.js'
import {
  type WatchAssetParameters,
  type WatchAssetReturnType,
  watchAsset,
} from '../../actions/wallet/watchAsset.js'
import {
  type WriteContractParameters,
  type WriteContractReturnType,
  writeContract,
} from '../../actions/wallet/writeContract.js'
import type { Chain } from '../../types/chain.js'
import type {
  ContractFunctionArgs,
  ContractFunctionName,
} from '../../types/contract.js'
import type { Client } from '../createClient.js'
import type { Transport } from '../transports/createTransport.js'

export type WalletActions<
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
> = {
  /**
   * Adds an EVM chain to the wallet.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/addChain
   * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
   *
   * @param args - {@link AddChainParameters}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { optimism } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   transport: custom(window.ethereum),
   * })
   * await client.addChain({ chain: optimism })
   */
  addChain: (args: AddChainParameters) => Promise<void>
  /**
   * Deploys a contract to the network, given bytecode and constructor arguments.
   *
   * - Docs: https://viem.sh/docs/contract/deployContract
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts
   *
   * @param args - {@link DeployContractParameters}
   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}
   *
   * @example
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const hash = await client.deployContract({
   *   abi: [],
   *   account: '0x,
   *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
   * })
   */
  deployContract: <
    const abi extends Abi | readonly unknown[],
    chainOverride extends Chain | undefined,
  >(
    args: DeployContractParameters<abi, chain, account, chainOverride>,
  ) => Promise<DeployContractReturnType>
  /**
   * Returns a list of account addresses owned by the wallet or client.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/getAddresses
   * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)
   *
   * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const accounts = await client.getAddresses()
   */
  getAddresses: () => Promise<GetAddressesReturnType>
  /**
   * Returns the status of a call batch that was sent via `sendCalls`.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus
   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
   *
   * @param client - Client to use
   * @returns Status of the calls. {@link GetCallsStatusReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   *
   * const { receipts, status } = await client.getCallsStatus({ id: '0xdeadbeef' })
   */
  getCallsStatus: (
    parameters: GetCallsStatusParameters,
  ) => Promise<GetCallsStatusReturnType>
  /**
   * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).
   *
   * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities
   * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)
   *
   * @param client - Client to use
   * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   *
   * const capabilities = await client.getCapabilities({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   */
  getCapabilities: <chainId extends number | undefined>(
    parameters?: GetCapabilitiesParameters<chainId>,
  ) => Promise<GetCapabilitiesReturnType<chainId>>
  /**
   * Returns the chain ID associated with the current network.
   *
   * - Docs: https://viem.sh/docs/actions/public/getChainId
   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)
   *
   * @returns The current chain ID. {@link GetChainIdReturnType}
   *
   * @example
   * import { createWalletClient, http } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const chainId = await client.getChainId()
   * // 1
   */
  getChainId: () => Promise<GetChainIdReturnType>
  /**
   * Gets the wallets current permissions.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/getPermissions
   * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
   *
   * @returns The wallet permissions. {@link GetPermissionsReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const permissions = await client.getPermissions()
   */
  getPermissions: () => Promise<GetPermissionsReturnType>
  /**
   * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.
   * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).
   *
   * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.
   *
   * @param client - Client to use
   * @param parameters - {@link PrepareAuthorizationParameters}
   * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}
   *
   * @example
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const authorization = await client.prepareAuthorization({
   *   account: privateKeyToAccount('0x..'),
   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const authorization = await client.prepareAuthorization({
   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   */
  prepareAuthorization: (
    parameters: PrepareAuthorizationParameters<account>,
  ) => Promise<PrepareAuthorizationReturnType>
  /**
   * Prepares a transaction request for signing.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest
   *
   * @param args - {@link PrepareTransactionRequestParameters}
   * @returns The transaction request. {@link PrepareTransactionRequestReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const request = await client.prepareTransactionRequest({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   to: '0x0000000000000000000000000000000000000000',
   *   value: 1n,
   * })
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const request = await client.prepareTransactionRequest({
   *   to: '0x0000000000000000000000000000000000000000',
   *   value: 1n,
   * })
   */
  prepareTransactionRequest: <
    const request extends PrepareTransactionRequestRequest<
      chain,
      chainOverride
    >,
    chainOverride extends Chain | undefined = undefined,
    accountOverride extends Account | Address | undefined = undefined,
  >(
    args: PrepareTransactionRequestParameters<
      chain,
      account,
      chainOverride,
      accountOverride,
      request
    >,
  ) => Promise<
    PrepareTransactionRequestReturnType<
      chain,
      account,
      chainOverride,
      accountOverride,
      request
    >
  >
  /**
   * Requests a list of accounts managed by a wallet.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses
   * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)
   *
   * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).
   *
   * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.
   *
   * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const accounts = await client.requestAddresses()
   */
  requestAddresses: () => Promise<RequestAddressesReturnType>
  /**
   * Requests permissions for a wallet.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions
   * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
   *
   * @param args - {@link RequestPermissionsParameters}
   * @returns The wallet permissions. {@link RequestPermissionsReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const permissions = await client.requestPermissions({
   *   eth_accounts: {}
   * })
   */
  requestPermissions: (
    args: RequestPermissionsParameters,
  ) => Promise<RequestPermissionsReturnType>
  /**
   * Requests the connected wallet to send a batch of calls.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/sendCalls
   * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)
   *
   * @param client - Client to use
   * @returns Transaction identifier. {@link SendCallsReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   *
   * const id = await client.sendCalls({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   calls: [
   *     {
   *       data: '0xdeadbeef',
   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *     },
   *     {
   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *       value: 69420n,
   *     },
   *   ],
   * })
   */
  sendCalls: <
    const calls extends readonly unknown[],
    chainOverride extends Chain | undefined = undefined,
  >(
    parameters: SendCallsParameters<chain, account, chainOverride, calls>,
  ) => Promise<SendCallsReturnType>
  /**
   * Sends a **signed** transaction to the network
   *
   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction
   * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)
   *
   * @param client - Client to use
   * @param parameters - {@link SendRawTransactionParameters}
   * @returns The transaction hash. {@link SendRawTransactionReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   * import { sendRawTransaction } from 'viem/wallet'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   *
   * const hash = await client.sendRawTransaction({
   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'
   * })
   */
  sendRawTransaction: (
    args: SendRawTransactionParameters,
  ) => Promise<SendRawTransactionReturnType>
  /**
   * Creates, signs, and sends a new transaction to the network.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions
   * - JSON-RPC Methods:
   *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)
   *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)
   *
   * @param args - {@link SendTransactionParameters}
   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const hash = await client.sendTransaction({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *   value: 1000000000000000000n,
   * })
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const hash = await client.sendTransaction({
   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
   *   value: 1000000000000000000n,
   * })
   */
  sendTransaction: <
    const request extends SendTransactionRequest<chain, chainOverride>,
    chainOverride extends Chain | undefined = undefined,
  >(
    args: SendTransactionParameters<chain, account, chainOverride, request>,
  ) => Promise<SendTransactionReturnType>
  /**
   * Requests for the wallet to show information about a call batch
   * that was sent via `sendCalls`.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/showCallsStatus
   * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
   *
   * @param client - Client to use
   * @returns Displays status of the calls in wallet. {@link ShowCallsStatusReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   *
   * await client.showCallsStatus({ id: '0xdeadbeef' })
   */
  showCallsStatus: (
    parameters: ShowCallsStatusParameters,
  ) => Promise<ShowCallsStatusReturnType>
  /**
   * Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object.
   *
   * With the calculated signature, you can:
   * - use [`verifyAuthorization`](https://viem.sh/docs/eip7702/verifyAuthorization) to verify the signed Authorization object,
   * - use [`recoverAuthorizationAddress`](https://viem.sh/docs/eip7702/recoverAuthorizationAddress) to recover the signing address from the signed Authorization object.
   *
   * @param client - Client to use
   * @param parameters - {@link SignAuthorizationParameters}
   * @returns The signed Authorization object. {@link SignAuthorizationReturnType}
   *
   * @example
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const signature = await client.signAuthorization({
   *   account: privateKeyToAccount('0x..'),
   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: http(),
   * })
   *
   * const signature = await client.signAuthorization({
   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   * })
   */
  signAuthorization: (
    parameters: SignAuthorizationParameters<account>,
  ) => Promise<SignAuthorizationReturnType>
  /**
   * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/signMessage
   * - JSON-RPC Methods:
   *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)
   *   - Local Accounts: Signs locally. No JSON-RPC request.
   *
   * With the calculated signature, you can:
   * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,
   * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.
   *
   * @param args - {@link SignMessageParameters}
   * @returns The signed message. {@link SignMessageReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const signature = await client.signMessage({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   message: 'hello world',
   * })
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const signature = await client.signMessage({
   *   message: 'hello world',
   * })
   */
  signMessage: (
    args: SignMessageParameters<account>,
  ) => Promise<SignMessageReturnType>
  /**
   * Signs a transaction.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/signTransaction
   * - JSON-RPC Methods:
   *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)
   *   - Local Accounts: Signs locally. No JSON-RPC request.
   *
   * @param args - {@link SignTransactionParameters}
   * @returns The signed message. {@link SignTransactionReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const request = await client.prepareTransactionRequest({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   to: '0x0000000000000000000000000000000000000000',
   *   value: 1n,
   * })
   * const signature = await client.signTransaction(request)
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const request = await client.prepareTransactionRequest({
   *   to: '0x0000000000000000000000000000000000000000',
   *   value: 1n,
   * })
   * const signature = await client.signTransaction(request)
   */
  signTransaction: <
    chainOverride extends Chain | undefined,
    const request extends SignTransactionRequest<
      chain,
      chainOverride
    > = SignTransactionRequest<chain, chainOverride>,
  >(
    args: SignTransactionParameters<chain, account, chainOverride, request>,
  ) => Promise<SignTransactionReturnType<request>>
  /**
   * Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/signTypedData
   * - JSON-RPC Methods:
   *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)
   *   - Local Accounts: Signs locally. No JSON-RPC request.
   *
   * @param client - Client to use
   * @param args - {@link SignTypedDataParameters}
   * @returns The signed data. {@link SignTypedDataReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const signature = await client.signTypedData({
   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
   *   domain: {
   *     name: 'Ether Mail',
   *     version: '1',
   *     chainId: 1,
   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
   *   },
   *   types: {
   *     Person: [
   *       { name: 'name', type: 'string' },
   *       { name: 'wallet', type: 'address' },
   *     ],
   *     Mail: [
   *       { name: 'from', type: 'Person' },
   *       { name: 'to', type: 'Person' },
   *       { name: 'contents', type: 'string' },
   *     ],
   *   },
   *   primaryType: 'Mail',
   *   message: {
   *     from: {
   *       name: 'Cow',
   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
   *     },
   *     to: {
   *       name: 'Bob',
   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
   *     },
   *     contents: 'Hello, Bob!',
   *   },
   * })
   *
   * @example
   * // Account Hoisting
   * import { createWalletClient, http } from 'viem'
   * import { privateKeyToAccount } from 'viem/accounts'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   account: privateKeyToAccount('0x'),
   *   chain: mainnet,
   *   transport: http(),
   * })
   * const signature = await client.signTypedData({
   *   domain: {
   *     name: 'Ether Mail',
   *     version: '1',
   *     chainId: 1,
   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
   *   },
   *   types: {
   *     Person: [
   *       { name: 'name', type: 'string' },
   *       { name: 'wallet', type: 'address' },
   *     ],
   *     Mail: [
   *       { name: 'from', type: 'Person' },
   *       { name: 'to', type: 'Person' },
   *       { name: 'contents', type: 'string' },
   *     ],
   *   },
   *   primaryType: 'Mail',
   *   message: {
   *     from: {
   *       name: 'Cow',
   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
   *     },
   *     to: {
   *       name: 'Bob',
   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
   *     },
   *     contents: 'Hello, Bob!',
   *   },
   * })
   */
  signTypedData: <
    const typedData extends TypedData | { [key: string]: unknown },
    primaryType extends string,
  >(
    args: SignTypedDataParameters<typedData, primaryType, account>,
  ) => Promise<SignTypedDataReturnType>
  /**
   * Switch the target chain in a wallet.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/switchChain
   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)
   *
   * @param args - {@link SwitchChainParameters}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet, optimism } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * await client.switchChain({ id: optimism.id })
   */
  switchChain: (args: SwitchChainParameters) => Promise<void>
  /**
   * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus
   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
   *
   * @param client - Client to use
   * @param parameters - {@link WaitForCallsStatusParameters}
   * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   *
   * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })
   */
  waitForCallsStatus: (
    parameters: WaitForCallsStatusParameters,
  ) => Promise<WaitForCallsStatusReturnType>
  /**
   * Adds an EVM chain to the wallet.
   *
   * - Docs: https://viem.sh/docs/actions/wallet/watchAsset
   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)
   *
   * @param args - {@link WatchAssetParameters}
   * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}
   *
   * @example
   * import { createWalletClient, custom } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const success = await client.watchAsset({
   *   type: 'ERC20',
   *   options: {
   *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
   *     decimals: 18,
   *     symbol: 'WETH',
   *   },
   * })
   */
  watchAsset: (args: WatchAssetParameters) => Promise<WatchAssetReturnType>
  /**
   * Executes a write function on a contract.
   *
   * - Docs: https://viem.sh/docs/contract/writeContract
   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts
   *
   * A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.
   *
   * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
   *
   * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__
   *
   * @param args - {@link WriteContractParameters}
   * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}
   *
   * @example
   * import { createWalletClient, custom, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const hash = await client.writeContract({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
   *   functionName: 'mint',
   *   args: [69420],
   * })
   *
   * @example
   * // With Validation
   * import { createWalletClient, custom, parseAbi } from 'viem'
   * import { mainnet } from 'viem/chains'
   *
   * const client = createWalletClient({
   *   chain: mainnet,
   *   transport: custom(window.ethereum),
   * })
   * const { request } = await client.simulateContract({
   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
   *   functionName: 'mint',
   *   args: [69420],
   * }
   * const hash = await client.writeContract(request)
   */
  writeContract: <
    const abi extends Abi | readonly unknown[],
    functionName extends ContractFunctionName<abi, 'payable' | 'nonpayable'>,
    args extends ContractFunctionArgs<
      abi,
      'payable' | 'nonpayable',
      functionName
    >,
    chainOverride extends Chain | undefined = undefined,
  >(
    args: WriteContractParameters<
      abi,
      functionName,
      args,
      chain,
      account,
      chainOverride
    >,
  ) => Promise<WriteContractReturnType>
}

export function walletActions<
  transport extends Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
>(client: Client<transport, chain, account>): WalletActions<chain, account> {
  return {
    addChain: (args) => addChain(client, args),
    deployContract: (args) => deployContract(client, args),
    getAddresses: () => getAddresses(client),
    getCallsStatus: (args) => getCallsStatus(client, args),
    getCapabilities: (args) => getCapabilities(client, args),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    prepareAuthorization: (args) => prepareAuthorization(client, args),
    prepareTransactionRequest: (args) =>
      prepareTransactionRequest(client as any, args as any) as any,
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args) => requestPermissions(client, args),
    sendCalls: (args) => sendCalls(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    sendTransaction: (args) => sendTransaction(client, args),
    showCallsStatus: (args) => showCallsStatus(client, args),
    signAuthorization: (args) => signAuthorization(client, args),
    signMessage: (args) => signMessage(client, args),
    signTransaction: (args) => signTransaction(client, args),
    signTypedData: (args) => signTypedData(client, args),
    switchChain: (args) => switchChain(client, args),
    waitForCallsStatus: (args) => waitForCallsStatus(client, args),
    watchAsset: (args) => watchAsset(client, args),
    writeContract: (args) => writeContract(client, args as any),
  }
}
</file>

<file path="src/clients/transports/createTransport.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { EIP1193RequestFn } from '../../types/eip1193.js'
import type { OneOf } from '../../types/utils.js'
import { buildRequest } from '../../utils/buildRequest.js'
import { uid as uid_ } from '../../utils/uid.js'
import type { ClientConfig } from '../createClient.js'

export type TransportConfig<
  type extends string = string,
  eip1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,
> = {
  /** The name of the transport. */
  name: string
  /** The key of the transport. */
  key: string
  /** Methods to include or exclude from executing RPC requests. */
  methods?:
    | OneOf<
        | {
            include?: string[] | undefined
          }
        | {
            exclude?: string[] | undefined
          }
      >
    | undefined
  /** The JSON-RPC request function that matches the EIP-1193 request spec. */
  request: eip1193RequestFn
  /** The base delay (in ms) between retries. */
  retryDelay?: number | undefined
  /** The max number of times to retry. */
  retryCount?: number | undefined
  /** The timeout (in ms) for requests. */
  timeout?: number | undefined
  /** The type of the transport. */
  type: type
}

export type Transport<
  type extends string = string,
  rpcAttributes = Record<string, any>,
  eip1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,
> = <chain extends Chain | undefined = Chain>({
  chain,
}: {
  chain?: chain | undefined
  pollingInterval?: ClientConfig['pollingInterval'] | undefined
  retryCount?: TransportConfig['retryCount'] | undefined
  timeout?: TransportConfig['timeout'] | undefined
}) => {
  config: TransportConfig<type>
  request: eip1193RequestFn
  value?: rpcAttributes | undefined
}

export type CreateTransportErrorType = ErrorType

/**
 * @description Creates an transport intended to be used with a client.
 */
export function createTransport<
  type extends string,
  rpcAttributes extends Record<string, any>,
>(
  {
    key,
    methods,
    name,
    request,
    retryCount = 3,
    retryDelay = 150,
    timeout,
    type,
  }: TransportConfig<type>,
  value?: rpcAttributes | undefined,
): ReturnType<Transport<type, rpcAttributes>> {
  const uid = uid_()
  return {
    config: {
      key,
      methods,
      name,
      request,
      retryCount,
      retryDelay,
      timeout,
      type,
    },
    request: buildRequest(request, { methods, retryCount, retryDelay, uid }),
    value,
  }
}
</file>

<file path="src/clients/transports/custom.ts">
import type { ErrorType } from '../../errors/utils.js'
import {
  type CreateTransportErrorType,
  type Transport,
  type TransportConfig,
  createTransport,
} from './createTransport.js'

type EthereumProvider = { request(...args: any): Promise<any> }

export type CustomTransportConfig = {
  /** The key of the transport. */
  key?: TransportConfig['key'] | undefined
  /** Methods to include or exclude from executing RPC requests. */
  methods?: TransportConfig['methods'] | undefined
  /** The name of the transport. */
  name?: TransportConfig['name'] | undefined
  /** The max number of times to retry. */
  retryCount?: TransportConfig['retryCount'] | undefined
  /** The base delay (in ms) between retries. */
  retryDelay?: TransportConfig['retryDelay'] | undefined
}

export type CustomTransport = Transport<
  'custom',
  {},
  EthereumProvider['request']
>

export type CustomTransportErrorType = CreateTransportErrorType | ErrorType

/**
 * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.
 */
export function custom<provider extends EthereumProvider>(
  provider: provider,
  config: CustomTransportConfig = {},
): CustomTransport {
  const {
    key = 'custom',
    methods,
    name = 'Custom Provider',
    retryDelay,
  } = config
  return ({ retryCount: defaultRetryCount }) =>
    createTransport({
      key,
      methods,
      name,
      request: provider.request.bind(provider),
      retryCount: config.retryCount ?? defaultRetryCount,
      retryDelay,
      type: 'custom',
    })
}
</file>

<file path="src/clients/transports/fallback.ts">
import { ExecutionRevertedError } from '../../errors/node.js'
import {
  TransactionRejectedRpcError,
  UserRejectedRequestError,
} from '../../errors/rpc.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import { wait } from '../../utils/wait.js'

import {
  type CreateTransportErrorType,
  type Transport,
  type TransportConfig,
  createTransport,
} from './createTransport.js'
// TODO: Narrow `method` & `params` types.
export type OnResponseFn = (
  args: {
    method: string
    params: unknown[]
    transport: ReturnType<Transport>
  } & (
    | {
        error?: undefined
        response: unknown
        status: 'success'
      }
    | {
        error: Error
        response?: undefined
        status: 'error'
      }
  ),
) => void

type RankOptions = {
  /**
   * The polling interval (in ms) at which the ranker should ping the RPC URL.
   * @default client.pollingInterval
   */
  interval?: number | undefined
  /**
   * Ping method to determine latency.
   */
  ping?: (parameters: { transport: ReturnType<Transport> }) =>
    | Promise<unknown>
    | undefined
  /**
   * The number of previous samples to perform ranking on.
   * @default 10
   */
  sampleCount?: number | undefined
  /**
   * Timeout when sampling transports.
   * @default 1_000
   */
  timeout?: number | undefined
  /**
   * Weights to apply to the scores. Weight values are proportional.
   */
  weights?:
    | {
        /**
         * The weight to apply to the latency score.
         * @default 0.3
         */
        latency?: number | undefined
        /**
         * The weight to apply to the stability score.
         * @default 0.7
         */
        stability?: number | undefined
      }
    | undefined
}

export type FallbackTransportConfig = {
  /** The key of the Fallback transport. */
  key?: TransportConfig['key'] | undefined
  /** The name of the Fallback transport. */
  name?: TransportConfig['name'] | undefined
  /** Toggle to enable ranking, or rank options. */
  rank?: boolean | RankOptions | undefined
  /** The max number of times to retry. */
  retryCount?: TransportConfig['retryCount'] | undefined
  /** The base delay (in ms) between retries. */
  retryDelay?: TransportConfig['retryDelay'] | undefined
  /** Callback on whether an error should throw or try the next transport in the fallback. */
  shouldThrow?: (error: Error) => boolean | undefined
}

export type FallbackTransport<
  transports extends readonly Transport[] = readonly Transport[],
> = Transport<
  'fallback',
  {
    onResponse: (fn: OnResponseFn) => void
    transports: {
      [key in keyof transports]: ReturnType<transports[key]>
    }
  }
>

export type FallbackTransportErrorType = CreateTransportErrorType | ErrorType

export function fallback<const transports extends readonly Transport[]>(
  transports_: transports,
  config: FallbackTransportConfig = {},
): FallbackTransport<transports> {
  const {
    key = 'fallback',
    name = 'Fallback',
    rank = false,
    shouldThrow: shouldThrow_ = shouldThrow,
    retryCount,
    retryDelay,
  } = config
  return (({ chain, pollingInterval = 4_000, timeout, ...rest }) => {
    let transports = transports_

    let onResponse: OnResponseFn = () => {}

    const transport = createTransport(
      {
        key,
        name,
        async request({ method, params }) {
          let includes: boolean | undefined

          const fetch = async (i = 0): Promise<any> => {
            const transport = transports[i]({
              ...rest,
              chain,
              retryCount: 0,
              timeout,
            })
            try {
              const response = await transport.request({
                method,
                params,
              } as any)

              onResponse({
                method,
                params: params as unknown[],
                response,
                transport,
                status: 'success',
              })

              return response
            } catch (err) {
              onResponse({
                error: err as Error,
                method,
                params: params as unknown[],
                transport,
                status: 'error',
              })

              if (shouldThrow_(err as Error)) throw err

              // If we've reached the end of the fallbacks, throw the error.
              if (i === transports.length - 1) throw err

              // Check if at least one other transport includes the method
              includes ??= transports.slice(i + 1).some((transport) => {
                const { include, exclude } =
                  transport({ chain }).config.methods || {}
                if (include) return include.includes(method)
                if (exclude) return !exclude.includes(method)
                return true
              })
              if (!includes) throw err

              // Otherwise, try the next fallback.
              return fetch(i + 1)
            }
          }
          return fetch()
        },
        retryCount,
        retryDelay,
        type: 'fallback',
      },
      {
        onResponse: (fn: OnResponseFn) => (onResponse = fn),
        transports: transports.map((fn) => fn({ chain, retryCount: 0 })),
      },
    )

    if (rank) {
      const rankOptions = (typeof rank === 'object' ? rank : {}) as RankOptions
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_) => (transports = transports_ as transports),
        ping: rankOptions.ping,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights,
      })
    }
    return transport
  }) as FallbackTransport<transports>
}

export function shouldThrow(error: Error) {
  if ('code' in error && typeof error.code === 'number') {
    if (
      error.code === TransactionRejectedRpcError.code ||
      error.code === UserRejectedRequestError.code ||
      ExecutionRevertedError.nodeMessage.test(error.message) ||
      error.code === 5000 // CAIP UserRejectedRequestError
    )
      return true
  }
  return false
}

/** @internal */
export function rankTransports({
  chain,
  interval = 4_000,
  onTransports,
  ping,
  sampleCount = 10,
  timeout = 1_000,
  transports,
  weights = {},
}: {
  chain?: Chain | undefined
  interval: RankOptions['interval']
  onTransports: (transports: readonly Transport[]) => void
  ping?: RankOptions['ping'] | undefined
  sampleCount?: RankOptions['sampleCount'] | undefined
  timeout?: RankOptions['timeout'] | undefined
  transports: readonly Transport[]
  weights?: RankOptions['weights'] | undefined
}) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } =
    weights

  type SampleData = { latency: number; success: number }
  type Sample = SampleData[]
  const samples: Sample[] = []

  const rankTransports_ = async () => {
    // 1. Take a sample from each Transport.
    const sample: Sample = await Promise.all(
      transports.map(async (transport) => {
        const transport_ = transport({ chain, retryCount: 0, timeout })

        const start = Date.now()
        let end: number
        let success: number
        try {
          await (ping
            ? ping({ transport: transport_ })
            : transport_.request({ method: 'net_listening' }))
          success = 1
        } catch {
          success = 0
        } finally {
          end = Date.now()
        }
        const latency = end - start
        return { latency, success }
      }),
    )

    // 2. Store the sample. If we have more than `sampleCount` samples, remove
    // the oldest sample.
    samples.push(sample)
    if (samples.length > sampleCount) samples.shift()

    // 3. Calculate the max latency from samples.
    const maxLatency = Math.max(
      ...samples.map((sample) =>
        Math.max(...sample.map(({ latency }) => latency)),
      ),
    )

    // 4. Calculate the score for each Transport.
    const scores = transports
      .map((_, i) => {
        const latencies = samples.map((sample) => sample[i].latency)
        const meanLatency =
          latencies.reduce((acc, latency) => acc + latency, 0) /
          latencies.length
        const latencyScore = 1 - meanLatency / maxLatency

        const successes = samples.map((sample) => sample[i].success)
        const stabilityScore =
          successes.reduce((acc, success) => acc + success, 0) /
          successes.length

        if (stabilityScore === 0) return [0, i]
        return [
          latencyWeight * latencyScore + stabilityWeight * stabilityScore,
          i,
        ]
      })
      .sort((a, b) => b[0] - a[0])

    // 5. Sort the Transports by score.
    onTransports(scores.map(([, i]) => transports[i]))

    // 6. Wait, and then rank again.
    await wait(interval)
    rankTransports_()
  }
  rankTransports_()
}
</file>

<file path="src/clients/transports/http.ts">
import { RpcRequestError } from '../../errors/request.js'
import {
  UrlRequiredError,
  type UrlRequiredErrorType,
} from '../../errors/transport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { EIP1193RequestFn, RpcSchema } from '../../types/eip1193.js'
import type { RpcRequest } from '../../types/rpc.js'
import { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js'
import {
  type HttpRpcClientOptions,
  getHttpRpcClient,
} from '../../utils/rpc/http.js'

import {
  type CreateTransportErrorType,
  type Transport,
  type TransportConfig,
  createTransport,
} from './createTransport.js'

export type HttpTransportConfig<
  rpcSchema extends RpcSchema | undefined = undefined,
  raw extends boolean = false,
> = {
  /**
   * Whether to enable Batch JSON-RPC.
   * @link https://www.jsonrpc.org/specification#batch
   */
  batch?:
    | boolean
    | {
        /** The maximum number of JSON-RPC requests to send in a batch. @default 1_000 */
        batchSize?: number | undefined
        /** The maximum number of milliseconds to wait before sending a batch. @default 0 */
        wait?: number | undefined
      }
    | undefined
  /**
   * Request configuration to pass to `fetch`.
   * @link https://developer.mozilla.org/en-US/docs/Web/API/fetch
   */
  fetchOptions?: HttpRpcClientOptions['fetchOptions'] | undefined
  /** A callback to handle the response from `fetch`. */
  onFetchRequest?: HttpRpcClientOptions['onRequest'] | undefined
  /** A callback to handle the response from `fetch`. */
  onFetchResponse?: HttpRpcClientOptions['onResponse'] | undefined
  /** The key of the HTTP transport. */
  key?: TransportConfig['key'] | undefined
  /** Methods to include or exclude from executing RPC requests. */
  methods?: TransportConfig['methods'] | undefined
  /** The name of the HTTP transport. */
  name?: TransportConfig['name'] | undefined
  /** Whether to return JSON RPC errors as responses instead of throwing. */
  raw?: raw | boolean | undefined
  /** The max number of times to retry. */
  retryCount?: TransportConfig['retryCount'] | undefined
  /** The base delay (in ms) between retries. */
  retryDelay?: TransportConfig['retryDelay'] | undefined
  /** Typed JSON-RPC schema for the transport. */
  rpcSchema?: rpcSchema | RpcSchema | undefined
  /** The timeout (in ms) for the HTTP request. Default: 10_000 */
  timeout?: TransportConfig['timeout'] | undefined
}

export type HttpTransport<
  rpcSchema extends RpcSchema | undefined = undefined,
  raw extends boolean = false,
> = Transport<
  'http',
  {
    fetchOptions?: HttpTransportConfig['fetchOptions'] | undefined
    url?: string | undefined
  },
  EIP1193RequestFn<rpcSchema, raw>
>

export type HttpTransportErrorType =
  | CreateTransportErrorType
  | UrlRequiredErrorType
  | ErrorType

/**
 * @description Creates a HTTP transport that connects to a JSON-RPC API.
 */
export function http<
  rpcSchema extends RpcSchema | undefined = undefined,
  raw extends boolean = false,
>(
  /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */
  url?: string | undefined,
  config: HttpTransportConfig<rpcSchema, raw> = {},
): HttpTransport<rpcSchema, raw> {
  const {
    batch,
    fetchOptions,
    key = 'http',
    methods,
    name = 'HTTP JSON-RPC',
    onFetchRequest,
    onFetchResponse,
    retryDelay,
    raw,
  } = config
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1000, wait = 0 } =
      typeof batch === 'object' ? batch : {}
    const retryCount = config.retryCount ?? retryCount_
    const timeout = timeout_ ?? config.timeout ?? 10_000
    const url_ = url || chain?.rpcUrls.default.http[0]
    if (!url_) throw new UrlRequiredError()

    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout,
    })

    return createTransport(
      {
        key,
        methods,
        name,
        async request({ method, params }) {
          const body = { method, params }

          const { schedule } = createBatchScheduler({
            id: url_,
            wait,
            shouldSplitBatch(requests) {
              return requests.length > batchSize
            },
            fn: (body: RpcRequest[]) =>
              rpcClient.request({
                body,
              }),
            sort: (a, b) => a.id - b.id,
          })

          const fn = async (body: RpcRequest) =>
            batch
              ? schedule(body)
              : [
                  await rpcClient.request({
                    body,
                  }),
                ]

          const [{ error, result }] = await fn(body)

          if (raw) return { error, result }
          if (error)
            throw new RpcRequestError({
              body,
              error,
              url: url_,
            })
          return result
        },
        retryCount,
        retryDelay,
        timeout,
        type: 'http',
      },
      {
        fetchOptions,
        url: url_,
      },
    )
  }
}
</file>

<file path="src/clients/transports/ipc.ts">
import { RpcRequestError } from '../../errors/request.js'
import type { UrlRequiredErrorType } from '../../errors/transport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Hash } from '../../types/misc.js'
import type { RpcResponse } from '../../types/rpc.js'
import {
  type GetIpcRpcClientOptions,
  type IpcRpcClient,
  getIpcRpcClient,
} from '../../utils/rpc/ipc.js'
import {
  type CreateTransportErrorType,
  type Transport,
  type TransportConfig,
  createTransport,
} from './createTransport.js'

type IpcTransportSubscribeParameters = {
  onData: (data: RpcResponse) => void
  onError?: ((error: any) => void) | undefined
}

type IpcTransportSubscribeReturnType = {
  subscriptionId: Hash
  unsubscribe: () => Promise<RpcResponse<boolean>>
}

type IpcTransportSubscribe = {
  subscribe(
    args: IpcTransportSubscribeParameters & {
      /**
       * @description Add information about compiled contracts
       * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_addcompilationresult
       */
      params: ['newHeads']
    },
  ): Promise<IpcTransportSubscribeReturnType>
}

export type IpcTransportConfig = {
  /** The key of the Ipc transport. */
  key?: TransportConfig['key'] | undefined
  /** Methods to include or exclude from executing RPC requests. */
  methods?: TransportConfig['methods'] | undefined
  /** The name of the Ipc transport. */
  name?: TransportConfig['name'] | undefined
  /**
   * Whether or not to attempt to reconnect on socket failure.
   * @default true
   */
  reconnect?: GetIpcRpcClientOptions['reconnect'] | undefined
  /** The max number of times to retry. */
  retryCount?: TransportConfig['retryCount'] | undefined
  /** The base delay (in ms) between retries. */
  retryDelay?: TransportConfig['retryDelay'] | undefined
  /** The timeout (in ms) for async Ipc requests. Default: 10_000 */
  timeout?: TransportConfig['timeout'] | undefined
}

export type IpcTransport = Transport<
  'ipc',
  {
    getRpcClient(): Promise<IpcRpcClient>
    subscribe: IpcTransportSubscribe['subscribe']
  }
>

export type IpcTransportErrorType =
  | CreateTransportErrorType
  | UrlRequiredErrorType
  | ErrorType

/**
 * @description Creates an IPC transport that connects to a JSON-RPC API.
 */
export function ipc(
  path: string,
  config: IpcTransportConfig = {},
): IpcTransport {
  const {
    key = 'ipc',
    methods,
    name = 'IPC JSON-RPC',
    reconnect,
    retryDelay,
  } = config
  return ({ retryCount: retryCount_, timeout: timeout_ }) => {
    const retryCount = config.retryCount ?? retryCount_
    const timeout = timeout_ ?? config.timeout ?? 10_000
    return createTransport(
      {
        key,
        methods,
        name,
        async request({ method, params }) {
          const body = { method, params }
          const rpcClient = await getIpcRpcClient(path, { reconnect })
          const { error, result } = await rpcClient.requestAsync({
            body,
            timeout,
          })
          if (error)
            throw new RpcRequestError({
              body,
              error,
              url: path,
            })
          return result
        },
        retryCount,
        retryDelay,
        timeout,
        type: 'ipc',
      },
      {
        getRpcClient() {
          return getIpcRpcClient(path)
        },
        async subscribe({ params, onData, onError }: any) {
          const rpcClient = await getIpcRpcClient(path)
          const { result: subscriptionId } = await new Promise<any>(
            (resolve, reject) =>
              rpcClient.request({
                body: {
                  method: 'eth_subscribe',
                  params,
                },
                onResponse(response) {
                  if (response.error) {
                    reject(response.error)
                    onError?.(response.error)
                    return
                  }

                  if (typeof response.id === 'number') {
                    resolve(response)
                    return
                  }
                  if (response.method !== 'eth_subscription') return
                  onData(response.params)
                },
              }),
          )
          return {
            subscriptionId,
            async unsubscribe() {
              return new Promise<any>((resolve) =>
                rpcClient.request({
                  body: {
                    method: 'eth_unsubscribe',
                    params: [subscriptionId],
                  },
                  onResponse: resolve,
                }),
              )
            },
          }
        },
      },
    )
  }
}
</file>

<file path="src/clients/transports/webSocket.ts">
import { RpcRequestError } from '../../errors/request.js'
import {
  UrlRequiredError,
  type UrlRequiredErrorType,
} from '../../errors/transport.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Hash } from '../../types/misc.js'
import type { RpcResponse } from '../../types/rpc.js'
import { getSocket } from '../../utils/rpc/compat.js'
import type { SocketRpcClient } from '../../utils/rpc/socket.js'
import {
  type GetWebSocketRpcClientOptions,
  getWebSocketRpcClient,
} from '../../utils/rpc/webSocket.js'
import {
  type CreateTransportErrorType,
  type Transport,
  type TransportConfig,
  createTransport,
} from './createTransport.js'

type WebSocketTransportSubscribeParameters = {
  onData: (data: RpcResponse) => void
  onError?: ((error: any) => void) | undefined
}

type WebSocketTransportSubscribeReturnType = {
  subscriptionId: Hash
  unsubscribe: () => Promise<RpcResponse<boolean>>
}

type WebSocketTransportSubscribe = {
  subscribe(
    args: WebSocketTransportSubscribeParameters & {
      /**
       * @description Add information about compiled contracts
       * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_addcompilationresult
       */
      params: ['newHeads']
    },
  ): Promise<WebSocketTransportSubscribeReturnType>
}

export type WebSocketTransportConfig = {
  /**
   * Whether or not to send keep-alive ping messages.
   * @default true
   */
  keepAlive?: GetWebSocketRpcClientOptions['keepAlive'] | undefined
  /** The key of the WebSocket transport. */
  key?: TransportConfig['key'] | undefined
  /** Methods to include or exclude from executing RPC requests. */
  methods?: TransportConfig['methods'] | undefined
  /** The name of the WebSocket transport. */
  name?: TransportConfig['name'] | undefined
  /**
   * Whether or not to attempt to reconnect on socket failure.
   * @default true
   */
  reconnect?: GetWebSocketRpcClientOptions['reconnect'] | undefined
  /** The max number of times to retry. */
  retryCount?: TransportConfig['retryCount'] | undefined
  /** The base delay (in ms) between retries. */
  retryDelay?: TransportConfig['retryDelay'] | undefined
  /** The timeout (in ms) for async WebSocket requests. Default: 10_000 */
  timeout?: TransportConfig['timeout'] | undefined
}

export type WebSocketTransport = Transport<
  'webSocket',
  {
    /**
     * @deprecated use `getRpcClient` instead.
     */
    getSocket(): Promise<WebSocket>
    getRpcClient(): Promise<SocketRpcClient<WebSocket>>
    subscribe: WebSocketTransportSubscribe['subscribe']
  }
>

export type WebSocketTransportErrorType =
  | CreateTransportErrorType
  | UrlRequiredErrorType
  | ErrorType

/**
 * @description Creates a WebSocket transport that connects to a JSON-RPC API.
 */
export function webSocket(
  /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */
  url?: string,
  config: WebSocketTransportConfig = {},
): WebSocketTransport {
  const {
    keepAlive,
    key = 'webSocket',
    methods,
    name = 'WebSocket JSON-RPC',
    reconnect,
    retryDelay,
  } = config
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const retryCount = config.retryCount ?? retryCount_
    const timeout = timeout_ ?? config.timeout ?? 10_000
    const url_ = url || chain?.rpcUrls.default.webSocket?.[0]
    const wsRpcClientOpts = { keepAlive, reconnect }
    if (!url_) throw new UrlRequiredError()
    return createTransport(
      {
        key,
        methods,
        name,
        async request({ method, params }) {
          const body = { method, params }
          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts)
          const { error, result } = await rpcClient.requestAsync({
            body,
            timeout,
          })
          if (error)
            throw new RpcRequestError({
              body,
              error,
              url: url_,
            })
          return result
        },
        retryCount,
        retryDelay,
        timeout,
        type: 'webSocket',
      },
      {
        getSocket() {
          return getSocket(url_)
        },
        getRpcClient() {
          return getWebSocketRpcClient(url_, wsRpcClientOpts)
        },
        async subscribe({ params, onData, onError }: any) {
          const rpcClient = await getWebSocketRpcClient(url_, wsRpcClientOpts)
          const { result: subscriptionId } = await new Promise<any>(
            (resolve, reject) =>
              rpcClient.request({
                body: {
                  method: 'eth_subscribe',
                  params,
                },
                onError(error) {
                  reject(error)
                  onError?.(error)
                  return
                },
                onResponse(response) {
                  if (response.error) {
                    reject(response.error)
                    onError?.(response.error)
                    return
                  }

                  if (typeof response.id === 'number') {
                    resolve(response)
                    return
                  }
                  if (response.method !== 'eth_subscription') return
                  onData(response.params)
                },
              }),
          )
          return {
            subscriptionId,
            async unsubscribe() {
              return new Promise<any>((resolve) =>
                rpcClient.request({
                  body: {
                    method: 'eth_unsubscribe',
                    params: [subscriptionId],
                  },
                  onResponse: resolve,
                }),
              )
            },
          }
        },
      },
    )
  }
}
</file>

<file path="src/clients/createClient.test-d.ts">
import type { Address } from 'abitype'
import { describe, expectTypeOf, test } from 'vitest'

import type { Account, JsonRpcAccount } from '../accounts/types.js'
import { localhost, optimism } from '../chains/index.js'
import {
  type EIP1193RequestFn,
  createPublicClient,
  publicActions,
} from '../index.js'
import type { Chain } from '../types/chain.js'
import { type Client, createClient, rpcSchema } from './createClient.js'
import { walletActions } from './decorators/wallet.js'
import { http } from './transports/http.js'

test('with chain', () => {
  const client = createClient({
    chain: localhost,
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<Client>()
  expectTypeOf(client.chain).toEqualTypeOf(localhost)
})

test('without chain', () => {
  const client = createClient({
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<Client>()
  expectTypeOf(client.chain).toEqualTypeOf(undefined)
})

test('with account', () => {
  const client = createClient({
    account: '0x',
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<Client>()
  expectTypeOf(client.account).toEqualTypeOf<JsonRpcAccount<'0x'>>({
    address: '0x',
    type: 'json-rpc',
  })
})

test('without account', () => {
  const client = createClient({
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<Client>()
  expectTypeOf(client.account).toEqualTypeOf(undefined)
})

describe('extend', () => {
  test('default', () => {
    const client = createClient({
      chain: localhost,
      transport: http(),
    })

    const extended = client
      .extend((config) => ({
        getChainId: async () => config.chain.id,
        foo: 'bar',
      }))
      .extend(() => ({}))
      .extend((config) => ({ bar: `${config.foo}baz` }))

    expectTypeOf(extended).toMatchTypeOf<Client>()
    expectTypeOf(extended.bar).toEqualTypeOf<'barbaz'>()
    expectTypeOf(extended.foo).toEqualTypeOf<'bar'>()
    expectTypeOf(extended.getChainId).toEqualTypeOf<() => Promise<1337>>()
  })

  test('chain w/ formatter', async () => {
    const client = createClient({
      chain: optimism,
      transport: http(),
    }).extend(publicActions)
    await client.getBlock()
    await client.getTransaction({ hash: '0x' })
  })

  test('protected action', () => {
    const client = createClient({
      chain: localhost,
      transport: http(),
    })

    client.extend(() => ({
      async sendTransaction(args) {
        expectTypeOf(args.account).toEqualTypeOf<Address | Account | null>()
        expectTypeOf(args.to).toEqualTypeOf<Address | null | undefined>()
        expectTypeOf(args.value).toEqualTypeOf<bigint | undefined>()
        return '0x'
      },
    }))

    client.extend(() => ({
      // @ts-expect-error: Type 'string' is not assignable to type 'Promise<`0x${string}`>'.
      sendTransaction() {
        return '0x'
      },
    }))

    client.extend(() => ({
      // @ts-expect-error: Type '"bogus"' is not assignable to type '`0x${string}`'.
      async sendTransaction() {
        return 'bogus'
      },
    }))

    client.extend(() => ({
      // @ts-expect-error: Type 'SendTransactionParameters<Chain | undefined, Account | undefined, chainOverride>' is not assignable to type 'number'.
      async sendTransaction(_args: number) {
        return '0x'
      },
    }))
  })

  test('protected action pass through generic', () => {
    function getClient<chain extends Chain | undefined>(
      chain?: chain | undefined,
    ) {
      const client = createClient({
        chain,
        transport: http(),
      })
      return client.extend(walletActions)
    }
    getClient(localhost)
  })
})

test('custom rpc schema', () => {
  type MockRpcSchema = [
    {
      Method: 'wallet_wagmi'
      Parameters: [string]
      ReturnType: string
    },
  ]

  const client = createClient({
    rpcSchema: rpcSchema<MockRpcSchema>(),
    transport: http(),
  })

  expectTypeOf(client).toMatchTypeOf<Client>()
  expectTypeOf(client.request).toEqualTypeOf<EIP1193RequestFn<MockRpcSchema>>()
})

test('https://github.com/wevm/viem/issues/1955', () => {
  createPublicClient({
    chain: optimism,
    transport: http(),
  })
})
</file>

<file path="src/clients/createClient.ts">
import type { Address } from 'abitype'

import type { JsonRpcAccount } from '../accounts/types.js'
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../accounts/utils/parseAccount.js'
import type { ErrorType } from '../errors/utils.js'
import type { Account } from '../types/account.js'
import type { Chain } from '../types/chain.js'
import type {
  EIP1193RequestFn,
  EIP1474Methods,
  RpcSchema,
} from '../types/eip1193.js'
import type { ExactPartial, Prettify } from '../types/utils.js'
import type {
  CcipRequestParameters,
  CcipRequestReturnType,
} from '../utils/ccip.js'
import { uid } from '../utils/uid.js'
import type { PublicActions } from './decorators/public.js'
import type { WalletActions } from './decorators/wallet.js'
import type { Transport } from './transports/createTransport.js'

export type ClientConfig<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  accountOrAddress extends Account | Address | undefined =
    | Account
    | Address
    | undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
> = {
  /** The Account to use for the Client. This will be used for Actions that require an account as an argument. */
  account?: accountOrAddress | Account | Address | undefined
  /** Flags for batch settings. */
  batch?:
    | {
        /** Toggle to enable `eth_call` multicall aggregation. */
        multicall?: boolean | Prettify<MulticallBatchOptions> | undefined
      }
    | undefined
  /**
   * Time (in ms) that cached data will remain in memory.
   * @default 4_000
   */
  cacheTime?: number | undefined
  /**
   * [CCIP Read](https://eips.ethereum.org/EIPS/eip-3668) configuration.
   * If `false`, the client will not support offchain CCIP lookups.
   */
  ccipRead?:
    | {
        /**
         * A function that will be called to make the offchain CCIP lookup request.
         * @see https://eips.ethereum.org/EIPS/eip-3668#client-lookup-protocol
         */
        request?: (
          parameters: CcipRequestParameters,
        ) => Promise<CcipRequestReturnType>
      }
    | false
    | undefined
  /** Chain for the client. */
  chain?: Chain | undefined | chain
  /** A key for the client. */
  key?: string | undefined
  /** A name for the client. */
  name?: string | undefined
  /**
   * Frequency (in ms) for polling enabled actions & events.
   * @default 4_000
   */
  pollingInterval?: number | undefined
  /**
   * Typed JSON-RPC schema for the client.
   */
  rpcSchema?: rpcSchema | undefined
  /** The RPC transport */
  transport: transport
  /** The type of client. */
  type?: string | undefined
}

// Actions that are used internally by other Actions (ie. `call` is used by `readContract`).
// They are allowed to be extended, but must conform to their parameter & return type interfaces.
// Example: an extended `call` action must accept `CallParameters` as parameters,
// and conform to the `CallReturnType` return type.
type ExtendableProtectedActions<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
> = Pick<
  PublicActions<transport, chain, account>,
  | 'call'
  | 'createContractEventFilter'
  | 'createEventFilter'
  | 'estimateContractGas'
  | 'estimateGas'
  | 'getBlock'
  | 'getBlockNumber'
  | 'getChainId'
  | 'getContractEvents'
  | 'getEnsText'
  | 'getFilterChanges'
  | 'getGasPrice'
  | 'getLogs'
  | 'getTransaction'
  | 'getTransactionCount'
  | 'getTransactionReceipt'
  | 'prepareTransactionRequest'
  | 'readContract'
  | 'sendRawTransaction'
  | 'simulateContract'
  | 'uninstallFilter'
  | 'watchBlockNumber'
  | 'watchContractEvent'
> &
  Pick<WalletActions<chain, account>, 'sendTransaction' | 'writeContract'>

// TODO: Move `transport` to slot index 2 since `chain` and `account` used more frequently.
// Otherwise, we end up with a lot of `Client<Transport, chain, account>` in actions.
export type Client<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
  extended extends Extended | undefined = Extended | undefined,
> = Client_Base<transport, chain, account, rpcSchema> &
  (extended extends Extended ? extended : unknown) & {
    extend: <
      const client extends Extended &
        ExactPartial<ExtendableProtectedActions<transport, chain, account>>,
    >(
      fn: (
        client: Client<transport, chain, account, rpcSchema, extended>,
      ) => client,
    ) => Client<
      transport,
      chain,
      account,
      rpcSchema,
      Prettify<client> & (extended extends Extended ? extended : unknown)
    >
  }

type Client_Base<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
> = {
  /** The Account of the Client. */
  account: account
  /** Flags for batch settings. */
  batch?: ClientConfig['batch'] | undefined
  /** Time (in ms) that cached data will remain in memory. */
  cacheTime: number
  /** [CCIP Read](https://eips.ethereum.org/EIPS/eip-3668) configuration. */
  ccipRead?: ClientConfig['ccipRead'] | undefined
  /** Chain for the client. */
  chain: chain
  /** A key for the client. */
  key: string
  /** A name for the client. */
  name: string
  /** Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. */
  pollingInterval: number
  /** Request function wrapped with friendly error handling */
  request: EIP1193RequestFn<
    rpcSchema extends undefined ? EIP1474Methods : rpcSchema
  >
  /** The RPC transport */
  transport: ReturnType<transport>['config'] & ReturnType<transport>['value']
  /** The type of client. */
  type: string
  /** A unique ID for the client. */
  uid: string
}

type Extended = Prettify<
  // disallow redefining base properties
  { [_ in keyof Client_Base]?: undefined } & {
    [key: string]: unknown
  }
>

export type MulticallBatchOptions = {
  /** The maximum size (in bytes) for each calldata chunk. @default 1_024 */
  batchSize?: number | undefined
  /** The maximum number of milliseconds to wait before sending a batch. @default 0 */
  wait?: number | undefined
}

export type CreateClientErrorType = ParseAccountErrorType | ErrorType

export function createClient<
  transport extends Transport,
  chain extends Chain | undefined = undefined,
  accountOrAddress extends Account | Address | undefined = undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
>(
  parameters: ClientConfig<transport, chain, accountOrAddress, rpcSchema>,
): Prettify<
  Client<
    transport,
    chain,
    accountOrAddress extends Address
      ? Prettify<JsonRpcAccount<accountOrAddress>>
      : accountOrAddress,
    rpcSchema
  >
>

export function createClient(parameters: ClientConfig): Client {
  const {
    batch,
    cacheTime = parameters.pollingInterval ?? 4_000,
    ccipRead,
    key = 'base',
    name = 'Base Client',
    pollingInterval = 4_000,
    type = 'base',
  } = parameters

  const chain = parameters.chain
  const account = parameters.account
    ? parseAccount(parameters.account)
    : undefined
  const { config, request, value } = parameters.transport({
    chain,
    pollingInterval,
  })
  const transport = { ...config, ...value }

  const client = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid(),
  }

  function extend(base: typeof client) {
    type ExtendFn = (base: typeof client) => unknown
    return (extendFn: ExtendFn) => {
      const extended = extendFn(base) as Extended
      for (const key in client) delete extended[key]
      const combined = { ...base, ...extended }
      return Object.assign(combined, { extend: extend(combined as any) })
    }
  }

  return Object.assign(client, { extend: extend(client) as any })
}

/**
 * Defines a typed JSON-RPC schema for the client.
 * Note: This is a runtime noop function.
 */
export function rpcSchema<rpcSchema extends RpcSchema>(): rpcSchema {
  return null as any
}
</file>

<file path="src/clients/createPublicClient.bench-d.ts">
import { attest } from '@ark/attest'
import { test } from 'vitest'

import { createClient } from './createClient.js'
import { createPublicClient } from './createPublicClient.js'
import { publicActions } from './decorators/public.js'
import { http } from './transports/http.js'

test('createPublicClient', () => {
  createPublicClient({
    transport: http('https://cloudflare-eth.com'),
  })
  attest.instantiations([13956, 'instantiations'])
})

test('createClient.extend + publicActions', () => {
  createClient({
    transport: http('https://cloudflare-eth.com'),
  }).extend(publicActions)
  attest.instantiations([328328, 'instantiations'])
})
</file>

<file path="src/clients/createPublicClient.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { type Chain, localhost } from '../chains/index.js'
import type {
  GetBlockReturnType,
  GetTransactionReturnType,
  TransactionReceipt,
  Transport,
} from '../index.js'
import { rpcSchema } from './createClient.js'
import { type PublicClient, createPublicClient } from './createPublicClient.js'
import { http } from './transports/http.js'

test('with chain', () => {
  const client = createPublicClient({
    chain: localhost,
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<PublicClient>()
  expectTypeOf(client.chain).toEqualTypeOf(localhost)
})

test('without chain', () => {
  const client = createPublicClient({ transport: http() })
  expectTypeOf(client).toMatchTypeOf<PublicClient>()
  expectTypeOf(client.chain).toEqualTypeOf(undefined)
})

test('widened', async () => {
  const client = null as unknown as PublicClient
  expectTypeOf(client.chain).toEqualTypeOf<Chain | undefined>()

  const block = await client.getBlock()
  expectTypeOf(block).toEqualTypeOf<GetBlockReturnType>()

  const receipt = await client.getTransactionReceipt({ hash: '0x' })
  expectTypeOf(receipt).toEqualTypeOf<TransactionReceipt>()

  const transaction = await client.getTransaction({ hash: '0x' })
  expectTypeOf(transaction).toEqualTypeOf<GetTransactionReturnType>()
})

test('widened (w/ Chain)', async () => {
  const client = null as unknown as PublicClient<Transport, Chain>
  expectTypeOf(client.chain).toEqualTypeOf<Chain>()

  const block = await client.getBlock()
  expectTypeOf(block).toEqualTypeOf<GetBlockReturnType>()

  const receipt = await client.getTransactionReceipt({ hash: '0x' })
  expectTypeOf(receipt).toEqualTypeOf<TransactionReceipt>()

  const transaction = await client.getTransaction({ hash: '0x' })
  expectTypeOf(transaction).toEqualTypeOf<GetTransactionReturnType>()
})

test('with custom rpc schema', async () => {
  type MockRpcSchema = [
    {
      Method: 'eth_wagmi'
      Parameters: [string]
      ReturnType: string
    },
  ]

  const client = createPublicClient({
    rpcSchema: rpcSchema<MockRpcSchema>(),
    transport: http(),
  })

  expectTypeOf(client).toMatchTypeOf<PublicClient>()

  const result = await client.request({
    method: 'eth_wagmi',
    params: ['hello'],
  })
  expectTypeOf(result).toEqualTypeOf<string>()
})
</file>

<file path="src/clients/createPublicClient.ts">
import type { Address } from 'abitype'
import type { ErrorType } from '../errors/utils.js'
import type { Account, ParseAccount } from '../types/account.js'
import type { Chain } from '../types/chain.js'
import type { PublicRpcSchema, RpcSchema } from '../types/eip1193.js'
import type { Prettify } from '../types/utils.js'
import {
  type Client,
  type ClientConfig,
  type CreateClientErrorType,
  createClient,
} from './createClient.js'
import { type PublicActions, publicActions } from './decorators/public.js'
import type { Transport } from './transports/createTransport.js'

export type PublicClientConfig<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  accountOrAddress extends Account | Address | undefined = undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
> = Prettify<
  Pick<
    ClientConfig<transport, chain, accountOrAddress, rpcSchema>,
    | 'batch'
    | 'cacheTime'
    | 'ccipRead'
    | 'chain'
    | 'key'
    | 'name'
    | 'pollingInterval'
    | 'rpcSchema'
    | 'transport'
  >
>

export type PublicClient<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  accountOrAddress extends Account | undefined = undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
> = Prettify<
  Client<
    transport,
    chain,
    accountOrAddress,
    rpcSchema extends RpcSchema
      ? [...PublicRpcSchema, ...rpcSchema]
      : PublicRpcSchema,
    PublicActions<transport, chain>
  >
>

export type CreatePublicClientErrorType = CreateClientErrorType | ErrorType

/**
 * Creates a Public Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).
 *
 * - Docs: https://viem.sh/docs/clients/public
 *
 * A Public Client is an interface to "public" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).
 *
 * @param config - {@link PublicClientConfig}
 * @returns A Public Client. {@link PublicClient}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 */
export function createPublicClient<
  transport extends Transport,
  chain extends Chain | undefined = undefined,
  accountOrAddress extends Account | Address | undefined = undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
>(
  parameters: PublicClientConfig<transport, chain, accountOrAddress, rpcSchema>,
): PublicClient<transport, chain, ParseAccount<accountOrAddress>, rpcSchema> {
  const { key = 'public', name = 'Public Client' } = parameters
  const client = createClient({
    ...parameters,
    key,
    name,
    type: 'publicClient',
  })
  return client.extend(publicActions) as any
}
</file>

<file path="src/clients/createTestClient.bench-d.ts">
import { attest } from '@ark/attest'
import { test } from 'vitest'

import { createClient } from './createClient.js'
import { createTestClient } from './createTestClient.js'
import { testActions } from './decorators/test.js'
import { http } from './transports/http.js'

test('createTestClient', () => {
  createTestClient({
    mode: 'anvil',
    transport: http('https://cloudflare-eth.com'),
  })
  attest.instantiations([3155, 'instantiations'])
})

test('createClient.extend + testActions', () => {
  createClient({
    transport: http('https://cloudflare-eth.com'),
  }).extend(testActions({ mode: 'anvil' }))
  attest.instantiations([9142, 'instantiations'])
})
</file>

<file path="src/clients/createTestClient.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { localhost } from '../chains/index.js'
import { rpcSchema } from './createClient.js'
import { type TestClient, createTestClient } from './createTestClient.js'
import { http } from './transports/http.js'

test('with chain', () => {
  const client = createTestClient({
    chain: localhost,
    mode: 'anvil',
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<TestClient>()
  expectTypeOf(client.mode).toEqualTypeOf<'anvil'>()
  expectTypeOf(client.chain).toEqualTypeOf(localhost)
})

test('without chain', () => {
  const client = createTestClient({
    mode: 'anvil',
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<TestClient>()
  expectTypeOf(client.chain).toEqualTypeOf(undefined)
})

test('with custom rpc schema', async () => {
  type MockRpcSchema = [
    {
      Method: 'eth_wagmi'
      Parameters: [string]
      ReturnType: string
    },
  ]

  const client = createTestClient({
    mode: 'anvil',
    rpcSchema: rpcSchema<MockRpcSchema>(),
    transport: http(),
  })

  expectTypeOf(client).toMatchTypeOf<TestClient>()

  const result = await client.request({
    method: 'eth_wagmi',
    params: ['hello'],
  })
  expectTypeOf(result).toEqualTypeOf<string>()
})
</file>

<file path="src/clients/createTestClient.ts">
import type { Address } from 'abitype'

import type { Account } from '../accounts/types.js'
import type { ErrorType } from '../errors/utils.js'
import type { ParseAccount } from '../types/account.js'
import type { Chain } from '../types/chain.js'
import type { RpcSchema, TestRpcSchema } from '../types/eip1193.js'
import type { Prettify } from '../types/utils.js'
import {
  type Client,
  type ClientConfig,
  type CreateClientErrorType,
  createClient,
} from './createClient.js'
import { type TestActions, testActions } from './decorators/test.js'
import type { Transport } from './transports/createTransport.js'

export type TestClientMode = 'anvil' | 'hardhat' | 'ganache'

export type TestClientConfig<
  mode extends TestClientMode = TestClientMode,
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  accountOrAddress extends Account | Address | undefined =
    | Account
    | Address
    | undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
> = Prettify<
  Pick<
    ClientConfig<transport, chain, accountOrAddress, rpcSchema>,
    | 'account'
    | 'cacheTime'
    | 'chain'
    | 'key'
    | 'name'
    | 'pollingInterval'
    | 'rpcSchema'
    | 'transport'
  > & {
    /** Mode of the test client. */
    mode: mode | ('anvil' | 'hardhat' | 'ganache') // TODO: Type utility that expands `TestClientMode`
  }
>

export type TestClient<
  mode extends TestClientMode = TestClientMode,
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  includeActions extends boolean = true,
  rpcSchema extends RpcSchema | undefined = undefined,
> = Prettify<
  { mode: mode } & Client<
    transport,
    chain,
    account,
    rpcSchema extends RpcSchema
      ? [...TestRpcSchema<mode>, ...rpcSchema]
      : TestRpcSchema<mode>,
    { mode: mode } & (includeActions extends true
      ? TestActions
      : Record<string, unknown>)
  >
>

export type CreateTestClientErrorType = CreateClientErrorType | ErrorType

/**
 * @description Creates a test client with a given transport.
 */
/**
 * Creates a Test Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).
 *
 * - Docs: https://viem.sh/docs/clients/test
 *
 * A Test Client is an interface to "test" JSON-RPC API methods accessible through a local Ethereum test node such as [Anvil](https://book.getfoundry.sh/anvil/) or [Hardhat](https://hardhat.org/) such as mining blocks, impersonating accounts, setting fees, etc through [Test Actions](https://viem.sh/docs/actions/test/introduction).
 *
 * @param config - {@link TestClientConfig}
 * @returns A Test Client. {@link TestClient}
 *
 * @example
 * import { createTestClient, custom } from 'viem'
 * import { foundry } from 'viem/chains'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: foundry,
 *   transport: http(),
 * })
 */
export function createTestClient<
  mode extends 'anvil' | 'hardhat' | 'ganache', // TODO: Type utility that expands `TestClientMode`
  transport extends Transport,
  chain extends Chain | undefined = undefined,
  accountOrAddress extends Account | Address | undefined = undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
>(
  parameters: TestClientConfig<
    mode,
    transport,
    chain,
    accountOrAddress,
    rpcSchema
  >,
): TestClient<
  mode,
  transport,
  chain,
  ParseAccount<accountOrAddress>,
  true,
  rpcSchema
>

export function createTestClient(parameters: TestClientConfig): TestClient {
  const { key = 'test', name = 'Test Client', mode } = parameters
  const client = createClient({
    ...parameters,
    key,
    name,
    type: 'testClient',
  })
  return client.extend((config) => ({
    mode,
    ...testActions({ mode })(config),
  }))
}
</file>

<file path="src/clients/createWalletClient.bench-d.ts">
import { attest } from '@ark/attest'
import { test } from 'vitest'

import { createClient } from './createClient.js'
import { createWalletClient } from './createWalletClient.js'
import { walletActions } from './decorators/wallet.js'
import { http } from './transports/http.js'

test('createWalletClient', () => {
  createWalletClient({
    transport: http('https://cloudflare-eth.com'),
  })
  attest.instantiations([3000, 'instantiations'])
})

test('createClient.extend + walletActions', () => {
  createClient({
    transport: http('https://cloudflare-eth.com'),
  }).extend(walletActions)
  attest.instantiations([179759, 'instantiations'])
})
</file>

<file path="src/clients/createWalletClient.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import type { JsonRpcAccount } from '../accounts/types.js'
import { localhost } from '../chains/index.js'
import { rpcSchema } from './createClient.js'
import { type WalletClient, createWalletClient } from './createWalletClient.js'
import { publicActions } from './decorators/public.js'
import { http } from './transports/http.js'

test('with chain', () => {
  const client = createWalletClient({
    chain: localhost,
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<WalletClient>()
  expectTypeOf(client.chain).toEqualTypeOf(localhost)
})

test('without chain', () => {
  const client = createWalletClient({
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<WalletClient>()
  expectTypeOf(client.chain).toEqualTypeOf(undefined)
})

test('with account', () => {
  const client = createWalletClient({
    account: '0x',
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<WalletClient>()
  expectTypeOf(client.account).toEqualTypeOf<JsonRpcAccount<'0x'>>({
    address: '0x',
    type: 'json-rpc',
  })
})

test('without account', () => {
  const client = createWalletClient({
    transport: http(),
  })
  expectTypeOf(client).toMatchTypeOf<WalletClient>()
  expectTypeOf(client.account).toEqualTypeOf(undefined)
})

test('with custom rpc schema', async () => {
  type MockRpcSchema = [
    {
      Method: 'eth_wagmi'
      Parameters: [string]
      ReturnType: string
    },
  ]

  const client = createWalletClient({
    rpcSchema: rpcSchema<MockRpcSchema>(),
    transport: http(),
  })

  expectTypeOf(client).toMatchTypeOf<WalletClient>()

  const result = await client.request({
    method: 'eth_wagmi',
    params: ['hello'],
  })
  expectTypeOf(result).toEqualTypeOf<string>()
})

test('createWalletClient.extend + publicActions', () => {
  createWalletClient({
    chain: localhost,
    transport: http(),
  }).extend(publicActions)
})
</file>

<file path="src/clients/createWalletClient.ts">
import type { Address } from 'abitype'

import type { Account } from '../accounts/types.js'
import type { ErrorType } from '../errors/utils.js'
import type { ParseAccount } from '../types/account.js'
import type { Chain } from '../types/chain.js'
import type { RpcSchema, WalletRpcSchema } from '../types/eip1193.js'
import type { Prettify } from '../types/utils.js'
import {
  type Client,
  type ClientConfig,
  type CreateClientErrorType,
  createClient,
} from './createClient.js'
import { type WalletActions, walletActions } from './decorators/wallet.js'
import type { Transport } from './transports/createTransport.js'

export type WalletClientConfig<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  accountOrAddress extends Account | Address | undefined =
    | Account
    | Address
    | undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
> = Prettify<
  Pick<
    ClientConfig<transport, chain, accountOrAddress, rpcSchema>,
    | 'account'
    | 'cacheTime'
    | 'ccipRead'
    | 'chain'
    | 'key'
    | 'name'
    | 'pollingInterval'
    | 'rpcSchema'
    | 'transport'
  >
>

export type WalletClient<
  transport extends Transport = Transport,
  chain extends Chain | undefined = Chain | undefined,
  account extends Account | undefined = Account | undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
> = Prettify<
  Client<
    transport,
    chain,
    account,
    rpcSchema extends RpcSchema
      ? [...WalletRpcSchema, ...rpcSchema]
      : WalletRpcSchema,
    WalletActions<chain, account>
  >
>

export type CreateWalletClientErrorType = CreateClientErrorType | ErrorType

/**
 * Creates a Wallet Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).
 *
 * - Docs: https://viem.sh/docs/clients/wallet
 *
 * A Wallet Client is an interface to interact with [Ethereum Account(s)](https://ethereum.org/en/glossary/#account) and provides the ability to retrieve accounts, execute transactions, sign messages, etc. through [Wallet Actions](https://viem.sh/docs/actions/wallet/introduction).
 *
 * The Wallet Client supports signing over:
 * - [JSON-RPC Accounts](https://viem.sh/docs/clients/wallet#json-rpc-accounts) (e.g. Browser Extension Wallets, WalletConnect, etc).
 * - [Local Accounts](https://viem.sh/docs/clients/wallet#local-accounts-private-key-mnemonic-etc) (e.g. private key/mnemonic wallets).
 *
 * @param config - {@link WalletClientConfig}
 * @returns A Wallet Client. {@link WalletClient}
 *
 * @example
 * // JSON-RPC Account
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 *
 * @example
 * // Local Account
 * import { createWalletClient, custom } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x')
 *   chain: mainnet,
 *   transport: http(),
 * })
 */
export function createWalletClient<
  transport extends Transport,
  chain extends Chain | undefined = undefined,
  accountOrAddress extends Account | Address | undefined = undefined,
  rpcSchema extends RpcSchema | undefined = undefined,
>(
  parameters: WalletClientConfig<transport, chain, accountOrAddress, rpcSchema>,
): WalletClient<transport, chain, ParseAccount<accountOrAddress>, rpcSchema>

export function createWalletClient(
  parameters: WalletClientConfig,
): WalletClient {
  const { key = 'wallet', name = 'Wallet Client', transport } = parameters
  const client = createClient({
    ...parameters,
    key,
    name,
    transport,
    type: 'walletClient',
  })
  return client.extend(walletActions)
}
</file>

<file path="src/constants/address.ts">
export const entryPoint06Address =
  '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as const
export const entryPoint07Address =
  '0x0000000071727De22E5E9d8BAf0edAc6f37da032' as const
export const entryPoint08Address =
  '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108' as const

export const ethAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' as const

export const zeroAddress = '0x0000000000000000000000000000000000000000' as const
</file>

<file path="src/constants/blob.ts">
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters

/** Blob limit per transaction. */
const blobsPerTransaction = 6

/** The number of bytes in a BLS scalar field element. */
export const bytesPerFieldElement = 32

/** The number of field elements in a blob. */
export const fieldElementsPerBlob = 4096

/** The number of bytes in a blob. */
export const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob

/** Blob bytes limit per transaction. */
export const maxBytesPerTransaction =
  bytesPerBlob * blobsPerTransaction -
  // terminator byte (0x80).
  1 -
  // zero byte (0x00) appended to each field element.
  1 * fieldElementsPerBlob * blobsPerTransaction
</file>

<file path="src/constants/bytes.ts">
export const erc6492MagicBytes =
  '0x6492649264926492649264926492649264926492649264926492649264926492' as const

export const zeroHash =
  '0x0000000000000000000000000000000000000000000000000000000000000000' as const
</file>

<file path="src/constants/contract.ts">
export const aggregate3Signature = '0x82ad56cb'
</file>

<file path="src/constants/contracts.ts">
export const deploylessCallViaBytecodeBytecode =
  '0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe'

export const deploylessCallViaFactoryBytecode =
  '0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe'

export const universalSignatureValidatorByteCode =
  '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572'
</file>

<file path="src/constants/kzg.ts">
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters

export const versionedHashVersionKzg = 1
</file>

<file path="src/constants/number.ts">
export const maxInt8 = 2n ** (8n - 1n) - 1n
export const maxInt16 = 2n ** (16n - 1n) - 1n
export const maxInt24 = 2n ** (24n - 1n) - 1n
export const maxInt32 = 2n ** (32n - 1n) - 1n
export const maxInt40 = 2n ** (40n - 1n) - 1n
export const maxInt48 = 2n ** (48n - 1n) - 1n
export const maxInt56 = 2n ** (56n - 1n) - 1n
export const maxInt64 = 2n ** (64n - 1n) - 1n
export const maxInt72 = 2n ** (72n - 1n) - 1n
export const maxInt80 = 2n ** (80n - 1n) - 1n
export const maxInt88 = 2n ** (88n - 1n) - 1n
export const maxInt96 = 2n ** (96n - 1n) - 1n
export const maxInt104 = 2n ** (104n - 1n) - 1n
export const maxInt112 = 2n ** (112n - 1n) - 1n
export const maxInt120 = 2n ** (120n - 1n) - 1n
export const maxInt128 = 2n ** (128n - 1n) - 1n
export const maxInt136 = 2n ** (136n - 1n) - 1n
export const maxInt144 = 2n ** (144n - 1n) - 1n
export const maxInt152 = 2n ** (152n - 1n) - 1n
export const maxInt160 = 2n ** (160n - 1n) - 1n
export const maxInt168 = 2n ** (168n - 1n) - 1n
export const maxInt176 = 2n ** (176n - 1n) - 1n
export const maxInt184 = 2n ** (184n - 1n) - 1n
export const maxInt192 = 2n ** (192n - 1n) - 1n
export const maxInt200 = 2n ** (200n - 1n) - 1n
export const maxInt208 = 2n ** (208n - 1n) - 1n
export const maxInt216 = 2n ** (216n - 1n) - 1n
export const maxInt224 = 2n ** (224n - 1n) - 1n
export const maxInt232 = 2n ** (232n - 1n) - 1n
export const maxInt240 = 2n ** (240n - 1n) - 1n
export const maxInt248 = 2n ** (248n - 1n) - 1n
export const maxInt256 = 2n ** (256n - 1n) - 1n

export const minInt8 = -(2n ** (8n - 1n))
export const minInt16 = -(2n ** (16n - 1n))
export const minInt24 = -(2n ** (24n - 1n))
export const minInt32 = -(2n ** (32n - 1n))
export const minInt40 = -(2n ** (40n - 1n))
export const minInt48 = -(2n ** (48n - 1n))
export const minInt56 = -(2n ** (56n - 1n))
export const minInt64 = -(2n ** (64n - 1n))
export const minInt72 = -(2n ** (72n - 1n))
export const minInt80 = -(2n ** (80n - 1n))
export const minInt88 = -(2n ** (88n - 1n))
export const minInt96 = -(2n ** (96n - 1n))
export const minInt104 = -(2n ** (104n - 1n))
export const minInt112 = -(2n ** (112n - 1n))
export const minInt120 = -(2n ** (120n - 1n))
export const minInt128 = -(2n ** (128n - 1n))
export const minInt136 = -(2n ** (136n - 1n))
export const minInt144 = -(2n ** (144n - 1n))
export const minInt152 = -(2n ** (152n - 1n))
export const minInt160 = -(2n ** (160n - 1n))
export const minInt168 = -(2n ** (168n - 1n))
export const minInt176 = -(2n ** (176n - 1n))
export const minInt184 = -(2n ** (184n - 1n))
export const minInt192 = -(2n ** (192n - 1n))
export const minInt200 = -(2n ** (200n - 1n))
export const minInt208 = -(2n ** (208n - 1n))
export const minInt216 = -(2n ** (216n - 1n))
export const minInt224 = -(2n ** (224n - 1n))
export const minInt232 = -(2n ** (232n - 1n))
export const minInt240 = -(2n ** (240n - 1n))
export const minInt248 = -(2n ** (248n - 1n))
export const minInt256 = -(2n ** (256n - 1n))

export const maxUint8 = 2n ** 8n - 1n
export const maxUint16 = 2n ** 16n - 1n
export const maxUint24 = 2n ** 24n - 1n
export const maxUint32 = 2n ** 32n - 1n
export const maxUint40 = 2n ** 40n - 1n
export const maxUint48 = 2n ** 48n - 1n
export const maxUint56 = 2n ** 56n - 1n
export const maxUint64 = 2n ** 64n - 1n
export const maxUint72 = 2n ** 72n - 1n
export const maxUint80 = 2n ** 80n - 1n
export const maxUint88 = 2n ** 88n - 1n
export const maxUint96 = 2n ** 96n - 1n
export const maxUint104 = 2n ** 104n - 1n
export const maxUint112 = 2n ** 112n - 1n
export const maxUint120 = 2n ** 120n - 1n
export const maxUint128 = 2n ** 128n - 1n
export const maxUint136 = 2n ** 136n - 1n
export const maxUint144 = 2n ** 144n - 1n
export const maxUint152 = 2n ** 152n - 1n
export const maxUint160 = 2n ** 160n - 1n
export const maxUint168 = 2n ** 168n - 1n
export const maxUint176 = 2n ** 176n - 1n
export const maxUint184 = 2n ** 184n - 1n
export const maxUint192 = 2n ** 192n - 1n
export const maxUint200 = 2n ** 200n - 1n
export const maxUint208 = 2n ** 208n - 1n
export const maxUint216 = 2n ** 216n - 1n
export const maxUint224 = 2n ** 224n - 1n
export const maxUint232 = 2n ** 232n - 1n
export const maxUint240 = 2n ** 240n - 1n
export const maxUint248 = 2n ** 248n - 1n
export const maxUint256 = 2n ** 256n - 1n
</file>

<file path="src/constants/solidity.ts">
import type { AbiError } from 'abitype'

// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require
export const panicReasons = {
  1: 'An `assert` condition failed.',
  17: 'Arithmetic operation resulted in underflow or overflow.',
  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
  33: 'Attempted to convert to an invalid type.',
  34: 'Attempted to access a storage byte array that is incorrectly encoded.',
  49: 'Performed `.pop()` on an empty array',
  50: 'Array index is out of bounds.',
  65: 'Allocated too much memory or created an array which is too large.',
  81: 'Attempted to call a zero-initialized variable of internal function type.',
} as const

export const solidityError: AbiError = {
  inputs: [
    {
      name: 'message',
      type: 'string',
    },
  ],
  name: 'Error',
  type: 'error',
}
export const solidityPanic: AbiError = {
  inputs: [
    {
      name: 'reason',
      type: 'uint256',
    },
  ],
  name: 'Panic',
  type: 'error',
}
</file>

<file path="src/constants/strings.ts">
export const presignMessagePrefix = '\x19Ethereum Signed Message:\n'
</file>

<file path="src/constants/unit.ts">
export const etherUnits = {
  gwei: 9,
  wei: 18,
}
export const gweiUnits = {
  ether: -9,
  wei: 9,
}
export const weiUnits = {
  ether: -18,
  gwei: -9,
}
</file>

<file path="src/errors/abi.ts">
import type { Abi, AbiEvent, AbiParameter } from 'abitype'

import type { Hex } from '../types/misc.js'
import { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'
import { size } from '../utils/data/size.js'

import { BaseError } from './base.js'

export type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {
  name: 'AbiConstructorNotFoundError'
}
export class AbiConstructorNotFoundError extends BaseError {
  constructor({ docsPath }: { docsPath: string }) {
    super(
      [
        'A constructor was not found on the ABI.',
        'Make sure you are using the correct ABI and that the constructor exists on it.',
      ].join('\n'),
      {
        docsPath,
        name: 'AbiConstructorNotFoundError',
      },
    )
  }
}

export type AbiConstructorParamsNotFoundErrorType =
  AbiConstructorParamsNotFoundError & {
    name: 'AbiConstructorParamsNotFoundError'
  }

export class AbiConstructorParamsNotFoundError extends BaseError {
  constructor({ docsPath }: { docsPath: string }) {
    super(
      [
        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',
      ].join('\n'),
      {
        docsPath,
        name: 'AbiConstructorParamsNotFoundError',
      },
    )
  }
}

export type AbiDecodingDataSizeInvalidErrorType =
  AbiDecodingDataSizeInvalidError & {
    name: 'AbiDecodingDataSizeInvalidError'
  }
export class AbiDecodingDataSizeInvalidError extends BaseError {
  constructor({ data, size }: { data: Hex; size: number }) {
    super(
      [
        `Data size of ${size} bytes is invalid.`,
        'Size must be in increments of 32 bytes (size % 32 === 0).',
      ].join('\n'),
      {
        metaMessages: [`Data: ${data} (${size} bytes)`],
        name: 'AbiDecodingDataSizeInvalidError',
      },
    )
  }
}

export type AbiDecodingDataSizeTooSmallErrorType =
  AbiDecodingDataSizeTooSmallError & {
    name: 'AbiDecodingDataSizeTooSmallError'
  }
export class AbiDecodingDataSizeTooSmallError extends BaseError {
  data: Hex
  params: readonly AbiParameter[]
  size: number

  constructor({
    data,
    params,
    size,
  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {
    super(
      [`Data size of ${size} bytes is too small for given parameters.`].join(
        '\n',
      ),
      {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size} bytes)`,
        ],
        name: 'AbiDecodingDataSizeTooSmallError',
      },
    )

    this.data = data
    this.params = params
    this.size = size
  }
}

export type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {
  name: 'AbiDecodingZeroDataError'
}
export class AbiDecodingZeroDataError extends BaseError {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: 'AbiDecodingZeroDataError',
    })
  }
}

export type AbiEncodingArrayLengthMismatchErrorType =
  AbiEncodingArrayLengthMismatchError & {
    name: 'AbiEncodingArrayLengthMismatchError'
  }
export class AbiEncodingArrayLengthMismatchError extends BaseError {
  constructor({
    expectedLength,
    givenLength,
    type,
  }: { expectedLength: number; givenLength: number; type: string }) {
    super(
      [
        `ABI encoding array length mismatch for type ${type}.`,
        `Expected length: ${expectedLength}`,
        `Given length: ${givenLength}`,
      ].join('\n'),
      { name: 'AbiEncodingArrayLengthMismatchError' },
    )
  }
}

export type AbiEncodingBytesSizeMismatchErrorType =
  AbiEncodingBytesSizeMismatchError & {
    name: 'AbiEncodingBytesSizeMismatchError'
  }
export class AbiEncodingBytesSizeMismatchError extends BaseError {
  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {
    super(
      `Size of bytes "${value}" (bytes${size(
        value,
      )}) does not match expected size (bytes${expectedSize}).`,
      { name: 'AbiEncodingBytesSizeMismatchError' },
    )
  }
}

export type AbiEncodingLengthMismatchErrorType =
  AbiEncodingLengthMismatchError & {
    name: 'AbiEncodingLengthMismatchError'
  }
export class AbiEncodingLengthMismatchError extends BaseError {
  constructor({
    expectedLength,
    givenLength,
  }: { expectedLength: number; givenLength: number }) {
    super(
      [
        'ABI encoding params/values length mismatch.',
        `Expected length (params): ${expectedLength}`,
        `Given length (values): ${givenLength}`,
      ].join('\n'),
      { name: 'AbiEncodingLengthMismatchError' },
    )
  }
}

export type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {
  name: 'AbiErrorInputsNotFoundError'
}
export class AbiErrorInputsNotFoundError extends BaseError {
  constructor(errorName: string, { docsPath }: { docsPath: string }) {
    super(
      [
        `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
        'Cannot encode error result without knowing what the parameter types are.',
        'Make sure you are using the correct ABI and that the inputs exist on it.',
      ].join('\n'),
      {
        docsPath,
        name: 'AbiErrorInputsNotFoundError',
      },
    )
  }
}

export type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {
  name: 'AbiErrorNotFoundError'
}
export class AbiErrorNotFoundError extends BaseError {
  constructor(
    errorName?: string | undefined,
    { docsPath }: { docsPath?: string | undefined } = {},
  ) {
    super(
      [
        `Error ${errorName ? `"${errorName}" ` : ''}not found on ABI.`,
        'Make sure you are using the correct ABI and that the error exists on it.',
      ].join('\n'),
      {
        docsPath,
        name: 'AbiErrorNotFoundError',
      },
    )
  }
}

export type AbiErrorSignatureNotFoundErrorType =
  AbiErrorSignatureNotFoundError & {
    name: 'AbiErrorSignatureNotFoundError'
  }
export class AbiErrorSignatureNotFoundError extends BaseError {
  signature: Hex

  constructor(signature: Hex, { docsPath }: { docsPath: string }) {
    super(
      [
        `Encoded error signature "${signature}" not found on ABI.`,
        'Make sure you are using the correct ABI and that the error exists on it.',
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
      ].join('\n'),
      {
        docsPath,
        name: 'AbiErrorSignatureNotFoundError',
      },
    )
    this.signature = signature
  }
}

export type AbiEventSignatureEmptyTopicsErrorType =
  AbiEventSignatureEmptyTopicsError & {
    name: 'AbiEventSignatureEmptyTopicsError'
  }
export class AbiEventSignatureEmptyTopicsError extends BaseError {
  constructor({ docsPath }: { docsPath: string }) {
    super('Cannot extract event signature from empty topics.', {
      docsPath,
      name: 'AbiEventSignatureEmptyTopicsError',
    })
  }
}

export type AbiEventSignatureNotFoundErrorType =
  AbiEventSignatureNotFoundError & {
    name: 'AbiEventSignatureNotFoundError'
  }
export class AbiEventSignatureNotFoundError extends BaseError {
  constructor(signature: Hex, { docsPath }: { docsPath: string }) {
    super(
      [
        `Encoded event signature "${signature}" not found on ABI.`,
        'Make sure you are using the correct ABI and that the event exists on it.',
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
      ].join('\n'),
      {
        docsPath,
        name: 'AbiEventSignatureNotFoundError',
      },
    )
  }
}

export type AbiEventNotFoundErrorType = AbiEventNotFoundError & {
  name: 'AbiEventNotFoundError'
}
export class AbiEventNotFoundError extends BaseError {
  constructor(
    eventName?: string | undefined,
    { docsPath }: { docsPath?: string | undefined } = {},
  ) {
    super(
      [
        `Event ${eventName ? `"${eventName}" ` : ''}not found on ABI.`,
        'Make sure you are using the correct ABI and that the event exists on it.',
      ].join('\n'),
      {
        docsPath,
        name: 'AbiEventNotFoundError',
      },
    )
  }
}

export type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {
  name: 'AbiFunctionNotFoundError'
}
export class AbiFunctionNotFoundError extends BaseError {
  constructor(
    functionName?: string | undefined,
    { docsPath }: { docsPath?: string | undefined } = {},
  ) {
    super(
      [
        `Function ${functionName ? `"${functionName}" ` : ''}not found on ABI.`,
        'Make sure you are using the correct ABI and that the function exists on it.',
      ].join('\n'),
      {
        docsPath,
        name: 'AbiFunctionNotFoundError',
      },
    )
  }
}

export type AbiFunctionOutputsNotFoundErrorType =
  AbiFunctionOutputsNotFoundError & {
    name: 'AbiFunctionOutputsNotFoundError'
  }
export class AbiFunctionOutputsNotFoundError extends BaseError {
  constructor(functionName: string, { docsPath }: { docsPath: string }) {
    super(
      [
        `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
        'Cannot decode function result without knowing what the parameter types are.',
        'Make sure you are using the correct ABI and that the function exists on it.',
      ].join('\n'),
      {
        docsPath,
        name: 'AbiFunctionOutputsNotFoundError',
      },
    )
  }
}

export type AbiFunctionSignatureNotFoundErrorType =
  AbiFunctionSignatureNotFoundError & {
    name: 'AbiFunctionSignatureNotFoundError'
  }
export class AbiFunctionSignatureNotFoundError extends BaseError {
  constructor(signature: Hex, { docsPath }: { docsPath: string }) {
    super(
      [
        `Encoded function signature "${signature}" not found on ABI.`,
        'Make sure you are using the correct ABI and that the function exists on it.',
        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
      ].join('\n'),
      {
        docsPath,
        name: 'AbiFunctionSignatureNotFoundError',
      },
    )
  }
}

export type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {
  name: 'AbiItemAmbiguityError'
}
export class AbiItemAmbiguityError extends BaseError {
  constructor(
    x: { abiItem: Abi[number]; type: string },
    y: { abiItem: Abi[number]; type: string },
  ) {
    super('Found ambiguous types in overloaded ABI items.', {
      metaMessages: [
        `\`${x.type}\` in \`${formatAbiItem(x.abiItem)}\`, and`,
        `\`${y.type}\` in \`${formatAbiItem(y.abiItem)}\``,
        '',
        'These types encode differently and cannot be distinguished at runtime.',
        'Remove one of the ambiguous items in the ABI.',
      ],
      name: 'AbiItemAmbiguityError',
    })
  }
}

export type BytesSizeMismatchErrorType = BytesSizeMismatchError & {
  name: 'BytesSizeMismatchError'
}
export class BytesSizeMismatchError extends BaseError {
  constructor({
    expectedSize,
    givenSize,
  }: { expectedSize: number; givenSize: number }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
      name: 'BytesSizeMismatchError',
    })
  }
}

export type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {
  name: 'DecodeLogDataMismatch'
}
export class DecodeLogDataMismatch extends BaseError {
  abiItem: AbiEvent
  data: Hex
  params: readonly AbiParameter[]
  size: number

  constructor({
    abiItem,
    data,
    params,
    size,
  }: {
    abiItem: AbiEvent
    data: Hex
    params: readonly AbiParameter[]
    size: number
  }) {
    super(
      [
        `Data size of ${size} bytes is too small for non-indexed event parameters.`,
      ].join('\n'),
      {
        metaMessages: [
          `Params: (${formatAbiParams(params, { includeName: true })})`,
          `Data:   ${data} (${size} bytes)`,
        ],
        name: 'DecodeLogDataMismatch',
      },
    )

    this.abiItem = abiItem
    this.data = data
    this.params = params
    this.size = size
  }
}

export type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {
  name: 'DecodeLogTopicsMismatch'
}
export class DecodeLogTopicsMismatch extends BaseError {
  abiItem: AbiEvent

  constructor({
    abiItem,
    param,
  }: {
    abiItem: AbiEvent
    param: AbiParameter & { indexed: boolean }
  }) {
    super(
      [
        `Expected a topic for indexed event parameter${
          param.name ? ` "${param.name}"` : ''
        } on event "${formatAbiItem(abiItem, { includeName: true })}".`,
      ].join('\n'),
      { name: 'DecodeLogTopicsMismatch' },
    )

    this.abiItem = abiItem
  }
}

export type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {
  name: 'InvalidAbiEncodingTypeError'
}
export class InvalidAbiEncodingTypeError extends BaseError {
  constructor(type: string, { docsPath }: { docsPath: string }) {
    super(
      [
        `Type "${type}" is not a valid encoding type.`,
        'Please provide a valid ABI type.',
      ].join('\n'),
      { docsPath, name: 'InvalidAbiEncodingType' },
    )
  }
}

export type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {
  name: 'InvalidAbiDecodingTypeError'
}
export class InvalidAbiDecodingTypeError extends BaseError {
  constructor(type: string, { docsPath }: { docsPath: string }) {
    super(
      [
        `Type "${type}" is not a valid decoding type.`,
        'Please provide a valid ABI type.',
      ].join('\n'),
      { docsPath, name: 'InvalidAbiDecodingType' },
    )
  }
}

export type InvalidArrayErrorType = InvalidArrayError & {
  name: 'InvalidArrayError'
}
export class InvalidArrayError extends BaseError {
  constructor(value: unknown) {
    super([`Value "${value}" is not a valid array.`].join('\n'), {
      name: 'InvalidArrayError',
    })
  }
}

export type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {
  name: 'InvalidDefinitionTypeError'
}
export class InvalidDefinitionTypeError extends BaseError {
  constructor(type: string) {
    super(
      [
        `"${type}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"',
      ].join('\n'),
      { name: 'InvalidDefinitionTypeError' },
    )
  }
}

export type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {
  name: 'UnsupportedPackedAbiType'
}
export class UnsupportedPackedAbiType extends BaseError {
  constructor(type: unknown) {
    super(`Type "${type}" is not supported for packed encoding.`, {
      name: 'UnsupportedPackedAbiType',
    })
  }
}
</file>

<file path="src/errors/account.ts">
import { BaseError } from './base.js'

export type AccountNotFoundErrorType = AccountNotFoundError & {
  name: 'AccountNotFoundError'
}
export class AccountNotFoundError extends BaseError {
  constructor({ docsPath }: { docsPath?: string | undefined } = {}) {
    super(
      [
        'Could not find an Account to execute with this Action.',
        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',
      ].join('\n'),
      {
        docsPath,
        docsSlug: 'account',
        name: 'AccountNotFoundError',
      },
    )
  }
}

export type AccountTypeNotSupportedErrorType = AccountTypeNotSupportedError & {
  name: 'AccountTypeNotSupportedError'
}
export class AccountTypeNotSupportedError extends BaseError {
  constructor({
    docsPath,
    metaMessages,
    type,
  }: {
    docsPath?: string | undefined
    metaMessages?: string[] | undefined
    type: string
  }) {
    super(`Account type "${type}" is not supported.`, {
      docsPath,
      metaMessages,
      name: 'AccountTypeNotSupportedError',
    })
  }
}
</file>

<file path="src/errors/address.ts">
import { BaseError } from './base.js'

export type InvalidAddressErrorType = InvalidAddressError & {
  name: 'InvalidAddressError'
}
export class InvalidAddressError extends BaseError {
  constructor({ address }: { address: string }) {
    super(`Address "${address}" is invalid.`, {
      metaMessages: [
        '- Address must be a hex value of 20 bytes (40 hex characters).',
        '- Address must match its checksum counterpart.',
      ],
      name: 'InvalidAddressError',
    })
  }
}
</file>

<file path="src/errors/base.ts">
import { version } from './version.js'

type ErrorConfig = {
  getDocsUrl?: ((args: BaseErrorParameters) => string | undefined) | undefined
  version?: string | undefined
}

let errorConfig: ErrorConfig = {
  getDocsUrl: ({
    docsBaseUrl,
    docsPath = '',
    docsSlug,
  }: BaseErrorParameters) =>
    docsPath
      ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${
          docsSlug ? `#${docsSlug}` : ''
        }`
      : undefined,
  version: `viem@${version}`,
}

export function setErrorConfig(config: ErrorConfig) {
  errorConfig = config
}

type BaseErrorParameters = {
  cause?: BaseError | Error | undefined
  details?: string | undefined
  docsBaseUrl?: string | undefined
  docsPath?: string | undefined
  docsSlug?: string | undefined
  metaMessages?: string[] | undefined
  name?: string | undefined
}

export type BaseErrorType = BaseError & { name: 'BaseError' }
export class BaseError extends Error {
  details: string
  docsPath?: string | undefined
  metaMessages?: string[] | undefined
  shortMessage: string
  version: string

  override name = 'BaseError'

  constructor(shortMessage: string, args: BaseErrorParameters = {}) {
    const details = (() => {
      if (args.cause instanceof BaseError) return args.cause.details
      if (args.cause?.message) return args.cause.message
      return args.details!
    })()
    const docsPath = (() => {
      if (args.cause instanceof BaseError)
        return args.cause.docsPath || args.docsPath
      return args.docsPath
    })()
    const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath })

    const message = [
      shortMessage || 'An error occurred.',
      '',
      ...(args.metaMessages ? [...args.metaMessages, ''] : []),
      ...(docsUrl ? [`Docs: ${docsUrl}`] : []),
      ...(details ? [`Details: ${details}`] : []),
      ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),
    ].join('\n')

    super(message, args.cause ? { cause: args.cause } : undefined)

    this.details = details
    this.docsPath = docsPath
    this.metaMessages = args.metaMessages
    this.name = args.name ?? this.name
    this.shortMessage = shortMessage
    this.version = version
  }

  walk(): Error
  walk(fn: (err: unknown) => boolean): Error | null
  walk(fn?: any): any {
    return walk(this, fn)
  }
}

function walk(
  err: unknown,
  fn?: ((err: unknown) => boolean) | undefined,
): unknown {
  if (fn?.(err)) return err
  if (
    err &&
    typeof err === 'object' &&
    'cause' in err &&
    err.cause !== undefined
  )
    return walk(err.cause, fn)
  return fn ? null : err
}
</file>

<file path="src/errors/blob.ts">
import { versionedHashVersionKzg } from '../constants/kzg.js'
import type { Hash } from '../types/misc.js'

import { BaseError } from './base.js'

export type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {
  name: 'BlobSizeTooLargeError'
}
export class BlobSizeTooLargeError extends BaseError {
  constructor({ maxSize, size }: { maxSize: number; size: number }) {
    super('Blob size is too large.', {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],
      name: 'BlobSizeTooLargeError',
    })
  }
}

export type EmptyBlobErrorType = EmptyBlobError & {
  name: 'EmptyBlobError'
}
export class EmptyBlobError extends BaseError {
  constructor() {
    super('Blob data must not be empty.', { name: 'EmptyBlobError' })
  }
}

export type InvalidVersionedHashSizeErrorType =
  InvalidVersionedHashSizeError & {
    name: 'InvalidVersionedHashSizeError'
  }
export class InvalidVersionedHashSizeError extends BaseError {
  constructor({
    hash,
    size,
  }: {
    hash: Hash
    size: number
  }) {
    super(`Versioned hash "${hash}" size is invalid.`, {
      metaMessages: ['Expected: 32', `Received: ${size}`],
      name: 'InvalidVersionedHashSizeError',
    })
  }
}

export type InvalidVersionedHashVersionErrorType =
  InvalidVersionedHashVersionError & {
    name: 'InvalidVersionedHashVersionError'
  }
export class InvalidVersionedHashVersionError extends BaseError {
  constructor({
    hash,
    version,
  }: {
    hash: Hash
    version: number
  }) {
    super(`Versioned hash "${hash}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${version}`,
      ],
      name: 'InvalidVersionedHashVersionError',
    })
  }
}
</file>

<file path="src/errors/block.ts">
import type { Hash } from '../types/misc.js'

import { BaseError } from './base.js'

export type BlockNotFoundErrorType = BlockNotFoundError & {
  name: 'BlockNotFoundError'
}
export class BlockNotFoundError extends BaseError {
  constructor({
    blockHash,
    blockNumber,
  }: {
    blockHash?: Hash | undefined
    blockNumber?: bigint | undefined
  }) {
    let identifier = 'Block'
    if (blockHash) identifier = `Block at hash "${blockHash}"`
    if (blockNumber) identifier = `Block at number "${blockNumber}"`
    super(`${identifier} could not be found.`, { name: 'BlockNotFoundError' })
  }
}
</file>

<file path="src/errors/ccip.ts">
import type { Address } from 'abitype'

import type { Hex } from '../types/misc.js'
import { stringify } from '../utils/stringify.js'

import { BaseError } from './base.js'
import { getUrl } from './utils.js'

export type OffchainLookupErrorType = OffchainLookupError & {
  name: 'OffchainLookupError'
}
export class OffchainLookupError extends BaseError {
  constructor({
    callbackSelector,
    cause,
    data,
    extraData,
    sender,
    urls,
  }: {
    callbackSelector: Hex
    cause: BaseError
    data: Hex
    extraData: Hex
    sender: Address
    urls: readonly string[]
  }) {
    super(
      cause.shortMessage ||
        'An error occurred while fetching for an offchain result.',
      {
        cause,
        metaMessages: [
          ...(cause.metaMessages || []),
          cause.metaMessages?.length ? '' : [],
          'Offchain Gateway Call:',
          urls && [
            '  Gateway URL(s):',
            ...urls.map((url) => `    ${getUrl(url)}`),
          ],
          `  Sender: ${sender}`,
          `  Data: ${data}`,
          `  Callback selector: ${callbackSelector}`,
          `  Extra data: ${extraData}`,
        ].flat(),
        name: 'OffchainLookupError',
      },
    )
  }
}

export type OffchainLookupResponseMalformedErrorType =
  OffchainLookupResponseMalformedError & {
    name: 'OffchainLookupResponseMalformedError'
  }
export class OffchainLookupResponseMalformedError extends BaseError {
  constructor({ result, url }: { result: any; url: string }) {
    super(
      'Offchain gateway response is malformed. Response data must be a hex value.',
      {
        metaMessages: [
          `Gateway URL: ${getUrl(url)}`,
          `Response: ${stringify(result)}`,
        ],
        name: 'OffchainLookupResponseMalformedError',
      },
    )
  }
}

/** @internal */
export type OffchainLookupSenderMismatchErrorType =
  OffchainLookupSenderMismatchError & {
    name: 'OffchainLookupSenderMismatchError'
  }
export class OffchainLookupSenderMismatchError extends BaseError {
  constructor({ sender, to }: { sender: Address; to: Address }) {
    super(
      'Reverted sender address does not match target contract address (`to`).',
      {
        metaMessages: [
          `Contract address: ${to}`,
          `OffchainLookup sender address: ${sender}`,
        ],
        name: 'OffchainLookupSenderMismatchError',
      },
    )
  }
}
</file>

<file path="src/errors/chain.ts">
import type { Chain } from '../types/chain.js'

import { BaseError } from './base.js'

export type ChainDoesNotSupportContractErrorType =
  ChainDoesNotSupportContract & {
    name: 'ChainDoesNotSupportContract'
  }
export class ChainDoesNotSupportContract extends BaseError {
  constructor({
    blockNumber,
    chain,
    contract,
  }: {
    blockNumber?: bigint | undefined
    chain: Chain
    contract: { name: string; blockCreated?: number | undefined }
  }) {
    super(
      `Chain "${chain.name}" does not support contract "${contract.name}".`,
      {
        metaMessages: [
          'This could be due to any of the following:',
          ...(blockNumber &&
          contract.blockCreated &&
          contract.blockCreated > blockNumber
            ? [
                `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,
              ]
            : [
                `- The chain does not have the contract "${contract.name}" configured.`,
              ]),
        ],
        name: 'ChainDoesNotSupportContract',
      },
    )
  }
}

export type ChainMismatchErrorType = ChainMismatchError & {
  name: 'ChainMismatchError'
}
export class ChainMismatchError extends BaseError {
  constructor({
    chain,
    currentChainId,
  }: {
    chain: Chain
    currentChainId: number
  }) {
    super(
      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`,
      {
        metaMessages: [
          `Current Chain ID:  ${currentChainId}`,
          `Expected Chain ID: ${chain.id}  ${chain.name}`,
        ],
        name: 'ChainMismatchError',
      },
    )
  }
}

export type ChainNotFoundErrorType = ChainNotFoundError & {
  name: 'ChainNotFoundError'
}
export class ChainNotFoundError extends BaseError {
  constructor() {
    super(
      [
        'No chain was provided to the request.',
        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',
      ].join('\n'),
      {
        name: 'ChainNotFoundError',
      },
    )
  }
}

export type ClientChainNotConfiguredErrorType =
  ClientChainNotConfiguredError & {
    name: 'ClientChainNotConfiguredError'
  }
export class ClientChainNotConfiguredError extends BaseError {
  constructor() {
    super('No chain was provided to the Client.', {
      name: 'ClientChainNotConfiguredError',
    })
  }
}

export type InvalidChainIdErrorType = InvalidChainIdError & {
  name: 'InvalidChainIdError'
}
export class InvalidChainIdError extends BaseError {
  constructor({ chainId }: { chainId?: number | undefined }) {
    super(
      typeof chainId === 'number'
        ? `Chain ID "${chainId}" is invalid.`
        : 'Chain ID is invalid.',
      { name: 'InvalidChainIdError' },
    )
  }
}
</file>

<file path="src/errors/contract.ts">
import type { Abi, Address } from 'abitype'

import { parseAccount } from '../accounts/utils/parseAccount.js'
import type { CallParameters } from '../actions/public/call.js'
import { panicReasons } from '../constants/solidity.js'
import type { Chain } from '../types/chain.js'
import type { Hex } from '../types/misc.js'
import {
  type DecodeErrorResultReturnType,
  decodeErrorResult,
} from '../utils/abi/decodeErrorResult.js'
import { formatAbiItem } from '../utils/abi/formatAbiItem.js'
import { formatAbiItemWithArgs } from '../utils/abi/formatAbiItemWithArgs.js'
import { getAbiItem } from '../utils/abi/getAbiItem.js'
import { formatEther } from '../utils/unit/formatEther.js'
import { formatGwei } from '../utils/unit/formatGwei.js'

import { AbiErrorSignatureNotFoundError } from './abi.js'
import { BaseError } from './base.js'
import { prettyStateOverride } from './stateOverride.js'
import { prettyPrint } from './transaction.js'
import { getContractAddress } from './utils.js'

export type CallExecutionErrorType = CallExecutionError & {
  name: 'CallExecutionError'
}
export class CallExecutionError extends BaseError {
  override cause: BaseError

  constructor(
    cause: BaseError,
    {
      account: account_,
      docsPath,
      chain,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value,
      stateOverride,
    }: CallParameters & {
      chain?: Chain | undefined
      docsPath?: string | undefined
    },
  ) {
    const account = account_ ? parseAccount(account_) : undefined
    let prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value:
        typeof value !== 'undefined' &&
        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
      data,
      gas,
      gasPrice:
        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas:
        typeof maxFeePerGas !== 'undefined' &&
        `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas:
        typeof maxPriorityFeePerGas !== 'undefined' &&
        `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce,
    })

    if (stateOverride) {
      prettyArgs += `\n${prettyStateOverride(stateOverride)}`
    }

    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [
        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
        'Raw Call Arguments:',
        prettyArgs,
      ].filter(Boolean) as string[],
      name: 'CallExecutionError',
    })
    this.cause = cause
  }
}

export type ContractFunctionExecutionErrorType =
  ContractFunctionExecutionError & {
    name: 'ContractFunctionExecutionError'
  }
export class ContractFunctionExecutionError extends BaseError {
  abi: Abi
  args?: unknown[] | undefined
  override cause: BaseError
  contractAddress?: Address | undefined
  formattedArgs?: string | undefined
  functionName: string
  sender?: Address | undefined

  constructor(
    cause: BaseError,
    {
      abi,
      args,
      contractAddress,
      docsPath,
      functionName,
      sender,
    }: {
      abi: Abi
      args?: any | undefined
      contractAddress?: Address | undefined
      docsPath?: string | undefined
      functionName: string
      sender?: Address | undefined
    },
  ) {
    const abiItem = getAbiItem({ abi, args, name: functionName })
    const formattedArgs = abiItem
      ? formatAbiItemWithArgs({
          abiItem,
          args,
          includeFunctionName: false,
          includeName: false,
        })
      : undefined
    const functionWithParams = abiItem
      ? formatAbiItem(abiItem, { includeName: true })
      : undefined

    const prettyArgs = prettyPrint({
      address: contractAddress && getContractAddress(contractAddress),
      function: functionWithParams,
      args:
        formattedArgs &&
        formattedArgs !== '()' &&
        `${[...Array(functionName?.length ?? 0).keys()]
          .map(() => ' ')
          .join('')}${formattedArgs}`,
      sender,
    })

    super(
      cause.shortMessage ||
        `An unknown error occurred while executing the contract function "${functionName}".`,
      {
        cause,
        docsPath,
        metaMessages: [
          ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
          prettyArgs && 'Contract Call:',
          prettyArgs,
        ].filter(Boolean) as string[],
        name: 'ContractFunctionExecutionError',
      },
    )
    this.abi = abi
    this.args = args
    this.cause = cause
    this.contractAddress = contractAddress
    this.functionName = functionName
    this.sender = sender
  }
}

export type ContractFunctionRevertedErrorType =
  ContractFunctionRevertedError & {
    name: 'ContractFunctionRevertedError'
  }
export class ContractFunctionRevertedError extends BaseError {
  data?: DecodeErrorResultReturnType | undefined
  raw?: Hex | undefined
  reason?: string | undefined
  signature?: Hex | undefined

  constructor({
    abi,
    data,
    functionName,
    message,
  }: {
    abi: Abi
    data?: Hex | undefined
    functionName: string
    message?: string | undefined
  }) {
    let cause: Error | undefined
    let decodedData: DecodeErrorResultReturnType | undefined = undefined
    let metaMessages: string[] | undefined
    let reason: string | undefined
    if (data && data !== '0x') {
      try {
        decodedData = decodeErrorResult({ abi, data })
        const { abiItem, errorName, args: errorArgs } = decodedData
        if (errorName === 'Error') {
          reason = (errorArgs as [string])[0]
        } else if (errorName === 'Panic') {
          const [firstArg] = errorArgs as [number]
          reason = panicReasons[firstArg as keyof typeof panicReasons]
        } else {
          const errorWithParams = abiItem
            ? formatAbiItem(abiItem, { includeName: true })
            : undefined
          const formattedArgs =
            abiItem && errorArgs
              ? formatAbiItemWithArgs({
                  abiItem,
                  args: errorArgs,
                  includeFunctionName: false,
                  includeName: false,
                })
              : undefined

          metaMessages = [
            errorWithParams ? `Error: ${errorWithParams}` : '',
            formattedArgs && formattedArgs !== '()'
              ? `       ${[...Array(errorName?.length ?? 0).keys()]
                  .map(() => ' ')
                  .join('')}${formattedArgs}`
              : '',
          ]
        }
      } catch (err) {
        cause = err as Error
      }
    } else if (message) reason = message

    let signature: Hex | undefined
    if (cause instanceof AbiErrorSignatureNotFoundError) {
      signature = cause.signature
      metaMessages = [
        `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
        'Make sure you are using the correct ABI and that the error exists on it.',
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
      ]
    }

    super(
      (reason && reason !== 'execution reverted') || signature
        ? [
            `The contract function "${functionName}" reverted with the following ${
              signature ? 'signature' : 'reason'
            }:`,
            reason || signature,
          ].join('\n')
        : `The contract function "${functionName}" reverted.`,
      {
        cause,
        metaMessages,
        name: 'ContractFunctionRevertedError',
      },
    )

    this.data = decodedData
    this.raw = data
    this.reason = reason
    this.signature = signature
  }
}

export type ContractFunctionZeroDataErrorType =
  ContractFunctionZeroDataError & {
    name: 'ContractFunctionZeroDataError'
  }
export class ContractFunctionZeroDataError extends BaseError {
  constructor({ functionName }: { functionName: string }) {
    super(`The contract function "${functionName}" returned no data ("0x").`, {
      metaMessages: [
        'This could be due to any of the following:',
        `  - The contract does not have the function "${functionName}",`,
        '  - The parameters passed to the contract function may be invalid, or',
        '  - The address is not a contract.',
      ],
      name: 'ContractFunctionZeroDataError',
    })
  }
}

export type CounterfactualDeploymentFailedErrorType =
  CounterfactualDeploymentFailedError & {
    name: 'CounterfactualDeploymentFailedError'
  }
export class CounterfactualDeploymentFailedError extends BaseError {
  constructor({ factory }: { factory?: Address | undefined }) {
    super(
      `Deployment for counterfactual contract call failed${
        factory ? ` for factory "${factory}".` : ''
      }`,
      {
        metaMessages: [
          'Please ensure:',
          '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
          '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.',
        ],
        name: 'CounterfactualDeploymentFailedError',
      },
    )
  }
}

export type RawContractErrorType = RawContractError & {
  name: 'RawContractError'
}
export class RawContractError extends BaseError {
  code = 3

  data?: Hex | { data?: Hex | undefined } | undefined

  constructor({
    data,
    message,
  }: {
    data?: Hex | { data?: Hex | undefined } | undefined
    message?: string | undefined
  }) {
    super(message || '', { name: 'RawContractError' })
    this.data = data
  }
}
</file>

<file path="src/errors/cursor.ts">
import { BaseError } from './base.js'

export type NegativeOffsetErrorType = NegativeOffsetError & {
  name: 'NegativeOffsetError'
}
export class NegativeOffsetError extends BaseError {
  constructor({ offset }: { offset: number }) {
    super(`Offset \`${offset}\` cannot be negative.`, {
      name: 'NegativeOffsetError',
    })
  }
}

export type PositionOutOfBoundsErrorType = PositionOutOfBoundsError & {
  name: 'PositionOutOfBoundsError'
}
export class PositionOutOfBoundsError extends BaseError {
  constructor({ length, position }: { length: number; position: number }) {
    super(
      `Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`,
      { name: 'PositionOutOfBoundsError' },
    )
  }
}

export type RecursiveReadLimitExceededErrorType =
  RecursiveReadLimitExceededError & {
    name: 'RecursiveReadLimitExceededError'
  }
export class RecursiveReadLimitExceededError extends BaseError {
  constructor({ count, limit }: { count: number; limit: number }) {
    super(
      `Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`,
      { name: 'RecursiveReadLimitExceededError' },
    )
  }
}
</file>

<file path="src/errors/data.ts">
import { BaseError } from './base.js'

export type SliceOffsetOutOfBoundsErrorType = SliceOffsetOutOfBoundsError & {
  name: 'SliceOffsetOutOfBoundsError'
}
export class SliceOffsetOutOfBoundsError extends BaseError {
  constructor({
    offset,
    position,
    size,
  }: { offset: number; position: 'start' | 'end'; size: number }) {
    super(
      `Slice ${
        position === 'start' ? 'starting' : 'ending'
      } at offset "${offset}" is out-of-bounds (size: ${size}).`,
      { name: 'SliceOffsetOutOfBoundsError' },
    )
  }
}

export type SizeExceedsPaddingSizeErrorType = SizeExceedsPaddingSizeError & {
  name: 'SizeExceedsPaddingSizeError'
}
export class SizeExceedsPaddingSizeError extends BaseError {
  constructor({
    size,
    targetSize,
    type,
  }: {
    size: number
    targetSize: number
    type: 'hex' | 'bytes'
  }) {
    super(
      `${type.charAt(0).toUpperCase()}${type
        .slice(1)
        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,
      { name: 'SizeExceedsPaddingSizeError' },
    )
  }
}

export type InvalidBytesLengthErrorType = InvalidBytesLengthError & {
  name: 'InvalidBytesLengthError'
}
export class InvalidBytesLengthError extends BaseError {
  constructor({
    size,
    targetSize,
    type,
  }: {
    size: number
    targetSize: number
    type: 'hex' | 'bytes'
  }) {
    super(
      `${type.charAt(0).toUpperCase()}${type
        .slice(1)
        .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`,
      { name: 'InvalidBytesLengthError' },
    )
  }
}
</file>

<file path="src/errors/eip712.ts">
import type { Address } from 'abitype'
import { BaseError } from './base.js'

export type Eip712DomainNotFoundErrorType = Eip712DomainNotFoundError & {
  name: 'Eip712DomainNotFoundError'
}
export class Eip712DomainNotFoundError extends BaseError {
  constructor({ address }: { address: Address }) {
    super(`No EIP-712 domain found on contract "${address}".`, {
      metaMessages: [
        'Ensure that:',
        `- The contract is deployed at the address "${address}".`,
        '- `eip712Domain()` function exists on the contract.',
        '- `eip712Domain()` function matches signature to ERC-5267 specification.',
      ],
      name: 'Eip712DomainNotFoundError',
    })
  }
}
</file>

<file path="src/errors/encoding.ts">
import type { ByteArray, Hex } from '../types/misc.js'

import { BaseError } from './base.js'

export type IntegerOutOfRangeErrorType = IntegerOutOfRangeError & {
  name: 'IntegerOutOfRangeError'
}
export class IntegerOutOfRangeError extends BaseError {
  constructor({
    max,
    min,
    signed,
    size,
    value,
  }: {
    max?: string | undefined
    min: string
    signed?: boolean | undefined
    size?: number | undefined
    value: string
  }) {
    super(
      `Number "${value}" is not in safe ${
        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''
      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,
      { name: 'IntegerOutOfRangeError' },
    )
  }
}

export type InvalidBytesBooleanErrorType = InvalidBytesBooleanError & {
  name: 'InvalidBytesBooleanError'
}
export class InvalidBytesBooleanError extends BaseError {
  constructor(bytes: ByteArray) {
    super(
      `Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,
      {
        name: 'InvalidBytesBooleanError',
      },
    )
  }
}

export type InvalidHexBooleanErrorType = InvalidHexBooleanError & {
  name: 'InvalidHexBooleanError'
}
export class InvalidHexBooleanError extends BaseError {
  constructor(hex: Hex) {
    super(
      `Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`,
      { name: 'InvalidHexBooleanError' },
    )
  }
}

export type InvalidHexValueErrorType = InvalidHexValueError & {
  name: 'InvalidHexValueError'
}
export class InvalidHexValueError extends BaseError {
  constructor(value: Hex) {
    super(
      `Hex value "${value}" is an odd length (${value.length}). It must be an even length.`,
      { name: 'InvalidHexValueError' },
    )
  }
}

export type SizeOverflowErrorType = SizeOverflowError & {
  name: 'SizeOverflowError'
}
export class SizeOverflowError extends BaseError {
  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {
    super(
      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,
      { name: 'SizeOverflowError' },
    )
  }
}
</file>

<file path="src/errors/ens.ts">
import { BaseError } from './base.js'

export type EnsAvatarInvalidMetadataErrorType =
  EnsAvatarInvalidMetadataError & {
    name: 'EnsAvatarInvalidMetadataError'
  }
export class EnsAvatarInvalidMetadataError extends BaseError {
  constructor({ data }: { data: any }) {
    super(
      'Unable to extract image from metadata. The metadata may be malformed or invalid.',
      {
        metaMessages: [
          '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
          '',
          `Provided data: ${JSON.stringify(data)}`,
        ],
        name: 'EnsAvatarInvalidMetadataError',
      },
    )
  }
}

export type EnsAvatarInvalidNftUriErrorType = EnsAvatarInvalidNftUriError & {
  name: 'EnsAvatarInvalidNftUriError'
}
export class EnsAvatarInvalidNftUriError extends BaseError {
  constructor({ reason }: { reason: string }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: 'EnsAvatarInvalidNftUriError',
    })
  }
}

export type EnsAvatarUriResolutionErrorType = EnsAvatarUriResolutionError & {
  name: 'EnsAvatarUriResolutionError'
}
export class EnsAvatarUriResolutionError extends BaseError {
  constructor({ uri }: { uri: string }) {
    super(
      `Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`,
      { name: 'EnsAvatarUriResolutionError' },
    )
  }
}

export type EnsAvatarUnsupportedNamespaceErrorType =
  EnsAvatarUnsupportedNamespaceError & {
    name: 'EnsAvatarUnsupportedNamespaceError'
  }
export class EnsAvatarUnsupportedNamespaceError extends BaseError {
  constructor({ namespace }: { namespace: string }) {
    super(
      `ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`,
      { name: 'EnsAvatarUnsupportedNamespaceError' },
    )
  }
}
</file>

<file path="src/errors/estimateGas.ts">
import type { Account } from '../accounts/types.js'
import type { EstimateGasParameters } from '../actions/public/estimateGas.js'
import type { Chain } from '../types/chain.js'
import { formatEther } from '../utils/unit/formatEther.js'
import { formatGwei } from '../utils/unit/formatGwei.js'

import { BaseError } from './base.js'
import { prettyPrint } from './transaction.js'

export type EstimateGasExecutionErrorType = EstimateGasExecutionError & {
  name: 'EstimateGasExecutionError'
}
export class EstimateGasExecutionError extends BaseError {
  override cause: BaseError

  constructor(
    cause: BaseError,
    {
      account,
      docsPath,
      chain,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value,
    }: Omit<EstimateGasParameters<any>, 'account'> & {
      account?: Account | undefined
      chain?: Chain | undefined
      docsPath?: string | undefined
    },
  ) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value:
        typeof value !== 'undefined' &&
        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
      data,
      gas,
      gasPrice:
        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas:
        typeof maxFeePerGas !== 'undefined' &&
        `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas:
        typeof maxPriorityFeePerGas !== 'undefined' &&
        `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce,
    })

    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [
        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
        'Estimate Gas Arguments:',
        prettyArgs,
      ].filter(Boolean) as string[],
      name: 'EstimateGasExecutionError',
    })
    this.cause = cause
  }
}
</file>

<file path="src/errors/fee.ts">
import { formatGwei } from '../utils/unit/formatGwei.js'
import { BaseError } from './base.js'

export type BaseFeeScalarErrorType = BaseFeeScalarError & {
  name: 'BaseFeeScalarError'
}
export class BaseFeeScalarError extends BaseError {
  constructor() {
    super('`baseFeeMultiplier` must be greater than 1.', {
      name: 'BaseFeeScalarError',
    })
  }
}

export type Eip1559FeesNotSupportedErrorType = Eip1559FeesNotSupportedError & {
  name: 'Eip1559FeesNotSupportedError'
}
export class Eip1559FeesNotSupportedError extends BaseError {
  constructor() {
    super('Chain does not support EIP-1559 fees.', {
      name: 'Eip1559FeesNotSupportedError',
    })
  }
}

export type MaxFeePerGasTooLowErrorType = MaxFeePerGasTooLowError & {
  name: 'MaxFeePerGasTooLowError'
}
export class MaxFeePerGasTooLowError extends BaseError {
  constructor({ maxPriorityFeePerGas }: { maxPriorityFeePerGas: bigint }) {
    super(
      `\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(
        maxPriorityFeePerGas,
      )} gwei).`,
      { name: 'MaxFeePerGasTooLowError' },
    )
  }
}
</file>

<file path="src/errors/log.ts">
import { BaseError } from './base.js'

export type FilterTypeNotSupportedErrorType = FilterTypeNotSupportedError & {
  name: 'FilterTypeNotSupportedError'
}
export class FilterTypeNotSupportedError extends BaseError {
  constructor(type: string) {
    super(`Filter type "${type}" is not supported.`, {
      name: 'FilterTypeNotSupportedError',
    })
  }
}
</file>

<file path="src/errors/node.ts">
import { formatGwei } from '../utils/unit/formatGwei.js'

import { BaseError } from './base.js'

/**
 * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go
 *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41
 *
 * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go
 *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46
 *
 * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108
 */
export type ExecutionRevertedErrorType = ExecutionRevertedError & {
  code: 3
  name: 'ExecutionRevertedError'
}
export class ExecutionRevertedError extends BaseError {
  static code = 3
  static nodeMessage = /execution reverted/

  constructor({
    cause,
    message,
  }: { cause?: BaseError | undefined; message?: string | undefined } = {}) {
    const reason = message
      ?.replace('execution reverted: ', '')
      ?.replace('execution reverted', '')
    super(
      `Execution reverted ${
        reason ? `with reason: ${reason}` : 'for an unknown reason'
      }.`,
      {
        cause,
        name: 'ExecutionRevertedError',
      },
    )
  }
}

export type FeeCapTooHighErrorType = FeeCapTooHighError & {
  name: 'FeeCapTooHighError'
}
export class FeeCapTooHighError extends BaseError {
  static nodeMessage =
    /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
  constructor({
    cause,
    maxFeePerGas,
  }: {
    cause?: BaseError | undefined
    maxFeePerGas?: bigint | undefined
  } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${
        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''
      }) cannot be higher than the maximum allowed value (2^256-1).`,
      {
        cause,
        name: 'FeeCapTooHighError',
      },
    )
  }
}

export type FeeCapTooLowErrorType = FeeCapTooLowError & {
  name: 'FeeCapTooLowError'
}
export class FeeCapTooLowError extends BaseError {
  static nodeMessage =
    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
  constructor({
    cause,
    maxFeePerGas,
  }: {
    cause?: BaseError | undefined
    maxFeePerGas?: bigint | undefined
  } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${
        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''
      } gwei) cannot be lower than the block base fee.`,
      {
        cause,
        name: 'FeeCapTooLowError',
      },
    )
  }
}

export type NonceTooHighErrorType = NonceTooHighError & {
  name: 'NonceTooHighError'
}
export class NonceTooHighError extends BaseError {
  static nodeMessage = /nonce too high/
  constructor({
    cause,
    nonce,
  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {
    super(
      `Nonce provided for the transaction ${
        nonce ? `(${nonce}) ` : ''
      }is higher than the next one expected.`,
      { cause, name: 'NonceTooHighError' },
    )
  }
}

export type NonceTooLowErrorType = NonceTooLowError & {
  name: 'NonceTooLowError'
}
export class NonceTooLowError extends BaseError {
  static nodeMessage =
    /nonce too low|transaction already imported|already known/
  constructor({
    cause,
    nonce,
  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {
    super(
      [
        `Nonce provided for the transaction ${
          nonce ? `(${nonce}) ` : ''
        }is lower than the current nonce of the account.`,
        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',
      ].join('\n'),
      { cause, name: 'NonceTooLowError' },
    )
  }
}

export type NonceMaxValueErrorType = NonceMaxValueError & {
  name: 'NonceMaxValueError'
}
export class NonceMaxValueError extends BaseError {
  static nodeMessage = /nonce has max value/
  constructor({
    cause,
    nonce,
  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {
    super(
      `Nonce provided for the transaction ${
        nonce ? `(${nonce}) ` : ''
      }exceeds the maximum allowed nonce.`,
      { cause, name: 'NonceMaxValueError' },
    )
  }
}

export type InsufficientFundsErrorType = InsufficientFundsError & {
  name: 'InsufficientFundsError'
}
export class InsufficientFundsError extends BaseError {
  static nodeMessage =
    /insufficient funds|exceeds transaction sender account balance/
  constructor({ cause }: { cause?: BaseError | undefined } = {}) {
    super(
      [
        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',
      ].join('\n'),
      {
        cause,
        metaMessages: [
          'This error could arise when the account does not have enough funds to:',
          ' - pay for the total gas fee,',
          ' - pay for the value to send.',
          ' ',
          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
          ' - `gas` is the amount of gas needed for transaction to execute,',
          ' - `gas fee` is the gas fee,',
          ' - `value` is the amount of ether to send to the recipient.',
        ],
        name: 'InsufficientFundsError',
      },
    )
  }
}

export type IntrinsicGasTooHighErrorType = IntrinsicGasTooHighError & {
  name: 'IntrinsicGasTooHighError'
}
export class IntrinsicGasTooHighError extends BaseError {
  static nodeMessage = /intrinsic gas too high|gas limit reached/
  constructor({
    cause,
    gas,
  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {
    super(
      `The amount of gas ${
        gas ? `(${gas}) ` : ''
      }provided for the transaction exceeds the limit allowed for the block.`,
      {
        cause,
        name: 'IntrinsicGasTooHighError',
      },
    )
  }
}

export type IntrinsicGasTooLowErrorType = IntrinsicGasTooLowError & {
  name: 'IntrinsicGasTooLowError'
}
export class IntrinsicGasTooLowError extends BaseError {
  static nodeMessage = /intrinsic gas too low/
  constructor({
    cause,
    gas,
  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {
    super(
      `The amount of gas ${
        gas ? `(${gas}) ` : ''
      }provided for the transaction is too low.`,
      {
        cause,
        name: 'IntrinsicGasTooLowError',
      },
    )
  }
}

export type TransactionTypeNotSupportedErrorType =
  TransactionTypeNotSupportedError & {
    name: 'TransactionTypeNotSupportedError'
  }
export class TransactionTypeNotSupportedError extends BaseError {
  static nodeMessage = /transaction type not valid/
  constructor({ cause }: { cause?: BaseError | undefined }) {
    super('The transaction type is not supported for this chain.', {
      cause,
      name: 'TransactionTypeNotSupportedError',
    })
  }
}

export type TipAboveFeeCapErrorType = TipAboveFeeCapError & {
  name: 'TipAboveFeeCapError'
}
export class TipAboveFeeCapError extends BaseError {
  static nodeMessage =
    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
  constructor({
    cause,
    maxPriorityFeePerGas,
    maxFeePerGas,
  }: {
    cause?: BaseError | undefined
    maxPriorityFeePerGas?: bigint | undefined
    maxFeePerGas?: bigint | undefined
  } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${
          maxPriorityFeePerGas
            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`
            : ''
        }) cannot be higher than the fee cap (\`maxFeePerGas\`${
          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''
        }).`,
      ].join('\n'),
      {
        cause,
        name: 'TipAboveFeeCapError',
      },
    )
  }
}

export type UnknownNodeErrorType = UnknownNodeError & {
  name: 'UnknownNodeError'
}
export class UnknownNodeError extends BaseError {
  constructor({ cause }: { cause?: BaseError | undefined }) {
    super(`An error occurred while executing: ${cause?.shortMessage}`, {
      cause,
      name: 'UnknownNodeError',
    })
  }
}
</file>

<file path="src/errors/request.ts">
import { stringify } from '../utils/stringify.js'

import { BaseError } from './base.js'
import { getUrl } from './utils.js'

export type HttpRequestErrorType = HttpRequestError & {
  name: 'HttpRequestError'
}
export class HttpRequestError extends BaseError {
  body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined
  headers?: Headers | undefined
  status?: number | undefined
  url: string

  constructor({
    body,
    cause,
    details,
    headers,
    status,
    url,
  }: {
    body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined
    cause?: Error | undefined
    details?: string | undefined
    headers?: Headers | undefined
    status?: number | undefined
    url: string
  }) {
    super('HTTP request failed.', {
      cause,
      details,
      metaMessages: [
        status && `Status: ${status}`,
        `URL: ${getUrl(url)}`,
        body && `Request body: ${stringify(body)}`,
      ].filter(Boolean) as string[],
      name: 'HttpRequestError',
    })
    this.body = body
    this.headers = headers
    this.status = status
    this.url = url
  }
}

export type WebSocketRequestErrorType = WebSocketRequestError & {
  name: 'WebSocketRequestError'
}
export class WebSocketRequestError extends BaseError {
  constructor({
    body,
    cause,
    details,
    url,
  }: {
    body?: { [key: string]: unknown } | undefined
    cause?: Error | undefined
    details?: string | undefined
    url: string
  }) {
    super('WebSocket request failed.', {
      cause,
      details,
      metaMessages: [
        `URL: ${getUrl(url)}`,
        body && `Request body: ${stringify(body)}`,
      ].filter(Boolean) as string[],
      name: 'WebSocketRequestError',
    })
  }
}

export type RpcRequestErrorType = RpcRequestError & {
  name: 'RpcRequestError'
}
export class RpcRequestError extends BaseError {
  code: number
  data?: unknown

  constructor({
    body,
    error,
    url,
  }: {
    body: { [x: string]: unknown } | { [y: string]: unknown }[]
    error: { code: number; data?: unknown; message: string }
    url: string
  }) {
    super('RPC Request failed.', {
      cause: error as any,
      details: error.message,
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
      name: 'RpcRequestError',
    })
    this.code = error.code
    this.data = error.data
  }
}

export type SocketClosedErrorType = SocketClosedError & {
  name: 'SocketClosedError'
}
export class SocketClosedError extends BaseError {
  constructor({
    url,
  }: {
    url?: string | undefined
  } = {}) {
    super('The socket has been closed.', {
      metaMessages: [url && `URL: ${getUrl(url)}`].filter(Boolean) as string[],
      name: 'SocketClosedError',
    })
  }
}

export type TimeoutErrorType = TimeoutError & {
  name: 'TimeoutError'
}
export class TimeoutError extends BaseError {
  constructor({
    body,
    url,
  }: {
    body: { [x: string]: unknown } | { [y: string]: unknown }[]
    url: string
  }) {
    super('The request took too long to respond.', {
      details: 'The request timed out.',
      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],
      name: 'TimeoutError',
    })
  }
}
</file>

<file path="src/errors/rpc.ts">
import type { Prettify } from '../types/utils.js'
import { BaseError } from './base.js'
import { RpcRequestError } from './request.js'

const unknownErrorCode = -1

export type RpcErrorCode =
  | -1
  | -32700 // Parse error
  | -32600 // Invalid request
  | -32601 // Method not found
  | -32602 // Invalid params
  | -32603 // Internal error
  | -32000 // Invalid input
  | -32001 // Resource not found
  | -32002 // Resource unavailable
  | -32003 // Transaction rejected
  | -32004 // Method not supported
  | -32005 // Limit exceeded
  | -32006 // JSON-RPC version not supported
  | -32042 // Method not found

type RpcErrorOptions<code extends number = RpcErrorCode> = {
  code?: code | (number & {}) | undefined
  docsPath?: string | undefined
  metaMessages?: string[] | undefined
  name?: string | undefined
  shortMessage: string
}

/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.
 *
 * - EIP https://eips.ethereum.org/EIPS/eip-1474
 */
export type RpcErrorType = RpcError & { name: 'RpcError' }
export class RpcError<code_ extends number = RpcErrorCode> extends BaseError {
  code: code_ | (number & {})

  constructor(
    cause: Error,
    {
      code,
      docsPath,
      metaMessages,
      name,
      shortMessage,
    }: RpcErrorOptions<code_>,
  ) {
    super(shortMessage, {
      cause,
      docsPath,
      metaMessages:
        metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,
      name: name || 'RpcError',
    })
    this.name = name || cause.name
    this.code = (
      cause instanceof RpcRequestError ? cause.code : (code ?? unknownErrorCode)
    ) as code_
  }
}

export type ProviderRpcErrorCode =
  | 4001 // User Rejected Request
  | 4100 // Unauthorized
  | 4200 // Unsupported Method
  | 4900 // Disconnected
  | 4901 // Chain Disconnected
  | 4902 // Chain Not Recognized
  | 5700 // Unsupported non-optional capability
  | 5710 // Unsupported chain id
  | 5720 // Duplicate ID
  | 5730 // Unknown bundle id
  | 5740 // Bundle too large
  | 5750 // Atomic-ready wallet rejected upgrade
  | 5760 // Atomicity not supported

/**
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 *
 * - EIP https://eips.ethereum.org/EIPS/eip-1193
 */
export type ProviderRpcErrorType = ProviderRpcError & {
  name: 'ProviderRpcError'
}
export class ProviderRpcError<
  T = undefined,
> extends RpcError<ProviderRpcErrorCode> {
  data?: T | undefined

  constructor(
    cause: Error,
    options: Prettify<
      RpcErrorOptions<ProviderRpcErrorCode> & {
        data?: T | undefined
      }
    >,
  ) {
    super(cause, options)

    this.data = options.data
  }
}

/**
 * Subclass for a "Parse error" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type ParseRpcErrorType = ParseRpcError & {
  code: -32700
  name: 'ParseRpcError'
}
export class ParseRpcError extends RpcError {
  static code = -32700 as const

  constructor(cause: Error) {
    super(cause, {
      code: ParseRpcError.code,
      name: 'ParseRpcError',
      shortMessage:
        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
    })
  }
}

/**
 * Subclass for a "Invalid request" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type InvalidRequestRpcErrorType = InvalidRequestRpcError & {
  code: -32600
  name: 'InvalidRequestRpcError'
}
export class InvalidRequestRpcError extends RpcError {
  static code = -32600 as const

  constructor(cause: Error) {
    super(cause, {
      code: InvalidRequestRpcError.code,
      name: 'InvalidRequestRpcError',
      shortMessage: 'JSON is not a valid request object.',
    })
  }
}

/**
 * Subclass for a "Method not found" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type MethodNotFoundRpcErrorType = MethodNotFoundRpcError & {
  code: -32601
  name: 'MethodNotFoundRpcError'
}
export class MethodNotFoundRpcError extends RpcError {
  static code = -32601 as const

  constructor(cause: Error, { method }: { method?: string } = {}) {
    super(cause, {
      code: MethodNotFoundRpcError.code,
      name: 'MethodNotFoundRpcError',
      shortMessage: `The method${method ? ` "${method}"` : ''} does not exist / is not available.`,
    })
  }
}

/**
 * Subclass for an "Invalid params" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type InvalidParamsRpcErrorType = InvalidParamsRpcError & {
  code: -32602
  name: 'InvalidParamsRpcError'
}
export class InvalidParamsRpcError extends RpcError {
  static code = -32602 as const

  constructor(cause: Error) {
    super(cause, {
      code: InvalidParamsRpcError.code,
      name: 'InvalidParamsRpcError',
      shortMessage: [
        'Invalid parameters were provided to the RPC method.',
        'Double check you have provided the correct parameters.',
      ].join('\n'),
    })
  }
}

/**
 * Subclass for an "Internal error" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type InternalRpcErrorType = InternalRpcError & {
  code: -32603
  name: 'InternalRpcError'
}
export class InternalRpcError extends RpcError {
  static code = -32603 as const

  constructor(cause: Error) {
    super(cause, {
      code: InternalRpcError.code,
      name: 'InternalRpcError',
      shortMessage: 'An internal error was received.',
    })
  }
}

/**
 * Subclass for an "Invalid input" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type InvalidInputRpcErrorType = InvalidInputRpcError & {
  code: -32000
  name: 'InvalidInputRpcError'
}
export class InvalidInputRpcError extends RpcError {
  static code = -32000 as const

  constructor(cause: Error) {
    super(cause, {
      code: InvalidInputRpcError.code,
      name: 'InvalidInputRpcError',
      shortMessage: [
        'Missing or invalid parameters.',
        'Double check you have provided the correct parameters.',
      ].join('\n'),
    })
  }
}

/**
 * Subclass for a "Resource not found" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type ResourceNotFoundRpcErrorType = ResourceNotFoundRpcError & {
  code: -32001
  name: 'ResourceNotFoundRpcError'
}
export class ResourceNotFoundRpcError extends RpcError {
  override name = 'ResourceNotFoundRpcError'
  static code = -32001 as const

  constructor(cause: Error) {
    super(cause, {
      code: ResourceNotFoundRpcError.code,
      name: 'ResourceNotFoundRpcError',
      shortMessage: 'Requested resource not found.',
    })
  }
}

/**
 * Subclass for a "Resource unavailable" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type ResourceUnavailableRpcErrorType = ResourceUnavailableRpcError & {
  code: -32002
  name: 'ResourceUnavailableRpcError'
}
export class ResourceUnavailableRpcError extends RpcError {
  static code = -32002 as const

  constructor(cause: Error) {
    super(cause, {
      code: ResourceUnavailableRpcError.code,
      name: 'ResourceUnavailableRpcError',
      shortMessage: 'Requested resource not available.',
    })
  }
}

/**
 * Subclass for a "Transaction rejected" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type TransactionRejectedRpcErrorType = TransactionRejectedRpcError & {
  code: -32003
  name: 'TransactionRejectedRpcError'
}
export class TransactionRejectedRpcError extends RpcError {
  static code = -32003 as const

  constructor(cause: Error) {
    super(cause, {
      code: TransactionRejectedRpcError.code,
      name: 'TransactionRejectedRpcError',
      shortMessage: 'Transaction creation failed.',
    })
  }
}

/**
 * Subclass for a "Method not supported" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type MethodNotSupportedRpcErrorType = MethodNotSupportedRpcError & {
  code: -32004
  name: 'MethodNotSupportedRpcError'
}
export class MethodNotSupportedRpcError extends RpcError {
  static code = -32004 as const

  constructor(cause: Error, { method }: { method?: string } = {}) {
    super(cause, {
      code: MethodNotSupportedRpcError.code,
      name: 'MethodNotSupportedRpcError',
      shortMessage: `Method${method ? ` "${method}"` : ''} is not supported.`,
    })
  }
}

/**
 * Subclass for a "Limit exceeded" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type LimitExceededRpcErrorType = LimitExceededRpcError & {
  code: -32005
  name: 'LimitExceededRpcError'
}
export class LimitExceededRpcError extends RpcError {
  static code = -32005 as const

  constructor(cause: Error) {
    super(cause, {
      code: LimitExceededRpcError.code,
      name: 'LimitExceededRpcError',
      shortMessage: 'Request exceeds defined limit.',
    })
  }
}

/**
 * Subclass for a "JSON-RPC version not supported" EIP-1474 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes
 */
export type JsonRpcVersionUnsupportedErrorType =
  JsonRpcVersionUnsupportedError & {
    code: -32006
    name: 'JsonRpcVersionUnsupportedError'
  }
export class JsonRpcVersionUnsupportedError extends RpcError {
  static code = -32006 as const

  constructor(cause: Error) {
    super(cause, {
      code: JsonRpcVersionUnsupportedError.code,
      name: 'JsonRpcVersionUnsupportedError',
      shortMessage: 'Version of JSON-RPC protocol is not supported.',
    })
  }
}

/**
 * Subclass for a "User Rejected Request" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */
export type UserRejectedRequestErrorType = UserRejectedRequestError & {
  code: 4001
  name: 'UserRejectedRequestError'
}
export class UserRejectedRequestError extends ProviderRpcError {
  static code = 4001 as const

  constructor(cause: Error) {
    super(cause, {
      code: UserRejectedRequestError.code,
      name: 'UserRejectedRequestError',
      shortMessage: 'User rejected the request.',
    })
  }
}

/**
 * Subclass for an "Unauthorized" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */
export type UnauthorizedProviderErrorType = UnauthorizedProviderError & {
  code: 4100
  name: 'UnauthorizedProviderError'
}
export class UnauthorizedProviderError extends ProviderRpcError {
  static code = 4100 as const

  constructor(cause: Error) {
    super(cause, {
      code: UnauthorizedProviderError.code,
      name: 'UnauthorizedProviderError',
      shortMessage:
        'The requested method and/or account has not been authorized by the user.',
    })
  }
}

/**
 * Subclass for an "Unsupported Method" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */
export type UnsupportedProviderMethodErrorType =
  UnsupportedProviderMethodError & {
    code: 4200
    name: 'UnsupportedProviderMethodError'
  }
export class UnsupportedProviderMethodError extends ProviderRpcError {
  static code = 4200 as const

  constructor(cause: Error, { method }: { method?: string } = {}) {
    super(cause, {
      code: UnsupportedProviderMethodError.code,
      name: 'UnsupportedProviderMethodError',
      shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ''}.`,
    })
  }
}

/**
 * Subclass for an "Disconnected" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */
export type ProviderDisconnectedErrorType = ProviderDisconnectedError & {
  code: 4900
  name: 'ProviderDisconnectedError'
}
export class ProviderDisconnectedError extends ProviderRpcError {
  static code = 4900 as const

  constructor(cause: Error) {
    super(cause, {
      code: ProviderDisconnectedError.code,
      name: 'ProviderDisconnectedError',
      shortMessage: 'The Provider is disconnected from all chains.',
    })
  }
}

/**
 * Subclass for an "Chain Disconnected" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */
export type ChainDisconnectedErrorType = ChainDisconnectedError & {
  code: 4901
  name: 'ChainDisconnectedError'
}
export class ChainDisconnectedError extends ProviderRpcError {
  static code = 4901 as const

  constructor(cause: Error) {
    super(cause, {
      code: ChainDisconnectedError.code,
      name: 'ChainDisconnectedError',
      shortMessage: 'The Provider is not connected to the requested chain.',
    })
  }
}

/**
 * Subclass for an "Switch Chain" EIP-1193 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors
 */
export type SwitchChainErrorType = SwitchChainError & {
  code: 4902
  name: 'SwitchChainError'
}
export class SwitchChainError extends ProviderRpcError {
  static code = 4902 as const

  constructor(cause: Error) {
    super(cause, {
      code: SwitchChainError.code,
      name: 'SwitchChainError',
      shortMessage: 'An error occurred when attempting to switch chain.',
    })
  }
}

/**
 * Subclass for an "Unsupported non-optional capability" EIP-5792 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-5792#error-codes
 */
export type UnsupportedNonOptionalCapabilityErrorType =
  UnsupportedNonOptionalCapabilityError & {
    code: 5700
    name: 'UnsupportedNonOptionalCapabilityError'
  }
export class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
  static code = 5700 as const

  constructor(cause: Error) {
    super(cause, {
      code: UnsupportedNonOptionalCapabilityError.code,
      name: 'UnsupportedNonOptionalCapabilityError',
      shortMessage:
        'This Wallet does not support a capability that was not marked as optional.',
    })
  }
}

/**
 * Subclass for an "Unsupported chain id" EIP-5792 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-5792#error-codes
 */
export type UnsupportedChainIdErrorType = UnsupportedChainIdError & {
  code: 5710
  name: 'UnsupportedChainIdError'
}
export class UnsupportedChainIdError extends ProviderRpcError {
  static code = 5710 as const

  constructor(cause: Error) {
    super(cause, {
      code: UnsupportedChainIdError.code,
      name: 'UnsupportedChainIdError',
      shortMessage: 'This Wallet does not support the requested chain ID.',
    })
  }
}

/**
 * Subclass for an "Duplicate ID" EIP-5792 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-5792#error-codes
 */
export type DuplicateIdErrorType = DuplicateIdError & {
  code: 5720
  name: 'DuplicateIdError'
}
export class DuplicateIdError extends ProviderRpcError {
  static code = 5720 as const

  constructor(cause: Error) {
    super(cause, {
      code: DuplicateIdError.code,
      name: 'DuplicateIdError',
      shortMessage: 'There is already a bundle submitted with this ID.',
    })
  }
}

/**
 * Subclass for an "Unknown bundle ID" EIP-5792 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-5792#error-codes
 */
export type UnknownBundleIdErrorType = UnknownBundleIdError & {
  code: 5730
  name: 'UnknownBundleIdError'
}
export class UnknownBundleIdError extends ProviderRpcError {
  static code = 5730 as const

  constructor(cause: Error) {
    super(cause, {
      code: UnknownBundleIdError.code,
      name: 'UnknownBundleIdError',
      shortMessage: 'This bundle id is unknown / has not been submitted',
    })
  }
}

/**
 * Subclass for an "Bundle too large" EIP-5792 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-5792#error-codes
 */
export type BundleTooLargeErrorType = BundleTooLargeError & {
  code: 5740
  name: 'BundleTooLargeError'
}
export class BundleTooLargeError extends ProviderRpcError {
  static code = 5740 as const

  constructor(cause: Error) {
    super(cause, {
      code: BundleTooLargeError.code,
      name: 'BundleTooLargeError',
      shortMessage: 'The call bundle is too large for the Wallet to process.',
    })
  }
}

/**
 * Subclass for an "Atomic-ready wallet rejected upgrade" EIP-5792 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-5792#error-codes
 */
export type AtomicReadyWalletRejectedUpgradeErrorType =
  AtomicReadyWalletRejectedUpgradeError & {
    code: 5750
    name: 'AtomicReadyWalletRejectedUpgradeError'
  }
export class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
  static code = 5750 as const

  constructor(cause: Error) {
    super(cause, {
      code: AtomicReadyWalletRejectedUpgradeError.code,
      name: 'AtomicReadyWalletRejectedUpgradeError',
      shortMessage:
        'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',
    })
  }
}

/**
 * Subclass for an "Atomicity not supported" EIP-5792 error.
 *
 * EIP https://eips.ethereum.org/EIPS/eip-5792#error-codes
 */
export type AtomicityNotSupportedErrorType = AtomicityNotSupportedError & {
  code: 5760
  name: 'AtomicityNotSupportedError'
}
export class AtomicityNotSupportedError extends ProviderRpcError {
  static code = 5760 as const

  constructor(cause: Error) {
    super(cause, {
      code: AtomicityNotSupportedError.code,
      name: 'AtomicityNotSupportedError',
      shortMessage:
        'The wallet does not support atomic execution but the request requires it.',
    })
  }
}

/**
 * Subclass for an unknown RPC error.
 */
export type UnknownRpcErrorType = UnknownRpcError & {
  name: 'UnknownRpcError'
}
export class UnknownRpcError extends RpcError {
  constructor(cause: Error) {
    super(cause, {
      name: 'UnknownRpcError',
      shortMessage: 'An unknown RPC error occurred.',
    })
  }
}
</file>

<file path="src/errors/siwe.ts">
import { BaseError } from './base.js'

export type SiweInvalidMessageFieldErrorType = SiweInvalidMessageFieldError & {
  name: 'SiweInvalidMessageFieldError'
}
export class SiweInvalidMessageFieldError extends BaseError {
  constructor(parameters: {
    docsPath?: string | undefined
    field: string
    metaMessages?: string[] | undefined
  }) {
    const { docsPath, field, metaMessages } = parameters
    super(`Invalid Sign-In with Ethereum message field "${field}".`, {
      docsPath,
      metaMessages,
      name: 'SiweInvalidMessageFieldError',
    })
  }
}
</file>

<file path="src/errors/stateOverride.ts">
import type { StateMapping, StateOverride } from '../types/stateOverride.js'
import { BaseError } from './base.js'

export type AccountStateConflictErrorType = AccountStateConflictError & {
  name: 'AccountStateConflictError'
}

export class AccountStateConflictError extends BaseError {
  constructor({ address }: { address: string }) {
    super(`State for account "${address}" is set multiple times.`, {
      name: 'AccountStateConflictError',
    })
  }
}

export type StateAssignmentConflictErrorType = StateAssignmentConflictError & {
  name: 'StateAssignmentConflictError'
}

export class StateAssignmentConflictError extends BaseError {
  constructor() {
    super('state and stateDiff are set on the same account.', {
      name: 'StateAssignmentConflictError',
    })
  }
}

/** @internal */
export function prettyStateMapping(stateMapping: StateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}\n`
  }, '')
}

export function prettyStateOverride(stateOverride: StateOverride) {
  return stateOverride
    .reduce((pretty, { address, ...state }) => {
      let val = `${pretty}    ${address}:\n`
      if (state.nonce) val += `      nonce: ${state.nonce}\n`
      if (state.balance) val += `      balance: ${state.balance}\n`
      if (state.code) val += `      code: ${state.code}\n`
      if (state.state) {
        val += '      state:\n'
        val += prettyStateMapping(state.state)
      }
      if (state.stateDiff) {
        val += '      stateDiff:\n'
        val += prettyStateMapping(state.stateDiff)
      }
      return val
    }, '  State Override:\n')
    .slice(0, -1)
}
</file>

<file path="src/errors/transaction.ts">
import type { Account } from '../accounts/types.js'
import type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'
import type { BlockTag } from '../types/block.js'
import type { Chain } from '../types/chain.js'
import type { Hash, Hex } from '../types/misc.js'
import type { TransactionType } from '../types/transaction.js'
import { formatEther } from '../utils/unit/formatEther.js'
import { formatGwei } from '../utils/unit/formatGwei.js'

import { BaseError } from './base.js'

export function prettyPrint(
  args: Record<string, bigint | number | string | undefined | false | unknown>,
) {
  const entries = Object.entries(args)
    .map(([key, value]) => {
      if (value === undefined || value === false) return null
      return [key, value]
    })
    .filter(Boolean) as [string, string][]
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)
  return entries
    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
    .join('\n')
}

export type FeeConflictErrorType = FeeConflictError & {
  name: 'FeeConflictError'
}
export class FeeConflictError extends BaseError {
  constructor() {
    super(
      [
        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',
      ].join('\n'),
      { name: 'FeeConflictError' },
    )
  }
}

export type InvalidLegacyVErrorType = InvalidLegacyVError & {
  name: 'InvalidLegacyVError'
}
export class InvalidLegacyVError extends BaseError {
  constructor({ v }: { v: bigint }) {
    super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
      name: 'InvalidLegacyVError',
    })
  }
}

export type InvalidSerializableTransactionErrorType =
  InvalidSerializableTransactionError & {
    name: 'InvalidSerializableTransactionError'
  }
export class InvalidSerializableTransactionError extends BaseError {
  constructor({ transaction }: { transaction: Record<string, unknown> }) {
    super('Cannot infer a transaction type from provided transaction.', {
      metaMessages: [
        'Provided Transaction:',
        '{',
        prettyPrint(transaction),
        '}',
        '',
        'To infer the type, either provide:',
        '- a `type` to the Transaction, or',
        '- an EIP-1559 Transaction with `maxFeePerGas`, or',
        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
        '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',
        '- an EIP-7702 Transaction with `authorizationList`, or',
        '- a Legacy Transaction with `gasPrice`',
      ],
      name: 'InvalidSerializableTransactionError',
    })
  }
}

export type InvalidSerializedTransactionTypeErrorType =
  InvalidSerializedTransactionTypeError & {
    name: 'InvalidSerializedTransactionTypeError'
  }
export class InvalidSerializedTransactionTypeError extends BaseError {
  serializedType: Hex

  constructor({ serializedType }: { serializedType: Hex }) {
    super(`Serialized transaction type "${serializedType}" is invalid.`, {
      name: 'InvalidSerializedTransactionType',
    })

    this.serializedType = serializedType
  }
}

export type InvalidSerializedTransactionErrorType =
  InvalidSerializedTransactionError & {
    name: 'InvalidSerializedTransactionError'
  }
export class InvalidSerializedTransactionError extends BaseError {
  serializedTransaction: Hex
  type: TransactionType

  constructor({
    attributes,
    serializedTransaction,
    type,
  }: {
    attributes: Record<string, unknown>
    serializedTransaction: Hex
    type: TransactionType
  }) {
    const missing = Object.entries(attributes)
      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))
      .filter(Boolean)
    super(`Invalid serialized transaction of type "${type}" was provided.`, {
      metaMessages: [
        `Serialized Transaction: "${serializedTransaction}"`,
        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',
      ].filter(Boolean),
      name: 'InvalidSerializedTransactionError',
    })

    this.serializedTransaction = serializedTransaction
    this.type = type
  }
}

export type InvalidStorageKeySizeErrorType = InvalidStorageKeySizeError & {
  name: 'InvalidStorageKeySizeError'
}
export class InvalidStorageKeySizeError extends BaseError {
  constructor({ storageKey }: { storageKey: Hex }) {
    super(
      `Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor(
        (storageKey.length - 2) / 2,
      )} bytes.`,
      { name: 'InvalidStorageKeySizeError' },
    )
  }
}

export type TransactionExecutionErrorType = TransactionExecutionError & {
  name: 'TransactionExecutionError'
}
export class TransactionExecutionError extends BaseError {
  override cause: BaseError

  constructor(
    cause: BaseError,
    {
      account,
      docsPath,
      chain,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value,
    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {
      account: Account | null
      chain?: Chain | undefined
      docsPath?: string | undefined
    },
  ) {
    const prettyArgs = prettyPrint({
      chain: chain && `${chain?.name} (id: ${chain?.id})`,
      from: account?.address,
      to,
      value:
        typeof value !== 'undefined' &&
        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
      data,
      gas,
      gasPrice:
        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas:
        typeof maxFeePerGas !== 'undefined' &&
        `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas:
        typeof maxPriorityFeePerGas !== 'undefined' &&
        `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce,
    })

    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [
        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
        'Request Arguments:',
        prettyArgs,
      ].filter(Boolean) as string[],
      name: 'TransactionExecutionError',
    })
    this.cause = cause
  }
}

export type TransactionNotFoundErrorType = TransactionNotFoundError & {
  name: 'TransactionNotFoundError'
}
export class TransactionNotFoundError extends BaseError {
  constructor({
    blockHash,
    blockNumber,
    blockTag,
    hash,
    index,
  }: {
    blockHash?: Hash | undefined
    blockNumber?: bigint | undefined
    blockTag?: BlockTag | undefined
    hash?: Hash | undefined
    index?: number | undefined
  }) {
    let identifier = 'Transaction'
    if (blockTag && index !== undefined)
      identifier = `Transaction at block time "${blockTag}" at index "${index}"`
    if (blockHash && index !== undefined)
      identifier = `Transaction at block hash "${blockHash}" at index "${index}"`
    if (blockNumber && index !== undefined)
      identifier = `Transaction at block number "${blockNumber}" at index "${index}"`
    if (hash) identifier = `Transaction with hash "${hash}"`
    super(`${identifier} could not be found.`, {
      name: 'TransactionNotFoundError',
    })
  }
}

export type TransactionReceiptNotFoundErrorType =
  TransactionReceiptNotFoundError & {
    name: 'TransactionReceiptNotFoundError'
  }
export class TransactionReceiptNotFoundError extends BaseError {
  constructor({ hash }: { hash: Hash }) {
    super(
      `Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`,
      {
        name: 'TransactionReceiptNotFoundError',
      },
    )
  }
}

export type WaitForTransactionReceiptTimeoutErrorType =
  WaitForTransactionReceiptTimeoutError & {
    name: 'WaitForTransactionReceiptTimeoutError'
  }
export class WaitForTransactionReceiptTimeoutError extends BaseError {
  constructor({ hash }: { hash: Hash }) {
    super(
      `Timed out while waiting for transaction with hash "${hash}" to be confirmed.`,
      { name: 'WaitForTransactionReceiptTimeoutError' },
    )
  }
}
</file>

<file path="src/errors/transport.ts">
import { BaseError } from './base.js'

export type UrlRequiredErrorType = UrlRequiredError & {
  name: 'UrlRequiredError'
}
export class UrlRequiredError extends BaseError {
  constructor() {
    super(
      'No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.',
      {
        docsPath: '/docs/clients/intro',
        name: 'UrlRequiredError',
      },
    )
  }
}
</file>

<file path="src/errors/typedData.ts">
import type { TypedData } from 'abitype'

import { stringify } from '../utils/stringify.js'
import { BaseError } from './base.js'

export type InvalidDomainErrorType = InvalidDomainError & {
  name: 'InvalidDomainError'
}
export class InvalidDomainError extends BaseError {
  constructor({ domain }: { domain: unknown }) {
    super(`Invalid domain "${stringify(domain)}".`, {
      metaMessages: ['Must be a valid EIP-712 domain.'],
    })
  }
}

export type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {
  name: 'InvalidPrimaryTypeError'
}
export class InvalidPrimaryTypeError extends BaseError {
  constructor({
    primaryType,
    types,
  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {
    super(
      `Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`,
      {
        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',
        metaMessages: ['Check that the primary type is a key in `types`.'],
      },
    )
  }
}

export type InvalidStructTypeErrorType = InvalidStructTypeError & {
  name: 'InvalidStructTypeError'
}
export class InvalidStructTypeError extends BaseError {
  constructor({ type }: { type: string }) {
    super(`Struct type "${type}" is invalid.`, {
      metaMessages: ['Struct type must not be a Solidity type.'],
      name: 'InvalidStructTypeError',
    })
  }
}
</file>

<file path="src/errors/unit.ts">
import { BaseError } from './base.js'

export type InvalidDecimalNumberErrorType = InvalidDecimalNumberError & {
  name: 'InvalidDecimalNumberError'
}
export class InvalidDecimalNumberError extends BaseError {
  constructor({ value }: { value: string }) {
    super(`Number \`${value}\` is not a valid decimal number.`, {
      name: 'InvalidDecimalNumberError',
    })
  }
}
</file>

<file path="src/errors/utils.ts">
import type { Address } from 'abitype'

export type ErrorType<name extends string = 'Error'> = Error & { name: name }

export const getContractAddress = (address: Address) => address
export const getUrl = (url: string) => url
</file>

<file path="src/errors/version.ts">
export const version = '2.28.3'
</file>

<file path="src/nonce/index.ts">
// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type CreateNonceManagerParameters,
  type NonceManager,
  type NonceManagerSource,
  createNonceManager,
  jsonRpc,
  nonceManager,
} from '../utils/nonceManager.js'
</file>

<file path="src/types/account.ts">
import type { Address } from 'abitype'

import type { Account, JsonRpcAccount } from '../accounts/types.js'
import type { IsUndefined, MaybeRequired, Prettify } from './utils.js'

export type DeriveAccount<
  account extends Account | undefined,
  accountOverride extends Account | Address | undefined,
> = accountOverride extends Account | Address ? accountOverride : account

export type GetAccountParameter<
  account extends Account | undefined = Account | undefined,
  accountOverride extends Account | Address | undefined = Account | Address,
  required extends boolean = true,
  nullish extends boolean = false,
> = MaybeRequired<
  {
    account?:
      | accountOverride
      | Account
      | Address
      | (nullish extends true ? null : never)
      | undefined
  },
  IsUndefined<account> extends true
    ? required extends true
      ? true
      : false
    : false
>

export type ParseAccount<
  accountOrAddress extends Account | Address | null | undefined =
    | Account
    | Address
    | null
    | undefined,
> = accountOrAddress extends Address
  ? Prettify<JsonRpcAccount<accountOrAddress>>
  : accountOrAddress

export type { Account } from '../accounts/types.js'
export type { HDKey } from '@scure/bip32'
</file>

<file path="src/types/authorization.ts">
import type { Address } from 'abitype'
import type { Hex, Signature } from './misc.js'
import type { ExactPartial, OneOf } from './utils.js'

export type Authorization<uint32 = number, signed extends boolean = false> = {
  /** Address of the contract to delegate to. */
  address: Address
  /** Chain ID. */
  chainId: uint32
  /** Nonce of the EOA to delegate to. */
  nonce: uint32
} & (signed extends true ? Signature<uint32> : ExactPartial<Signature<uint32>>)

export type AuthorizationList<
  uint32 = number,
  signed extends boolean = false,
> = readonly Authorization<uint32, signed>[]

export type AuthorizationRequest<uint32 = number> = OneOf<
  | {
      /** Address of the contract to delegate to. */
      address: Address
    }
  | {
      /**
       * Address of the contract to delegate to.
       * @alias `address`
       */
      contractAddress: Address
    }
> & {
  /** Chain ID. */
  chainId: uint32
  /** Nonce of the EOA to delegate to. */
  nonce: uint32
}

export type SignedAuthorization<uint32 = number> = Authorization<uint32, true>

export type SignedAuthorizationList<uint32 = number> =
  readonly SignedAuthorization<uint32>[]

export type SerializedAuthorization = readonly [
  chainId: Hex,
  address: Hex,
  nonce: Hex,
  yParity: Hex,
  r: Hex,
  s: Hex,
]
export type SerializedAuthorizationList = readonly SerializedAuthorization[]
</file>

<file path="src/types/block.ts">
import type { Address } from 'abitype'

import type { Hash, Hex } from './misc.js'
import type { Transaction } from './transaction.js'
import type { Withdrawal } from './withdrawal.js'

export type Block<
  quantity = bigint,
  includeTransactions extends boolean = boolean,
  blockTag extends BlockTag = BlockTag,
  transaction = Transaction<
    bigint,
    number,
    blockTag extends 'pending' ? true : false
  >,
> = {
  /** Base fee per gas */
  baseFeePerGas: quantity | null
  /** Total used blob gas by all transactions in this block */
  blobGasUsed: quantity
  /** Difficulty for this block */
  difficulty: quantity
  /** Excess blob gas */
  excessBlobGas: quantity
  /** "Extra data" field of this block */
  extraData: Hex
  /** Maximum gas allowed in this block */
  gasLimit: quantity
  /** Total used gas by all transactions in this block */
  gasUsed: quantity
  /** Block hash or `null` if pending */
  hash: blockTag extends 'pending' ? null : Hash
  /** Logs bloom filter or `null` if pending */
  logsBloom: blockTag extends 'pending' ? null : Hex
  /** Address that received this blocks mining rewards, COINBASE address */
  miner: Address
  /** Unique identifier for the block. */
  mixHash: Hash
  /** Proof-of-work hash or `null` if pending */
  nonce: blockTag extends 'pending' ? null : Hex
  /** Block number or `null` if pending */
  number: blockTag extends 'pending' ? null : quantity
  /** Root of the parent beacon chain block */
  parentBeaconBlockRoot?: Hex | undefined
  /** Parent block hash */
  parentHash: Hash
  /** Root of the this blocks receipts trie */
  receiptsRoot: Hex
  sealFields: Hex[]
  /** SHA3 of the uncles data in this block */
  sha3Uncles: Hash
  /** Size of this block in bytes */
  size: quantity
  /** Root of this blocks final state trie */
  stateRoot: Hash
  /** Unix timestamp of when this block was collated */
  timestamp: quantity
  /** Total difficulty of the chain until this block */
  totalDifficulty: quantity | null
  /** List of transaction objects or hashes */
  transactions: includeTransactions extends true ? transaction[] : Hash[]
  /** Root of this blocks transaction trie */
  transactionsRoot: Hash
  /** List of uncle hashes */
  uncles: Hash[]
  /** List of withdrawal objects */
  withdrawals?: Withdrawal[] | undefined
  /** Root of the this blocks withdrawals trie */
  withdrawalsRoot?: Hex | undefined
}

export type BlockIdentifier<quantity = bigint> = {
  /** Whether or not to throw an error if the block is not in the canonical chain as described below. Only allowed in conjunction with the blockHash tag. Defaults to false. */
  requireCanonical?: boolean | undefined
} & (
  | {
      /** The block in the canonical chain with this number */
      blockNumber: BlockNumber<quantity>
    }
  | {
      /** The block uniquely identified by this hash. The `blockNumber` and `blockHash` properties are mutually exclusive; exactly one of them must be set. */
      blockHash: Hash
    }
)

/** Represents a block number in the blockchain. */
export type BlockNumber<quantity = bigint> = quantity

/**
 * Specifies a particular block in the blockchain.
 *
 * - `"latest"`: the latest proposed block
 * - `"earliest"`: the earliest/genesis block  lowest numbered block the client has available
 * - `"pending"`: pending state/transactions  next block built by the client on top
 *   of unsafe and containing the set of transactions usually taken from local mempool
 * - `"safe"`: the latest safe head block  the most recent block that is safe from
 *   re-orgs under honest majority and certain synchronicity assumptions
 * - `"finalized"`: the latest finalized block  the most recent crypto-economically secure block;
 *   cannot be re-orged outside of manual intervention driven by community coordination
 *
 * Using `pending`, while allowed, is not advised, as it may lead
 * to internally inconsistent results. Use of `latest` is safe and will not
 * lead to inconsistent results. Depending on the backing RPC networks caching system,
 * the usage of `pending` may lead to inconsistencies as a result of an
 * overly aggressive cache system. This may cause downstream errors/invalid states.
 */
export type BlockTag = 'latest' | 'earliest' | 'pending' | 'safe' | 'finalized'

export type Uncle<
  quantity = bigint,
  includeTransactions extends boolean = boolean,
  blockTag extends BlockTag = BlockTag,
  transaction = Transaction<
    bigint,
    number,
    blockTag extends 'pending' ? true : false
  >,
> = Block<quantity, includeTransactions, blockTag, transaction>
</file>

<file path="src/types/calls.ts">
import type { AbiStateMutability, Address } from 'abitype'
import type { Hex } from './misc.js'
import type { GetMulticallContractParameters } from './multicall.js'
import type { OneOf, Prettify } from './utils.js'

export type Call<
  call = unknown,
  extraProperties extends Record<string, unknown> = {},
> = OneOf<
  | (extraProperties & {
      data?: Hex | undefined
      to: Address
      value?: bigint | undefined
    })
  | (extraProperties &
      (Omit<
        GetMulticallContractParameters<call, AbiStateMutability>,
        'address'
      > & {
        to: Address
        value?: bigint | undefined
      }))
>

export type Calls<
  calls extends readonly unknown[],
  extraProperties extends Record<string, unknown> = {},
  ///
  result extends readonly any[] = [],
> = calls extends readonly [] // no calls, return empty
  ? readonly []
  : calls extends readonly [infer call] // one call left before returning `result`
    ? readonly [...result, Prettify<Call<call, extraProperties>>]
    : calls extends readonly [infer call, ...infer rest] // grab first call and recurse through `rest`
      ? Calls<
          [...rest],
          extraProperties,
          [...result, Prettify<Call<call, extraProperties>>]
        >
      : readonly unknown[] extends calls
        ? calls
        : // If `calls` is *some* array but we couldn't assign `unknown[]` to it, then it must hold some known/homogenous type!
          // use this to infer the param types in the case of Array.map() argument
          calls extends readonly (infer call extends OneOf<Call>)[]
          ? readonly Prettify<call>[]
          : // Fallback
            readonly OneOf<Call>[]

export type Batches<
  batches extends readonly { calls: readonly unknown[] }[],
  properties extends Record<string, any> = {},
  ///
  result extends readonly any[] = [],
> = batches extends readonly [infer batch extends { calls: readonly unknown[] }]
  ? [...result, { calls: Calls<batch['calls']> } & properties]
  : batches extends readonly [
        infer batch extends { calls: readonly unknown[] },
        ...infer rest extends readonly { calls: readonly unknown[] }[],
      ]
    ? Batches<
        [...rest],
        properties,
        [...result, { calls: Calls<batch['calls']> } & properties]
      >
    : batches
</file>

<file path="src/types/chain.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import type { base } from '~viem/chains/index.js'
import type { celo } from '../chains/definitions/celo.js'
import type { mainnet } from '../chains/definitions/mainnet.js'
import type { optimism } from '../chains/definitions/optimism.js'
import type {
  Chain,
  DeriveChain,
  ExtractChainFormatterParameters,
  GetChainParameter,
} from './chain.js'
import type { TransactionRequest } from './transaction.js'

test('DeriveChain', () => {
  type Result = DeriveChain<Chain | undefined, Chain | undefined>
  expectTypeOf<Result>().toEqualTypeOf<Chain | undefined>()

  type Result2 = DeriveChain<typeof mainnet, Chain | undefined>
  expectTypeOf<Result2>().toEqualTypeOf<typeof mainnet | Chain>()

  type Result3 = DeriveChain<Chain | undefined, typeof mainnet>
  expectTypeOf<Result3>().toEqualTypeOf<typeof mainnet>()

  type Result4 = DeriveChain<typeof mainnet, typeof optimism>
  expectTypeOf<Result4>().toEqualTypeOf<typeof optimism>()

  type Result5 = DeriveChain<Chain | undefined, Chain>
  expectTypeOf<Result5>().toEqualTypeOf<Chain>()
})

test('ExtractChainFormatterParameters', () => {
  type Result = ExtractChainFormatterParameters<
    typeof mainnet,
    'transactionRequest',
    TransactionRequest
  >
  expectTypeOf<Result['type']>().toEqualTypeOf<
    'legacy' | 'eip2930' | 'eip1559' | 'eip4844' | 'eip7702' | undefined
  >()

  type Result2 = ExtractChainFormatterParameters<
    typeof base,
    'transactionRequest',
    TransactionRequest
  >
  expectTypeOf<Result2['type']>().toEqualTypeOf<
    'legacy' | 'eip2930' | 'eip1559' | 'eip4844' | 'eip7702' | undefined
  >()

  type Result3 = ExtractChainFormatterParameters<
    typeof celo,
    'transactionRequest',
    TransactionRequest
  >
  expectTypeOf<Result3['type']>().toEqualTypeOf<
    | 'legacy'
    | 'eip2930'
    | 'eip1559'
    | 'eip4844'
    | 'eip7702'
    | 'cip64'
    | undefined
  >()
  expectTypeOf<Result3['feeCurrency']>().toEqualTypeOf<
    `0x${string}` | undefined
  >()

  type Result4 = ExtractChainFormatterParameters<
    typeof celo,
    'transaction',
    TransactionRequest
  >
  expectTypeOf<Result4['gatewayFee']>().toEqualTypeOf<
    `0x${string}` | null | undefined
  >()
})

test('GetChainParameter', () => {
  type Result = GetChainParameter<Chain | undefined, Chain | undefined>
  expectTypeOf<Result>().toEqualTypeOf<{ chain: Chain | null | undefined }>()

  type Result2 = GetChainParameter<Chain, Chain | undefined>
  expectTypeOf<Result2>().toEqualTypeOf<{ chain?: Chain | null | undefined }>()

  type Result3 = GetChainParameter<Chain | undefined, Chain>
  expectTypeOf<Result3>().toEqualTypeOf<{ chain: Chain | null }>()

  type Result4 = GetChainParameter<undefined, Chain>
  expectTypeOf<Result4>().toEqualTypeOf<{ chain: Chain | null }>()

  type Result5 = GetChainParameter<Chain, undefined>
  expectTypeOf<Result5>().toEqualTypeOf<{ chain?: undefined | null }>()

  type Result6 = GetChainParameter<typeof mainnet, undefined>
  expectTypeOf<Result6>().toEqualTypeOf<{ chain?: undefined | null }>()

  type Result7 = GetChainParameter<typeof mainnet, typeof optimism>
  expectTypeOf<Result7>().toEqualTypeOf<{
    chain?: typeof optimism | undefined | null
  }>()
})
</file>

<file path="src/types/chain.ts">
import type { Address } from 'abitype'

import type { EstimateFeesPerGasReturnType } from '../actions/public/estimateFeesPerGas.js'
import type { PrepareTransactionRequestParameters } from '../actions/wallet/prepareTransactionRequest.js'
import type { Client } from '../clients/createClient.js'
import type { Transport } from '../clients/transports/createTransport.js'
import type { Account } from '../types/account.js'
import type { FeeValuesType } from '../types/fee.js'
import type {
  TransactionSerializable,
  TransactionSerializableGeneric,
  TransactionSerializedGeneric,
} from '../types/transaction.js'
import type { IsNarrowable, IsUndefined, Prettify } from '../types/utils.js'
import type { FormattedBlock } from '../utils/formatters/block.js'
import type { SerializeTransactionFn } from '../utils/transaction/serializeTransaction.js'

export type Chain<
  formatters extends ChainFormatters | undefined = ChainFormatters | undefined,
  custom extends Record<string, unknown> | undefined =
    | Record<string, unknown>
    | undefined,
> = {
  /** Collection of block explorers */
  blockExplorers?:
    | {
        [key: string]: ChainBlockExplorer
        default: ChainBlockExplorer
      }
    | undefined
  /** Collection of contracts */
  contracts?:
    | Prettify<
        {
          [key: string]:
            | ChainContract
            | { [sourceId: number]: ChainContract | undefined }
            | undefined
        } & {
          ensRegistry?: ChainContract | undefined
          ensUniversalResolver?: ChainContract | undefined
          multicall3?: ChainContract | undefined
          universalSignatureVerifier?: ChainContract | undefined
        }
      >
    | undefined
  /** Collection of ENS TLDs for the chain. */
  ensTlds?: readonly string[] | undefined
  /** ID in number form */
  id: number
  /** Human-readable name */
  name: string
  /** Currency used by chain */
  nativeCurrency: ChainNativeCurrency
  /** Collection of RPC endpoints */
  rpcUrls: {
    [key: string]: ChainRpcUrls
    default: ChainRpcUrls
  }
  /** Source Chain ID (ie. the L1 chain) */
  sourceId?: number | undefined
  /** Flag for test networks */
  testnet?: boolean | undefined
} & ChainConfig<formatters, custom>

/////////////////////////////////////////////////////////////////////
// Config
/////////////////////////////////////////////////////////////////////

export type ChainConfig<
  formatters extends ChainFormatters | undefined = ChainFormatters | undefined,
  custom extends Record<string, unknown> | undefined =
    | Record<string, unknown>
    | undefined,
> = {
  /** Custom chain data. */
  custom?: custom | undefined
  /** Modifies how fees are derived. */
  fees?: ChainFees<formatters | undefined> | undefined
  /** Modifies how data is formatted and typed (e.g. blocks and transactions) */
  formatters?: formatters | undefined
  /** Modifies how data is serialized (e.g. transactions). */
  serializers?: ChainSerializers<formatters> | undefined
}

/////////////////////////////////////////////////////////////////////
// Fees
/////////////////////////////////////////////////////////////////////

export type ChainFeesFnParameters<
  formatters extends ChainFormatters | undefined = ChainFormatters | undefined,
> = {
  /** The latest block. */
  block: Prettify<
    FormattedBlock<Omit<Chain, 'formatters'> & { formatters: formatters }>
  >
  client: Client<Transport, Chain>
  /**
   * A transaction request. This value will be undefined if the caller
   * is outside of a transaction request context (e.g. a direct call to
   * the `estimateFeesPerGas` Action).
   */
  request?:
    | PrepareTransactionRequestParameters<
        Omit<Chain, 'formatters'> & { formatters: formatters },
        Account | undefined,
        undefined
      >
    | undefined
}

export type ChainEstimateFeesPerGasFnParameters<
  formatters extends ChainFormatters | undefined = ChainFormatters | undefined,
> = {
  /** A function to multiply the base fee based on the `baseFeeMultiplier` value. */
  multiply: (x: bigint) => bigint
  /** The type of fees to return. */
  type: FeeValuesType
} & ChainFeesFnParameters<formatters>

export type ChainEstimateFeesPerGasFn<
  formatters extends ChainFormatters | undefined = ChainFormatters | undefined,
> = (
  args: ChainEstimateFeesPerGasFnParameters<formatters>,
) => Promise<EstimateFeesPerGasReturnType | null>

export type ChainMaxPriorityFeePerGasFn<
  formatters extends ChainFormatters | undefined = ChainFormatters | undefined,
> = (
  args: ChainFeesFnParameters<formatters>,
) => Promise<bigint | null> | bigint | null

export type ChainFees<
  formatters extends ChainFormatters | undefined = ChainFormatters | undefined,
> = {
  /**
   * The fee multiplier to use to account for fee fluctuations.
   * Used in the [`estimateFeesPerGas` Action](/docs/actions/public/estimateFeesPerGas).
   *
   * @default 1.2
   */
  baseFeeMultiplier?:
    | number
    | ((args: ChainFeesFnParameters<formatters>) => Promise<number> | number)
  /**
   * The default `maxPriorityFeePerGas` to use when a priority
   * fee is not defined upon sending a transaction.
   *
   * Overrides the return value in the [`estimateMaxPriorityFeePerGas` Action](/docs/actions/public/estimateMaxPriorityFeePerGas).
   */
  maxPriorityFeePerGas?:
    | bigint
    | ChainMaxPriorityFeePerGasFn<formatters>
    | undefined
  /** @deprecated Use `maxPriorityFeePerGas` instead. */
  defaultPriorityFee?:
    | bigint
    | ChainMaxPriorityFeePerGasFn<formatters>
    | undefined
  /**
   * Allows customization of fee per gas values (e.g. `maxFeePerGas`/`maxPriorityFeePerGas`).
   *
   * Overrides the return value in the [`estimateFeesPerGas` Action](/docs/actions/public/estimateFeesPerGas).
   */
  estimateFeesPerGas?: ChainEstimateFeesPerGasFn<formatters> | undefined
}

/////////////////////////////////////////////////////////////////////
// Formatters
/////////////////////////////////////////////////////////////////////

export type ChainFormatters = {
  /** Modifies how the Block structure is formatted & typed. */
  block?: ChainFormatter<'block'> | undefined
  /** Modifies how the Transaction structure is formatted & typed. */
  transaction?: ChainFormatter<'transaction'> | undefined
  /** Modifies how the TransactionReceipt structure is formatted & typed. */
  transactionReceipt?: ChainFormatter<'transactionReceipt'> | undefined
  /** Modifies how the TransactionRequest structure is formatted & typed. */
  transactionRequest?: ChainFormatter<'transactionRequest'> | undefined
}

export type ChainFormatter<type extends string = string> = {
  format: (args: any) => any
  type: type
}

/////////////////////////////////////////////////////////////////////
// Serializers
/////////////////////////////////////////////////////////////////////

export type ChainSerializers<
  formatters extends ChainFormatters | undefined = undefined,
  ///
  transaction extends
    TransactionSerializableGeneric = formatters extends ChainFormatters
    ? formatters['transactionRequest'] extends ChainFormatter
      ? TransactionSerializableGeneric &
          Parameters<formatters['transactionRequest']['format']>[0]
      : TransactionSerializable
    : TransactionSerializable,
> = {
  /** Modifies how Transactions are serialized. */
  transaction?:
    | SerializeTransactionFn<transaction, TransactionSerializedGeneric>
    | undefined
}

/////////////////////////////////////////////////////////////////////
// Utils
/////////////////////////////////////////////////////////////////////

export type ExtractChainFormatterExclude<
  chain extends Chain | undefined,
  type extends keyof ChainFormatters,
> = chain extends { formatters?: infer formatters extends ChainFormatters }
  ? formatters[type] extends { exclude: infer exclude }
    ? Extract<exclude, readonly string[]>[number]
    : ''
  : ''

export type ExtractChainFormatterParameters<
  chain extends Chain | undefined,
  type extends keyof ChainFormatters,
  fallback,
> = chain extends { formatters?: infer formatters extends ChainFormatters }
  ? formatters[type] extends ChainFormatter
    ? Parameters<formatters[type]['format']>[0]
    : fallback
  : fallback

export type ExtractChainFormatterReturnType<
  chain extends Chain | undefined,
  type extends keyof ChainFormatters,
  fallback,
> = IsNarrowable<chain, Chain> extends true
  ? chain extends {
      formatters?:
        | { [_ in type]?: infer formatter extends ChainFormatter }
        | undefined
    }
    ? chain['formatters'] extends undefined
      ? fallback
      : IsNarrowable<formatter, ChainFormatter<type>> extends true
        ? ReturnType<formatter['format']>
        : fallback
    : fallback
  : fallback

export type DeriveChain<
  chain extends Chain | undefined,
  chainOverride extends Chain | undefined,
> = chainOverride extends Chain ? chainOverride : chain

export type GetChainParameter<
  chain extends Chain | undefined,
  chainOverride extends Chain | undefined = Chain | undefined,
> = IsUndefined<chain> extends true
  ? { chain: chainOverride | null }
  : { chain?: chainOverride | null | undefined }

/////////////////////////////////////////////////////////////////////
// Constants
/////////////////////////////////////////////////////////////////////

type ChainBlockExplorer = {
  name: string
  url: string
  apiUrl?: string | undefined
}

export type ChainContract = {
  address: Address
  blockCreated?: number | undefined
}

type ChainNativeCurrency = {
  name: string
  /** 2-6 characters long */
  symbol: string
  decimals: number
}

type ChainRpcUrls = {
  http: readonly string[]
  webSocket?: readonly string[] | undefined
}
</file>

<file path="src/types/contract.test-d.ts">
import {
  type Abi,
  type Address,
  type ResolvedRegister,
  parseAbi,
} from 'abitype'
import type { seaportAbi } from 'abitype/abis'
import { expectTypeOf, test } from 'vitest'

import type {
  AbiEventParameterToPrimitiveType,
  AbiEventParametersToPrimitiveTypes,
  AbiEventTopicToPrimitiveType,
  ContractFunctionArgs,
  ContractFunctionName,
  ContractFunctionParameters,
  ContractFunctionReturnType,
  ExtractAbiFunctionForArgs,
  GetEventArgs,
  GetValue,
  LogTopicType,
  Widen,
} from './contract.js'
import type { Hex } from './misc.js'

test('ContractFunctionName', () => {
  expectTypeOf<ContractFunctionName<typeof seaportAbi>>().toEqualTypeOf<
    | 'cancel'
    | 'fulfillBasicOrder'
    | 'fulfillBasicOrder_efficient_6GL6yc'
    | 'fulfillOrder'
    | 'fulfillAdvancedOrder'
    | 'fulfillAvailableOrders'
    | 'fulfillAvailableAdvancedOrders'
    | 'getContractOffererNonce'
    | 'getOrderHash'
    | 'getOrderStatus'
    | 'getCounter'
    | 'incrementCounter'
    | 'information'
    | 'name'
    | 'matchAdvancedOrders'
    | 'matchOrders'
    | 'validate'
  >()

  expectTypeOf<
    ContractFunctionName<typeof seaportAbi, 'pure' | 'view'>
  >().toEqualTypeOf<
    | 'name'
    | 'getContractOffererNonce'
    | 'getCounter'
    | 'getOrderHash'
    | 'getOrderStatus'
    | 'information'
  >()
})

test('ContractFunctionArgs', () => {
  expectTypeOf<
    ContractFunctionArgs<typeof seaportAbi, 'pure' | 'view', 'getOrderStatus'>
  >().toEqualTypeOf<readonly [Address]>()

  const abi = parseAbi([
    'function foo() view returns (int8)',
    'function foo(address) view returns (string)',
    'function foo(address, address) view returns ((address foo, address bar))',
    'function bar() view returns (int8)',
  ])
  expectTypeOf<
    ContractFunctionArgs<typeof abi, 'pure' | 'view', 'foo'>
  >().toEqualTypeOf<
    readonly [] | readonly [Address] | readonly [Address, Address]
  >()
})

test('ContractFunctionParameters', () => {
  type Result = ContractFunctionParameters<
    typeof seaportAbi,
    'pure' | 'view',
    'getOrderStatus'
  >
  expectTypeOf<Result['args']>().toEqualTypeOf<readonly [Address]>()
})

test('ContractFunctionReturnType', () => {
  type Result = ContractFunctionReturnType<
    typeof seaportAbi,
    'pure' | 'view',
    'getOrderStatus'
  >
  expectTypeOf<Result>().toEqualTypeOf<
    readonly [boolean, boolean, bigint, bigint]
  >()
})

test('Widen', () => {
  expectTypeOf<Widen<1>>().toEqualTypeOf<number>()
  expectTypeOf<Widen<1n>>().toEqualTypeOf<bigint>()
  expectTypeOf<Widen<true>>().toEqualTypeOf<boolean>()
  expectTypeOf<Widen<'foo'>>().toEqualTypeOf<string>()
  expectTypeOf<Widen<'0x123'>>().toEqualTypeOf<Address>()
  expectTypeOf<Widen<'0xbytes'>>().toEqualTypeOf<
    ResolvedRegister['BytesType']['inputs']
  >()

  expectTypeOf<Widen<[]>>().toEqualTypeOf<readonly []>()

  expectTypeOf<Widen<{ foo: 'bar'; boo: 123n }>>().toEqualTypeOf<{
    foo: string
    boo: bigint
  }>()
  expectTypeOf<Widen<{ foo: 'bar'; boo: [123n] }>>().toEqualTypeOf<{
    foo: string
    boo: readonly [bigint]
  }>()

  expectTypeOf<Widen<[123n]>>().toEqualTypeOf<readonly [bigint]>()
  expectTypeOf<Widen<[{ foo: 'bar'; boo: 123n }]>>().toEqualTypeOf<
    readonly [{ foo: string; boo: bigint }]
  >()

  expectTypeOf<Widen<123n[]>>().toEqualTypeOf<readonly bigint[]>()
  expectTypeOf<Widen<(123n | '0x')[]>>().toEqualTypeOf<
    readonly (bigint | Address)[]
  >()

  expectTypeOf<Widen<readonly unknown[]>>().toEqualTypeOf<readonly unknown[]>()
})

test('ExtractAbiFunctionForArgs', () => {
  const abi = parseAbi([
    'function foo() view returns (int8)',
    'function foo(address) view returns (string)',
    'function foo(address, address) view returns ((address foo, address bar))',
    'function bar() view returns (int8)',
  ])

  expectTypeOf<
    ExtractAbiFunctionForArgs<typeof abi, 'pure' | 'view', 'foo', []>
  >().toEqualTypeOf<(typeof abi)[0]>()
  expectTypeOf<
    ExtractAbiFunctionForArgs<typeof abi, 'pure' | 'view', 'foo', readonly []>
  >().toEqualTypeOf<(typeof abi)[0]>()
  expectTypeOf<
    ExtractAbiFunctionForArgs<typeof abi, 'pure' | 'view', 'foo', ['0x']>
  >().toEqualTypeOf<(typeof abi)[1]>()
  expectTypeOf<
    ExtractAbiFunctionForArgs<typeof abi, 'pure' | 'view', 'foo', ['0x', '0x']>
  >().toEqualTypeOf<(typeof abi)[2]>()

  expectTypeOf<
    ExtractAbiFunctionForArgs<typeof abi, 'payable', never, never>
  >().toEqualTypeOf<never>()
})

test('ContractFunctionReturnType', () => {
  const abi = parseAbi([
    'function foo() view returns (int8)',
    'function foo(address) view returns (string)',
    'function foo(address, address) view returns ((address foo, address bar))',
    'function bar() view returns (int8)',
  ])

  expectTypeOf<
    ContractFunctionReturnType<typeof abi, 'pure' | 'view', 'foo', readonly []>
  >().toEqualTypeOf<number>()
  expectTypeOf<
    ContractFunctionReturnType<typeof abi, 'pure' | 'view', 'foo'>
  >().toEqualTypeOf<number>()
  expectTypeOf<
    ContractFunctionReturnType<
      typeof abi,
      'pure' | 'view',
      'foo',
      readonly ['0x']
    >
  >().toEqualTypeOf<string>()
  expectTypeOf<
    ContractFunctionReturnType<
      typeof abi,
      'pure' | 'view',
      'foo',
      readonly ['0x', '0x']
    >
  >().toEqualTypeOf<{ foo: Address; bar: Address }>()
})

test('GetEventArgs', () => {
  type Result = GetEventArgs<
    [
      {
        inputs: [
          {
            indexed: true
            name: 'from'
            type: 'address'
          },
          {
            indexed: true
            name: 'to'
            type: 'address'
          },
          {
            indexed: false
            name: 'tokenId'
            type: 'uint256'
          },
        ]
        name: 'Transfer'
        type: 'event'
      },
    ],
    'Transfer'
  >
  expectTypeOf<Result>().toEqualTypeOf<{
    from?: `0x${string}` | `0x${string}`[] | null | undefined
    to?: `0x${string}` | `0x${string}`[] | null | undefined
  }>()
})

test('GetValue', () => {
  // payable
  type Result = GetValue<typeof seaportAbi, 'fulfillAdvancedOrder'>
  expectTypeOf<Result>().toEqualTypeOf<{ value?: bigint }>()

  // other
  expectTypeOf<GetValue<typeof seaportAbi, 'getOrderStatus'>>().toEqualTypeOf<{
    value?: never
  }>()
  expectTypeOf<GetValue<typeof seaportAbi, 'cancel'>>().toEqualTypeOf<{
    value?: never
  }>()

  // unknown abi
  expectTypeOf<GetValue<Abi, 'foo'>>().toEqualTypeOf<{
    value?: bigint | undefined
  }>()
  const abi = [
    {
      type: 'function',
      name: 'foo',
      inputs: [],
      outputs: [{ type: 'uint256' }],
    },
  ]
  expectTypeOf<GetValue<typeof abi, 'foo'>>().toEqualTypeOf<{
    value?: bigint | undefined
  }>()
})

// -----------------------------------------------------------------------------------------------

test('LogTopicType', () => {
  expectTypeOf<LogTopicType<string, Hex>>().toEqualTypeOf<string>()
  expectTypeOf<LogTopicType<string, Hex[]>>().toEqualTypeOf<string[]>()
  expectTypeOf<LogTopicType<string, null>>().toEqualTypeOf<null>()

  expectTypeOf<LogTopicType<string, Hex | null>>().toEqualTypeOf<
    string | null
  >()
})

test('AbiEventParameterToPrimitiveType', () => {
  expectTypeOf<
    AbiEventParameterToPrimitiveType<{ name: 'foo'; type: 'string' }>
  >().toEqualTypeOf<string | string[] | null>()
  expectTypeOf<
    AbiEventParameterToPrimitiveType<
      { name: 'foo'; type: 'string' },
      { EnableUnion: false }
    >
  >().toEqualTypeOf<string>()
})

test('AbiEventTopicToPrimitiveType', () => {
  expectTypeOf<
    AbiEventTopicToPrimitiveType<{ name: 'foo'; type: 'string' }, Hex>
  >().toEqualTypeOf<`0x${string}`>()
  expectTypeOf<
    AbiEventTopicToPrimitiveType<{ name: 'foo'; type: 'string' }, Hex[]>
  >().toEqualTypeOf<`0x${string}`[][]>() // TODO: Is this correct?
  expectTypeOf<
    AbiEventTopicToPrimitiveType<{ name: 'foo'; type: 'string' }, null>
  >().toEqualTypeOf<null>()

  expectTypeOf<
    AbiEventTopicToPrimitiveType<{ name: 'foo'; type: 'string' }, Hex | null>
  >().toEqualTypeOf<`0x${string}` | null>()

  expectTypeOf<
    AbiEventTopicToPrimitiveType<{ name: 'foo'; type: 'bool' }, Hex>
  >().toEqualTypeOf<boolean>()
  expectTypeOf<
    AbiEventTopicToPrimitiveType<{ name: 'foo'; type: 'bool' }, Hex[]>
  >().toEqualTypeOf<boolean[]>()
})

test('AbiEventParametersToPrimitiveTypes', () => {
  // named parameters
  expectTypeOf<
    AbiEventParametersToPrimitiveTypes<
      [{ name: 'foo'; type: 'string'; indexed: true }]
    >
  >().toEqualTypeOf<{
    foo?: string | string[] | null | undefined
  }>()
  expectTypeOf<
    AbiEventParametersToPrimitiveTypes<
      [
        { name: 'foo'; type: 'string'; indexed: true },
        { name: 'bar'; type: 'uint8'; indexed: true },
        { name: 'baz'; type: 'address'; indexed: false },
      ]
    >
  >().toEqualTypeOf<{
    foo?: string | string[] | null | undefined
    bar?: number | number[] | null | undefined
  }>()

  type Named_AllowNonIndexed = AbiEventParametersToPrimitiveTypes<
    [
      { name: 'foo'; type: 'string'; indexed: true },
      { name: 'bar'; type: 'uint8'; indexed: true },
      { name: 'baz'; type: 'address'; indexed: false },
    ],
    {
      EnableUnion: true
      IndexedOnly: false
      Required: false
    }
  >
  expectTypeOf<Named_AllowNonIndexed>().toEqualTypeOf<{
    foo?: string | string[] | null | undefined
    bar?: number | number[] | null | undefined
    baz?: `0x${string}` | `0x${string}`[] | null | undefined
  }>()
  type Named_DisableUnion = AbiEventParametersToPrimitiveTypes<
    [
      { name: 'foo'; type: 'string'; indexed: true },
      { name: 'bar'; type: 'uint8'; indexed: true },
      { name: 'baz'; type: 'address'; indexed: false },
    ],
    {
      EnableUnion: false
      IndexedOnly: true
      Required: false
    }
  >
  expectTypeOf<Named_DisableUnion>().toEqualTypeOf<{
    foo?: string
    bar?: number
  }>()

  // unnamed parameters
  expectTypeOf<
    AbiEventParametersToPrimitiveTypes<
      [
        { type: 'string'; indexed: true },
        { type: 'uint8'; indexed: true },
        {
          type: 'address'
          indexed: false
        },
      ]
    >
  >().toEqualTypeOf<
    | readonly []
    | readonly [string | string[] | null]
    | readonly [string | string[] | null, number | number[] | null]
  >()

  type Unnamed_AllowNonIndexed = AbiEventParametersToPrimitiveTypes<
    [
      { type: 'string'; indexed: true },
      { type: 'uint8'; indexed: true },
      { type: 'address'; indexed: false },
    ],
    {
      EnableUnion: true
      IndexedOnly: false
      Required: false
    }
  >
  expectTypeOf<Unnamed_AllowNonIndexed>().toEqualTypeOf<
    | readonly []
    | readonly [string | string[] | null]
    | readonly [string | string[] | null, number | number[] | null]
    | readonly [
        string | string[] | null,
        number | number[] | null,
        `0x${string}` | `0x${string}`[] | null,
      ]
  >()

  type Unnamed_DisableUnion = AbiEventParametersToPrimitiveTypes<
    [
      { type: 'string'; indexed: true },
      { type: 'uint8'; indexed: true },
      { type: 'address'; indexed: false },
    ],
    {
      EnableUnion: false
      IndexedOnly: true
      Required: false
    }
  >
  expectTypeOf<Unnamed_DisableUnion>().toEqualTypeOf<
    readonly [] | readonly [string] | readonly [string, number]
  >()

  // mixed parameters (named and unnamed)
  expectTypeOf<
    AbiEventParametersToPrimitiveTypes<
      [
        { type: 'string'; indexed: true },
        { named: 'bar'; type: 'uint8'; indexed: true },
      ]
    >
  >().toEqualTypeOf<
    | readonly []
    | readonly [string | string[] | null]
    | readonly [string | string[] | null, number | number[] | null]
  >()
})
</file>

<file path="src/types/contract.ts">
import type {
  Abi,
  AbiEvent,
  AbiFunction,
  AbiParameter,
  AbiParameterToPrimitiveType,
  AbiParametersToPrimitiveTypes,
  AbiStateMutability,
  Address,
  ExtractAbiError,
  ExtractAbiErrorNames,
  ExtractAbiEvent,
  ExtractAbiEventNames,
  ExtractAbiFunction,
  ExtractAbiFunctionNames,
  ResolvedRegister,
} from 'abitype'

import type { Hex, LogTopic } from './misc.js'
import type { TransactionRequest } from './transaction.js'
import type {
  Filter,
  IsNarrowable,
  IsUnion,
  MaybeRequired,
  NoInfer,
  Prettify,
  UnionToTuple,
} from './utils.js'

export type ContractFunctionName<
  abi extends Abi | readonly unknown[] = Abi,
  mutability extends AbiStateMutability = AbiStateMutability,
> = ExtractAbiFunctionNames<
  abi extends Abi ? abi : Abi,
  mutability
> extends infer functionName extends string
  ? [functionName] extends [never]
    ? string
    : functionName
  : string

export type ContractErrorName<abi extends Abi | readonly unknown[] = Abi> =
  ExtractAbiErrorNames<
    abi extends Abi ? abi : Abi
  > extends infer errorName extends string
    ? [errorName] extends [never]
      ? string
      : errorName
    : string

export type ContractEventName<abi extends Abi | readonly unknown[] = Abi> =
  ExtractAbiEventNames<
    abi extends Abi ? abi : Abi
  > extends infer eventName extends string
    ? [eventName] extends [never]
      ? string
      : eventName
    : string

export type ContractFunctionArgs<
  abi extends Abi | readonly unknown[] = Abi,
  mutability extends AbiStateMutability = AbiStateMutability,
  functionName extends ContractFunctionName<
    abi,
    mutability
  > = ContractFunctionName<abi, mutability>,
> = AbiParametersToPrimitiveTypes<
  ExtractAbiFunction<
    abi extends Abi ? abi : Abi,
    functionName,
    mutability
  >['inputs'],
  'inputs'
> extends infer args
  ? [args] extends [never]
    ? readonly unknown[]
    : args
  : readonly unknown[]

export type ContractConstructorArgs<
  abi extends Abi | readonly unknown[] = Abi,
> = AbiParametersToPrimitiveTypes<
  Extract<
    (abi extends Abi ? abi : Abi)[number],
    { type: 'constructor' }
  >['inputs'],
  'inputs'
> extends infer args
  ? [args] extends [never]
    ? readonly unknown[]
    : args
  : readonly unknown[]

export type ContractErrorArgs<
  abi extends Abi | readonly unknown[] = Abi,
  errorName extends ContractErrorName<abi> = ContractErrorName<abi>,
> = AbiParametersToPrimitiveTypes<
  ExtractAbiError<abi extends Abi ? abi : Abi, errorName>['inputs'],
  'inputs'
> extends infer args
  ? [args] extends [never]
    ? readonly unknown[]
    : args
  : readonly unknown[]

export type ContractEventArgs<
  abi extends Abi | readonly unknown[] = Abi,
  eventName extends ContractEventName<abi> = ContractEventName<abi>,
> = AbiEventParametersToPrimitiveTypes<
  ExtractAbiEvent<abi extends Abi ? abi : Abi, eventName>['inputs']
> extends infer args
  ? [args] extends [never]
    ? readonly unknown[] | Record<string, unknown>
    : args
  : readonly unknown[] | Record<string, unknown>

export type ContractEventArgsFromTopics<
  abi extends Abi | readonly unknown[] = Abi,
  eventName extends ContractEventName<abi> = ContractEventName<abi>,
  strict extends boolean = true,
> = AbiEventParametersToPrimitiveTypes<
  ExtractAbiEvent<abi extends Abi ? abi : Abi, eventName>['inputs'],
  { EnableUnion: false; IndexedOnly: false; Required: strict }
> extends infer args
  ? [args] extends [never]
    ? readonly unknown[] | Record<string, unknown>
    : args
  : readonly unknown[] | Record<string, unknown>

export type Widen<type> =
  | ([unknown] extends [type] ? unknown : never)
  | (type extends Function ? type : never)
  | (type extends ResolvedRegister['BigIntType'] ? bigint : never)
  | (type extends boolean ? boolean : never)
  | (type extends ResolvedRegister['IntType'] ? number : never)
  | (type extends string
      ? type extends ResolvedRegister['AddressType']
        ? ResolvedRegister['AddressType']
        : type extends ResolvedRegister['BytesType']['inputs']
          ? ResolvedRegister['BytesType']
          : string
      : never)
  | (type extends readonly [] ? readonly [] : never)
  | (type extends Record<string, unknown>
      ? { [K in keyof type]: Widen<type[K]> }
      : never)
  | (type extends { length: number }
      ? {
          [K in keyof type]: Widen<type[K]>
        } extends infer Val extends readonly unknown[]
        ? readonly [...Val]
        : never
      : never)

export type UnionWiden<type> = type extends any ? Widen<type> : never

export type ExtractAbiFunctionForArgs<
  abi extends Abi,
  mutability extends AbiStateMutability,
  functionName extends ContractFunctionName<abi, mutability>,
  args extends ContractFunctionArgs<abi, mutability, functionName>,
> = ExtractAbiFunction<
  abi,
  functionName,
  mutability
> extends infer abiFunction extends AbiFunction
  ? IsUnion<abiFunction> extends true // narrow overloads using `args` by converting to tuple and filtering out overloads that don't match
    ? UnionToTuple<abiFunction> extends infer abiFunctions extends
        readonly AbiFunction[]
      ? // convert back to union (removes `never` tuple entries)
        { [k in keyof abiFunctions]: CheckArgs<abiFunctions[k], args> }[number]
      : never
    : abiFunction
  : never
type CheckArgs<
  abiFunction extends AbiFunction,
  args,
  ///
  targetArgs extends AbiParametersToPrimitiveTypes<
    abiFunction['inputs'],
    'inputs'
  > = AbiParametersToPrimitiveTypes<abiFunction['inputs'], 'inputs'>,
> = (readonly [] extends args ? readonly [] : args) extends targetArgs // fallback to `readonly []` if `args` has no value (e.g. `args` property not provided)
  ? abiFunction
  : never

export type ContractFunctionParameters<
  abi extends Abi | readonly unknown[] = Abi,
  mutability extends AbiStateMutability = AbiStateMutability,
  functionName extends ContractFunctionName<
    abi,
    mutability
  > = ContractFunctionName<abi, mutability>,
  args extends ContractFunctionArgs<
    abi,
    mutability,
    functionName
  > = ContractFunctionArgs<abi, mutability, functionName>,
  deployless extends boolean = false,
  ///
  allFunctionNames = ContractFunctionName<abi, mutability>,
  allArgs = ContractFunctionArgs<abi, mutability, functionName>,
  // when `args` is inferred to `readonly []` ("inputs": []) or `never` (`abi` declared as `Abi` or not inferrable), allow `args` to be optional.
  // important that both branches return same structural type
> = {
  abi: abi
  functionName:
    | allFunctionNames // show all options
    | (functionName extends allFunctionNames ? functionName : never) // infer value
  args?: (abi extends Abi ? UnionWiden<args> : never) | allArgs | undefined
} & (readonly [] extends allArgs ? {} : { args: Widen<args> }) &
  (deployless extends true
    ? { address?: undefined; code: Hex }
    : { address: Address })

export type ContractFunctionReturnType<
  abi extends Abi | readonly unknown[] = Abi,
  mutability extends AbiStateMutability = AbiStateMutability,
  functionName extends ContractFunctionName<
    abi,
    mutability
  > = ContractFunctionName<abi, mutability>,
  args extends ContractFunctionArgs<
    abi,
    mutability,
    functionName
  > = ContractFunctionArgs<abi, mutability, functionName>,
> = abi extends Abi
  ? Abi extends abi
    ? unknown
    : AbiParametersToPrimitiveTypes<
          ExtractAbiFunctionForArgs<
            abi,
            mutability,
            functionName,
            args
          >['outputs']
        > extends infer types
      ? types extends readonly []
        ? void
        : types extends readonly [infer type]
          ? type
          : types
      : never
  : unknown

export type AbiItem = Abi[number]

export type ExtractAbiItemNames<abi extends Abi> = Extract<
  abi[number],
  { name: string }
>['name']

export type ExtractAbiItem<
  abi extends Abi,
  name extends ExtractAbiItemNames<abi>,
> = Extract<abi[number], { name: name }>

export type AbiItemName<abi extends Abi | readonly unknown[] = Abi> =
  abi extends Abi ? ExtractAbiItemNames<abi> : string

export type AbiItemArgs<
  abi extends Abi | readonly unknown[] = Abi,
  name extends AbiItemName<abi> = AbiItemName<abi>,
> = AbiParametersToPrimitiveTypes<
  ExtractAbiItem<abi extends Abi ? abi : Abi, name>['inputs'],
  'inputs'
> extends infer args
  ? [args] extends [never]
    ? readonly unknown[]
    : args
  : readonly unknown[]

export type ExtractAbiItemForArgs<
  abi extends Abi,
  name extends AbiItemName<abi>,
  args extends AbiItemArgs<abi, name>,
> = ExtractAbiItem<abi, name> extends infer abiItem extends AbiItem & {
  inputs: readonly AbiParameter[]
}
  ? IsUnion<abiItem> extends true // narrow overloads using `args` by converting to tuple and filtering out overloads that don't match
    ? UnionToTuple<abiItem> extends infer abiItems extends readonly (AbiItem & {
        inputs: readonly AbiParameter[]
      })[]
      ? {
          [k in keyof abiItems]: (
            readonly [] extends args
              ? readonly [] // fallback to `readonly []` if `args` has no value (e.g. `args` property not provided)
              : args
          ) extends AbiParametersToPrimitiveTypes<
            abiItems[k]['inputs'],
            'inputs'
          >
            ? abiItems[k]
            : never
        }[number] // convert back to union (removes `never` tuple entries: `['foo', never, 'bar'][number]` => `'foo' | 'bar'`)
      : never
    : abiItem
  : never

export type EventDefinition = `${string}(${string})`

export type GetValue<
  abi extends Abi | readonly unknown[],
  functionName extends string,
  valueType = TransactionRequest['value'],
  abiFunction extends AbiFunction = abi extends Abi
    ? ExtractAbiFunction<abi, functionName>
    : AbiFunction,
  _Narrowable extends boolean = IsNarrowable<abi, Abi>,
> = _Narrowable extends true
  ? abiFunction['stateMutability'] extends 'payable'
    ? { value?: NoInfer<valueType> | undefined }
    : abiFunction['payable'] extends true
      ? { value?: NoInfer<valueType> | undefined }
      : { value?: undefined }
  : { value?: NoInfer<valueType> | undefined }

//////////////////////////////////////////////////////////////////////////////////////////////////

export type MaybeAbiEventName<abiEvent extends AbiEvent | undefined> =
  abiEvent extends AbiEvent ? abiEvent['name'] : undefined

export type MaybeExtractEventArgsFromAbi<
  abi extends Abi | readonly unknown[] | undefined,
  eventName extends string | undefined,
> = abi extends Abi | readonly unknown[]
  ? eventName extends string
    ? GetEventArgs<abi, eventName>
    : undefined
  : undefined

//////////////////////////////////////////////////////////////////////
// ABI item args

export type GetEventArgs<
  abi extends Abi | readonly unknown[],
  eventName extends string,
  config extends EventParameterOptions = DefaultEventParameterOptions,
  abiEvent extends AbiEvent & { type: 'event' } = abi extends Abi
    ? ExtractAbiEvent<abi, eventName>
    : AbiEvent & { type: 'event' },
  args = AbiEventParametersToPrimitiveTypes<abiEvent['inputs'], config>,
  FailedToParseArgs =
    | ([args] extends [never] ? true : false)
    | (readonly unknown[] extends args ? true : false),
> = true extends FailedToParseArgs
  ? readonly unknown[] | Record<string, unknown>
  : args

//////////////////////////////////////////////////////////////////////
// ABI event types

type EventParameterOptions = {
  EnableUnion?: boolean
  IndexedOnly?: boolean
  Required?: boolean
}
type DefaultEventParameterOptions = {
  EnableUnion: true
  IndexedOnly: true
  Required: false
}

export type AbiEventParametersToPrimitiveTypes<
  abiParameters extends readonly AbiParameter[],
  //
  _options extends EventParameterOptions = DefaultEventParameterOptions,
  // Remove non-indexed parameters based on `Options['IndexedOnly']`
> = abiParameters extends readonly []
  ? readonly []
  : Filter<
        abiParameters,
        _options['IndexedOnly'] extends true ? { indexed: true } : object
      > extends infer Filtered extends readonly AbiParameter[]
    ? _HasUnnamedAbiParameter<Filtered> extends true
      ? // Has unnamed tuple parameters so return as array
          | readonly [
              ...{
                [K in keyof Filtered]: AbiEventParameterToPrimitiveType<
                  Filtered[K],
                  _options
                >
              },
            ]
          // Distribute over tuple to represent optional parameters
          | (_options['Required'] extends true
              ? never
              : // Distribute over tuple to represent optional parameters
                Filtered extends readonly [
                    ...infer Head extends readonly AbiParameter[],
                    infer _,
                  ]
                ? AbiEventParametersToPrimitiveTypes<
                    readonly [...{ [K in keyof Head]: Omit<Head[K], 'name'> }],
                    _options
                  >
                : never)
      : // All tuple parameters are named so return as object
        {
            [Parameter in Filtered[number] as Parameter extends {
              name: infer Name extends string
            }
              ? Name
              : never]?:
              | AbiEventParameterToPrimitiveType<Parameter, _options>
              | undefined
          } extends infer Mapped
        ? Prettify<
            MaybeRequired<
              Mapped,
              _options['Required'] extends boolean
                ? _options['Required']
                : false
            >
          >
        : never
    : never

// TODO: Speed up by returning immediately as soon as named parameter is found.
type _HasUnnamedAbiParameter<abiParameters extends readonly AbiParameter[]> =
  abiParameters extends readonly [
    infer Head extends AbiParameter,
    ...infer Tail extends readonly AbiParameter[],
  ]
    ? Head extends { name: string }
      ? Head['name'] extends ''
        ? true
        : _HasUnnamedAbiParameter<Tail>
      : true
    : false

/**
 * @internal
 */
export type LogTopicType<
  primitiveType = Hex,
  topic extends LogTopic = LogTopic,
> = topic extends Hex
  ? primitiveType
  : topic extends Hex[]
    ? primitiveType[]
    : topic extends null
      ? null
      : never

/**
 * @internal
 */
export type AbiEventParameterToPrimitiveType<
  abiParameter extends AbiParameter,
  //
  _options extends EventParameterOptions = DefaultEventParameterOptions,
  _type = AbiParameterToPrimitiveType<abiParameter>,
> = _options['EnableUnion'] extends true ? LogTopicType<_type> : _type

type HashedEventTypes = 'bytes' | 'string' | 'tuple' | `${string}[${string}]`

/**
 * @internal
 */
export type AbiEventTopicToPrimitiveType<
  abiParameter extends AbiParameter,
  topic extends LogTopic,
  primitiveType = abiParameter['type'] extends HashedEventTypes
    ? topic
    : AbiParameterToPrimitiveType<abiParameter>,
> = LogTopicType<primitiveType, topic>
</file>

<file path="src/types/eip1193.test-d.ts">
import type { Address } from 'abitype'
import { expectTypeOf, test } from 'vitest'
import type {
  EIP1193Parameters,
  EIP1193RequestFn,
  PublicRpcSchema,
  TestRpcSchema,
  WalletRpcSchema,
} from './eip1193.js'
import type { Hash, Hex } from './misc.js'
import type { Quantity, RpcLog, RpcTransaction } from './rpc.js'

test('default', async () => {
  type DefaultRequestFn = EIP1193RequestFn
  type DefaultParameters = EIP1193Parameters

  const request: DefaultRequestFn = null as any

  const x = await request({ method: 'eth_wagmi' })
  expectTypeOf<typeof x>().toEqualTypeOf<unknown>()

  request({ method: 'eth_wagmi', params: undefined })
  request({ method: 'eth_wagmi', params: [] })
  request({ method: 'eth_wagmi', params: [{ foo: 'bar' }] })

  expectTypeOf<DefaultParameters>().toEqualTypeOf<{
    method: string
    params?: unknown
  }>()
  expectTypeOf<ReturnType<DefaultRequestFn>>().toEqualTypeOf<Promise<unknown>>()
})

test('public methods', async () => {
  type PublicRequestFn = EIP1193RequestFn<PublicRpcSchema>
  type PublicParameters = EIP1193Parameters<PublicRpcSchema>

  const request: PublicRequestFn = null as any

  const x1 = await request({ method: 'eth_blockNumber' })
  expectTypeOf<typeof x1>().toEqualTypeOf<Quantity>()

  const x2 = await request({
    method: 'eth_newFilter',
    params: [{ address: '0x', fromBlock: '0x', toBlock: '0x', topics: ['0x'] }],
  })
  expectTypeOf<typeof x2>().toEqualTypeOf<Quantity>()

  const x3 = await request({
    method: 'eth_getLogs',
    params: [{ address: '0x', fromBlock: '0x', toBlock: '0x', topics: ['0x'] }],
  })
  expectTypeOf<typeof x3>().toEqualTypeOf<RpcLog[]>()

  const x4 = await request<{
    Method: 'eth_wagmi'
    Parameters: undefined
    ReturnType: number
  }>({ method: 'eth_wagmi' })
  expectTypeOf<typeof x4>().toEqualTypeOf<number>()

  // @ts-expect-error
  request({ method: 'eth_newFilter' })
  // @ts-expect-error
  request({ method: 'eth_wagmi' })

  expectTypeOf<PublicParameters['method']>().toEqualTypeOf<
    PublicRpcSchema[number]['Method']
  >()
})

test('wallet methods', async () => {
  type WalletRequestFn = EIP1193RequestFn<WalletRpcSchema>
  type WalletParameters = EIP1193Parameters<WalletRpcSchema>

  const request: WalletRequestFn = null as any

  const x1 = await request({ method: 'eth_accounts' })
  expectTypeOf<typeof x1>().toEqualTypeOf<Address[]>()

  const x2 = await request({
    method: 'eth_sendTransaction',
    params: [
      {
        from: '0x',
      },
    ],
  })
  expectTypeOf<typeof x2>().toEqualTypeOf<Hash>()

  const x3 = await request({
    method: 'personal_sign',
    params: ['0x', '0x'],
  })
  expectTypeOf<typeof x3>().toEqualTypeOf<Hex>()

  const x4 = await request<{
    Method: 'eth_wagmi'
    Parameters: undefined
    ReturnType: number
  }>({ method: 'eth_wagmi' })
  expectTypeOf<typeof x4>().toEqualTypeOf<number>()

  // @ts-expect-error
  request({ method: 'eth_sendTransaction' })
  // @ts-expect-error
  request({ method: 'eth_wagmi' })

  expectTypeOf<WalletParameters['method']>().toEqualTypeOf<
    WalletRpcSchema[number]['Method']
  >()
})

test('test methods (strict)', async () => {
  type TestRequestFn = EIP1193RequestFn<TestRpcSchema<'anvil'>>
  type TestParameters = EIP1193Parameters<TestRpcSchema<'anvil'>>

  const request: TestRequestFn = null as any

  const x1 = await request({
    method: 'anvil_addCompilationResult',
    params: [1],
  })
  expectTypeOf<typeof x1>().toEqualTypeOf<any>()

  const x2 = await request({
    method: 'anvil_enableTraces',
  })
  expectTypeOf<typeof x2>().toEqualTypeOf<void>()

  const x3 = await request({
    method: 'txpool_content',
  })
  expectTypeOf<typeof x3>().toEqualTypeOf<{
    pending: Record<`0x${string}`, Record<string, RpcTransaction>>
    queued: Record<`0x${string}`, Record<string, RpcTransaction>>
  }>()

  const x4 = await request<{
    Parameters: undefined
    ReturnType: number
  }>({ method: 'eth_wagmi' })
  expectTypeOf<typeof x4>().toEqualTypeOf<number>()

  // @ts-expect-error
  request({ method: 'anvil_addCompilationResult' })
  // @ts-expect-error
  request({ method: 'anvil_addCompilationResult', params: 'lol' })
  // @ts-expect-error
  request({ method: 'eth_wagmi' })

  expectTypeOf<TestParameters['method']>().toEqualTypeOf<
    TestRpcSchema<'anvil'>[number]['Method']
  >()
})

test('custom methods (strict)', async () => {
  type CustomSchema = [
    { Method: 'eth_wagmi'; Parameters: [number]; ReturnType: string },
    { Method: 'eth_viem'; Parameters?: never; ReturnType: number },
  ]
  type CustomRequestFn = EIP1193RequestFn<CustomSchema>
  type CustomParameters = EIP1193Parameters<CustomSchema>

  const request: CustomRequestFn = null as any

  const x1 = await request({ method: 'eth_wagmi', params: [1] })
  expectTypeOf<typeof x1>().toEqualTypeOf<string>()

  const x2 = await request<{ Parameters: undefined; ReturnType: number }>({
    method: 'eth_wagmi',
  })
  expectTypeOf<typeof x2>().toEqualTypeOf<number>()

  // @ts-expect-error
  request({ method: 'eth_wagmi' })
  // @ts-expect-error
  request({ method: 'eth_lol' })

  expectTypeOf<CustomParameters['method']>().toEqualTypeOf<
    CustomSchema[number]['Method']
  >()
})
</file>

<file path="src/types/eip1193.ts">
import type { Address } from 'abitype'

import type * as BlockOverrides from 'ox/BlockOverrides'
import type * as Rpc from 'ox/RpcResponse'
import type {
  RpcEstimateUserOperationGasReturnType,
  RpcGetUserOperationByHashReturnType,
  RpcUserOperation,
  RpcUserOperationReceipt,
} from '../account-abstraction/types/rpc.js'
import type { BlockTag } from './block.js'
import type { Hash, Hex, LogTopic } from './misc.js'
import type { RpcStateOverride } from './rpc.js'
import type {
  RpcBlock as Block,
  RpcBlockIdentifier as BlockIdentifier,
  RpcBlockNumber as BlockNumber,
  RpcFeeHistory as FeeHistory,
  RpcLog as Log,
  RpcProof as Proof,
  Quantity,
  RpcTransaction as Transaction,
  RpcTransactionReceipt as TransactionReceipt,
  RpcTransactionRequest as TransactionRequest,
  RpcUncle as Uncle,
} from './rpc.js'
import type { AccessList } from './transaction.js'
import type { ExactPartial, OneOf, PartialBy, Prettify } from './utils.js'

//////////////////////////////////////////////////
// Provider

export type EIP1474Methods = [
  ...PublicRpcSchema,
  ...WalletRpcSchema,
  ...BundlerRpcSchema,
  ...PaymasterRpcSchema,
]

export type EIP1193Provider = Prettify<
  EIP1193Events & {
    request: EIP1193RequestFn<EIP1474Methods>
  }
>

//////////////////////////////////////////////////
// Errors

export type ProviderRpcErrorType = ProviderRpcError & {
  name: 'ProviderRpcError'
}
export class ProviderRpcError extends Error {
  code: number
  details: string

  constructor(code: number, message: string) {
    super(message)
    this.code = code
    this.details = message
  }
}

//////////////////////////////////////////////////
// Provider Events

export type ProviderConnectInfo = {
  chainId: string
}

export type ProviderMessage = {
  type: string
  data: unknown
}

export type EIP1193EventMap = {
  accountsChanged(accounts: Address[]): void
  chainChanged(chainId: string): void
  connect(connectInfo: ProviderConnectInfo): void
  disconnect(error: ProviderRpcError): void
  message(message: ProviderMessage): void
}

export type EIP1193Events = {
  on<event extends keyof EIP1193EventMap>(
    event: event,
    listener: EIP1193EventMap[event],
  ): void
  removeListener<event extends keyof EIP1193EventMap>(
    event: event,
    listener: EIP1193EventMap[event],
  ): void
}

//////////////////////////////////////////////////
// Provider Requests

export type AddEthereumChainParameter = {
  /** A 0x-prefixed hexadecimal string */
  chainId: string
  /** The chain name. */
  chainName: string
  /** Native currency for the chain. */
  nativeCurrency?:
    | {
        name: string
        symbol: string
        decimals: number
      }
    | undefined
  rpcUrls: readonly string[]
  blockExplorerUrls?: string[] | undefined
  iconUrls?: string[] | undefined
}

export type NetworkSync = {
  /** The current block number */
  currentBlock: Quantity
  /** Number of latest block on the network */
  highestBlock: Quantity
  /** Block number at which syncing started */
  startingBlock: Quantity
}

export type WalletCapabilities = {
  [capability: string]: any
}

export type WalletCapabilitiesRecord<
  capabilities extends WalletCapabilities = WalletCapabilities,
  id extends string | number = Hex,
> = {
  [chainId in id]: capabilities
}

export type WalletCallReceipt<quantity = Hex, status = Hex> = {
  logs: {
    address: Hex
    data: Hex
    topics: Hex[]
  }[]
  status: status
  blockHash: Hex
  blockNumber: quantity
  gasUsed: quantity
  transactionHash: Hex
}

export type WalletGrantPermissionsParameters = {
  signer?:
    | {
        type: string
        data?: unknown | undefined
      }
    | undefined
  permissions: readonly {
    data: unknown
    policies: readonly {
      data: unknown
      type: string
    }[]
    required?: boolean | undefined
    type: string
  }[]
  expiry: number
}

export type WalletGrantPermissionsReturnType = {
  expiry: number
  factory?: `0x${string}` | undefined
  factoryData?: string | undefined
  grantedPermissions: readonly {
    data: unknown
    policies: readonly {
      data: unknown
      type: string
    }[]
    required?: boolean | undefined
    type: string
  }[]
  permissionsContext: string
  signerData?:
    | {
        userOpBuilder?: `0x${string}` | undefined
        submitToAddress?: `0x${string}` | undefined
      }
    | undefined
}

export type WalletGetCallsStatusReturnType<
  capabilities extends WalletCapabilities = WalletCapabilities,
  numberType = Hex,
  bigintType = Hex,
  receiptStatus = Hex,
> = {
  atomic: boolean
  capabilities?: capabilities | WalletCapabilities | undefined
  chainId: numberType
  id: string
  receipts?: WalletCallReceipt<bigintType, receiptStatus>[] | undefined
  status: number
  version: string
}

export type WalletPermissionCaveat = {
  type: string
  value: any
}

export type WalletPermission = {
  caveats: WalletPermissionCaveat[]
  date: number
  id: string
  invoker: `http://${string}` | `https://${string}`
  parentCapability: 'eth_accounts' | string
}

export type WalletSendCallsParameters<
  capabilities extends WalletCapabilities = WalletCapabilities,
  chainId extends Hex | number = Hex,
  quantity extends Quantity | bigint = Quantity,
> = [
  {
    atomicRequired: boolean
    calls: readonly {
      capabilities?: capabilities | WalletCapabilities | undefined
      to?: Address | undefined
      data?: Hex | undefined
      value?: quantity | undefined
    }[]
    capabilities?: capabilities | WalletCapabilities | undefined
    chainId?: chainId | undefined
    id?: string | undefined
    from?: Address | undefined
    version: string
  },
]

export type WalletSendCallsReturnType<
  capabilities extends WalletCapabilities = WalletCapabilities,
> = {
  capabilities?: capabilities | undefined
  id: string
}

export type WatchAssetParams = {
  /** Token type. */
  type: 'ERC20'
  options: {
    /** The address of the token contract */
    address: string
    /** A ticker symbol or shorthand, up to 11 characters */
    symbol: string
    /** The number of token decimals */
    decimals: number
    /** A string url of the token logo */
    image?: string | undefined
  }
}

export type BundlerRpcSchema = [
  /**
   * @description Returns the chain ID associated with the current network
   *
   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_chainid
   */
  {
    Method: 'eth_chainId'
    Parameters?: undefined
    ReturnType: Hex
  },
  /**
   * @description Estimate the gas values for a UserOperation.
   *
   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_estimateuseroperationgas
   *
   * @example
   * provider.request({
   *  method: 'eth_estimateUserOperationGas',
   *  params: [{ ... }]
   * })
   * // => { ... }
   */
  {
    Method: 'eth_estimateUserOperationGas'
    Parameters:
      | [userOperation: RpcUserOperation, entrypoint: Address]
      | [
          userOperation: RpcUserOperation,
          entrypoint: Address,
          stateOverrideSet: RpcStateOverride,
        ]
    ReturnType: RpcEstimateUserOperationGasReturnType
  },
  /**
   * @description Return a UserOperation based on a hash.
   *
   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_getuseroperationbyhash
   *
   * @example
   * provider.request({
   *  method: 'eth_getUserOperationByHash',
   *  params: ['0x...']
   * })
   * // => { ... }
   */
  {
    Method: 'eth_getUserOperationByHash'
    Parameters: [hash: Hash]
    ReturnType: RpcGetUserOperationByHashReturnType | null
  },
  /**
   * @description Return a UserOperation receipt based on a hash.
   *
   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_getuseroperationreceipt
   *
   * @example
   * provider.request({
   *  method: 'eth_getUserOperationReceipt',
   *  params: ['0x...']
   * })
   * // => { ... }
   */
  {
    Method: 'eth_getUserOperationReceipt'
    Parameters: [hash: Hash]
    ReturnType: RpcUserOperationReceipt | null
  },
  /**
   * @description Submits a User Operation object to the User Operation pool of the client.
   *
   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_senduseroperation
   *
   * @example
   * provider.request({
   *  method: 'eth_sendUserOperation',
   *  params: [{ ... }]
   * })
   * // => '0x...'
   */
  {
    Method: 'eth_sendUserOperation'
    Parameters: [userOperation: RpcUserOperation, entrypoint: Address]
    ReturnType: Hash
  },
  /**
   * @description Return the list of supported entry points by the client.
   *
   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_supportedentrypoints
   */
  {
    Method: 'eth_supportedEntryPoints'
    Parameters?: undefined
    ReturnType: readonly Address[]
  },
]

export type DebugBundlerRpcSchema = [
  /**
   * @description Clears the bundler mempool and reputation data of paymasters/accounts/factories/aggregators.
   *
   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L1
   */
  {
    Method: 'debug_bundler_clearState'
    Parameters?: undefined
    ReturnType: undefined
  },
  /**
   * @description Returns the current mempool
   *
   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L8
   */
  {
    Method: 'debug_bundler_dumpMempool'
    Parameters: [entryPoint: Address]
    ReturnType: readonly { userOp: RpcUserOperation }[]
  },
  /**
   * @description Forces the bundler to execute the entire current mempool.
   *
   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L19
   */
  {
    Method: 'debug_bundler_sendBundleNow'
    Parameters?: undefined
    ReturnType: Hash
  },
  /**
   * @description Toggles bundling mode between 'auto' and 'manual'
   *
   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L26
   */
  {
    Method: 'debug_bundler_setBundlingMode'
    Parameters: [mode: 'auto' | 'manual']
    ReturnType: undefined
  },
  /**
   * @description Sets reputation of given addresses.
   *
   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L37
   */
  {
    Method: 'debug_bundler_setReputation'
    Parameters: [
      reputations: readonly {
        address: Address
        opsSeen: Hex
        opsIncluded: Hex
      }[],
      entryPoint: Address,
    ]
    ReturnType: undefined
  },
  /**
   * @description Returns the reputation data of all observed addresses.
   *
   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L52
   */
  {
    Method: 'debug_bundler_dumpReputation'
    Parameters: [entryPoint: Address]
    ReturnType: readonly {
      address: Address
      opsSeen: Hex
      opsIncluded: Hex
    }[]
  },
  /**
   * @description Add a bulk of UserOps into the mempool
   *
   * @link https://github.com/eth-infinitism/bundler-spec/blob/a247b5de59a702063ea5b09d6136f119a061642b/src/debug/debug.yaml#L64
   */
  {
    Method: 'debug_bundler_addUserOps'
    Parameters: [userOps: readonly RpcUserOperation[], entryPoint: Address]
    ReturnType: undefined
  },
]

export type PaymasterRpcSchema = [
  /**
   * @description Returns the chain ID associated with the current network
   *
   * @link https://eips.ethereum.org/EIPS/eip-4337#-eth_chainid
   */
  {
    Method: 'pm_getPaymasterStubData'
    Parameters?: [
      userOperation: OneOf<
        | PartialBy<
            Pick<
              RpcUserOperation<'0.6'>,
              | 'callData'
              | 'callGasLimit'
              | 'initCode'
              | 'maxFeePerGas'
              | 'maxPriorityFeePerGas'
              | 'nonce'
              | 'sender'
              | 'preVerificationGas'
              | 'verificationGasLimit'
            >,
            | 'callGasLimit'
            | 'initCode'
            | 'maxFeePerGas'
            | 'maxPriorityFeePerGas'
            | 'preVerificationGas'
            | 'verificationGasLimit'
          >
        | PartialBy<
            Pick<
              RpcUserOperation<'0.7'>,
              | 'callData'
              | 'callGasLimit'
              | 'factory'
              | 'factoryData'
              | 'maxFeePerGas'
              | 'maxPriorityFeePerGas'
              | 'nonce'
              | 'sender'
              | 'preVerificationGas'
              | 'verificationGasLimit'
            >,
            | 'callGasLimit'
            | 'factory'
            | 'factoryData'
            | 'maxFeePerGas'
            | 'maxPriorityFeePerGas'
            | 'preVerificationGas'
            | 'verificationGasLimit'
          >
      >,
      entrypoint: Address,
      chainId: Hex,
      context: unknown,
    ]
    ReturnType: OneOf<
      | { paymasterAndData: Hex }
      | {
          paymaster: Address
          paymasterData: Hex
          paymasterVerificationGasLimit: Hex
          paymasterPostOpGasLimit: Hex
        }
    > & {
      sponsor?: { name: string; icon?: string | undefined } | undefined
      isFinal?: boolean | undefined
    }
  },
  /**
   * @description Returns values to be used in paymaster-related fields of a signed user operation.
   *
   * @link https://github.com/ethereum/ERCs/blob/master/ERCS/erc-7677.md#pm_getpaymasterdata
   */
  {
    Method: 'pm_getPaymasterData'
    Parameters?: [
      userOperation:
        | Pick<
            RpcUserOperation<'0.6'>,
            | 'callData'
            | 'callGasLimit'
            | 'initCode'
            | 'maxFeePerGas'
            | 'maxPriorityFeePerGas'
            | 'nonce'
            | 'sender'
            | 'preVerificationGas'
            | 'verificationGasLimit'
          >
        | Pick<
            RpcUserOperation<'0.7'>,
            | 'callData'
            | 'callGasLimit'
            | 'factory'
            | 'factoryData'
            | 'maxFeePerGas'
            | 'maxPriorityFeePerGas'
            | 'nonce'
            | 'sender'
            | 'preVerificationGas'
            | 'verificationGasLimit'
          >,
      entrypoint: Address,
      chainId: Hex,
      context: unknown,
    ]
    ReturnType: OneOf<
      | { paymasterAndData: Hex }
      | {
          paymaster: Address
          paymasterData: Hex
          paymasterVerificationGasLimit: Hex
          paymasterPostOpGasLimit: Hex
        }
    >
  },
]

export type PublicRpcSchema = [
  /**
   * @description Returns the version of the current client
   *
   * @example
   * provider.request({ method: 'web3_clientVersion' })
   * // => 'MetaMask/v1.0.0'
   */
  {
    Method: 'web3_clientVersion'
    Parameters?: undefined
    ReturnType: string
  },
  /**
   * @description Hashes data using the Keccak-256 algorithm
   *
   * @example
   * provider.request({ method: 'web3_sha3', params: ['0x68656c6c6f20776f726c64'] })
   * // => '0xc94770007dda54cF92009BFF0dE90c06F603a09f'
   */
  {
    Method: 'web3_sha3'
    Parameters: [data: Hash]
    ReturnType: string
  },
  /**
   * @description Determines if this client is listening for new network connections
   *
   * @example
   * provider.request({ method: 'net_listening' })
   * // => true
   */
  {
    Method: 'net_listening'
    Parameters?: undefined
    ReturnType: boolean
  },
  /**
   * @description Returns the number of peers currently connected to this client
   *
   * @example
   * provider.request({ method: 'net_peerCount' })
   * // => '0x1'
   */
  {
    Method: 'net_peerCount'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Returns the chain ID associated with the current network
   *
   * @example
   * provider.request({ method: 'net_version' })
   * // => '1'
   */
  {
    Method: 'net_version'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Returns the base fee per blob gas in wei.
   *
   * @example
   * provider.request({ method: 'eth_blobBaseFee' })
   * // => '0x09184e72a000'
   */
  {
    Method: 'eth_blobBaseFee'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Returns the number of the most recent block seen by this client
   *
   * @example
   * provider.request({ method: 'eth_blockNumber' })
   * // => '0x1b4'
   */
  {
    Method: 'eth_blockNumber'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Executes a new message call immediately without submitting a transaction to the network
   *
   * @example
   * provider.request({ method: 'eth_call', params: [{ to: '0x...', data: '0x...' }] })
   * // => '0x...'
   */
  {
    Method: 'eth_call'
    Parameters:
      | [transaction: ExactPartial<TransactionRequest>]
      | [
          transaction: ExactPartial<TransactionRequest>,
          block: BlockNumber | BlockTag | BlockIdentifier,
        ]
      | [
          transaction: ExactPartial<TransactionRequest>,
          block: BlockNumber | BlockTag | BlockIdentifier,
          stateOverrideSet: RpcStateOverride,
        ]
    ReturnType: Hex
  },
  /**
   * @description Executes a new message call immediately without submitting a transaction to the network
   *
   * @example
   * provider.request({ method: 'eth_call', params: [{ to: '0x...', data: '0x...' }] })
   * // => '0x...'
   */
  {
    Method: 'eth_createAccessList'
    Parameters:
      | [transaction: ExactPartial<TransactionRequest>]
      | [
          transaction: ExactPartial<TransactionRequest>,
          block: BlockNumber | BlockTag | BlockIdentifier,
        ]
    ReturnType: {
      accessList: AccessList
      gasUsed: Quantity
    }
  },
  /**
   * @description Returns the chain ID associated with the current network
   * @example
   * provider.request({ method: 'eth_chainId' })
   * // => '1'
   */
  {
    Method: 'eth_chainId'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Returns the client coinbase address.
   * @example
   * provider.request({ method: 'eth_coinbase' })
   * // => '0x...'
   */
  {
    Method: 'eth_coinbase'
    Parameters?: undefined
    ReturnType: Address
  },
  /**
   * @description Estimates the gas necessary to complete a transaction without submitting it to the network
   *
   * @example
   * provider.request({
   *  method: 'eth_estimateGas',
   *  params: [{ from: '0x...', to: '0x...', value: '0x...' }]
   * })
   * // => '0x5208'
   */
  {
    Method: 'eth_estimateGas'
    Parameters:
      | [transaction: TransactionRequest]
      | [transaction: TransactionRequest, block: BlockNumber | BlockTag]
      | [
          transaction: TransactionRequest,
          block: BlockNumber | BlockTag,
          stateOverride: RpcStateOverride,
        ]
    ReturnType: Quantity
  },
  /**
   * @description Returns a collection of historical gas information
   *
   * @example
   * provider.request({
   *  method: 'eth_feeHistory',
   *  params: ['4', 'latest', ['25', '75']]
   * })
   * // => {
   * //   oldestBlock: '0x1',
   * //   baseFeePerGas: ['0x1', '0x2', '0x3', '0x4'],
   * //   gasUsedRatio: ['0x1', '0x2', '0x3', '0x4'],
   * //   reward: [['0x1', '0x2'], ['0x3', '0x4'], ['0x5', '0x6'], ['0x7', '0x8']]
   * // }
   * */
  {
    Method: 'eth_feeHistory'
    Parameters: [
      /** Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available. */
      blockCount: Quantity,
      /** Highest number block of the requested range. */
      newestBlock: BlockNumber | BlockTag,
      /** A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used. */
      rewardPercentiles: number[] | undefined,
    ]
    ReturnType: FeeHistory
  },
  /**
   * @description Returns the current price of gas expressed in wei
   *
   * @example
   * provider.request({ method: 'eth_gasPrice' })
   * // => '0x09184e72a000'
   */
  {
    Method: 'eth_gasPrice'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Returns the balance of an address in wei
   *
   * @example
   * provider.request({ method: 'eth_getBalance', params: ['0x...', 'latest'] })
   * // => '0x12a05...'
   */
  {
    Method: 'eth_getBalance'
    Parameters: [
      address: Address,
      block: BlockNumber | BlockTag | BlockIdentifier,
    ]
    ReturnType: Quantity
  },
  /**
   * @description Returns information about a block specified by hash
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getBlockByHash', params: ['0x...', true] })
   * // => {
   * //   number: '0x1b4',
   * //   hash: '0x...',
   * //   parentHash: '0x...',
   * //   ...
   * // }
   */
  {
    Method: 'eth_getBlockByHash'
    Parameters: [
      /** hash of a block */
      hash: Hash,
      /** true will pull full transaction objects, false will pull transaction hashes */
      includeTransactionObjects: boolean,
    ]
    ReturnType: Block | null
  },
  /**
   * @description Returns information about a block specified by number
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getBlockByNumber', params: ['0x1b4', true] })
   * // => {
   * //   number: '0x1b4',
   * //   hash: '0x...',
   * //   parentHash: '0x...',
   * //   ...
   * // }
   */
  {
    Method: 'eth_getBlockByNumber'
    Parameters: [
      /** block number, or one of "latest", "safe", "finalized", "earliest" or "pending" */
      block: BlockNumber | BlockTag,
      /** true will pull full transaction objects, false will pull transaction hashes */
      includeTransactionObjects: boolean,
    ]
    ReturnType: Block | null
  },
  /**
   * @description Returns the number of transactions in a block specified by block hash
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getBlockTransactionCountByHash', params: ['0x...'] })
   * // => '0x1'
   */
  {
    Method: 'eth_getBlockTransactionCountByHash'
    Parameters: [hash: Hash]
    ReturnType: Quantity
  },
  /**
   * @description Returns the number of transactions in a block specified by block number
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getBlockTransactionCountByNumber', params: ['0x1b4'] })
   * // => '0x1'
   */
  {
    Method: 'eth_getBlockTransactionCountByNumber'
    Parameters: [block: BlockNumber | BlockTag]
    ReturnType: Quantity
  },
  /**
   * @description Returns the contract code stored at a given address
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getCode', params: ['0x...', 'latest'] })
   * // => '0x...'
   */
  {
    Method: 'eth_getCode'
    Parameters: [
      address: Address,
      block: BlockNumber | BlockTag | BlockIdentifier,
    ]
    ReturnType: Hex
  },
  /**
   * @description Returns a list of all logs based on filter ID since the last log retrieval
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getFilterChanges', params: ['0x...'] })
   * // => [{ ... }, { ... }]
   */
  {
    Method: 'eth_getFilterChanges'
    Parameters: [filterId: Quantity]
    ReturnType: Log[] | Hex[]
  },
  /**
   * @description Returns a list of all logs based on filter ID
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getFilterLogs', params: ['0x...'] })
   * // => [{ ... }, { ... }]
   */
  {
    Method: 'eth_getFilterLogs'
    Parameters: [filterId: Quantity]
    ReturnType: Log[]
  },
  /**
   * @description Returns a list of all logs based on a filter object
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getLogs', params: [{ fromBlock: '0x...', toBlock: '0x...', address: '0x...', topics: ['0x...'] }] })
   * // => [{ ... }, { ... }]
   */
  {
    Method: 'eth_getLogs'
    Parameters: [
      {
        address?: Address | Address[] | undefined
        topics?: LogTopic[] | undefined
      } & (
        | {
            fromBlock?: BlockNumber | BlockTag | undefined
            toBlock?: BlockNumber | BlockTag | undefined
            blockHash?: undefined
          }
        | {
            fromBlock?: undefined
            toBlock?: undefined
            blockHash?: Hash | undefined
          }
      ),
    ]
    ReturnType: Log[]
  },
  /**
   * @description Returns the account and storage values of the specified account including the Merkle-proof.
   * @link https://eips.ethereum.org/EIPS/eip-1186
   * @example
   * provider.request({ method: 'eth_getProof', params: ['0x...', ['0x...'], 'latest'] })
   * // => {
   * //   ...
   * // }
   */
  {
    Method: 'eth_getProof'
    Parameters: [
      /** Address of the account. */
      address: Address,
      /** An array of storage-keys that should be proofed and included. */
      storageKeys: Hash[],
      block: BlockNumber | BlockTag,
    ]
    ReturnType: Proof
  },
  /**
   * @description Returns the value from a storage position at an address
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getStorageAt', params: ['0x...', '0x...', 'latest'] })
   * // => '0x...'
   */
  {
    Method: 'eth_getStorageAt'
    Parameters: [
      address: Address,
      index: Quantity,
      block: BlockNumber | BlockTag | BlockIdentifier,
    ]
    ReturnType: Hex
  },
  /**
   * @description Returns information about a transaction specified by block hash and transaction index
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getTransactionByBlockHashAndIndex', params: ['0x...', '0x...'] })
   * // => { ... }
   */
  {
    Method: 'eth_getTransactionByBlockHashAndIndex'
    Parameters: [hash: Hash, index: Quantity]
    ReturnType: Transaction | null
  },
  /**
   * @description Returns information about a transaction specified by block number and transaction index
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getTransactionByBlockNumberAndIndex', params: ['0x...', '0x...'] })
   * // => { ... }
   */
  {
    Method: 'eth_getTransactionByBlockNumberAndIndex'
    Parameters: [block: BlockNumber | BlockTag, index: Quantity]
    ReturnType: Transaction | null
  },
  /**
   * @description Returns information about a transaction specified by hash
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getTransactionByHash', params: ['0x...'] })
   * // => { ... }
   */
  {
    Method: 'eth_getTransactionByHash'
    Parameters: [hash: Hash]
    ReturnType: Transaction | null
  },
  /**
   * @description Returns the number of transactions sent from an address
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getTransactionCount', params: ['0x...', 'latest'] })
   * // => '0x1'
   */
  {
    Method: 'eth_getTransactionCount'
    Parameters: [
      address: Address,
      block: BlockNumber | BlockTag | BlockIdentifier,
    ]
    ReturnType: Quantity
  },
  /**
   * @description Returns the receipt of a transaction specified by hash
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getTransactionReceipt', params: ['0x...'] })
   * // => { ... }
   */
  {
    Method: 'eth_getTransactionReceipt'
    Parameters: [hash: Hash]
    ReturnType: TransactionReceipt | null
  },
  /**
   * @description Returns information about an uncle specified by block hash and uncle index position
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getUncleByBlockHashAndIndex', params: ['0x...', '0x...'] })
   * // => { ... }
   */
  {
    Method: 'eth_getUncleByBlockHashAndIndex'
    Parameters: [hash: Hash, index: Quantity]
    ReturnType: Uncle | null
  },
  /**
   * @description Returns information about an uncle specified by block number and uncle index position
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getUncleByBlockNumberAndIndex', params: ['0x...', '0x...'] })
   * // => { ... }
   */
  {
    Method: 'eth_getUncleByBlockNumberAndIndex'
    Parameters: [block: BlockNumber | BlockTag, index: Quantity]
    ReturnType: Uncle | null
  },
  /**
   * @description Returns the number of uncles in a block specified by block hash
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getUncleCountByBlockHash', params: ['0x...'] })
   * // => '0x1'
   */
  {
    Method: 'eth_getUncleCountByBlockHash'
    Parameters: [hash: Hash]
    ReturnType: Quantity
  },
  /**
   * @description Returns the number of uncles in a block specified by block number
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_getUncleCountByBlockNumber', params: ['0x...'] })
   * // => '0x1'
   */
  {
    Method: 'eth_getUncleCountByBlockNumber'
    Parameters: [block: BlockNumber | BlockTag]
    ReturnType: Quantity
  },
  /**
   * @description Returns the current maxPriorityFeePerGas in wei.
   * @link https://ethereum.github.io/execution-apis/api-documentation/
   * @example
   * provider.request({ method: 'eth_maxPriorityFeePerGas' })
   * // => '0x5f5e100'
   */
  {
    Method: 'eth_maxPriorityFeePerGas'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Creates a filter to listen for new blocks that can be used with `eth_getFilterChanges`
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_newBlockFilter' })
   * // => '0x1'
   */
  {
    Method: 'eth_newBlockFilter'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Creates a filter to listen for specific state changes that can then be used with `eth_getFilterChanges`
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_newFilter', params: [{ fromBlock: '0x...', toBlock: '0x...', address: '0x...', topics: ['0x...'] }] })
   * // => '0x1'
   */
  {
    Method: 'eth_newFilter'
    Parameters: [
      filter: {
        fromBlock?: BlockNumber | BlockTag | undefined
        toBlock?: BlockNumber | BlockTag | undefined
        address?: Address | Address[] | undefined
        topics?: LogTopic[] | undefined
      },
    ]
    ReturnType: Quantity
  },
  /**
   * @description Creates a filter to listen for new pending transactions that can be used with `eth_getFilterChanges`
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_newPendingTransactionFilter' })
   * // => '0x1'
   */
  {
    Method: 'eth_newPendingTransactionFilter'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Returns the current Ethereum protocol version
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_protocolVersion' })
   * // => '54'
   */
  {
    Method: 'eth_protocolVersion'
    Parameters?: undefined
    ReturnType: string
  },
  /**
   * @description Sends a **signed** transaction to the network
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_sendRawTransaction', params: ['0x...'] })
   * // => '0x...'
   */
  {
    Method: 'eth_sendRawTransaction'
    Parameters: [signedTransaction: Hex]
    ReturnType: Hash
  },
  /**
   * @description Simulates execution of a set of calls with optional block and state overrides.
   * @example
   * provider.request({ method: 'eth_simulateV1', params: [{ blockStateCalls: [{ calls: [{ from: '0x...', to: '0x...', value: '0x...', data: '0x...' }] }] }, 'latest'] })
   * // => { ... }
   */
  {
    Method: 'eth_simulateV1'
    Parameters: [
      {
        blockStateCalls: readonly {
          blockOverrides?: BlockOverrides.Rpc | undefined
          calls?: readonly ExactPartial<TransactionRequest>[] | undefined
          stateOverrides?: RpcStateOverride | undefined
        }[]
        returnFullTransactions?: boolean | undefined
        traceTransfers?: boolean | undefined
        validation?: boolean | undefined
      },
      BlockNumber | BlockTag,
    ]
    ReturnType: readonly (Block & {
      calls: readonly {
        error?:
          | {
              data?: Hex | undefined
              code: number
              message: string
            }
          | undefined
        logs?: readonly Log[] | undefined
        gasUsed: Hex
        returnData: Hex
        status: Hex
      }[]
    })[]
  },
  /**
   * @description Destroys a filter based on filter ID
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_uninstallFilter', params: ['0x1'] })
   * // => true
   */
  {
    Method: 'eth_uninstallFilter'
    Parameters: [filterId: Quantity]
    ReturnType: boolean
  },
]

export type TestRpcSchema<mode extends string> = [
  /**
   * @description Add information about compiled contracts
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_addcompilationresult
   */
  {
    Method: `${mode}_addCompilationResult`
    Parameters: any[]
    ReturnType: any
  },
  /**
   * @description Remove a transaction from the mempool
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_droptransaction
   */
  {
    Method: `${mode}_dropTransaction`
    Parameters: [hash: Hash]
    ReturnType: void
  },
  /**
   * @description Serializes the current state (including contracts code, contract's storage, accounts properties, etc.) into a savable data blob.
   */
  {
    Method: `${mode}_dumpState`
    Parameters?: undefined
    ReturnType: Hex
  },
  /**
   * @description Turn on call traces for transactions that are returned to the user when they execute a transaction (instead of just txhash/receipt).
   */
  {
    Method: `${mode}_enableTraces`
    Parameters?: undefined
    ReturnType: void
  },
  /**
   * @description Impersonate an account or contract address.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_impersonateaccount
   */
  {
    Method: `${mode}_impersonateAccount`
    Parameters: [address: Address]
    ReturnType: void
  },
  /**
   * @description Returns true if automatic mining is enabled, and false otherwise. See [Mining Modes](https://hardhat.org/hardhat-network/explanation/mining-modes) to learn more.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_getautomine
   */
  {
    Method: `${mode}_getAutomine`
    Parameters?: undefined
    ReturnType: boolean
  },
  /**
   * @description Adds state previously dumped with `dumpState` to the current chain.
   */
  {
    Method: `${mode}_loadState`
    Parameters?: [Hex] | undefined
    ReturnType: void
  },
  /**
   * @description Advance the block number of the network by a certain number of blocks
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_mine
   */
  {
    Method: `${mode}_mine`
    Parameters: [
      /** Number of blocks to mine. */
      count: Hex,
      /** Interval between each block in seconds. */
      interval: Hex | undefined,
    ]
    ReturnType: void
  },
  /**
   * @description Resets the fork.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_reset
   */
  {
    Method: `${mode}_reset`
    Parameters: any[]
    ReturnType: void
  },
  /**
   * @description Modifies the balance of an account.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setbalance
   */
  {
    Method: `${mode}_setBalance`
    Parameters: [
      /** The address of the target account. */
      address: Address,
      /** Amount to send in wei. */
      balance: Quantity,
    ]
    ReturnType: void
  },
  /**
   * @description Modifies the bytecode stored at an account's address.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setcode
   */
  {
    Method: `${mode}_setCode`
    Parameters: [
      /** The address of the contract. */
      address: Address,
      /** Data bytecode. */
      data: string,
    ]
    ReturnType: void
  },
  /**
   * @description Sets the coinbase address to be used in new blocks.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setcoinbase
   */
  {
    Method: `${mode}_setCoinbase`
    Parameters: [
      /** The address to set as the coinbase address. */
      address: Address,
    ]
    ReturnType: void
  },
  /**
   * @description Enable or disable logging on the test node network.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setcoinbase
   */
  {
    Method: `${mode}_setLoggingEnabled`
    Parameters: [enabled: boolean]
    ReturnType: void
  },
  /**
   * @description Change the minimum gas price accepted by the network (in wei).
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setmingasprice
   */
  {
    Method: `${mode}_setMinGasPrice`
    Parameters: [gasPrice: Quantity]
    ReturnType: void
  },
  /**
   * @description Sets the base fee of the next block.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setnextblockbasefeepergas
   */
  {
    Method: `${mode}_setNextBlockBaseFeePerGas`
    Parameters: [baseFeePerGas: Quantity]
    ReturnType: void
  },
  /**
   * @description Modifies an account's nonce by overwriting it.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setnonce
   */
  {
    Method: `${mode}_setNonce`
    Parameters: [
      /** The account address. */
      address: Address,
      /** The new nonce. */
      nonce: Quantity,
    ]
    ReturnType: void
  },
  /**
   * @description Sets the backend RPC URL.
   */
  {
    Method: `${mode}_setRpcUrl`
    Parameters: [url: string]
    ReturnType: void
  },
  /**
   * @description Writes a single position of an account's storage.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_setstorageat
   */
  {
    Method: `${mode}_setStorageAt`
    Parameters: [
      /** The account address. */
      address: Address,
      /** The storage position index. */
      index: Quantity,
      /** The storage value. */
      value: Quantity,
    ]
    ReturnType: void
  },
  /**
   * @description Use this method to stop impersonating an account after having previously used impersonateAccount.
   * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_stopimpersonatingaccount
   */
  {
    Method: `${mode}_stopImpersonatingAccount`
    Parameters: [
      /** The address to stop impersonating. */
      address: Address,
    ]
    ReturnType: void
  },
  /**
   * @description Jump forward in time by the given amount of time, in seconds.
   * @link https://github.com/trufflesuite/ganache/blob/ef1858d5d6f27e4baeb75cccd57fb3dc77a45ae8/src/chains/ethereum/ethereum/RPC-METHODS.md#evm_increasetime
   */
  {
    Method: `${mode}_increaseTime`
    Parameters: [seconds: number]
    ReturnType: Quantity
  },
  /**
   * @description Modifies the balance of an account.
   * @link https://ganache.dev/#evm_setAccountBalance
   */
  {
    Method: 'evm_setAccountBalance'
    Parameters: [
      /** The address of the target account. */
      address: Address,
      /** Amount to send in wei. */
      value: Quantity,
    ]
    ReturnType: void
  },
  /**
   * @description Modifies the bytecode stored at an account's address.
   * @link https://ganache.dev/#evm_setAccountCode
   */
  {
    Method: 'evm_setAccountCode'
    Parameters: [
      /** The address of the contract. */
      address: Address,
      /** Data bytecode. */
      data: string,
    ]
    ReturnType: void
  },
  /**
   * @description Enables or disables, based on the single boolean argument, the automatic mining of new blocks with each new transaction submitted to the network.
   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setautomine
   */
  {
    Method: 'evm_setAutomine'
    Parameters: [boolean]
    ReturnType: void
  },
  /**
   * @description Sets the block's gas limit.
   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setblockgaslimit
   */
  {
    Method: 'evm_setBlockGasLimit'
    Parameters: [gasLimit: Quantity]
    ReturnType: void
  },
  /**
   * @description Jump forward in time by the given amount of time, in seconds.
   * @link https://github.com/trufflesuite/ganache/blob/ef1858d5d6f27e4baeb75cccd57fb3dc77a45ae8/src/chains/ethereum/ethereum/RPC-METHODS.md#evm_increasetime
   */
  {
    Method: 'evm_increaseTime'
    Parameters: [seconds: Quantity]
    ReturnType: Quantity
  },
  /**
   * @description Similar to `evm_increaseTime` but sets a block timestamp `interval`.
   * The timestamp of the next block will be computed as `lastBlock_timestamp` + `interval`
   */
  {
    Method: `${mode}_setBlockTimestampInterval`
    Parameters: [seconds: number]
    ReturnType: void
  },
  /**
   * @description Removes `setBlockTimestampInterval` if it exists
   */
  {
    Method: `${mode}_removeBlockTimestampInterval`
    Parameters?: undefined
    ReturnType: void
  },
  /**
   * @description Enables (with a numeric argument greater than 0) or disables (with a numeric argument equal to 0), the automatic mining of blocks at a regular interval of milliseconds, each of which will include all pending transactions.
   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setintervalmining
   */
  {
    Method: 'evm_setIntervalMining'
    Parameters: [number]
    ReturnType: void
  },
  /**
   * @description Set the timestamp of the next block.
   * @link https://hardhat.org/hardhat-network/docs/reference#evm_setnextblocktimestamp
   */
  {
    Method: 'evm_setNextBlockTimestamp'
    Parameters: [Quantity]
    ReturnType: void
  },
  /**
   * @description Snapshot the state of the blockchain at the current block. Takes no parameters. Returns the id of the snapshot that was created.
   * @link https://hardhat.org/hardhat-network/docs/reference#evm_snapshot
   */
  {
    Method: 'evm_snapshot'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Revert the state of the blockchain to a previous snapshot. Takes a single parameter, which is the snapshot id to revert to.
   */
  {
    Method: 'evm_revert'
    Parameters?: [id: Quantity] | undefined
    ReturnType: void
  },
  /**
   * @description Enables the automatic mining of new blocks with each new transaction submitted to the network.
   * @link https://ganache.dev/#miner_start
   */
  {
    Method: 'miner_start'
    Parameters?: undefined
    ReturnType: void
  },
  /**
   * @description Disables the automatic mining of new blocks with each new transaction submitted to the network.
   * @link https://ganache.dev/#miner_stop
   */
  {
    Method: 'miner_stop'
    Parameters?: undefined
    ReturnType: void
  },
  /**
   * @link https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-txpool#txpool-content
   */
  {
    Method: 'txpool_content'
    Parameters?: undefined
    ReturnType: {
      pending: Record<Address, Record<string, Transaction>>
      queued: Record<Address, Record<string, Transaction>>
    }
  },
  /**
   * @link https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-txpool#txpool-inspect
   */
  {
    Method: 'txpool_inspect'
    Parameters?: undefined
    ReturnType: {
      pending: Record<Address, Record<string, string>>
      queued: Record<Address, Record<string, string>>
    }
  },
  /**
   * @link https://geth.ethereum.org/docs/interacting-with-geth/rpc/ns-txpool#txpool-inspect
   */
  {
    Method: 'txpool_status'
    Parameters?: undefined
    ReturnType: {
      pending: Quantity
      queued: Quantity
    }
  },
  /**
   * @description Returns whether the client is actively mining new blocks.
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_mining' })
   * // => true
   */
  {
    Method: 'eth_mining'
    Parameters?: undefined
    ReturnType: boolean
  },
  /**
   * @description Advance the block number of the network by a certain number of blocks.
   * @link https://ganache.dev/#evm_mine
   */
  {
    Method: 'evm_mine'
    Parameters?:
      | [
          {
            /** Number of blocks to mine. */
            blocks: Hex
          },
        ]
      | undefined
    ReturnType: void
  },
  /**
   * @description Creates, signs, and sends a new transaction to the network regardless of the signature.
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_sendTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })
   * // => '0x...'
   */
  {
    Method: 'eth_sendUnsignedTransaction'
    Parameters: [transaction: TransactionRequest]
    ReturnType: Hash
  },
]

export type WalletRpcSchema = [
  /**
   * @description Returns a list of addresses owned by this client
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_accounts' })
   * // => ['0x0fB69...']
   */
  {
    Method: 'eth_accounts'
    Parameters?: undefined
    ReturnType: Address[]
  },
  /**
   * @description Returns the current chain ID associated with the wallet.
   * @example
   * provider.request({ method: 'eth_chainId' })
   * // => '1'
   */
  {
    Method: 'eth_chainId'
    Parameters?: undefined
    ReturnType: Quantity
  },
  /**
   * @description Estimates the gas necessary to complete a transaction without submitting it to the network
   *
   * @example
   * provider.request({
   *  method: 'eth_estimateGas',
   *  params: [{ from: '0x...', to: '0x...', value: '0x...' }]
   * })
   * // => '0x5208'
   */
  {
    Method: 'eth_estimateGas'
    Parameters:
      | [transaction: TransactionRequest]
      | [transaction: TransactionRequest, block: BlockNumber | BlockTag]
      | [
          transaction: TransactionRequest,
          block: BlockNumber | BlockTag,
          stateOverride: RpcStateOverride,
        ]
    ReturnType: Quantity
  },
  /**
   * @description Requests that the user provides an Ethereum address to be identified by. Typically causes a browser extension popup to appear.
   * @link https://eips.ethereum.org/EIPS/eip-1102
   * @example
   * provider.request({ method: 'eth_requestAccounts' }] })
   * // => ['0x...', '0x...']
   */
  {
    Method: 'eth_requestAccounts'
    Parameters?: undefined
    ReturnType: Address[]
  },
  /**
   * @description Creates, signs, and sends a new transaction to the network
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_sendTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })
   * // => '0x...'
   */
  {
    Method: 'eth_sendTransaction'
    Parameters: [transaction: TransactionRequest]
    ReturnType: Hash
  },
  /**
   * @description Sends and already-signed transaction to the network
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_sendRawTransaction', params: ['0x...'] })
   * // => '0x...'
   */
  {
    Method: 'eth_sendRawTransaction'
    Parameters: [signedTransaction: Hex]
    ReturnType: Hash
  },
  /**
   * @description Calculates an Ethereum-specific signature in the form of `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_sign', params: ['0x...', '0x...'] })
   * // => '0x...'
   */
  {
    Method: 'eth_sign'
    Parameters: [
      /** Address to use for signing */
      address: Address,
      /** Data to sign */
      data: Hex,
    ]
    ReturnType: Hex
  },
  /**
   * @description Signs a transaction that can be submitted to the network at a later time using with `eth_sendRawTransaction`
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_signTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })
   * // => '0x...'
   */
  {
    Method: 'eth_signTransaction'
    Parameters: [request: TransactionRequest]
    ReturnType: Hex
  },
  /**
   * @description Calculates an Ethereum-specific signature in the form of `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_signTypedData_v4', params: [{ from: '0x...', data: [{ type: 'string', name: 'message', value: 'hello world' }] }] })
   * // => '0x...'
   */
  {
    Method: 'eth_signTypedData_v4'
    Parameters: [
      /** Address to use for signing */
      address: Address,
      /** Message to sign containing type information, a domain separator, and data */
      message: string,
    ]
    ReturnType: Hex
  },
  /**
   * @description Returns information about the status of this clients network synchronization
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'eth_syncing' })
   * // => { startingBlock: '0x...', currentBlock: '0x...', highestBlock: '0x...' }
   */
  {
    Method: 'eth_syncing'
    Parameters?: undefined
    ReturnType: NetworkSync | false
  },
  /**
   * @description Calculates an Ethereum-specific signature in the form of `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'personal_sign', params: ['0x...', '0x...'] })
   * // => '0x...'
   */
  {
    Method: 'personal_sign'
    Parameters: [
      /** Data to sign */
      data: Hex,
      /** Address to use for signing */
      address: Address,
    ]
    ReturnType: Hex
  },
  /**
   * @description Add an Ethereum chain to the wallet.
   * @link https://eips.ethereum.org/EIPS/eip-3085
   * @example
   * provider.request({ method: 'wallet_addEthereumChain', params: [{ chainId: 1, rpcUrl: 'https://mainnet.infura.io/v3/...' }] })
   * // => { ... }
   */
  {
    Method: 'wallet_addEthereumChain'
    Parameters: [chain: AddEthereumChainParameter]
    ReturnType: null
  },
  /**
   * @description Returns the status of a call batch that was sent via `wallet_sendCalls`.
   * @link https://eips.ethereum.org/EIPS/eip-5792
   * @example
   * provider.request({ method: 'wallet_getCallsStatus' })
   * // => { ... }
   */
  {
    Method: 'wallet_getCallsStatus'
    Parameters?: [string]
    ReturnType: WalletGetCallsStatusReturnType
  },
  /**
   * @description Gets the connected wallet's capabilities.
   * @link https://eips.ethereum.org/EIPS/eip-5792
   * @example
   * provider.request({ method: 'wallet_getCapabilities' })
   * // => { ... }
   */
  {
    Method: 'wallet_getCapabilities'
    Parameters?:
      | readonly []
      | readonly [Address | undefined]
      | readonly [Address | undefined, readonly Hex[] | undefined]
      | undefined
    ReturnType: Prettify<WalletCapabilitiesRecord>
  },
  /**
   * @description Gets the wallets current permissions.
   * @link https://eips.ethereum.org/EIPS/eip-2255
   * @example
   * provider.request({ method: 'wallet_getPermissions' })
   * // => { ... }
   */
  {
    Method: 'wallet_getPermissions'
    Parameters?: undefined
    ReturnType: WalletPermission[]
  },
  /**
   * @description Requests permissions from a wallet
   * @link https://eips.ethereum.org/EIPS/eip-7715
   * @example
   * provider.request({ method: 'wallet_grantPermissions', params: [{ ... }] })
   * // => { ... }
   */
  {
    Method: 'wallet_grantPermissions'
    Parameters?: [WalletGrantPermissionsParameters]
    ReturnType: Prettify<WalletGrantPermissionsReturnType>
  },
  /**
   * @description Requests the given permissions from the user.
   * @link https://eips.ethereum.org/EIPS/eip-2255
   * @example
   * provider.request({ method: 'wallet_requestPermissions', params: [{ eth_accounts: {} }] })
   * // => { ... }
   */
  {
    Method: 'wallet_requestPermissions'
    Parameters: [permissions: { eth_accounts: Record<string, any> }]
    ReturnType: WalletPermission[]
  },
  /**
   * @description Revokes the given permissions from the user.
   * @link https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md
   * @example
   * provider.request({ method: 'wallet_revokePermissions', params: [{ eth_accounts: {} }] })
   * // => { ... }
   */
  {
    Method: 'wallet_revokePermissions'
    Parameters: [permissions: { eth_accounts: Record<string, any> }]
    ReturnType: null
  },
  /**
   * @description Requests the connected wallet to send a batch of calls.
   * @link https://eips.ethereum.org/EIPS/eip-5792
   * @example
   * provider.request({ method: 'wallet_sendCalls' })
   * // => { ... }
   */
  {
    Method: 'wallet_sendCalls'
    Parameters?: WalletSendCallsParameters
    ReturnType: WalletSendCallsReturnType
  },
  /**
   * @description Creates, signs, and sends a new transaction to the network
   * @link https://eips.ethereum.org/EIPS/eip-1474
   * @example
   * provider.request({ method: 'wallet_sendTransaction', params: [{ from: '0x...', to: '0x...', value: '0x...' }] })
   * // => '0x...'
   */
  {
    Method: 'wallet_sendTransaction'
    Parameters: [transaction: TransactionRequest]
    ReturnType: Hash
  },
  /**
   * @description Requests for the wallet to show information about a call batch
   * that was sent via `wallet_sendCalls`.
   * @link https://eips.ethereum.org/EIPS/eip-5792
   * @example
   * provider.request({ method: 'wallet_showCallsStatus', params: ['...'] })
   */
  {
    Method: 'wallet_showCallsStatus'
    Parameters?: [string]
    ReturnType: void
  },
  /**
   * @description Switch the wallet to the given Ethereum chain.
   * @link https://eips.ethereum.org/EIPS/eip-3326
   * @example
   * provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0xf00' }] })
   * // => { ... }
   */
  {
    Method: 'wallet_switchEthereumChain'
    Parameters: [chain: { chainId: string }]
    ReturnType: null
  },
  /**
   * @description Requests that the user tracks the token in their wallet. Returns a boolean indicating if the token was successfully added.
   * @link https://eips.ethereum.org/EIPS/eip-747
   * @example
   * provider.request({ method: 'wallet_watchAsset' }] })
   * // => true
   */
  {
    Method: 'wallet_watchAsset'
    Parameters: WatchAssetParams
    ReturnType: boolean
  },
]

///////////////////////////////////////////////////////////////////////////
// Utils

export type RpcSchema = readonly {
  Method: string
  Parameters?: unknown | undefined
  ReturnType: unknown
}[]

export type RpcSchemaOverride = Omit<RpcSchema[number], 'Method'>

export type EIP1193Parameters<
  rpcSchema extends RpcSchema | undefined = undefined,
> = rpcSchema extends RpcSchema
  ? {
      [K in keyof rpcSchema]: Prettify<
        {
          method: rpcSchema[K] extends rpcSchema[number]
            ? rpcSchema[K]['Method']
            : never
        } & (rpcSchema[K] extends rpcSchema[number]
          ? rpcSchema[K]['Parameters'] extends undefined
            ? { params?: undefined }
            : { params: rpcSchema[K]['Parameters'] }
          : never)
      >
    }[number]
  : {
      method: string
      params?: unknown | undefined
    }

export type EIP1193RequestOptions = {
  /** Deduplicate in-flight requests. */
  dedupe?: boolean | undefined
  /** Methods to include or exclude from executing RPC requests. */
  methods?:
    | OneOf<
        | {
            include?: string[] | undefined
          }
        | {
            exclude?: string[] | undefined
          }
      >
    | undefined
  /** The base delay (in ms) between retries. */
  retryDelay?: number | undefined
  /** The max number of times to retry. */
  retryCount?: number | undefined
  /** Unique identifier for the request. */
  uid?: string | undefined
}

type DerivedRpcSchema<
  rpcSchema extends RpcSchema | undefined,
  rpcSchemaOverride extends RpcSchemaOverride | undefined,
> = rpcSchemaOverride extends RpcSchemaOverride
  ? [rpcSchemaOverride & { Method: string }]
  : rpcSchema

export type EIP1193RequestFn<
  rpcSchema extends RpcSchema | undefined = undefined,
  raw extends boolean = false,
> = <
  rpcSchemaOverride extends RpcSchemaOverride | undefined = undefined,
  _parameters extends EIP1193Parameters<
    DerivedRpcSchema<rpcSchema, rpcSchemaOverride>
  > = EIP1193Parameters<DerivedRpcSchema<rpcSchema, rpcSchemaOverride>>,
  _returnType = DerivedRpcSchema<rpcSchema, rpcSchemaOverride> extends RpcSchema
    ? raw extends true
      ? OneOf<
          | {
              result: Extract<
                DerivedRpcSchema<rpcSchema, rpcSchemaOverride>[number],
                { Method: _parameters['method'] }
              >['ReturnType']
            }
          | { error: Rpc.ErrorObject }
        >
      : Extract<
          DerivedRpcSchema<rpcSchema, rpcSchemaOverride>[number],
          { Method: _parameters['method'] }
        >['ReturnType']
    : raw extends true
      ? OneOf<
          | {
              result: unknown
            }
          | {
              error: Rpc.ErrorObject
            }
        >
      : unknown,
>(
  args: _parameters,
  options?: EIP1193RequestOptions | undefined,
) => Promise<_returnType>
</file>

<file path="src/types/eip4844.ts">
import type { ByteArray, Hex } from './misc.js'

export type BlobSidecar<type extends Hex | ByteArray = Hex | ByteArray> = {
  /** The blob associated with the transaction. */
  blob: type
  /** The KZG commitment corresponding to this blob. */
  commitment: type
  /** The KZG proof corresponding to this blob and commitment. */
  proof: type
}
export type BlobSidecars<type extends Hex | ByteArray = Hex | ByteArray> =
  BlobSidecar<type>[]
</file>

<file path="src/types/ens.ts">
export type AssetGateway = 'ipfs' | 'arweave'

export type AssetGatewayUrls = {
  [_key in AssetGateway]?: string | undefined
}
</file>

<file path="src/types/fee.ts">
import type { OneOf } from './utils.js'

export type FeeHistory<quantity = bigint> = {
  /**
   * An array of block base fees per gas (in wei). This includes the next block after
   * the newest of the returned range, because this value can be derived from the newest block.
   * Zeroes are returned for pre-EIP-1559 blocks. */
  baseFeePerGas: quantity[]
  /** An array of block gas used ratios. These are calculated as the ratio of gasUsed and gasLimit. */
  gasUsedRatio: number[]
  /** Lowest number block of the returned range. */
  oldestBlock: quantity
  /** An array of effective priority fees (in wei) per gas data points from a single block. All zeroes are returned if the block is empty. */
  reward?: quantity[][] | undefined
}

export type FeeValuesLegacy<quantity = bigint> = {
  /** Base fee per gas. */
  gasPrice: quantity
  maxFeePerBlobGas?: undefined
  maxFeePerGas?: undefined
  maxPriorityFeePerGas?: undefined
}

export type FeeValuesEIP1559<quantity = bigint> = {
  gasPrice?: undefined
  maxFeePerBlobGas?: undefined
  /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */
  maxFeePerGas: quantity
  /** Max priority fee per gas (in wei). */
  maxPriorityFeePerGas: quantity
}

export type FeeValuesEIP4844<quantity = bigint> = {
  gasPrice?: undefined
  /** Maximum total fee per gas sender is willing to pay for blob gas (in wei). */
  maxFeePerBlobGas: quantity
  /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */
  maxFeePerGas: quantity
  /** Max priority fee per gas (in wei). */
  maxPriorityFeePerGas: quantity
}

export type FeeValues<quantity = bigint> = OneOf<
  | FeeValuesLegacy<quantity>
  | FeeValuesEIP1559<quantity>
  | FeeValuesEIP4844<quantity>
>

export type FeeValuesType = 'legacy' | 'eip1559' | 'eip4844'
</file>

<file path="src/types/filter.ts">
import type { Abi } from 'abitype'

import type { BlockNumber, BlockTag } from './block.js'
import type { MaybeExtractEventArgsFromAbi } from './contract.js'
import type { EIP1193RequestFn, PublicRpcSchema } from './eip1193.js'
import type { Hex } from './misc.js'
import type { Filter as Filter_ } from './utils.js'

export type FilterType = 'transaction' | 'block' | 'event'

type FilterRpcSchema = Filter_<
  PublicRpcSchema,
  {
    Method: 'eth_getFilterLogs' | 'eth_getFilterChanges' | 'eth_uninstallFilter'
  }
>

export type Filter<
  filterType extends FilterType = 'event',
  abi extends Abi | readonly unknown[] | undefined = undefined,
  eventName extends string | undefined = undefined,
  args extends
    | MaybeExtractEventArgsFromAbi<abi, eventName>
    | undefined = MaybeExtractEventArgsFromAbi<abi, eventName>,
  strict extends boolean | undefined = undefined,
  fromBlock extends BlockNumber | BlockTag | undefined = undefined,
  toBlock extends BlockNumber | BlockTag | undefined = undefined,
> = {
  id: Hex
  request: EIP1193RequestFn<FilterRpcSchema>
  type: filterType
} & (filterType extends 'event'
  ? {
      fromBlock?: fromBlock | undefined
      toBlock?: toBlock | undefined
    } & (abi extends Abi
      ? undefined extends eventName
        ? {
            abi: abi
            args?: undefined
            eventName?: undefined
            strict: strict
          }
        : args extends MaybeExtractEventArgsFromAbi<abi, eventName>
          ? {
              abi: abi
              args: args
              eventName: eventName
              strict: strict
            }
          : {
              abi: abi
              args?: undefined
              eventName: eventName
              strict: strict
            }
      : {
          abi?: undefined
          args?: undefined
          eventName?: undefined
          strict?: undefined
        })
  : {})
</file>

<file path="src/types/kzg.ts">
import type { Address } from 'abitype'

import type { LocalAccount } from '../accounts/types.js'
import type { ByteArray } from './misc.js'
import type { TransactionRequestEIP4844 } from './transaction.js'
import type { MaybeRequired } from './utils.js'

export type Kzg = {
  /**
   * Convert a blob to a KZG commitment.
   */
  blobToKzgCommitment(blob: ByteArray): ByteArray
  /**
   * Given a blob, return the KZG proof that is used to verify it against the
   * commitment.
   */
  computeBlobKzgProof(blob: ByteArray, commitment: ByteArray): ByteArray
}

export type GetTransactionRequestKzgParameter<
  request extends unknown | undefined = undefined,
> = MaybeRequired<
  {
    /** KZG implementation */
    kzg?: Kzg | undefined
  },
  request extends {
    account: LocalAccount<string, Address>
    blobs: TransactionRequestEIP4844['blobs']
  }
    ? true
    : false
>
</file>

<file path="src/types/log.ts">
import type {
  Abi,
  AbiEvent,
  Address,
  ExtractAbiEvent,
  ExtractAbiEventNames,
} from 'abitype'

import type {
  AbiEventParametersToPrimitiveTypes,
  GetEventArgs,
} from './contract.js'
import type { Hash, Hex } from './misc.js'

export type Log<
  quantity = bigint,
  index = number,
  pending extends boolean = boolean,
  abiEvent extends AbiEvent | undefined = undefined,
  strict extends boolean | undefined = undefined,
  abi extends Abi | readonly unknown[] | undefined = abiEvent extends AbiEvent
    ? [abiEvent]
    : undefined,
  eventName extends string | undefined = abiEvent extends AbiEvent
    ? abiEvent['name']
    : undefined,
> = {
  /** The address from which this log originated */
  address: Address
  /** Hash of block containing this log or `null` if pending */
  blockHash: pending extends true ? null : Hash
  /** Number of block containing this log or `null` if pending */
  blockNumber: pending extends true ? null : quantity
  /** Contains the non-indexed arguments of the log */
  data: Hex
  /** Index of this log within its block or `null` if pending */
  logIndex: pending extends true ? null : index
  /** Hash of the transaction that created this log or `null` if pending */
  transactionHash: pending extends true ? null : Hash
  /** Index of the transaction that created this log or `null` if pending */
  transactionIndex: pending extends true ? null : index
  /** `true` if this filter has been destroyed and is invalid */
  removed: boolean
} & GetInferredLogValues<abiEvent, abi, eventName, strict>

type Topics<
  head extends AbiEvent['inputs'],
  base = [Hex],
> = head extends readonly [
  infer _Head,
  ...infer Tail extends AbiEvent['inputs'],
]
  ? _Head extends { indexed: true }
    ? [Hex, ...Topics<Tail>]
    : Topics<Tail>
  : base

type GetTopics<
  abiEvent extends AbiEvent | undefined = undefined,
  abi extends Abi | readonly unknown[] = [abiEvent],
  eventName extends string | undefined = abiEvent extends AbiEvent
    ? abiEvent['name']
    : undefined,
  _AbiEvent extends AbiEvent | undefined = abi extends Abi
    ? eventName extends string
      ? ExtractAbiEvent<abi, eventName>
      : undefined
    : undefined,
  _Args = _AbiEvent extends AbiEvent
    ? AbiEventParametersToPrimitiveTypes<_AbiEvent['inputs']>
    : never,
  _FailedToParseArgs =
    | ([_Args] extends [never] ? true : false)
    | (readonly unknown[] extends _Args ? true : false),
> = true extends _FailedToParseArgs
  ? [Hex, ...Hex[]] | []
  : abiEvent extends AbiEvent
    ? Topics<abiEvent['inputs']>
    : _AbiEvent extends AbiEvent
      ? Topics<_AbiEvent['inputs']>
      : [Hex, ...Hex[]] | []

type GetInferredLogValues<
  abiEvent extends AbiEvent | undefined = undefined,
  abi extends Abi | readonly unknown[] | undefined = abiEvent extends AbiEvent
    ? [abiEvent]
    : undefined,
  eventName extends string | undefined = abiEvent extends AbiEvent
    ? abiEvent['name']
    : undefined,
  strict extends boolean | undefined = undefined,
  _EventNames extends string = abi extends Abi
    ? Abi extends abi
      ? string
      : ExtractAbiEventNames<abi>
    : string,
> = abi extends Abi
  ? eventName extends string
    ? {
        args: GetEventArgs<
          abi,
          eventName,
          {
            EnableUnion: false
            IndexedOnly: false
            Required: strict extends boolean ? strict : false
          }
        >
        /** The event name decoded from `topics`. */
        eventName: eventName
        /** List of order-dependent topics */
        topics: GetTopics<abiEvent, abi, eventName>
      }
    : {
        [name in _EventNames]: {
          args: GetEventArgs<
            abi,
            name,
            {
              EnableUnion: false
              IndexedOnly: false
              Required: strict extends boolean ? strict : false
            }
          >
          /** The event name decoded from `topics`. */
          eventName: name
          /** List of order-dependent topics */
          topics: GetTopics<abiEvent, abi, name>
        }
      }[_EventNames]
  : {
      topics: [Hex, ...Hex[]] | []
    }
</file>

<file path="src/types/misc.ts">
import type { OneOf } from './utils.js'

export type ByteArray = Uint8Array
export type Hex = `0x${string}`
export type Hash = `0x${string}`
export type LogTopic = Hex | Hex[] | null
export type SignableMessage =
  | string
  | {
      /** Raw data representation of the message. */
      raw: Hex | ByteArray
    }
export type SignatureLegacy<bigintType = bigint> = {
  r: Hex
  s: Hex
  v: bigintType
}
export type Signature<numberType = number, bigintType = bigint> = OneOf<
  | SignatureLegacy
  | {
      r: Hex
      s: Hex
      /** @deprecated use `yParity`. */
      v: bigintType
      yParity?: numberType | undefined
    }
  | {
      r: Hex
      s: Hex
      /** @deprecated use `yParity`. */
      v?: bigintType | undefined
      yParity: numberType
    }
>
export type CompactSignature = {
  r: Hex
  yParityAndS: Hex
}
</file>

<file path="src/types/multicall.ts">
import type { Abi, AbiStateMutability } from 'abitype'

import type {
  ContractFunctionArgs,
  ContractFunctionName,
  ContractFunctionParameters,
  ContractFunctionReturnType,
} from './contract.js'
import type { MaybePartial, Prettify } from './utils.js'

export type MulticallContracts<
  contracts extends readonly unknown[],
  options extends {
    mutability: AbiStateMutability
    optional?: boolean
    properties?: Record<string, any>
  } = { mutability: AbiStateMutability },
  ///
  result extends readonly any[] = [],
> = contracts extends readonly [] // no contracts, return empty
  ? readonly []
  : contracts extends readonly [infer contract] // one contract left before returning `result`
    ? readonly [
        ...result,
        MaybePartial<
          Prettify<
            GetMulticallContractParameters<contract, options['mutability']> &
              options['properties']
          >,
          options['optional']
        >,
      ]
    : contracts extends readonly [infer contract, ...infer rest] // grab first contract and recurse through `rest`
      ? MulticallContracts<
          [...rest],
          options,
          [
            ...result,
            MaybePartial<
              Prettify<
                GetMulticallContractParameters<
                  contract,
                  options['mutability']
                > &
                  options['properties']
              >,
              options['optional']
            >,
          ]
        >
      : readonly unknown[] extends contracts
        ? contracts
        : // If `contracts` is *some* array but we couldn't assign `unknown[]` to it, then it must hold some known/homogenous type!
          // use this to infer the param types in the case of Array.map() argument
          contracts extends readonly (infer contract extends
              ContractFunctionParameters)[]
          ? readonly MaybePartial<
              Prettify<contract & options['properties']>,
              options['optional']
            >[]
          : // Fallback
            readonly MaybePartial<
              Prettify<ContractFunctionParameters & options['properties']>,
              options['optional']
            >[]

export type MulticallResults<
  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],
  allowFailure extends boolean = true,
  options extends {
    error?: Error | undefined
    extraProperties?: Record<string, unknown> | undefined
    mutability: AbiStateMutability
  } = { error: Error; extraProperties: {}; mutability: AbiStateMutability },
  ///
  result extends any[] = [],
> = contracts extends readonly [] // no contracts, return empty
  ? readonly []
  : contracts extends readonly [infer contract] // one contract left before returning `result`
    ? [
        ...result,
        MulticallResponse<
          GetMulticallContractReturnType<contract, options['mutability']>,
          options['error'],
          allowFailure,
          options['extraProperties']
        >,
      ]
    : contracts extends readonly [infer contract, ...infer rest] // grab first contract and recurse through `rest`
      ? MulticallResults<
          [...rest],
          allowFailure,
          options,
          [
            ...result,
            MulticallResponse<
              GetMulticallContractReturnType<contract, options['mutability']>,
              options['error'],
              allowFailure,
              options['extraProperties']
            >,
          ]
        >
      : readonly unknown[] extends contracts
        ? MulticallResponse<
            unknown,
            options['error'],
            allowFailure,
            options['extraProperties']
          >[]
        : // If `contracts` is *some* array but we couldn't assign `unknown[]` to it, then it must hold some known/homogenous type!
          // use this to infer the param types in the case of Array.map() argument
          contracts extends readonly (infer contract extends
              ContractFunctionParameters)[]
          ? MulticallResponse<
              GetMulticallContractReturnType<contract, options['mutability']>,
              options['error'],
              allowFailure,
              options['extraProperties']
            >[]
          : // Fallback
            MulticallResponse<
              unknown,
              options['error'],
              allowFailure,
              options['extraProperties']
            >[]

export type MulticallResponse<
  result = unknown,
  error = unknown,
  allowFailure extends boolean = true,
  extraProperties extends Record<string, unknown> | undefined = {},
> = allowFailure extends true
  ?
      | (extraProperties & {
          error?: undefined
          result: result
          status: 'success'
        })
      | (extraProperties & {
          error: unknown extends error ? Error : error
          result?: undefined
          status: 'failure'
        })
  : result

// infer contract parameters from `unknown`
export type GetMulticallContractParameters<
  contract,
  mutability extends AbiStateMutability,
> = contract extends { abi: infer abi extends Abi } // 1. Check if `abi` is const-asserted or defined inline
  ? // 1a. Check if `functionName` is valid for `abi`
    contract extends {
      functionName: infer functionName extends ContractFunctionName<
        abi,
        mutability
      >
    }
    ? // 1aa. Check if `args` is valid for `abi` and `functionName`
      contract extends {
        args: infer args extends ContractFunctionArgs<
          abi,
          mutability,
          functionName
        >
      }
      ? ContractFunctionParameters<abi, mutability, functionName, args> // `args` valid, pass through
      : ContractFunctionParameters<abi, mutability, functionName> // invalid `args`
    : // 1b. `functionName` is invalid, check if `abi` is declared as `Abi`
      Abi extends abi
      ? ContractFunctionParameters // `abi` declared as `Abi`, unable to infer types further
      : // `abi` is const-asserted or defined inline, infer types for `functionName` and `args`
        ContractFunctionParameters<abi, mutability>
  : ContractFunctionParameters<readonly unknown[]> // invalid `contract['abi']`, set to `readonly unknown[]`

type GetMulticallContractReturnType<
  contract,
  mutability extends AbiStateMutability,
> = contract extends { abi: infer abi extends Abi } // 1. Check if `abi` is const-asserted or defined inline
  ? // Check if `functionName` is valid for `abi`
    contract extends {
      functionName: infer functionName extends ContractFunctionName<
        abi,
        mutability
      >
    }
    ? // Check if `args` is valid for `abi` and `functionName`
      contract extends {
        args: infer args extends ContractFunctionArgs<
          abi,
          mutability,
          functionName
        >
      }
      ? ContractFunctionReturnType<abi, mutability, functionName, args> // `args` valid, pass through
      : ContractFunctionReturnType<abi, mutability, functionName> // invalid `args`
    : ContractFunctionReturnType<abi, mutability> // Invalid `functionName`
  : ContractFunctionReturnType // invalid `contract['abi']` (not const-asserted or declared as `Abi`)
</file>

<file path="src/types/proof.ts">
import type { Address } from 'abitype'
import type { Hash } from './misc.js'

type AccountProof = Hash

type StorageProof<quantity = bigint> = {
  key: Hash
  proof: Hash[]
  value: quantity
}

export type Proof<quantity = bigint, index = number> = {
  address: Address
  balance: quantity
  codeHash: Hash
  nonce: index
  storageHash: Hash
  accountProof: AccountProof[]
  storageProof: StorageProof<quantity>[]
}
</file>

<file path="src/types/rpc.ts">
import type { Address } from 'abitype'

import type {
  Block,
  BlockIdentifier,
  BlockNumber,
  BlockTag,
  Uncle,
} from './block.js'
import type { FeeHistory, FeeValues } from './fee.js'
import type { Log } from './log.js'
import type { Hex } from './misc.js'
import type { Proof } from './proof.js'
import type {
  TransactionEIP1559,
  TransactionEIP2930,
  TransactionEIP4844,
  TransactionEIP7702,
  TransactionLegacy,
  TransactionReceipt,
  TransactionRequestEIP1559,
  TransactionRequestEIP2930,
  TransactionRequestEIP4844,
  TransactionRequestEIP7702,
  TransactionRequestLegacy,
} from './transaction.js'
import type { Omit, OneOf, PartialBy } from './utils.js'

export type Index = `0x${string}`
export type Quantity = `0x${string}`
export type Status = '0x0' | '0x1'
export type TransactionType =
  | '0x0'
  | '0x1'
  | '0x2'
  | '0x3'
  | '0x4'
  | (string & {})

export type RpcAuthorization = {
  /** Address of the contract to set as code for the Authority. */
  address: Address
  /** Chain ID to authorize. */
  chainId: Hex
  /** Nonce of the Authority to authorize. */
  nonce: Hex
  /** ECDSA r value. */
  r: Hex
  /** ECDSA s value. */
  s: Hex
  /** y parity. */
  yParity: Hex
}
export type RpcAuthorizationList = readonly RpcAuthorization[]
export type RpcBlock<
  blockTag extends BlockTag = BlockTag,
  includeTransactions extends boolean = boolean,
  transaction = RpcTransaction<blockTag extends 'pending' ? true : false>,
> = Block<Quantity, includeTransactions, blockTag, transaction>
export type RpcBlockNumber = BlockNumber<Quantity>
export type RpcBlockIdentifier = BlockIdentifier<Quantity>
export type RpcUncle = Uncle<Quantity>
export type RpcFeeHistory = FeeHistory<Quantity>
export type RpcFeeValues = FeeValues<Quantity>
export type RpcLog = Log<Quantity, Index>
export type RpcProof = Proof<Quantity, Index>
export type RpcTransactionReceipt = TransactionReceipt<
  Quantity,
  Index,
  Status,
  TransactionType
>
export type RpcTransactionRequest = OneOf<
  | TransactionRequestLegacy<Quantity, Index, '0x0'>
  | TransactionRequestEIP2930<Quantity, Index, '0x1'>
  | TransactionRequestEIP1559<Quantity, Index, '0x2'>
  | TransactionRequestEIP4844<Quantity, Index, '0x3'>
  | (Omit<
      TransactionRequestEIP7702<Quantity, Index, '0x4'>,
      'authorizationList'
    > & { authorizationList?: RpcAuthorizationList | undefined })
>
// `yParity` is optional on the RPC type as some nodes do not return it
// for 1559 & 2930 transactions (they should!).
export type RpcTransaction<pending extends boolean = boolean> = OneOf<
  | Omit<TransactionLegacy<Quantity, Index, pending, '0x0'>, 'typeHex'>
  | PartialBy<
      Omit<TransactionEIP2930<Quantity, Index, pending, '0x1'>, 'typeHex'>,
      'yParity'
    >
  | PartialBy<
      Omit<TransactionEIP1559<Quantity, Index, pending, '0x2'>, 'typeHex'>,
      'yParity'
    >
  | PartialBy<
      Omit<TransactionEIP4844<Quantity, Index, pending, '0x3'>, 'typeHex'>,
      'yParity'
    >
  | PartialBy<
      Omit<
        TransactionEIP7702<Quantity, Index, pending, '0x4'>,
        'authorizationList' | 'typeHex'
      > & { authorizationList?: RpcAuthorizationList | undefined },
      'yParity'
    >
>

type SuccessResult<result> = {
  method?: undefined
  result: result
  error?: undefined
}
type ErrorResult<error> = {
  method?: undefined
  result?: undefined
  error: error
}
type Subscription<result, error> = {
  method: 'eth_subscription'
  error?: undefined
  result?: undefined
  params:
    | {
        subscription: string
        result: result
        error?: undefined
      }
    | {
        subscription: string
        result?: undefined
        error: error
      }
}

export type RpcRequest = {
  jsonrpc?: '2.0' | undefined
  method: string
  params?: any | undefined
  id?: number | undefined
}

export type RpcResponse<result = any, error = any> = {
  jsonrpc: `${number}`
  id: number
} & (SuccessResult<result> | ErrorResult<error> | Subscription<result, error>)

/** A key-value mapping of slot and storage values (supposedly 32 bytes each) */
export type RpcStateMapping = {
  [slots: Hex]: Hex
}

export type RpcAccountStateOverride = {
  /** Fake balance to set for the account before executing the call. <32 bytes */
  balance?: Hex | undefined
  /** Fake nonce to set for the account before executing the call. <8 bytes */
  nonce?: Hex | undefined
  /** Fake EVM bytecode to inject into the account before executing the call. */
  code?: Hex | undefined
  /** Fake key-value mapping to override all slots in the account storage before executing the call. */
  state?: RpcStateMapping | undefined
  /** Fake key-value mapping to override individual slots in the account storage before executing the call. */
  stateDiff?: RpcStateMapping | undefined
}

export type RpcStateOverride = {
  [address: Address]: RpcAccountStateOverride
}
</file>

<file path="src/types/stateOverride.ts">
import type { Address } from 'abitype'
import type { Hex } from './misc.js'
import type { OneOf } from './utils.js'

export type StateMapping = Array<{
  slot: Hex
  value: Hex
}>

export type StateOverride = Array<
  {
    address: Address
    balance?: bigint | undefined
    nonce?: number | undefined
    code?: Hex | undefined
  } & OneOf<
    | {
        /** Fake key-value mapping to override all slots in the account storage before executing the call. */
        state?: StateMapping | undefined
      }
    | {
        /** Fake key-value mapping to override individual slots in the account storage before executing the call. */
        stateDiff?: StateMapping | undefined
      }
  >
>
</file>

<file path="src/types/transaction.ts">
import type { Address } from 'abitype'

import type {
  AuthorizationList,
  SignedAuthorizationList,
} from './authorization.js'
import type { BlobSidecar } from './eip4844.js'
import type {
  FeeValuesEIP1559,
  FeeValuesEIP4844,
  FeeValuesLegacy,
} from './fee.js'
import type { Kzg } from './kzg.js'
import type { Log } from './log.js'
import type { ByteArray, Hash, Hex, Signature } from './misc.js'
import type {
  Branded,
  ExactPartial,
  IsNever,
  Omit,
  OneOf,
  RequiredBy,
} from './utils.js'

export type AccessList = readonly {
  address: Address
  storageKeys: readonly Hex[]
}[]

export type TransactionType =
  | 'legacy'
  | 'eip1559'
  | 'eip2930'
  | 'eip4844'
  | 'eip7702'
  | (string & {})

export type TransactionReceipt<
  quantity = bigint,
  index = number,
  status = 'success' | 'reverted',
  type = TransactionType,
> = {
  /** The actual value per gas deducted from the sender's account for blob gas. Only specified for blob transactions as defined by EIP-4844. */
  blobGasPrice?: quantity | undefined
  /** The amount of blob gas used. Only specified for blob transactions as defined by EIP-4844. */
  blobGasUsed?: quantity | undefined
  /** Hash of block containing this transaction */
  blockHash: Hash
  /** Number of block containing this transaction */
  blockNumber: quantity
  /** Address of new contract or `null` if no contract was created */
  contractAddress: Address | null | undefined
  /** Gas used by this and all preceding transactions in this block */
  cumulativeGasUsed: quantity
  /** Pre-London, it is equal to the transaction's gasPrice. Post-London, it is equal to the actual gas price paid for inclusion. */
  effectiveGasPrice: quantity
  /** Transaction sender */
  from: Address
  /** Gas used by this transaction */
  gasUsed: quantity
  /** List of log objects generated by this transaction */
  logs: Log<quantity, index, false>[]
  /** Logs bloom filter */
  logsBloom: Hex
  /** The post-transaction state root. Only specified for transactions included before the Byzantium upgrade. */
  root?: Hash | undefined
  /** `success` if this transaction was successful or `reverted` if it failed */
  status: status
  /** Transaction recipient or `null` if deploying a contract */
  to: Address | null
  /** Hash of this transaction */
  transactionHash: Hash
  /** Index of this transaction in the block */
  transactionIndex: index
  /** Transaction type */
  type: type
}

export type TransactionBase<
  quantity = bigint,
  index = number,
  isPending extends boolean = boolean,
> = {
  /** Hash of block containing this transaction or `null` if pending */
  blockHash: isPending extends true ? null : Hash
  /** Number of block containing this transaction or `null` if pending */
  blockNumber: isPending extends true ? null : quantity
  /** Transaction sender */
  from: Address
  /** Gas provided for transaction execution */
  gas: quantity
  /** Hash of this transaction */
  hash: Hash
  /** Contract code or a hashed method call */
  input: Hex
  /** Unique number identifying this transaction */
  nonce: index
  /** ECDSA signature r */
  r: Hex
  /** ECDSA signature s */
  s: Hex
  /** Transaction recipient or `null` if deploying a contract */
  to: Address | null
  /** Index of this transaction in the block or `null` if pending */
  transactionIndex: isPending extends true ? null : index
  /** The type represented as hex. */
  typeHex: Hex | null
  /** ECDSA recovery ID */
  v: quantity
  /** Value in wei sent with this transaction */
  value: quantity
  /** The parity of the y-value of the secp256k1 signature. */
  yParity: index
}

export type TransactionLegacy<
  quantity = bigint,
  index = number,
  isPending extends boolean = boolean,
  type = 'legacy',
> = Omit<TransactionBase<quantity, index, isPending>, 'yParity'> & {
  /** EIP-2930 Access List. */
  accessList?: undefined
  authorizationList?: undefined
  blobVersionedHashes?: undefined
  /** Chain ID that this transaction is valid on. */
  chainId?: index | undefined
  yParity?: undefined
  type: type
} & FeeValuesLegacy<quantity>

export type TransactionEIP2930<
  quantity = bigint,
  index = number,
  isPending extends boolean = boolean,
  type = 'eip2930',
> = TransactionBase<quantity, index, isPending> & {
  /** EIP-2930 Access List. */
  accessList: AccessList
  authorizationList?: undefined
  blobVersionedHashes?: undefined
  /** Chain ID that this transaction is valid on. */
  chainId: index
  type: type
} & FeeValuesLegacy<quantity>

export type TransactionEIP1559<
  quantity = bigint,
  index = number,
  isPending extends boolean = boolean,
  type = 'eip1559',
> = TransactionBase<quantity, index, isPending> & {
  /** EIP-2930 Access List. */
  accessList: AccessList
  authorizationList?: undefined
  blobVersionedHashes?: undefined
  /** Chain ID that this transaction is valid on. */
  chainId: index
  type: type
} & FeeValuesEIP1559<quantity>

export type TransactionEIP4844<
  quantity = bigint,
  index = number,
  isPending extends boolean = boolean,
  type = 'eip4844',
> = TransactionBase<quantity, index, isPending> & {
  /** EIP-2930 Access List. */
  accessList: AccessList
  authorizationList?: undefined
  /** List of versioned blob hashes associated with the transaction's blobs. */
  blobVersionedHashes: readonly Hex[]
  /** Chain ID that this transaction is valid on. */
  chainId: index
  type: type
} & FeeValuesEIP4844<quantity>

export type TransactionEIP7702<
  quantity = bigint,
  index = number,
  isPending extends boolean = boolean,
  type = 'eip7702',
> = TransactionBase<quantity, index, isPending> & {
  /** EIP-2930 Access List. */
  accessList: AccessList
  /** Authorization list for the transaction. */
  authorizationList: SignedAuthorizationList
  blobVersionedHashes?: undefined
  /** Chain ID that this transaction is valid on. */
  chainId: index
  type: type
} & FeeValuesEIP1559<quantity>

export type Transaction<
  quantity = bigint,
  index = number,
  isPending extends boolean = boolean,
> = OneOf<
  | TransactionLegacy<quantity, index, isPending>
  | TransactionEIP2930<quantity, index, isPending>
  | TransactionEIP1559<quantity, index, isPending>
  | TransactionEIP4844<quantity, index, isPending>
  | TransactionEIP7702<quantity, index, isPending>
>

////////////////////////////////////////////////////////////////////////////////////////////
// Request
////////////////////////////////////////////////////////////////////////////////////////////

export type TransactionRequestBase<
  quantity = bigint,
  index = number,
  type = string,
> = {
  /** Contract code or a hashed method call with encoded args */
  data?: Hex | undefined
  /** Transaction sender */
  from?: Address | undefined
  /** Gas provided for transaction execution */
  gas?: quantity | undefined
  /** Unique number identifying this transaction */
  nonce?: index | undefined
  /** Transaction recipient */
  to?: Address | null | undefined
  /** Transaction type */
  type?: type | undefined
  /** Value in wei sent with this transaction */
  value?: quantity | undefined
}

export type TransactionRequestLegacy<
  quantity = bigint,
  index = number,
  type = 'legacy',
> = TransactionRequestBase<quantity, index, type> &
  ExactPartial<FeeValuesLegacy<quantity>>

export type TransactionRequestEIP2930<
  quantity = bigint,
  index = number,
  type = 'eip2930',
> = TransactionRequestBase<quantity, index, type> &
  ExactPartial<FeeValuesLegacy<quantity>> & {
    accessList?: AccessList | undefined
  }

export type TransactionRequestEIP1559<
  quantity = bigint,
  index = number,
  type = 'eip1559',
> = TransactionRequestBase<quantity, index, type> &
  ExactPartial<FeeValuesEIP1559<quantity>> & {
    accessList?: AccessList | undefined
  }

export type TransactionRequestEIP4844<
  quantity = bigint,
  index = number,
  type = 'eip4844',
> = RequiredBy<TransactionRequestBase<quantity, index, type>, 'to'> &
  RequiredBy<ExactPartial<FeeValuesEIP4844<quantity>>, 'maxFeePerBlobGas'> & {
    accessList?: AccessList | undefined
    /** The blobs associated with this transaction. */
    blobs: readonly Hex[] | readonly ByteArray[]
    blobVersionedHashes?: readonly Hex[] | undefined
    kzg?: Kzg | undefined
    sidecars?: readonly BlobSidecar<Hex>[] | undefined
  }

export type TransactionRequestEIP7702<
  quantity = bigint,
  index = number,
  type = 'eip7702',
> = TransactionRequestBase<quantity, index, type> &
  ExactPartial<FeeValuesEIP1559<quantity>> & {
    accessList?: AccessList | undefined
    authorizationList?: AuthorizationList<index, boolean> | undefined
  }

export type TransactionRequest<quantity = bigint, index = number> = OneOf<
  | TransactionRequestLegacy<quantity, index>
  | TransactionRequestEIP2930<quantity, index>
  | TransactionRequestEIP1559<quantity, index>
  | TransactionRequestEIP4844<quantity, index>
  | TransactionRequestEIP7702<quantity, index>
>

export type TransactionRequestGeneric<
  quantity = bigint,
  index = number,
> = TransactionRequestBase<quantity, index> & {
  accessList?: AccessList | undefined
  blobs?: readonly Hex[] | readonly ByteArray[] | undefined
  blobVersionedHashes?: readonly Hex[] | undefined
  gasPrice?: quantity | undefined
  maxFeePerBlobGas?: quantity | undefined
  maxFeePerGas?: quantity | undefined
  maxPriorityFeePerGas?: quantity | undefined
  type?: string | undefined
}

////////////////////////////////////////////////////////////////////////////////////////////
// Serializable
////////////////////////////////////////////////////////////////////////////////////////////

export type TransactionSerializedEIP1559 = `0x02${string}`
export type TransactionSerializedEIP2930 = `0x01${string}`
export type TransactionSerializedEIP4844 = `0x03${string}`
export type TransactionSerializedEIP7702 = `0x04${string}`
export type TransactionSerializedLegacy = Branded<`0x${string}`, 'legacy'>
export type TransactionSerializedGeneric = `0x${string}`
export type TransactionSerialized<
  type extends TransactionType = TransactionType,
  result =
    | (type extends 'eip1559' ? TransactionSerializedEIP1559 : never)
    | (type extends 'eip2930' ? TransactionSerializedEIP2930 : never)
    | (type extends 'eip4844' ? TransactionSerializedEIP4844 : never)
    | (type extends 'eip7702' ? TransactionSerializedEIP7702 : never)
    | (type extends 'legacy' ? TransactionSerializedLegacy : never),
> = IsNever<result> extends true ? TransactionSerializedGeneric : result

export type TransactionSerializableBase<
  quantity = bigint,
  index = number,
> = Omit<TransactionRequestBase<quantity, index>, 'from'> &
  ExactPartial<Signature>

export type TransactionSerializableLegacy<
  quantity = bigint,
  index = number,
> = TransactionSerializableBase<quantity, index> &
  ExactPartial<FeeValuesLegacy<quantity>> & {
    chainId?: number | undefined
    type?: 'legacy' | undefined
  }

export type TransactionSerializableEIP2930<
  quantity = bigint,
  index = number,
> = TransactionSerializableBase<quantity, index> &
  ExactPartial<FeeValuesLegacy<quantity>> & {
    accessList?: AccessList | undefined
    chainId: number
    type?: 'eip2930' | undefined
    yParity?: number | undefined
  }

export type TransactionSerializableEIP1559<
  quantity = bigint,
  index = number,
> = TransactionSerializableBase<quantity, index> &
  ExactPartial<FeeValuesEIP1559<quantity>> & {
    accessList?: AccessList | undefined
    chainId: number
    type?: 'eip1559' | undefined
    yParity?: number | undefined
  }

export type TransactionSerializableEIP4844<
  quantity = bigint,
  index = number,
> = TransactionSerializableBase<quantity, index> &
  ExactPartial<FeeValuesEIP4844<quantity>> & {
    accessList?: AccessList | undefined
    chainId: number
    sidecars?: readonly BlobSidecar<Hex>[] | false | undefined
    type?: 'eip4844' | undefined
    yParity?: number | undefined
  } & OneOf<
    | {
        blobs?: readonly Hex[] | readonly ByteArray[] | undefined
        blobVersionedHashes: readonly Hex[]
      }
    | {
        blobs: readonly Hex[] | readonly ByteArray[]
        blobVersionedHashes?: readonly Hex[] | undefined
        kzg: Kzg
      }
  >

export type TransactionSerializableEIP7702<
  quantity = bigint,
  index = number,
> = TransactionSerializableBase<quantity, index> &
  ExactPartial<FeeValuesEIP1559<quantity>> & {
    accessList?: AccessList | undefined
    authorizationList: SignedAuthorizationList
    chainId: number
    type?: 'eip7702' | undefined
    yParity?: number | undefined
  }

export type TransactionSerializable<quantity = bigint, index = number> = OneOf<
  | TransactionSerializableLegacy<quantity, index>
  | TransactionSerializableEIP2930<quantity, index>
  | TransactionSerializableEIP1559<quantity, index>
  | TransactionSerializableEIP4844<quantity, index>
  | TransactionSerializableEIP7702<quantity, index>
>

export type TransactionSerializableGeneric<
  quantity = bigint,
  index = number,
> = TransactionSerializableBase<quantity, index> & {
  accessList?: AccessList | undefined
  authorizationList?: AuthorizationList<index, boolean> | undefined
  blobs?: readonly Hex[] | readonly ByteArray[] | undefined
  blobVersionedHashes?: readonly Hex[] | undefined
  chainId?: number | undefined
  gasPrice?: quantity | undefined
  maxFeePerBlobGas?: quantity | undefined
  maxFeePerGas?: quantity | undefined
  maxPriorityFeePerGas?: quantity | undefined
  sidecars?: readonly BlobSidecar<Hex>[] | false | undefined
  type?: string | undefined
}
</file>

<file path="src/types/transport.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import { fallback } from '../clients/transports/fallback.js'
import { http } from '../clients/transports/http.js'
import { webSocket } from '../clients/transports/webSocket.js'
import type { HasTransportType } from './transport.js'

test('HasTransportType', () => {
  {
    const transport = webSocket()
    expectTypeOf<
      HasTransportType<typeof transport, 'http'>
    >().toEqualTypeOf<false>()
    expectTypeOf<
      HasTransportType<typeof transport, 'webSocket'>
    >().toEqualTypeOf<true>()
  }
  {
    const transport = http()
    expectTypeOf<
      HasTransportType<typeof transport, 'http'>
    >().toEqualTypeOf<true>()
    expectTypeOf<
      HasTransportType<typeof transport, 'webSocket'>
    >().toEqualTypeOf<false>()
  }
  {
    const transport = fallback([http(), webSocket()])
    expectTypeOf<
      HasTransportType<typeof transport, 'http'>
    >().toEqualTypeOf<true>()
    expectTypeOf<
      HasTransportType<typeof transport, 'webSocket'>
    >().toEqualTypeOf<true>()
  }
  {
    const transport = fallback([webSocket()])
    expectTypeOf<
      HasTransportType<typeof transport, 'http'>
    >().toEqualTypeOf<false>()
    expectTypeOf<
      HasTransportType<typeof transport, 'webSocket'>
    >().toEqualTypeOf<true>()
  }
})
</file>

<file path="src/types/transport.ts">
import type { Transport } from '../clients/transports/createTransport.js'
import type { FallbackTransport } from '../clients/transports/fallback.js'
import type { Some } from './utils.js'

export type GetTransportConfig<transport extends Transport> =
  ReturnType<transport>['config']

export type GetPollOptions<transport extends Transport> =
  | (HasTransportType<transport, 'webSocket'> extends true
      ? {
          batch?: undefined
          /**
           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.
           * @default false
           */
          poll?: false | undefined
          pollingInterval?: undefined
        }
      : never)
  | {
      poll?: true | undefined
      /**
       * Whether or not the transaction hashes should be batched on each invocation.
       * @default true
       */
      batch?: boolean | undefined
      /**
       * Polling frequency (in ms). Defaults to Client's pollingInterval config.
       * @default client.pollingInterval
       */
      pollingInterval?: number | undefined
    }

export type HasTransportType<
  transport extends Transport,
  type extends string,
> = GetTransportConfig<transport>['type'] extends type
  ? true
  : transport extends FallbackTransport<
        infer transports extends readonly Transport[]
      >
    ? Some<
        {
          [key in keyof transports]: GetTransportConfig<transports[key]>['type']
        },
        type
      >
    : false
</file>

<file path="src/types/typedData.ts">
import type {
  TypedData,
  TypedDataDomain,
  TypedDataToPrimitiveTypes,
} from 'abitype'

import type { Prettify } from './utils.js'

export type TypedDataDefinition<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
  ///
  primaryTypes = typedData extends TypedData ? keyof typedData : string,
> = primaryType extends 'EIP712Domain'
  ? EIP712DomainDefinition<typedData, primaryType>
  : MessageDefinition<typedData, primaryType, primaryTypes>

type MessageDefinition<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData = keyof typedData,
  ///
  primaryTypes = typedData extends TypedData ? keyof typedData : string,
  schema extends Record<string, unknown> = typedData extends TypedData
    ? TypedDataToPrimitiveTypes<typedData>
    : Record<string, unknown>,
  message = schema[primaryType extends keyof schema
    ? primaryType
    : keyof schema],
> = {
  types: typedData
} & {
  primaryType:
    | primaryTypes // show all values
    | (primaryType extends primaryTypes ? primaryType : never) // infer value
  domain?:
    | (schema extends { EIP712Domain: infer domain }
        ? domain
        : Prettify<TypedDataDomain>)
    | undefined
  message: { [_: string]: any } extends message // Check if message was inferred
    ? Record<string, unknown>
    : message
}

type EIP712DomainDefinition<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends 'EIP712Domain' = 'EIP712Domain',
  ///
  schema extends Record<string, unknown> = typedData extends TypedData
    ? TypedDataToPrimitiveTypes<typedData>
    : Record<string, unknown>,
> = {
  types?: typedData | undefined
} & {
  primaryType: 'EIP712Domain' | primaryType
  domain: schema extends { EIP712Domain: infer domain }
    ? domain
    : Prettify<TypedDataDomain>
  message?: undefined
}
</file>

<file path="src/types/utils.test-d.ts">
import { expectTypeOf, test } from 'vitest'

import type {
  ExactPartial,
  Filter,
  IsNarrowable,
  IsNever,
  IsUndefined,
  IsUnion,
  MaybePartial,
  Or,
  UnionToTuple,
} from './utils.js'

test('Filter', () => {
  expectTypeOf<Filter<[1, 'foo', false, 'baz'], 1 | boolean>>().toEqualTypeOf<
    readonly [1, false]
  >()
})

test('IsNarrowable', () => {
  expectTypeOf<IsNarrowable<'foo', string>>().toEqualTypeOf<true>()
  expectTypeOf<IsNarrowable<string, string>>().toEqualTypeOf<false>()
})

test('IsNever', () => {
  expectTypeOf<IsNever<never>>().toEqualTypeOf<true>()

  expectTypeOf<IsNever<'never'>>().toEqualTypeOf<false>()
  expectTypeOf<IsNever<undefined>>().toEqualTypeOf<false>()
  expectTypeOf<IsNever<null>>().toEqualTypeOf<false>()
  expectTypeOf<IsNever<0>>().toEqualTypeOf<false>()
  expectTypeOf<IsNever<false>>().toEqualTypeOf<false>()
  expectTypeOf<IsNever<[]>>().toEqualTypeOf<false>()
  expectTypeOf<IsNever<{}>>().toEqualTypeOf<false>()
  expectTypeOf<IsNever<never[]>>().toEqualTypeOf<false>()
})

test('IsUndefined', () => {
  expectTypeOf<IsUndefined<undefined>>().toEqualTypeOf<true>()

  expectTypeOf<IsUndefined<never>>().toEqualTypeOf<false>()
  expectTypeOf<IsUndefined<'never'>>().toEqualTypeOf<false>()
  expectTypeOf<IsUndefined<null>>().toEqualTypeOf<false>()
  expectTypeOf<IsUndefined<0>>().toEqualTypeOf<false>()
  expectTypeOf<IsUndefined<false>>().toEqualTypeOf<false>()
  expectTypeOf<IsUndefined<[]>>().toEqualTypeOf<false>()
  expectTypeOf<IsUndefined<{}>>().toEqualTypeOf<false>()
  expectTypeOf<IsUndefined<undefined[]>>().toEqualTypeOf<false>()
})

test('Or', () => {
  expectTypeOf<Or<[true, false, true]>>().toEqualTypeOf<true>()
  expectTypeOf<Or<[false, false, false]>>().toEqualTypeOf<false>()
})

test('UnionToTuple', () => {
  expectTypeOf<UnionToTuple<'foo' | 'bar'>>().toEqualTypeOf<['foo', 'bar']>()
})

test('IsUnion', () => {
  expectTypeOf<IsUnion<'foo' | 'bar'>>().toEqualTypeOf<true>()
  expectTypeOf<IsUnion<'foo'>>().toEqualTypeOf<false>()
})

test('MaybePartial', () => {
  expectTypeOf<MaybePartial<{ a: string; b: number }, true>>().toEqualTypeOf<{
    a?: string | undefined
    b?: number | undefined
  }>()
  expectTypeOf<MaybePartial<{ a: string; b: number }, false>>().toEqualTypeOf<{
    a: string
    b: number
  }>()
})

test('ExactPartial', () => {
  expectTypeOf<ExactPartial<{ a: string; b: number }>>().toEqualTypeOf<{
    a?: string | undefined
    b?: number | undefined
  }>()
})
</file>

<file path="src/types/utils.ts">
declare const symbol: unique symbol

/**
 * Creates a branded type of {@link T} with the brand {@link U}.
 *
 * @param T - Type to brand
 * @param U - Label
 * @returns Branded type
 *
 * @example
 * type Result = Branded<string, 'foo'>
 * //   ^? type Result = string & { [symbol]: 'foo' }
 */
export type Branded<T, U> = T & { [symbol]: U }

/**
 * Filters out all members of {@link T} that are not {@link P}
 *
 * @param T - Items to filter
 * @param P - Type to filter out
 * @returns Filtered items
 *
 * @example
 * type Result = Filter<['a', 'b', 'c'], 'b'>
 * //   ^? type Result = ['a', 'c']
 */
export type Filter<
  T extends readonly unknown[],
  P,
  Acc extends readonly unknown[] = [],
> = T extends readonly [infer F, ...infer Rest extends readonly unknown[]]
  ? [F] extends [P]
    ? Filter<Rest, P, [...Acc, F]>
    : Filter<Rest, P, Acc>
  : readonly [...Acc]

/**
 * @description Checks if {@link T} can be narrowed further than {@link U}
 * @param T - Type to check
 * @param U - Type to against
 * @example
 * type Result = IsNarrowable<'foo', string>
 * //   ^? true
 */
export type IsNarrowable<T, U> = IsNever<
  (T extends U ? true : false) & (U extends T ? false : true)
> extends true
  ? false
  : true

/**
 * @description Checks if {@link T} is `never`
 * @param T - Type to check
 * @example
 * type Result = IsNever<never>
 * //   ^? type Result = true
 */
export type IsNever<T> = [T] extends [never] ? true : false

/** Removes `readonly` from all properties of an object. */
export type Mutable<type extends object> = {
  -readonly [key in keyof type]: type[key]
}

/**
 * @description Evaluates boolean "or" condition for {@link T} properties.
 * @param T - Type to check
 *
 * * @example
 * type Result = Or<[false, true, false]>
 * //   ^? type Result = true
 *
 * @example
 * type Result = Or<[false, false, false]>
 * //   ^? type Result = false
 */
export type Or<T extends readonly unknown[]> = T extends readonly [
  infer Head,
  ...infer Tail,
]
  ? Head extends true
    ? true
    : Or<Tail>
  : false

/**
 * @description Checks if {@link T} is `undefined`
 * @param T - Type to check
 * @example
 * type Result = IsUndefined<undefined>
 * //   ^? type Result = true
 */
export type IsUndefined<T> = [undefined] extends [T] ? true : false

export type MaybePromise<T> = T | Promise<T>

/**
 * @description Makes attributes on the type T required if required is true.
 *
 * @example
 * MaybeRequired<{ a: string, b?: number }, true>
 * => { a: string, b: number }
 *
 * MaybeRequired<{ a: string, b?: number }, false>
 * => { a: string, b?: number }
 */
export type MaybeRequired<T, required extends boolean> = required extends true
  ? ExactRequired<T>
  : T

/**
 * @description Assigns the properties of U onto T.
 *
 * @example
 * Assign<{ a: string, b: number }, { a: undefined, c: boolean }>
 * => { a: undefined, b: number, c: boolean }
 */
export type Assign<T, U> = Assign_<T, U> & U
type Assign_<T, U> = {
  [K in keyof T as K extends keyof U
    ? U[K] extends void
      ? never
      : K
    : K]: K extends keyof U ? U[K] : T[K]
}

// TODO: Remove when peer dep `typescript@>=4.5` (NoInfer is native)
export type NoInfer<type> = [type][type extends any ? 0 : never]

/**
 * @description Constructs a type by excluding `undefined` from `T`.
 *
 * @example
 * NoUndefined<string | undefined>
 * => string
 *
 * @internal
 */
export type NoUndefined<T> = T extends undefined ? never : T

/** Strict version of built-in Omit type */
export type Omit<type, keys extends keyof type> = Pick<
  type,
  Exclude<keyof type, keys>
>

/**
 * @description Creates a type that is a partial of T, but with the required keys K.
 *
 * @example
 * PartialBy<{ a: string, b: number }, 'a'>
 * => { a?: string, b: number }
 */
export type PartialBy<T, K extends keyof T> = Omit<T, K> &
  ExactPartial<Pick<T, K>>

/**
 * @description Combines members of an intersection into a readable type.
 *
 * @see {@link https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg}
 * @example
 * Prettify<{ a: string } & { b: string } & { c: number, d: bigint }>
 * => { a: string, b: string, c: number, d: bigint }
 */
export type Prettify<T> = {
  [K in keyof T]: T[K]
} & {}

/** @internal */
export type Evaluate<type> = {
  [key in keyof type]: type[key]
} & {}

/**
 * @description Creates a type that is T with the required keys K.
 *
 * @example
 * RequiredBy<{ a?: string, b: number }, 'a'>
 * => { a: string, b: number }
 */
export type RequiredBy<T, K extends keyof T> = Omit<T, K> &
  ExactRequired<Pick<T, K>>

/**
 * @description Returns truthy if `array` contains `value`.
 *
 * @example
 * Some<[1, 2, 3], 2>
 * => true
 */
export type Some<
  array extends readonly unknown[],
  value,
> = array extends readonly [value, ...unknown[]]
  ? true
  : array extends readonly [unknown, ...infer rest]
    ? Some<rest, value>
    : false

/**
 * @description Creates a type that extracts the values of T.
 *
 * @example
 * ValueOf<{ a: string, b: number }>
 * => string | number
 *
 * @internal
 */
export type ValueOf<T> = T[keyof T]

export type UnionToTuple<
  union,
  ///
  last = LastInUnion<union>,
> = [union] extends [never] ? [] : [...UnionToTuple<Exclude<union, last>>, last]
type LastInUnion<U> = UnionToIntersection<
  U extends unknown ? (x: U) => 0 : never
> extends (x: infer l) => 0
  ? l
  : never
type UnionToIntersection<union> = (
  union extends unknown
    ? (arg: union) => 0
    : never
) extends (arg: infer i) => 0
  ? i
  : never

export type IsUnion<
  union,
  ///
  union2 = union,
> = union extends union2 ? ([union2] extends [union] ? false : true) : never

export type MaybePartial<
  type,
  enabled extends boolean | undefined,
> = enabled extends true ? Prettify<ExactPartial<type>> : type

export type ExactPartial<type> = {
  [key in keyof type]?: type[key] | undefined
}

export type ExactRequired<type> = {
  [P in keyof type]-?: Exclude<type[P], undefined>
}

export type OneOf<
  union extends object,
  fallback extends object | undefined = undefined,
  ///
  keys extends KeyofUnion<union> = KeyofUnion<union>,
> = union extends infer item
  ? Prettify<
      item & {
        [key in Exclude<keys, keyof item>]?: fallback extends object
          ? key extends keyof fallback
            ? fallback[key]
            : undefined
          : undefined
      }
    >
  : never
type KeyofUnion<type> = type extends type ? keyof type : never

///////////////////////////////////////////////////////////////////////////
// Loose types

/**
 * Loose version of {@link Omit}
 * @internal
 */
export type LooseOmit<type, keys extends string> = Pick<
  type,
  Exclude<keyof type, keys>
>

///////////////////////////////////////////////////////////////////////////
// Union types

export type UnionEvaluate<type> = type extends object ? Prettify<type> : type

export type UnionLooseOmit<type, keys extends string> = type extends any
  ? LooseOmit<type, keys>
  : never

/**
 * @description Construct a type with the properties of union type T except for those in type K.
 * @example
 * type Result = UnionOmit<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>
 * => { b: number } | { b: undefined, c: number }
 */
export type UnionOmit<type, keys extends keyof type> = type extends any
  ? Omit<type, keys>
  : never

/**
 * @description Construct a type with the properties of union type T except for those in type K.
 * @example
 * type Result = UnionOmit<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>
 * => { b: number } | { b: undefined, c: number }
 */
export type UnionPick<type, keys extends keyof type> = type extends any
  ? Pick<type, keys>
  : never

/**
 * @description Creates a type that is a partial of T, but with the required keys K.
 *
 * @example
 * PartialBy<{ a: string, b: number } | { a: string, b: undefined, c: number }, 'a'>
 * => { a?: string, b: number } | { a?: string, b: undefined, c: number }
 */
export type UnionPartialBy<T, K extends keyof T> = T extends any
  ? PartialBy<T, K>
  : never

/**
 * @description Creates a type that is T with the required keys K.
 *
 * @example
 * RequiredBy<{ a?: string, b: number } | { a?: string, c?: number }, 'a'>
 * => { a: string, b: number } | { a: string, c?: number }
 */
export type UnionRequiredBy<T, K extends keyof T> = T extends any
  ? RequiredBy<T, K>
  : never
</file>

<file path="src/types/window.ts">
import type { EIP1193Provider } from './eip1193.js'

declare global {
  interface Window {
    ethereum?: EIP1193Provider | undefined
  }
}
</file>

<file path="src/types/withdrawal.ts">
import type { Hex } from './misc.js'

export type Withdrawal = {
  address: Hex
  amount: Hex
  index: Hex
  validatorIndex: Hex
}
</file>

<file path="src/utils/address/getAddress.bench.ts">
import { getAddress as getAddressV6 } from 'ethers'
import { bench, describe } from 'vitest'

import { getAddress } from './getAddress.js'

describe.skip('Get Address', () => {
  bench('viem: getAddress', () => {
    getAddress('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC')
  })

  bench('ethers: getAddress', () => {
    getAddressV6('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC')
  })
})
</file>

<file path="src/utils/address/getAddress.ts">
import type { Address } from 'abitype'

import { InvalidAddressError } from '../../errors/address.js'
import type { ErrorType } from '../../errors/utils.js'
import {
  type StringToBytesErrorType,
  stringToBytes,
} from '../encoding/toBytes.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'
import { LruMap } from '../lru.js'
import { type IsAddressErrorType, isAddress } from './isAddress.js'

const checksumAddressCache = /*#__PURE__*/ new LruMap<Address>(8192)

export type ChecksumAddressErrorType =
  | Keccak256ErrorType
  | StringToBytesErrorType
  | ErrorType

export function checksumAddress(
  address_: Address,
  /**
   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
   * that relies on EIP-55 checksum encoding (checksum without chainId).
   *
   * It is highly recommended to not use this feature unless you
   * know what you are doing.
   *
   * See more: https://github.com/ethereum/EIPs/issues/1121
   */
  chainId?: number | undefined,
): Address {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`)!

  const hexAddress = chainId
    ? `${chainId}${address_.toLowerCase()}`
    : address_.substring(2).toLowerCase()
  const hash = keccak256(stringToBytes(hexAddress), 'bytes')

  const address = (
    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress
  ).split('')
  for (let i = 0; i < 40; i += 2) {
    if (hash[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase()
    }
    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase()
    }
  }

  const result = `0x${address.join('')}` as const
  checksumAddressCache.set(`${address_}.${chainId}`, result)
  return result
}

export type GetAddressErrorType =
  | ChecksumAddressErrorType
  | IsAddressErrorType
  | ErrorType

export function getAddress(
  address: string,
  /**
   * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
   * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
   * that relies on EIP-55 checksum encoding (checksum without chainId).
   *
   * It is highly recommended to not use this feature unless you
   * know what you are doing.
   *
   * See more: https://github.com/ethereum/EIPs/issues/1121
   */
  chainId?: number,
): Address {
  if (!isAddress(address, { strict: false }))
    throw new InvalidAddressError({ address })
  return checksumAddress(address, chainId)
}
</file>

<file path="src/utils/address/getContractAddress.bench.ts">
import { getCreateAddress } from 'ethers'
import { bench, describe } from 'vitest'

import { getContractAddress } from './getContractAddress.js'

describe.skip('Get Contract Address (CREATE)', () => {
  bench('viem: getContractAddress', () => {
    getContractAddress({
      from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
      nonce: 69420n,
    })
  })

  bench('ethers: getContractAddress', () => {
    getCreateAddress({
      from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b',
      nonce: 69420n,
    })
  })
})
</file>

<file path="src/utils/address/getContractAddress.ts">
import type { Address } from 'abitype'

import type { ByteArray, Hex } from '../../types/misc.js'
import { type ConcatErrorType, concat } from '../data/concat.js'
import { type IsBytesErrorType, isBytes } from '../data/isBytes.js'
import { type PadErrorType, pad } from '../data/pad.js'
import { type SliceErrorType, slice } from '../data/slice.js'
import { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'
import { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'

import type { ErrorType } from '../../errors/utils.js'
import { type GetAddressErrorType, getAddress } from './getAddress.js'

export type GetCreateAddressOptions = {
  from: Address
  nonce: bigint
}

export type GetCreate2AddressOptions =
  | {
      bytecode: ByteArray | Hex
      from: Address
      salt: ByteArray | Hex
    }
  | {
      bytecodeHash: ByteArray | Hex
      from: Address
      salt: ByteArray | Hex
    }

export type GetContractAddressOptions =
  | ({
      opcode?: 'CREATE' | undefined
    } & GetCreateAddressOptions)
  | ({ opcode: 'CREATE2' } & GetCreate2AddressOptions)

export function getContractAddress(opts: GetContractAddressOptions) {
  if (opts.opcode === 'CREATE2') return getCreate2Address(opts)
  return getCreateAddress(opts)
}

export type GetCreateAddressErrorType =
  | Keccak256ErrorType
  | GetAddressErrorType
  | ToBytesErrorType
  | ToRlpErrorType
  | ErrorType

export function getCreateAddress(opts: GetCreateAddressOptions) {
  const from = toBytes(getAddress(opts.from))

  let nonce = toBytes(opts.nonce)
  if (nonce[0] === 0) nonce = new Uint8Array([])

  return getAddress(
    `0x${keccak256(toRlp([from, nonce], 'bytes')).slice(26)}` as Address,
  )
}

export type GetCreate2AddressErrorType =
  | ConcatErrorType
  | Keccak256ErrorType
  | GetAddressErrorType
  | IsBytesErrorType
  | PadErrorType
  | SliceErrorType
  | ToBytesErrorType
  | ToRlpErrorType
  | ErrorType

export function getCreate2Address(opts: GetCreate2AddressOptions) {
  const from = toBytes(getAddress(opts.from))
  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {
    size: 32,
  })

  const bytecodeHash = (() => {
    if ('bytecodeHash' in opts) {
      if (isBytes(opts.bytecodeHash)) return opts.bytecodeHash
      return toBytes(opts.bytecodeHash)
    }
    return keccak256(opts.bytecode, 'bytes')
  })()

  return getAddress(
    slice(keccak256(concat([toBytes('0xff'), from, salt, bytecodeHash])), 12),
  )
}
</file>

<file path="src/utils/address/isAddress.bench.ts">
import { isAddress as isAddressV6 } from 'ethers'
import { bench, describe } from 'vitest'

import { isAddress, isAddressCache } from './isAddress.js'

describe('Is Address', () => {
  bench('viem: isAddress', () => {
    isAddressCache.clear()
    isAddress('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC', { strict: false })
  })

  bench('viem: isAddress (strict)', () => {
    isAddressCache.clear()
    isAddress('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC')
  })

  bench('ethers: isAddress', () => {
    isAddressV6('0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC')
  })
})
</file>

<file path="src/utils/address/isAddress.ts">
import type { Address } from 'abitype'
import type { ErrorType } from '../../errors/utils.js'
import { LruMap } from '../lru.js'
import { checksumAddress } from './getAddress.js'

const addressRegex = /^0x[a-fA-F0-9]{40}$/

/** @internal */
export const isAddressCache = /*#__PURE__*/ new LruMap<boolean>(8192)

export type IsAddressOptions = {
  /**
   * Enables strict mode. Whether or not to compare the address against its checksum.
   *
   * @default true
   */
  strict?: boolean | undefined
}

export type IsAddressErrorType = ErrorType

export function isAddress(
  address: string,
  options?: IsAddressOptions | undefined,
): address is Address {
  const { strict = true } = options ?? {}
  const cacheKey = `${address}.${strict}`

  if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey)!

  const result = (() => {
    if (!addressRegex.test(address)) return false
    if (address.toLowerCase() === address) return true
    if (strict) return checksumAddress(address as Address) === address
    return true
  })()
  isAddressCache.set(cacheKey, result)
  return result
}
</file>

<file path="src/utils/address/isAddressEqual.ts">
import type { Address } from 'abitype'

import {
  InvalidAddressError,
  type InvalidAddressErrorType,
} from '../../errors/address.js'
import type { ErrorType } from '../../errors/utils.js'
import { isAddress } from './isAddress.js'

export type IsAddressEqualReturnType = boolean
export type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType

export function isAddressEqual(a: Address, b: Address) {
  if (!isAddress(a, { strict: false }))
    throw new InvalidAddressError({ address: a })
  if (!isAddress(b, { strict: false }))
    throw new InvalidAddressError({ address: b })
  return a.toLowerCase() === b.toLowerCase()
}
</file>

<file path="src/utils/authorization/hashAuthorization.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { AuthorizationRequest } from '../../types/authorization.js'
import type { ByteArray, Hex } from '../../types/misc.js'
import { type ConcatHexErrorType, concatHex } from '../data/concat.js'
import { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'
import { type NumberToHexErrorType, numberToHex } from '../encoding/toHex.js'
import { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'

type To = 'hex' | 'bytes'

export type HashAuthorizationParameters<to extends To> =
  AuthorizationRequest & {
    /** Output format. @default "hex" */
    to?: to | To | undefined
  }

export type HashAuthorizationReturnType<to extends To> =
  | (to extends 'bytes' ? ByteArray : never)
  | (to extends 'hex' ? Hex : never)

export type HashAuthorizationErrorType =
  | Keccak256ErrorType
  | ConcatHexErrorType
  | ToRlpErrorType
  | NumberToHexErrorType
  | HexToBytesErrorType
  | ErrorType

/**
 * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.
 */
export function hashAuthorization<to extends To = 'hex'>(
  parameters: HashAuthorizationParameters<to>,
): HashAuthorizationReturnType<to> {
  const { chainId, nonce, to } = parameters
  const address = parameters.contractAddress ?? parameters.address
  const hash = keccak256(
    concatHex([
      '0x05',
      toRlp([
        chainId ? numberToHex(chainId) : '0x',
        address,
        nonce ? numberToHex(nonce) : '0x',
      ]),
    ]),
  )
  if (to === 'bytes') return hexToBytes(hash) as HashAuthorizationReturnType<to>
  return hash as HashAuthorizationReturnType<to>
}
</file>

<file path="src/utils/authorization/recoverAuthorizationAddress.ts">
import type { Address } from 'abitype'

import type { ErrorType } from '../../errors/utils.js'
import type {
  Authorization,
  AuthorizationRequest,
  SignedAuthorization,
} from '../../types/authorization.js'
import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import type { OneOf } from '../../types/utils.js'
import {
  type RecoverAddressErrorType,
  recoverAddress,
} from '../signature/recoverAddress.js'
import {
  type HashAuthorizationErrorType,
  hashAuthorization,
} from './hashAuthorization.js'

export type RecoverAuthorizationAddressParameters<
  authorization extends OneOf<
    Authorization | AuthorizationRequest | SignedAuthorization
  > = OneOf<Authorization | AuthorizationRequest | SignedAuthorization>,
  //
  _signature = Hex | ByteArray | OneOf<Signature | SignedAuthorization>,
> = {
  /**
   * The Authorization object.
   *
   * - If an unsigned `authorization` is provided, the `signature` property is required.
   * - If a signed `authorization` is provided, the `signature` property does not need to be provided.
   */
  authorization:
    | authorization
    | OneOf<Authorization | AuthorizationRequest | SignedAuthorization>
} & (authorization extends SignedAuthorization
  ? {
      /** Signature of the Authorization. Not required if the `authorization` is signed. */
      signature?: _signature | undefined
    }
  : {
      /** Signature of the Authorization. Not required if the `authorization` is signed. */
      signature: _signature
    })

export type RecoverAuthorizationAddressReturnType = Address

export type RecoverAuthorizationAddressErrorType =
  | HashAuthorizationErrorType
  | RecoverAddressErrorType
  | ErrorType

export async function recoverAuthorizationAddress<
  const authorization extends OneOf<
    Authorization | AuthorizationRequest | SignedAuthorization
  >,
>(
  parameters: RecoverAuthorizationAddressParameters<authorization>,
): Promise<RecoverAuthorizationAddressReturnType> {
  const { authorization, signature } = parameters

  return recoverAddress({
    hash: hashAuthorization(authorization as AuthorizationRequest),
    signature: (signature ?? authorization) as Signature,
  })
}
</file>

<file path="src/utils/authorization/serializeAuthorizationList.ts">
import type { ErrorType } from '../../errors/utils.js'
import type {
  AuthorizationList,
  SerializedAuthorizationList,
} from '../../types/authorization.js'
import { toHex } from '../encoding/toHex.js'
import { toYParitySignatureArray } from '../transaction/serializeTransaction.js'

export type SerializeAuthorizationListReturnType = SerializedAuthorizationList

export type SerializeAuthorizationListErrorType = ErrorType

/*
 * Serializes an EIP-7702 authorization list.
 */
export function serializeAuthorizationList(
  authorizationList?: AuthorizationList<number, true> | undefined,
): SerializeAuthorizationListReturnType {
  if (!authorizationList || authorizationList.length === 0) return []

  const serializedAuthorizationList = []
  for (const authorization of authorizationList) {
    const { chainId, nonce, ...signature } = authorization
    const contractAddress = authorization.address
    serializedAuthorizationList.push([
      chainId ? toHex(chainId) : '0x',
      contractAddress,
      nonce ? toHex(nonce) : '0x',
      ...toYParitySignatureArray({}, signature),
    ])
  }

  return serializedAuthorizationList as {} as SerializeAuthorizationListReturnType
}
</file>

<file path="src/utils/authorization/verifyAuthorization.ts">
import type { Address } from 'abitype'

import type { ErrorType } from '../../errors/utils.js'
import { type GetAddressErrorType, getAddress } from '../address/getAddress.js'
import {
  type IsAddressEqualErrorType,
  isAddressEqual,
} from '../address/isAddressEqual.js'
import {
  type RecoverAuthorizationAddressErrorType,
  type RecoverAuthorizationAddressParameters,
  recoverAuthorizationAddress,
} from './recoverAuthorizationAddress.js'

export type VerifyAuthorizationParameters =
  RecoverAuthorizationAddressParameters & {
    /** The address that signed the Authorization object. */
    address: Address
  }

export type VerifyAuthorizationReturnType = boolean

export type VerifyAuthorizationErrorType =
  | IsAddressEqualErrorType
  | GetAddressErrorType
  | RecoverAuthorizationAddressErrorType
  | ErrorType

/**
 * Verify that an Authorization object was signed by the provided address.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyAuthorization}
 *
 * @param parameters - {@link VerifyAuthorizationParameters}
 * @returns Whether or not the signature is valid. {@link VerifyAuthorizationReturnType}
 */
export async function verifyAuthorization({
  address,
  authorization,
  signature,
}: VerifyAuthorizationParameters): Promise<VerifyAuthorizationReturnType> {
  return isAddressEqual(
    getAddress(address),
    await recoverAuthorizationAddress({
      authorization,
      signature,
    }),
  )
}
</file>

<file path="src/utils/chain/assertCurrentChain.ts">
import {
  ChainMismatchError,
  type ChainMismatchErrorType,
  ChainNotFoundError,
  type ChainNotFoundErrorType,
} from '../../errors/chain.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'

export type AssertCurrentChainParameters = {
  chain?: Chain | undefined
  currentChainId: number
}

export type AssertCurrentChainErrorType =
  | ChainNotFoundErrorType
  | ChainMismatchErrorType
  | ErrorType

export function assertCurrentChain({
  chain,
  currentChainId,
}: AssertCurrentChainParameters): void {
  if (!chain) throw new ChainNotFoundError()
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId })
}
</file>

<file path="src/utils/chain/defineChain.ts">
import type { Chain, ChainFormatters } from '../../types/chain.js'
import type { Assign, Prettify } from '../../types/utils.js'

export function defineChain<
  formatters extends ChainFormatters,
  const chain extends Chain<formatters>,
>(chain: chain): Prettify<Assign<Chain<undefined>, chain>> {
  return {
    formatters: undefined,
    fees: undefined,
    serializers: undefined,
    ...chain,
  } as Assign<Chain<undefined>, chain>
}
</file>

<file path="src/utils/chain/extractChain.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'

export type ExtractChainParameters<
  chains extends readonly Chain[],
  chainId extends chains[number]['id'],
> = {
  chains: chains
  id: chainId | chains[number]['id']
}

export type ExtractChainReturnType<
  chains extends readonly Chain[],
  chainId extends chains[number]['id'],
> = Extract<chains[number], { id: chainId }>

export type ExtractChainErrorType = ErrorType

export function extractChain<
  const chains extends readonly Chain[],
  chainId extends chains[number]['id'],
>({
  chains,
  id,
}: ExtractChainParameters<chains, chainId>): ExtractChainReturnType<
  chains,
  chainId
> {
  return chains.find((chain) => chain.id === id) as ExtractChainReturnType<
    chains,
    chainId
  >
}
</file>

<file path="src/utils/chain/getChainContractAddress.ts">
import {
  ChainDoesNotSupportContract,
  type ChainDoesNotSupportContractErrorType,
} from '../../errors/chain.js'
import type { Chain, ChainContract } from '../../types/chain.js'

export type GetChainContractAddressErrorType =
  ChainDoesNotSupportContractErrorType

export function getChainContractAddress({
  blockNumber,
  chain,
  contract: name,
}: {
  blockNumber?: bigint | undefined
  chain: Chain
  contract: string
}) {
  const contract = (chain?.contracts as Record<string, ChainContract>)?.[name]
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name },
    })

  if (
    blockNumber &&
    contract.blockCreated &&
    contract.blockCreated > blockNumber
  )
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name,
        blockCreated: contract.blockCreated,
      },
    })

  return contract.address
}
</file>

<file path="src/utils/ens/avatar/parseAvatarRecord.ts">
import type { Client } from '../../../clients/createClient.js'
import type { Transport } from '../../../clients/transports/createTransport.js'
import type { ErrorType } from '../../../errors/utils.js'
import type { Chain } from '../../../types/chain.js'
import type { AssetGatewayUrls } from '../../../types/ens.js'

import {
  type GetJsonImageErrorType,
  type GetMetadataAvatarUriErrorType,
  type GetNftTokenUriErrorType,
  type ParseAvatarUriErrorType,
  type ParseNftUriErrorType,
  type ResolveAvatarUriErrorType,
  getJsonImage,
  getMetadataAvatarUri,
  getNftTokenUri,
  parseAvatarUri,
  parseNftUri,
  resolveAvatarUri,
} from './utils.js'

export type ParseAvatarRecordErrorType =
  | ParseNftAvatarUriErrorType
  | ParseAvatarUriErrorType
  | ErrorType

/*
 * @description Parses an ENS avatar record.
 *
 * @example
 * parseAvatarRecord('eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063')
 * 'https://ipfs.io/ipfs/QmSP4nq9fnN9dAiCj42ug9Wa79rqmQerZXZch82VqpiH7U/image.gif'
 *
 * @see https://docs.ens.domains/web/avatars
 *
 */
export async function parseAvatarRecord<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  {
    gatewayUrls,
    record,
  }: {
    gatewayUrls?: AssetGatewayUrls | undefined
    record: string
  },
): Promise<string> {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record })
  return parseAvatarUri({ uri: record, gatewayUrls })
}

type ParseNftAvatarUriErrorType =
  | ParseNftUriErrorType
  | GetNftTokenUriErrorType
  | ResolveAvatarUriErrorType
  | ParseAvatarUriErrorType
  | GetJsonImageErrorType
  | GetMetadataAvatarUriErrorType
  | ErrorType

async function parseNftAvatarUri<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  {
    gatewayUrls,
    record,
  }: {
    gatewayUrls?: AssetGatewayUrls | undefined
    record: string
  },
): Promise<string> {
  // parse NFT URI into properties
  const nft = parseNftUri(record)
  // fetch tokenURI from the NFT contract
  const nftUri = await getNftTokenUri(client, { nft })
  // resolve the URI from the fetched tokenURI
  const {
    uri: resolvedNftUri,
    isOnChain,
    isEncoded,
  } = resolveAvatarUri({ uri: nftUri, gatewayUrls })

  // if the resolved URI is on chain, return the data
  if (
    isOnChain &&
    (resolvedNftUri.includes('data:application/json;base64,') ||
      resolvedNftUri.startsWith('{'))
  ) {
    const encodedJson = isEncoded
      ? // if it is encoded, decode it
        atob(resolvedNftUri.replace('data:application/json;base64,', ''))
      : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
        resolvedNftUri

    const decoded = JSON.parse(encodedJson)
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls })
  }

  let uriTokenId = nft.tokenID
  if (nft.namespace === 'erc1155')
    uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0')

  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),
  })
}
</file>

<file path="src/utils/ens/avatar/utils.ts">
import type { Address } from 'abitype'

import {
  type ReadContractErrorType,
  readContract,
} from '../../../actions/public/readContract.js'
import type { Client } from '../../../clients/createClient.js'
import type { Transport } from '../../../clients/transports/createTransport.js'
import {
  EnsAvatarInvalidMetadataError,
  type EnsAvatarInvalidMetadataErrorType,
  EnsAvatarInvalidNftUriError,
  type EnsAvatarInvalidNftUriErrorType,
  EnsAvatarUnsupportedNamespaceError,
  type EnsAvatarUnsupportedNamespaceErrorType,
  EnsAvatarUriResolutionError,
  type EnsAvatarUriResolutionErrorType,
} from '../../../errors/ens.js'
import type { ErrorType } from '../../../errors/utils.js'
import type { Chain } from '../../../types/chain.js'
import type { AssetGatewayUrls } from '../../../types/ens.js'

type UriItem = {
  uri: string
  isOnChain: boolean
  isEncoded: boolean
}

const networkRegex =
  /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/
const ipfsHashRegex =
  /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/

type IsImageUriErrorType = ErrorType

/** @internal */
export async function isImageUri(uri: string) {
  try {
    const res = await fetch(uri, { method: 'HEAD' })
    // retrieve content type header to check if content is image
    if (res.status === 200) {
      const contentType = res.headers.get('content-type')
      return contentType?.startsWith('image/')
    }
    return false
  } catch (error: any) {
    // if error is not cors related then fail
    if (typeof error === 'object' && typeof error.response !== 'undefined') {
      return false
    }
    // fail in NodeJS, since the error is not cors but any other network issue
    // biome-ignore lint/suspicious/noPrototypeBuiltins:
    if (!globalThis.hasOwnProperty('Image')) return false
    // in case of cors, use image api to validate if given url is an actual image
    return new Promise((resolve) => {
      const img = new Image()
      img.onload = () => {
        resolve(true)
      }
      img.onerror = () => {
        resolve(false)
      }
      img.src = uri
    })
  }
}

type GetGatewayErrorType = ErrorType

/** @internal */
export function getGateway(custom: string | undefined, defaultGateway: string) {
  if (!custom) return defaultGateway
  if (custom.endsWith('/')) return custom.slice(0, -1)
  return custom
}

export type ResolveAvatarUriErrorType =
  | GetGatewayErrorType
  | EnsAvatarUriResolutionErrorType
  | ErrorType

export function resolveAvatarUri({
  uri,
  gatewayUrls,
}: {
  uri: string
  gatewayUrls?: AssetGatewayUrls | undefined
}): UriItem {
  const isEncoded = base64Regex.test(uri)
  if (isEncoded) return { uri, isOnChain: true, isEncoded }

  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io')
  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net')

  const networkRegexMatch = uri.match(networkRegex)
  const {
    protocol,
    subpath,
    target,
    subtarget = '',
  } = networkRegexMatch?.groups || {}

  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/'
  const isIPFS =
    protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri)

  if (uri.startsWith('http') && !isIPNS && !isIPFS) {
    let replacedUri = uri
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave)
    return { uri: replacedUri, isOnChain: false, isEncoded: false }
  }

  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false,
    }
  }

  if (protocol === 'ar:/' && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ''}`,
      isOnChain: false,
      isEncoded: false,
    }
  }

  let parsedUri = uri.replace(dataURIRegex, '')
  if (parsedUri.startsWith('<svg')) {
    // if svg, base64 encode
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`
  }

  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false,
    }
  }

  throw new EnsAvatarUriResolutionError({ uri })
}

export type GetJsonImageErrorType =
  | EnsAvatarInvalidMetadataErrorType
  | ErrorType

export function getJsonImage(data: any) {
  // validation check for json data, must include one of theses properties
  if (
    typeof data !== 'object' ||
    (!('image' in data) && !('image_url' in data) && !('image_data' in data))
  ) {
    throw new EnsAvatarInvalidMetadataError({ data })
  }

  return data.image || data.image_url || data.image_data
}

export type GetMetadataAvatarUriErrorType =
  | EnsAvatarUriResolutionErrorType
  | ParseAvatarUriErrorType
  | GetJsonImageErrorType
  | ErrorType

export async function getMetadataAvatarUri({
  gatewayUrls,
  uri,
}: {
  gatewayUrls?: AssetGatewayUrls | undefined
  uri: string
}): Promise<string> {
  try {
    const res = await fetch(uri).then((res) => res.json())
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res),
    })
    return image
  } catch {
    throw new EnsAvatarUriResolutionError({ uri })
  }
}

export type ParseAvatarUriErrorType =
  | ResolveAvatarUriErrorType
  | IsImageUriErrorType
  | EnsAvatarUriResolutionErrorType
  | ErrorType

export async function parseAvatarUri({
  gatewayUrls,
  uri,
}: {
  gatewayUrls?: AssetGatewayUrls | undefined
  uri: string
}): Promise<string> {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls })
  if (isOnChain) return resolvedURI

  // check if resolvedURI is an image, if it is return the url
  const isImage = await isImageUri(resolvedURI)
  if (isImage) return resolvedURI

  throw new EnsAvatarUriResolutionError({ uri })
}

type ParsedNft = {
  chainID: number
  namespace: string
  contractAddress: Address
  tokenID: string
}

export type ParseNftUriErrorType = EnsAvatarInvalidNftUriErrorType | ErrorType

export function parseNftUri(uri_: string): ParsedNft {
  let uri = uri_
  // parse valid nft spec (CAIP-22/CAIP-29)
  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs
  if (uri.startsWith('did:nft:')) {
    // convert DID to CAIP
    uri = uri.replace('did:nft:', '').replace(/_/g, '/')
  }

  const [reference, asset_namespace, tokenID] = uri.split('/')
  const [eip_namespace, chainID] = reference.split(':')
  const [erc_namespace, contractAddress] = asset_namespace.split(':')

  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')
    throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' })
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' })
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: 'Contract address not found',
    })
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' })
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' })

  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress: contractAddress as Address,
    tokenID,
  }
}

export type GetNftTokenUriErrorType =
  | ReadContractErrorType
  | EnsAvatarUnsupportedNamespaceErrorType
  | ErrorType

export async function getNftTokenUri<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  { nft }: { nft: ParsedNft },
) {
  if (nft.namespace === 'erc721') {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: 'tokenURI',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: 'tokenId', type: 'uint256' }],
          outputs: [{ name: '', type: 'string' }],
        },
      ],
      functionName: 'tokenURI',
      args: [BigInt(nft.tokenID)],
    })
  }
  if (nft.namespace === 'erc1155') {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: 'uri',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: '_id', type: 'uint256' }],
          outputs: [{ name: '', type: 'string' }],
        },
      ],
      functionName: 'uri',
      args: [BigInt(nft.tokenID)],
    })
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace })
}
</file>

<file path="src/utils/ens/encodedLabelToLabelhash.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import { type IsHexErrorType, isHex } from '../data/isHex.js'

export type EncodedLabelToLabelhashErrorType = IsHexErrorType | ErrorType

export function encodedLabelToLabelhash(label: string): Hex | null {
  if (label.length !== 66) return null
  if (label.indexOf('[') !== 0) return null
  if (label.indexOf(']') !== 65) return null
  const hash = `0x${label.slice(1, 65)}`
  if (!isHex(hash)) return null
  return hash
}
</file>

<file path="src/utils/ens/encodeLabelhash.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'

export type EncodeLabelhashErrorType = ErrorType

export function encodeLabelhash(hash: Hex): `[${string}]` {
  return `[${hash.slice(2)}]`
}
</file>

<file path="src/utils/ens/errors.ts">
import { panicReasons } from '../../constants/solidity.js'
import { BaseError } from '../../errors/base.js'
import { ContractFunctionRevertedError } from '../../errors/contract.js'
import type { ErrorType } from '../../errors/utils.js'

/** @internal */
export type IsNullUniversalResolverErrorErrorType = ErrorType

/*
 * @description Checks if error is a valid null result UniversalResolver error
 */
export function isNullUniversalResolverError(
  err: unknown,
  callType: 'resolve' | 'reverse',
): boolean {
  if (!(err instanceof BaseError)) return false
  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError)
  if (!(cause instanceof ContractFunctionRevertedError)) return false
  if (cause.data?.errorName === 'ResolverNotFound') return true
  if (cause.data?.errorName === 'ResolverWildcardNotSupported') return true
  if (cause.data?.errorName === 'ResolverNotContract') return true
  if (cause.data?.errorName === 'ResolverError') return true
  if (cause.data?.errorName === 'HttpError') return true
  // Backwards compatibility for older UniversalResolver contracts
  if (
    cause.reason?.includes(
      'Wildcard on non-extended resolvers is not supported',
    )
  )
    return true
  // No primary name set for address.
  if (callType === 'reverse' && cause.reason === panicReasons[50]) return true
  return false
}
</file>

<file path="src/utils/ens/labelhash.ts">
import type { ErrorType } from '../../errors/utils.js'
import {
  type StringToBytesErrorType,
  stringToBytes,
} from '../encoding/toBytes.js'
import { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'
import {
  type EncodedLabelToLabelhashErrorType,
  encodedLabelToLabelhash,
} from './encodedLabelToLabelhash.js'

export type LabelhashErrorType =
  | BytesToHexErrorType
  | EncodedLabelToLabelhashErrorType
  | Keccak256ErrorType
  | StringToBytesErrorType
  | ErrorType

/**
 * @description Hashes ENS label
 *
 * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @example
 * labelhash('eth')
 * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'
 */
export function labelhash(label: string) {
  const result = new Uint8Array(32).fill(0)
  if (!label) return bytesToHex(result)
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label))
}
</file>

<file path="src/utils/ens/localBatchGatewayRequest.ts">
import { batchGatewayAbi } from '../../constants/abis.js'
import { solidityError } from '../../constants/solidity.js'
import type { Hex } from '../../types/misc.js'
import { decodeFunctionData } from '../abi/decodeFunctionData.js'
import { encodeErrorResult } from '../abi/encodeErrorResult.js'
import { encodeFunctionResult } from '../abi/encodeFunctionResult.js'
import type {
  CcipRequestErrorType,
  CcipRequestParameters,
  CcipRequestReturnType,
} from '../ccip.js'

export const localBatchGatewayUrl = 'x-batch-gateway:true'

export async function localBatchGatewayRequest(parameters: {
  data: Hex
  ccipRequest: (
    parameters: CcipRequestParameters,
  ) => Promise<CcipRequestReturnType>
}): Promise<Hex> {
  const { data, ccipRequest } = parameters

  const {
    args: [queries],
  } = decodeFunctionData({ abi: batchGatewayAbi, data })

  const failures: boolean[] = []
  const responses: Hex[] = []
  await Promise.all(
    queries.map(async (query, i) => {
      try {
        responses[i] = await ccipRequest(query)
        failures[i] = false
      } catch (err) {
        failures[i] = true
        responses[i] = encodeError(err as CcipRequestErrorType)
      }
    }),
  )

  return encodeFunctionResult({
    abi: batchGatewayAbi,
    functionName: 'query',
    result: [failures, responses],
  })
}

function encodeError(error: CcipRequestErrorType): Hex {
  if (error.name === 'HttpRequestError' && error.status)
    return encodeErrorResult({
      abi: batchGatewayAbi,
      errorName: 'HttpError',
      args: [error.status, error.shortMessage],
    })
  return encodeErrorResult({
    abi: [solidityError],
    errorName: 'Error',
    args: ['shortMessage' in error ? error.shortMessage : error.message],
  })
}
</file>

<file path="src/utils/ens/namehash.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray } from '../../types/misc.js'
import { type ConcatErrorType, concat } from '../data/concat.js'
import {
  type StringToBytesErrorType,
  type ToBytesErrorType,
  stringToBytes,
  toBytes,
} from '../encoding/toBytes.js'
import { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'
import {
  type EncodedLabelToLabelhashErrorType,
  encodedLabelToLabelhash,
} from './encodedLabelToLabelhash.js'

export type NamehashErrorType =
  | BytesToHexErrorType
  | EncodedLabelToLabelhashErrorType
  | ToBytesErrorType
  | Keccak256ErrorType
  | StringToBytesErrorType
  | ConcatErrorType
  | ErrorType

/**
 * @description Hashes ENS name
 *
 * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @example
 * namehash('wevm.eth')
 * '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'
 *
 * @link https://eips.ethereum.org/EIPS/eip-137
 */
export function namehash(name: string) {
  let result = new Uint8Array(32).fill(0) as ByteArray
  if (!name) return bytesToHex(result)

  const labels = name.split('.')
  // Iterate in reverse order building up hash
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i])
    const hashed = hashFromEncodedLabel
      ? toBytes(hashFromEncodedLabel)
      : keccak256(stringToBytes(labels[i]), 'bytes')
    result = keccak256(concat([result, hashed]), 'bytes')
  }

  return bytesToHex(result)
}
</file>

<file path="src/utils/ens/normalize.ts">
import * as Ens from 'ox/Ens'
import type { ErrorType } from '../../errors/utils.js'

export type NormalizeErrorType = ErrorType

/**
 * @description Normalizes ENS name according to ENSIP-15.
 *
 * @example
 * normalize('wevm.eth')
 * 'wevm.eth'
 *
 * @see https://docs.ens.domains/contract-api-reference/name-processing#normalising-names
 * @see https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md
 */
export function normalize(name: string) {
  return Ens.normalize(name)
}
</file>

<file path="src/utils/ens/packetToBytes.ts">
// Adapted from https://github.com/mafintosh/dns-packet
import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray } from '../../types/misc.js'
import {
  type StringToBytesErrorType,
  stringToBytes,
} from '../encoding/toBytes.js'
import {
  type EncodeLabelhashErrorType,
  encodeLabelhash,
} from './encodeLabelhash.js'
import { type LabelhashErrorType, labelhash } from './labelhash.js'

export type PacketToBytesErrorType =
  | EncodeLabelhashErrorType
  | LabelhashErrorType
  | StringToBytesErrorType
  | ErrorType

/*
 * @description Encodes a DNS packet into a ByteArray containing a UDP payload.
 *
 * @example
 * packetToBytes('awkweb.eth')
 * '0x0661776b7765620365746800'
 *
 * @see https://docs.ens.domains/resolution/names#dns
 *
 */
export function packetToBytes(packet: string): ByteArray {
  // strip leading and trailing `.`
  const value = packet.replace(/^\.|\.$/gm, '')
  if (value.length === 0) return new Uint8Array(1)

  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2)

  let offset = 0
  const list = value.split('.')
  for (let i = 0; i < list.length; i++) {
    let encoded = stringToBytes(list[i])
    // if the length is > 255, make the encoded label value a labelhash
    // this is compatible with the universal resolver
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])))
    bytes[offset] = encoded.length
    bytes.set(encoded, offset + 1)
    offset += encoded.length + 1
  }

  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1)

  return bytes
}
</file>

<file path="src/utils/errors/getCallError.ts">
import type { CallParameters } from '../../actions/public/call.js'
import type { BaseError } from '../../errors/base.js'
import {
  CallExecutionError,
  type CallExecutionErrorType,
} from '../../errors/contract.js'
import { UnknownNodeError } from '../../errors/node.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'

import {
  type GetNodeErrorParameters,
  type GetNodeErrorReturnType,
  getNodeError,
} from './getNodeError.js'

export type GetCallErrorReturnType<cause = ErrorType> = Omit<
  CallExecutionErrorType,
  'cause'
> & {
  cause: cause | GetNodeErrorReturnType
}

export function getCallError<err extends ErrorType<string>>(
  err: err,
  {
    docsPath,
    ...args
  }: CallParameters & {
    chain?: Chain | undefined
    docsPath?: string | undefined
  },
): GetCallErrorReturnType<err> {
  const cause = (() => {
    const cause = getNodeError(
      err as {} as BaseError,
      args as GetNodeErrorParameters,
    )
    if (cause instanceof UnknownNodeError) return err as {} as BaseError
    return cause
  })()
  return new CallExecutionError(cause, {
    docsPath,
    ...args,
  }) as GetCallErrorReturnType<err>
}
</file>

<file path="src/utils/errors/getContractError.ts">
import type { Abi, Address } from 'abitype'

import { AbiDecodingZeroDataError } from '../../errors/abi.js'
import { BaseError } from '../../errors/base.js'
import {
  ContractFunctionExecutionError,
  type ContractFunctionExecutionErrorType,
  ContractFunctionRevertedError,
  type ContractFunctionRevertedErrorType,
  ContractFunctionZeroDataError,
  type ContractFunctionZeroDataErrorType,
  RawContractError,
} from '../../errors/contract.js'
import { RpcRequestError } from '../../errors/request.js'
import { InternalRpcError } from '../../errors/rpc.js'
import type { ErrorType } from '../../errors/utils.js'

const EXECUTION_REVERTED_ERROR_CODE = 3

export type GetContractErrorReturnType<cause = ErrorType> = Omit<
  ContractFunctionExecutionErrorType,
  'cause'
> & {
  cause:
    | cause
    | ContractFunctionZeroDataErrorType
    | ContractFunctionRevertedErrorType
}

export function getContractError<err extends ErrorType<string>>(
  err: err,
  {
    abi,
    address,
    args,
    docsPath,
    functionName,
    sender,
  }: {
    abi: Abi
    args: any
    address?: Address | undefined
    docsPath?: string | undefined
    functionName: string
    sender?: Address | undefined
  },
): GetContractErrorReturnType {
  const error = (
    err instanceof RawContractError
      ? err
      : err instanceof BaseError
        ? err.walk((err) => 'data' in (err as Error)) || err.walk()
        : {}
  ) as BaseError
  const { code, data, details, message, shortMessage } =
    error as RawContractError

  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName })
    if (
      [EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) &&
      (data || details || message || shortMessage)
    ) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === 'object' ? data.data : data,
        functionName,
        message:
          error instanceof RpcRequestError
            ? details
            : (shortMessage ?? message),
      })
    }
    return err
  })()

  return new ContractFunctionExecutionError(cause as BaseError, {
    abi,
    args,
    contractAddress: address,
    docsPath,
    functionName,
    sender,
  }) as GetContractErrorReturnType
}
</file>

<file path="src/utils/errors/getEstimateGasError.ts">
import type { Account } from '../../accounts/types.js'
import type { EstimateGasParameters } from '../../actions/public/estimateGas.js'
import type { BaseError } from '../../errors/base.js'
import {
  EstimateGasExecutionError,
  type EstimateGasExecutionErrorType,
} from '../../errors/estimateGas.js'
import { UnknownNodeError } from '../../errors/node.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'

import {
  type GetNodeErrorParameters,
  type GetNodeErrorReturnType,
  getNodeError,
} from './getNodeError.js'

export type GetEstimateGasErrorReturnType<cause = ErrorType> = Omit<
  EstimateGasExecutionErrorType,
  'cause'
> & { cause: cause | GetNodeErrorReturnType }

export function getEstimateGasError<err extends ErrorType<string>>(
  err: err,
  {
    docsPath,
    ...args
  }: Omit<EstimateGasParameters, 'account'> & {
    account?: Account | undefined
    chain?: Chain | undefined
    docsPath?: string | undefined
  },
): GetEstimateGasErrorReturnType<err> {
  const cause = (() => {
    const cause = getNodeError(
      err as {} as BaseError,
      args as GetNodeErrorParameters,
    )
    if (cause instanceof UnknownNodeError) return err as {} as BaseError
    return cause
  })()
  return new EstimateGasExecutionError(cause, {
    docsPath,
    ...args,
  }) as GetEstimateGasErrorReturnType<err>
}
</file>

<file path="src/utils/errors/getNodeError.ts">
import type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'
import { BaseError } from '../../errors/base.js'
import {
  ExecutionRevertedError,
  type ExecutionRevertedErrorType,
  FeeCapTooHighError,
  type FeeCapTooHighErrorType,
  FeeCapTooLowError,
  type FeeCapTooLowErrorType,
  InsufficientFundsError,
  type InsufficientFundsErrorType,
  IntrinsicGasTooHighError,
  type IntrinsicGasTooHighErrorType,
  IntrinsicGasTooLowError,
  type IntrinsicGasTooLowErrorType,
  NonceMaxValueError,
  type NonceMaxValueErrorType,
  NonceTooHighError,
  type NonceTooHighErrorType,
  NonceTooLowError,
  type NonceTooLowErrorType,
  TipAboveFeeCapError,
  type TipAboveFeeCapErrorType,
  TransactionTypeNotSupportedError,
  type TransactionTypeNotSupportedErrorType,
  UnknownNodeError,
  type UnknownNodeErrorType,
} from '../../errors/node.js'
import { RpcRequestError } from '../../errors/request.js'
import {
  InvalidInputRpcError,
  TransactionRejectedRpcError,
} from '../../errors/rpc.js'
import type { ExactPartial } from '../../types/utils.js'

export function containsNodeError(err: BaseError) {
  return (
    err instanceof TransactionRejectedRpcError ||
    err instanceof InvalidInputRpcError ||
    (err instanceof RpcRequestError && err.code === ExecutionRevertedError.code)
  )
}

export type GetNodeErrorParameters = ExactPartial<
  SendTransactionParameters<any>
>

export type GetNodeErrorReturnType =
  | ExecutionRevertedErrorType
  | FeeCapTooHighErrorType
  | FeeCapTooLowErrorType
  | NonceTooHighErrorType
  | NonceTooLowErrorType
  | NonceMaxValueErrorType
  | InsufficientFundsErrorType
  | IntrinsicGasTooHighErrorType
  | IntrinsicGasTooLowErrorType
  | TransactionTypeNotSupportedErrorType
  | TipAboveFeeCapErrorType
  | UnknownNodeErrorType

export function getNodeError(
  err: BaseError,
  args: GetNodeErrorParameters,
): GetNodeErrorReturnType {
  const message = (err.details || '').toLowerCase()

  const executionRevertedError =
    err instanceof BaseError
      ? err.walk(
          (e) =>
            (e as { code: number } | null | undefined)?.code ===
            ExecutionRevertedError.code,
        )
      : err
  if (executionRevertedError instanceof BaseError)
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details,
    }) as any
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details,
    }) as any
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
    }) as any
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
    }) as any
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce }) as any
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce }) as any
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce }) as any
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err }) as any
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas }) as any
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas }) as any
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err }) as any
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas,
    }) as any
  return new UnknownNodeError({
    cause: err,
  }) as any
}
</file>

<file path="src/utils/errors/getTransactionError.ts">
import type { Account } from '../../accounts/types.js'
import type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'
import type { BaseError } from '../../errors/base.js'
import { UnknownNodeError } from '../../errors/node.js'
import {
  TransactionExecutionError,
  type TransactionExecutionErrorType,
} from '../../errors/transaction.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'

import {
  type GetNodeErrorParameters,
  type GetNodeErrorReturnType,
  getNodeError,
} from './getNodeError.js'

export type GetTransactionErrorParameters = Omit<
  SendTransactionParameters,
  'account' | 'chain'
> & {
  account: Account | null
  chain?: Chain | undefined
  docsPath?: string | undefined
}

export type GetTransactionErrorReturnType<cause = ErrorType> = Omit<
  TransactionExecutionErrorType,
  'cause'
> & { cause: cause | GetNodeErrorReturnType }

export function getTransactionError<err extends ErrorType<string>>(
  err: err,
  { docsPath, ...args }: GetTransactionErrorParameters,
): GetTransactionErrorReturnType<err> {
  const cause = (() => {
    const cause = getNodeError(
      err as {} as BaseError,
      args as GetNodeErrorParameters,
    )
    if (cause instanceof UnknownNodeError) return err as {} as BaseError
    return cause
  })()
  return new TransactionExecutionError(cause, {
    docsPath,
    ...args,
  }) as GetTransactionErrorReturnType<err>
}
</file>

<file path="src/utils/filters/createFilterRequestScope.ts">
import type { Client } from '../../clients/createClient.js'
import type { Transport } from '../../clients/transports/createTransport.js'
import type { OnResponseFn } from '../../clients/transports/fallback.js'
import type { Chain } from '../../types/chain.js'
import type { PublicRpcSchema } from '../../types/eip1193.js'
import type { EIP1193RequestFn } from '../../types/eip1193.js'
import type { Hex } from '../../types/misc.js'
import type { Filter } from '../../types/utils.js'

type CreateFilterRequestScopeParameters = {
  method:
    | 'eth_newFilter'
    | 'eth_newPendingTransactionFilter'
    | 'eth_newBlockFilter'
}

type FilterRpcSchema = Filter<
  PublicRpcSchema,
  { Method: 'eth_getFilterLogs' | 'eth_getFilterChanges' }
>

type CreateFilterRequestScopeReturnType = (
  id: Hex,
) => EIP1193RequestFn<FilterRpcSchema>

/**
 * Scopes `request` to the filter ID. If the client is a fallback, it will
 * listen for responses and scope the child transport `request` function
 * to the successful filter ID.
 */
export function createFilterRequestScope<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  { method }: CreateFilterRequestScopeParameters,
): CreateFilterRequestScopeReturnType {
  const requestMap: Record<Hex, EIP1193RequestFn> = {}

  if (client.transport.type === 'fallback')
    client.transport.onResponse?.(
      ({
        method: method_,
        response: id,
        status,
        transport,
      }: Parameters<OnResponseFn>[0]) => {
        if (status === 'success' && method === method_)
          requestMap[id as Hex] = transport.request
      },
    )

  return ((id) =>
    requestMap[id] || client.request) as CreateFilterRequestScopeReturnType
}
</file>

<file path="src/utils/formatters/block.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Block, BlockTag } from '../../types/block.js'
import type { Chain } from '../../types/chain.js'
import type {
  ExtractChainFormatterExclude,
  ExtractChainFormatterReturnType,
} from '../../types/chain.js'
import type { Hash } from '../../types/misc.js'
import type { RpcBlock } from '../../types/rpc.js'
import type { ExactPartial, Prettify } from '../../types/utils.js'

import { type DefineFormatterErrorType, defineFormatter } from './formatter.js'
import { type FormattedTransaction, formatTransaction } from './transaction.js'

type BlockPendingDependencies = 'hash' | 'logsBloom' | 'nonce' | 'number'

export type FormattedBlock<
  chain extends Chain | undefined = undefined,
  includeTransactions extends boolean = boolean,
  blockTag extends BlockTag = BlockTag,
  _FormatterReturnType = ExtractChainFormatterReturnType<
    chain,
    'block',
    Block<bigint, includeTransactions>
  >,
  _ExcludedPendingDependencies extends string = BlockPendingDependencies &
    ExtractChainFormatterExclude<chain, 'block'>,
  _Formatted = Omit<_FormatterReturnType, BlockPendingDependencies> & {
    [_key in _ExcludedPendingDependencies]: never
  } & Pick<
      Block<bigint, includeTransactions, blockTag>,
      BlockPendingDependencies
    >,
  _Transactions = includeTransactions extends true
    ? Prettify<FormattedTransaction<chain, blockTag>>[]
    : Hash[],
> = Omit<_Formatted, 'transactions'> & {
  transactions: _Transactions
}

export type FormatBlockErrorType = ErrorType

export function formatBlock(block: ExactPartial<RpcBlock>) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === 'string') return transaction
    return formatTransaction(transaction)
  })
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
    difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
    excessBlobGas: block.excessBlobGas
      ? BigInt(block.excessBlobGas)
      : undefined,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : undefined,
    timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
    transactions,
    totalDifficulty: block.totalDifficulty
      ? BigInt(block.totalDifficulty)
      : null,
  } as Block
}

export type DefineBlockErrorType = DefineFormatterErrorType | ErrorType

export const defineBlock = /*#__PURE__*/ defineFormatter('block', formatBlock)
</file>

<file path="src/utils/formatters/extract.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { ChainFormatter } from '../../types/chain.js'

export type ExtractErrorType = ErrorType

/**
 * @description Picks out the keys from `value` that exist in the formatter..
 */
export function extract(
  value_: Record<string, unknown>,
  { format }: { format?: ChainFormatter['format'] | undefined },
) {
  if (!format) return {}

  const value: Record<string, unknown> = {}
  function extract_(formatted: Record<string, any>) {
    const keys = Object.keys(formatted)
    for (const key of keys) {
      if (key in value_) value[key] = value_[key]
      if (
        formatted[key] &&
        typeof formatted[key] === 'object' &&
        !Array.isArray(formatted[key])
      )
        extract_(formatted[key])
    }
  }

  const formatted = format(value_ || {})
  extract_(formatted)

  return value
}
</file>

<file path="src/utils/formatters/feeHistory.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { FeeHistory } from '../../types/fee.js'
import type { RpcFeeHistory } from '../../types/rpc.js'

export type FormatFeeHistoryErrorType = ErrorType

export function formatFeeHistory(feeHistory: RpcFeeHistory): FeeHistory {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) =>
      reward.map((value) => BigInt(value)),
    ),
  }
}
</file>

<file path="src/utils/formatters/formatter.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Prettify } from '../../types/utils.js'

export type DefineFormatterErrorType = ErrorType

export function defineFormatter<type extends string, parameters, returnType>(
  type: type,
  format: (_: parameters) => returnType,
) {
  return <
    parametersOverride,
    returnTypeOverride,
    exclude extends (keyof parameters | keyof parametersOverride)[] = [],
  >({
    exclude,
    format: overrides,
  }: {
    exclude?: exclude | undefined
    format: (_: parametersOverride) => returnTypeOverride
  }) => {
    return {
      exclude,
      format: (args: parametersOverride) => {
        const formatted = format(args as any)
        if (exclude) {
          for (const key of exclude) {
            delete (formatted as any)[key]
          }
        }
        return {
          ...formatted,
          ...overrides(args),
        } as Prettify<returnTypeOverride> & {
          [_key in exclude[number]]: never
        }
      },
      type,
    }
  }
}
</file>

<file path="src/utils/formatters/log.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Log } from '../../types/log.js'
import type { RpcLog } from '../../types/rpc.js'
import type { ExactPartial } from '../../types/utils.js'

export type FormatLogErrorType = ErrorType

export function formatLog(
  log: ExactPartial<RpcLog>,
  {
    args,
    eventName,
  }: { args?: unknown | undefined; eventName?: string | undefined } = {},
) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex
      ? Number(log.transactionIndex)
      : null,
    ...(eventName ? { args, eventName } : {}),
  } as Log
}
</file>

<file path="src/utils/formatters/proof.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { Proof } from '../../types/proof.js'
import type { RpcProof } from '../../types/rpc.js'
import type { ExactPartial } from '../../types/utils.js'
import { hexToNumber } from '../index.js'

export type FormatProofErrorType = ErrorType

function formatStorageProof(storageProof: RpcProof['storageProof']) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value),
  }))
}

export function formatProof(proof: ExactPartial<RpcProof>) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : undefined,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,
    storageProof: proof.storageProof
      ? formatStorageProof(proof.storageProof)
      : undefined,
  } as Proof
}
</file>

<file path="src/utils/formatters/transaction.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { SignedAuthorizationList } from '../../types/authorization.js'
import type { BlockTag } from '../../types/block.js'
import type { Chain } from '../../types/chain.js'
import type {
  ExtractChainFormatterExclude,
  ExtractChainFormatterReturnType,
} from '../../types/chain.js'
import type { Hex } from '../../types/misc.js'
import type { RpcAuthorizationList, RpcTransaction } from '../../types/rpc.js'
import type { Transaction, TransactionType } from '../../types/transaction.js'
import type { ExactPartial, UnionLooseOmit } from '../../types/utils.js'
import { hexToNumber } from '../encoding/fromHex.js'
import { type DefineFormatterErrorType, defineFormatter } from './formatter.js'

type TransactionPendingDependencies =
  | 'blockHash'
  | 'blockNumber'
  | 'transactionIndex'

export type FormattedTransaction<
  chain extends Chain | undefined = undefined,
  blockTag extends BlockTag = BlockTag,
  _FormatterReturnType = ExtractChainFormatterReturnType<
    chain,
    'transaction',
    Transaction
  >,
  _ExcludedPendingDependencies extends string = TransactionPendingDependencies &
    ExtractChainFormatterExclude<chain, 'transaction'>,
> = UnionLooseOmit<_FormatterReturnType, TransactionPendingDependencies> & {
  [_K in _ExcludedPendingDependencies]: never
} & Pick<
    Transaction<bigint, number, blockTag extends 'pending' ? true : false>,
    TransactionPendingDependencies
  >

export const transactionType = {
  '0x0': 'legacy',
  '0x1': 'eip2930',
  '0x2': 'eip1559',
  '0x3': 'eip4844',
  '0x4': 'eip7702',
} as const satisfies Record<Hex, TransactionType>

export type FormatTransactionErrorType = ErrorType

export function formatTransaction(transaction: ExactPartial<RpcTransaction>) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber
      ? BigInt(transaction.blockNumber)
      : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : undefined,
    gas: transaction.gas ? BigInt(transaction.gas) : undefined,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas
      ? BigInt(transaction.maxFeePerBlobGas)
      : undefined,
    maxFeePerGas: transaction.maxFeePerGas
      ? BigInt(transaction.maxFeePerGas)
      : undefined,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
      ? BigInt(transaction.maxPriorityFeePerGas)
      : undefined,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : undefined,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex
      ? Number(transaction.transactionIndex)
      : null,
    type: transaction.type
      ? (transactionType as any)[transaction.type]
      : undefined,
    typeHex: transaction.type ? transaction.type : undefined,
    value: transaction.value ? BigInt(transaction.value) : undefined,
    v: transaction.v ? BigInt(transaction.v) : undefined,
  } as Transaction

  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(
      transaction.authorizationList,
    )

  transaction_.yParity = (() => {
    // If `yParity` is provided, we will use it.
    if (transaction.yParity) return Number(transaction.yParity)

    // If no `yParity` provided, try derive from `v`.
    if (typeof transaction_.v === 'bigint') {
      if (transaction_.v === 0n || transaction_.v === 27n) return 0
      if (transaction_.v === 1n || transaction_.v === 28n) return 1
      if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0
    }

    return undefined
  })()

  if (transaction_.type === 'legacy') {
    delete transaction_.accessList
    delete transaction_.maxFeePerBlobGas
    delete transaction_.maxFeePerGas
    delete transaction_.maxPriorityFeePerGas
    delete transaction_.yParity
  }
  if (transaction_.type === 'eip2930') {
    delete transaction_.maxFeePerBlobGas
    delete transaction_.maxFeePerGas
    delete transaction_.maxPriorityFeePerGas
  }
  if (transaction_.type === 'eip1559') {
    delete transaction_.maxFeePerBlobGas
  }
  return transaction_
}

export type DefineTransactionErrorType = DefineFormatterErrorType | ErrorType

export const defineTransaction = /*#__PURE__*/ defineFormatter(
  'transaction',
  formatTransaction,
)

//////////////////////////////////////////////////////////////////////////////

function formatAuthorizationList(
  authorizationList: RpcAuthorizationList,
): SignedAuthorizationList {
  return authorizationList.map((authorization) => ({
    address: (authorization as any).address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity),
  })) as SignedAuthorizationList
}
</file>

<file path="src/utils/formatters/transactionReceipt.ts">
import type { ErrorType } from '../../errors/utils.js'
import type {
  Chain,
  ExtractChainFormatterReturnType,
} from '../../types/chain.js'
import type { RpcTransactionReceipt } from '../../types/rpc.js'
import type { TransactionReceipt } from '../../types/transaction.js'
import type { ExactPartial } from '../../types/utils.js'
import { hexToNumber } from '../encoding/fromHex.js'

import { type DefineFormatterErrorType, defineFormatter } from './formatter.js'
import { formatLog } from './log.js'
import { transactionType } from './transaction.js'

export type FormattedTransactionReceipt<
  chain extends Chain | undefined = undefined,
> = ExtractChainFormatterReturnType<
  chain,
  'transactionReceipt',
  TransactionReceipt
>

export const receiptStatuses = {
  '0x0': 'reverted',
  '0x1': 'success',
} as const

export type FormatTransactionReceiptErrorType = ErrorType

export function formatTransactionReceipt(
  transactionReceipt: ExactPartial<RpcTransactionReceipt>,
) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber
      ? BigInt(transactionReceipt.blockNumber)
      : null,
    contractAddress: transactionReceipt.contractAddress
      ? transactionReceipt.contractAddress
      : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed
      ? BigInt(transactionReceipt.cumulativeGasUsed)
      : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice
      ? BigInt(transactionReceipt.effectiveGasPrice)
      : null,
    gasUsed: transactionReceipt.gasUsed
      ? BigInt(transactionReceipt.gasUsed)
      : null,
    logs: transactionReceipt.logs
      ? transactionReceipt.logs.map((log) => formatLog(log))
      : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex
      ? hexToNumber(transactionReceipt.transactionIndex)
      : null,
    status: transactionReceipt.status
      ? receiptStatuses[transactionReceipt.status]
      : null,
    type: transactionReceipt.type
      ? transactionType[
          transactionReceipt.type as keyof typeof transactionType
        ] || transactionReceipt.type
      : null,
  } as TransactionReceipt

  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)

  return receipt
}

export type DefineTransactionReceiptErrorType =
  | DefineFormatterErrorType
  | ErrorType

export const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(
  'transactionReceipt',
  formatTransactionReceipt,
)
</file>

<file path="src/utils/formatters/transactionRequest.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { AuthorizationList } from '../../types/authorization.js'
import type {
  Chain,
  ExtractChainFormatterParameters,
} from '../../types/chain.js'
import type { ByteArray } from '../../types/misc.js'
import type {
  RpcAuthorizationList,
  RpcTransactionRequest,
} from '../../types/rpc.js'
import type { TransactionRequest } from '../../types/transaction.js'
import type { ExactPartial } from '../../types/utils.js'
import { bytesToHex, numberToHex } from '../encoding/toHex.js'
import { type DefineFormatterErrorType, defineFormatter } from './formatter.js'

export type FormattedTransactionRequest<
  chain extends Chain | undefined = Chain | undefined,
> = ExtractChainFormatterParameters<
  chain,
  'transactionRequest',
  TransactionRequest
>

export const rpcTransactionType = {
  legacy: '0x0',
  eip2930: '0x1',
  eip1559: '0x2',
  eip4844: '0x3',
  eip7702: '0x4',
} as const

export type FormatTransactionRequestErrorType = ErrorType

export function formatTransactionRequest(
  request: ExactPartial<TransactionRequest>,
) {
  const rpcRequest = {} as RpcTransactionRequest

  if (typeof request.authorizationList !== 'undefined')
    rpcRequest.authorizationList = formatAuthorizationList(
      request.authorizationList,
    )
  if (typeof request.accessList !== 'undefined')
    rpcRequest.accessList = request.accessList
  if (typeof request.blobVersionedHashes !== 'undefined')
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes
  if (typeof request.blobs !== 'undefined') {
    if (typeof request.blobs[0] !== 'string')
      rpcRequest.blobs = (request.blobs as ByteArray[]).map((x) =>
        bytesToHex(x),
      )
    else rpcRequest.blobs = request.blobs
  }
  if (typeof request.data !== 'undefined') rpcRequest.data = request.data
  if (typeof request.from !== 'undefined') rpcRequest.from = request.from
  if (typeof request.gas !== 'undefined')
    rpcRequest.gas = numberToHex(request.gas)
  if (typeof request.gasPrice !== 'undefined')
    rpcRequest.gasPrice = numberToHex(request.gasPrice)
  if (typeof request.maxFeePerBlobGas !== 'undefined')
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas)
  if (typeof request.maxFeePerGas !== 'undefined')
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)
  if (typeof request.maxPriorityFeePerGas !== 'undefined')
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)
  if (typeof request.nonce !== 'undefined')
    rpcRequest.nonce = numberToHex(request.nonce)
  if (typeof request.to !== 'undefined') rpcRequest.to = request.to
  if (typeof request.type !== 'undefined')
    rpcRequest.type = rpcTransactionType[request.type]
  if (typeof request.value !== 'undefined')
    rpcRequest.value = numberToHex(request.value)

  return rpcRequest
}

export type DefineTransactionRequestErrorType =
  | DefineFormatterErrorType
  | ErrorType

export const defineTransactionRequest = /*#__PURE__*/ defineFormatter(
  'transactionRequest',
  formatTransactionRequest,
)

//////////////////////////////////////////////////////////////////////////////

function formatAuthorizationList(
  authorizationList: AuthorizationList<number, boolean>,
): RpcAuthorizationList {
  return authorizationList.map(
    (authorization) =>
      ({
        address: authorization.address,
        r: authorization.r
          ? numberToHex(BigInt(authorization.r))
          : authorization.r,
        s: authorization.s
          ? numberToHex(BigInt(authorization.s))
          : authorization.s,
        chainId: numberToHex(authorization.chainId),
        nonce: numberToHex(authorization.nonce),
        ...(typeof authorization.yParity !== 'undefined'
          ? { yParity: numberToHex(authorization.yParity) }
          : {}),
        ...(typeof authorization.v !== 'undefined' &&
        typeof authorization.yParity === 'undefined'
          ? { v: numberToHex(authorization.v) }
          : {}),
      }) as any,
  ) as RpcAuthorizationList
}
</file>

<file path="src/utils/promise/createBatchScheduler.ts">
import type { ErrorType } from '../../errors/utils.js'
import { type PromiseWithResolvers, withResolvers } from './withResolvers.js'

type Resolved<returnType extends readonly unknown[] = any> = [
  result: returnType[number],
  results: returnType,
]

type SchedulerItem = {
  args: unknown
  resolve: PromiseWithResolvers<unknown>['resolve']
  reject: PromiseWithResolvers<unknown>['reject']
}

type BatchResultsCompareFn<result = unknown> = (a: result, b: result) => number

type CreateBatchSchedulerArguments<
  parameters = unknown,
  returnType extends readonly unknown[] = readonly unknown[],
> = {
  fn: (args: parameters[]) => Promise<returnType>
  id: number | string
  shouldSplitBatch?: ((args: parameters[]) => boolean) | undefined
  wait?: number | undefined
  sort?: BatchResultsCompareFn<returnType[number]> | undefined
}

type CreateBatchSchedulerReturnType<
  parameters = unknown,
  returnType extends readonly unknown[] = readonly unknown[],
> = {
  flush: () => void
  schedule: parameters extends undefined
    ? (args?: parameters | undefined) => Promise<Resolved<returnType>>
    : (args: parameters) => Promise<Resolved<returnType>>
}

export type CreateBatchSchedulerErrorType = ErrorType

const schedulerCache = /*#__PURE__*/ new Map<number | string, SchedulerItem[]>()

/** @internal */
export function createBatchScheduler<
  parameters,
  returnType extends readonly unknown[],
>({
  fn,
  id,
  shouldSplitBatch,
  wait = 0,
  sort,
}: CreateBatchSchedulerArguments<
  parameters,
  returnType
>): CreateBatchSchedulerReturnType<parameters, returnType> {
  const exec = async () => {
    const scheduler = getScheduler()
    flush()

    const args = scheduler.map(({ args }) => args)

    if (args.length === 0) return

    fn(args as parameters[])
      .then((data) => {
        if (sort && Array.isArray(data)) data.sort(sort)
        for (let i = 0; i < scheduler.length; i++) {
          const { resolve } = scheduler[i]
          resolve?.([data[i], data])
        }
      })
      .catch((err) => {
        for (let i = 0; i < scheduler.length; i++) {
          const { reject } = scheduler[i]
          reject?.(err)
        }
      })
  }

  const flush = () => schedulerCache.delete(id)

  const getBatchedArgs = () =>
    getScheduler().map(({ args }) => args) as parameters[]

  const getScheduler = () => schedulerCache.get(id) || []

  const setScheduler = (item: SchedulerItem) =>
    schedulerCache.set(id, [...getScheduler(), item])

  return {
    flush,
    async schedule(args: parameters) {
      const { promise, resolve, reject } = withResolvers()

      const split = shouldSplitBatch?.([...getBatchedArgs(), args])

      if (split) exec()

      const hasActiveScheduler = getScheduler().length > 0
      if (hasActiveScheduler) {
        setScheduler({ args, resolve, reject })
        return promise
      }

      setScheduler({ args, resolve, reject })
      setTimeout(exec, wait)
      return promise
    },
  } as unknown as CreateBatchSchedulerReturnType<parameters, returnType>
}
</file>

<file path="src/utils/promise/withCache.ts">
import type { ErrorType } from '../../errors/utils.js'

/** @internal */
export const promiseCache = /*#__PURE__*/ new Map()
/** @internal */
export const responseCache = /*#__PURE__*/ new Map()

export type GetCacheErrorType = ErrorType

export function getCache<data>(cacheKey: string) {
  const buildCache = <data>(cacheKey: string, cache: Map<string, data>) => ({
    clear: () => cache.delete(cacheKey),
    get: () => cache.get(cacheKey),
    set: (data: data) => cache.set(cacheKey, data),
  })

  const promise = buildCache<Promise<data>>(cacheKey, promiseCache)
  const response = buildCache<{ created: Date; data: data }>(
    cacheKey,
    responseCache,
  )

  return {
    clear: () => {
      promise.clear()
      response.clear()
    },
    promise,
    response,
  }
}

type WithCacheParameters = {
  /** The key to cache the data against. */
  cacheKey: string
  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */
  cacheTime?: number | undefined
}

/**
 * @description Returns the result of a given promise, and caches the result for
 * subsequent invocations against a provided cache key.
 */
export async function withCache<data>(
  fn: () => Promise<data>,
  { cacheKey, cacheTime = Number.POSITIVE_INFINITY }: WithCacheParameters,
) {
  const cache = getCache<data>(cacheKey)

  // If a response exists in the cache, and it's not expired, return it
  // and do not invoke the promise.
  // If the max age is 0, the cache is disabled.
  const response = cache.response.get()
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime()
    if (age < cacheTime) return response.data
  }

  let promise = cache.promise.get()
  if (!promise) {
    promise = fn()

    // Store the promise in the cache so that subsequent invocations
    // will wait for the same promise to resolve (deduping).
    cache.promise.set(promise)
  }

  try {
    const data = await promise

    // Store the response in the cache so that subsequent invocations
    // will return the same response.
    cache.response.set({ created: new Date(), data })

    return data
  } finally {
    // Clear the promise cache so that subsequent invocations will
    // invoke the promise again.
    cache.promise.clear()
  }
}
</file>

<file path="src/utils/promise/withDedupe.ts">
import { LruMap } from '../lru.js'

/** @internal */
export const promiseCache = /*#__PURE__*/ new LruMap<Promise<any>>(8192)

type WithDedupeOptions = {
  enabled?: boolean | undefined
  id?: string | undefined
}

/** Deduplicates in-flight promises. */
export function withDedupe<data>(
  fn: () => Promise<data>,
  { enabled = true, id }: WithDedupeOptions,
): Promise<data> {
  if (!enabled || !id) return fn()
  if (promiseCache.get(id)) return promiseCache.get(id)!
  const promise = fn().finally(() => promiseCache.delete(id))
  promiseCache.set(id, promise)
  return promise
}
</file>

<file path="src/utils/promise/withResolvers.ts">
/** @internal */
export type PromiseWithResolvers<type> = {
  promise: Promise<type>
  resolve: (value: type | PromiseLike<type>) => void
  reject: (reason?: unknown) => void
}

/** @internal */
export function withResolvers<type>(): PromiseWithResolvers<type> {
  let resolve: PromiseWithResolvers<type>['resolve'] = () => undefined
  let reject: PromiseWithResolvers<type>['reject'] = () => undefined

  const promise = new Promise<type>((resolve_, reject_) => {
    resolve = resolve_
    reject = reject_
  })

  return { promise, resolve, reject }
}
</file>

<file path="src/utils/promise/withRetry.ts">
import type { ErrorType } from '../../errors/utils.js'
import { wait } from '../wait.js'

export type WithRetryParameters = {
  // The delay (in ms) between retries.
  delay?:
    | ((config: { count: number; error: Error }) => number)
    | number
    | undefined
  // The max number of times to retry.
  retryCount?: number | undefined
  // Whether or not to retry when an error is thrown.
  shouldRetry?:
    | (({
        count,
        error,
      }: {
        count: number
        error: Error
      }) => Promise<boolean> | boolean)
    | undefined
}

export type WithRetryErrorType = ErrorType

export function withRetry<data>(
  fn: () => Promise<data>,
  {
    delay: delay_ = 100,
    retryCount = 2,
    shouldRetry = () => true,
  }: WithRetryParameters = {},
) {
  return new Promise<data>((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }: { error: Error }) => {
        const delay =
          typeof delay_ === 'function' ? delay_({ count, error }) : delay_
        if (delay) await wait(delay)
        attemptRetry({ count: count + 1 })
      }

      try {
        const data = await fn()
        resolve(data)
      } catch (err) {
        if (
          count < retryCount &&
          (await shouldRetry({ count, error: err as Error }))
        )
          return retry({ error: err as Error })
        reject(err)
      }
    }
    attemptRetry()
  })
}
</file>

<file path="src/utils/promise/withTimeout.ts">
import type { ErrorType } from '../../errors/utils.js'

export type WithTimeoutErrorType = ErrorType

export function withTimeout<data>(
  fn: ({
    signal,
  }: { signal: AbortController['signal'] | null }) => Promise<data>,
  {
    errorInstance = new Error('timed out'),
    timeout,
    signal,
  }: {
    // The error instance to throw when the timeout is reached.
    errorInstance?: Error | undefined
    // The timeout (in ms).
    timeout: number
    // Whether or not the timeout should use an abort signal.
    signal?: boolean | undefined
  },
): Promise<data> {
  return new Promise((resolve, reject) => {
    ;(async () => {
      let timeoutId!: NodeJS.Timeout
      try {
        const controller = new AbortController()
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort()
            } else {
              reject(errorInstance)
            }
          }, timeout) as NodeJS.Timeout // need to cast because bun globals.d.ts overrides @types/node
        }
        resolve(await fn({ signal: controller?.signal || null }))
      } catch (err) {
        if ((err as Error)?.name === 'AbortError') reject(errorInstance)
        reject(err)
      } finally {
        clearTimeout(timeoutId)
      }
    })()
  })
}
</file>

<file path="src/utils/rpc/compat.ts">
// TODO(v3): This file is here for backwards compatibility, and to prevent breaking changes.
// These APIs will be removed in v3.

/* c8 ignore start */
import type {
  TimeoutErrorType,
  WebSocketRequestError,
} from '../../errors/request.js'
import type { ErrorType } from '../../errors/utils.js'
import type { RpcResponse } from '../../types/rpc.js'
import type { WithTimeoutErrorType } from '../promise/withTimeout.js'
import { type HttpRequestParameters, getHttpRpcClient } from './http.js'
import type { SocketRpcClient } from './socket.js'
import { getWebSocketRpcClient } from './webSocket.js'

export type WebSocketOptions = Parameters<
  SocketRpcClient<WebSocket>['request']
>[0]
export type WebSocketReturnType = SocketRpcClient<WebSocket>
export type WebSocketErrorType = WebSocketRequestError | ErrorType

function webSocket(
  socketClient: SocketRpcClient<WebSocket>,
  { body, onError, onResponse }: WebSocketOptions,
): WebSocketReturnType {
  socketClient.request({
    body,
    onError,
    onResponse,
  })
  return socketClient
}

export type WebSocketAsyncOptions = Parameters<
  SocketRpcClient<WebSocket>['requestAsync']
>[0]
export type WebSocketAsyncReturnType = RpcResponse
export type WebSocketAsyncErrorType =
  | WebSocketErrorType
  | TimeoutErrorType
  | WithTimeoutErrorType
  | ErrorType

async function webSocketAsync(
  socketClient: SocketRpcClient<WebSocket>,
  { body, timeout = 10_000 }: WebSocketAsyncOptions,
): Promise<WebSocketAsyncReturnType> {
  return socketClient.requestAsync({
    body,
    timeout,
  })
}

/**
 * @deprecated use `getSocketClient` instead.
 *
 * ```diff
 * -import { getSocket } from 'viem/utils'
 * +import { getSocketClient } from 'viem/utils'
 *
 * -const socket = await getSocket(url)
 * +const socketClient = await getSocketClient(url)
 * +const socket = socketClient.socket
 * ```
 */
export async function getSocket(url: string) {
  const client = await getWebSocketRpcClient(url)
  return Object.assign(client.socket, {
    requests: client.requests,
    subscriptions: client.subscriptions,
  })
}

export const rpc = {
  /**
   * @deprecated use `getHttpRpcClient` instead.
   *
   * ```diff
   * -import { rpc } from 'viem/utils'
   * +import { getHttpRpcClient } from 'viem/utils'
   *
   * -rpc.http(url, params)
   * +const httpClient = getHttpRpcClient(url)
   * +httpClient.request(params)
   * ```
   */
  http(url: string, params: HttpRequestParameters) {
    return getHttpRpcClient(url).request(params)
  },
  /**
   * @deprecated use `getWebSocketRpcClient` instead.
   *
   * ```diff
   * -import { rpc } from 'viem/utils'
   * +import { getWebSocketRpcClient } from 'viem/utils'
   *
   * -rpc.webSocket(url, params)
   * +const webSocketClient = getWebSocketRpcClient(url)
   * +webSocketClient.request(params)
   * ```
   */
  webSocket,
  /**
   * @deprecated use `getWebSocketRpcClient` instead.
   *
   * ```diff
   * -import { rpc } from 'viem/utils'
   * +import { getWebSocketRpcClient } from 'viem/utils'
   *
   * -const response = await rpc.webSocketAsync(url, params)
   * +const webSocketClient = getWebSocketRpcClient(url)
   * +const response = await webSocketClient.requestAsync(params)
   * ```
   */
  webSocketAsync,
}
/* c8 ignore end */
</file>

<file path="src/utils/rpc/http.ts">
import {
  HttpRequestError,
  type HttpRequestErrorType as HttpRequestErrorType_,
  TimeoutError,
  type TimeoutErrorType,
} from '../../errors/request.js'
import type { ErrorType } from '../../errors/utils.js'
import type { RpcRequest, RpcResponse } from '../../types/rpc.js'
import type { MaybePromise } from '../../types/utils.js'
import {
  type WithTimeoutErrorType,
  withTimeout,
} from '../promise/withTimeout.js'
import { stringify } from '../stringify.js'
import { idCache } from './id.js'

export type HttpRpcClientOptions = {
  /** Request configuration to pass to `fetch`. */
  fetchOptions?: Omit<RequestInit, 'body'> | undefined
  /** A callback to handle the request. */
  onRequest?:
    | ((
        request: Request,
        init: RequestInit,
      ) => MaybePromise<
        void | undefined | (RequestInit & { url?: string | undefined })
      >)
    | undefined
  /** A callback to handle the response. */
  onResponse?: ((response: Response) => Promise<void> | void) | undefined
  /** The timeout (in ms) for the request. */
  timeout?: number | undefined
}

export type HttpRequestParameters<
  body extends RpcRequest | RpcRequest[] = RpcRequest,
> = {
  /** The RPC request body. */
  body: body
  /** Request configuration to pass to `fetch`. */
  fetchOptions?: HttpRpcClientOptions['fetchOptions'] | undefined
  /** A callback to handle the response. */
  onRequest?:
    | ((
        request: Request,
        init: RequestInit,
      ) => MaybePromise<
        void | undefined | (RequestInit & { url?: string | undefined })
      >)
    | undefined
  /** A callback to handle the response. */
  onResponse?: ((response: Response) => Promise<void> | void) | undefined
  /** The timeout (in ms) for the request. */
  timeout?: HttpRpcClientOptions['timeout'] | undefined
}

export type HttpRequestReturnType<
  body extends RpcRequest | RpcRequest[] = RpcRequest,
> = body extends RpcRequest[] ? RpcResponse[] : RpcResponse

export type HttpRequestErrorType =
  | HttpRequestErrorType_
  | TimeoutErrorType
  | WithTimeoutErrorType
  | ErrorType

export type HttpRpcClient = {
  request<body extends RpcRequest | RpcRequest[]>(
    params: HttpRequestParameters<body>,
  ): Promise<HttpRequestReturnType<body>>
}

export function getHttpRpcClient(
  url: string,
  options: HttpRpcClientOptions = {},
): HttpRpcClient {
  return {
    async request(params) {
      const {
        body,
        onRequest = options.onRequest,
        onResponse = options.onResponse,
        timeout = options.timeout ?? 10_000,
      } = params

      const fetchOptions = {
        ...(options.fetchOptions ?? {}),
        ...(params.fetchOptions ?? {}),
      }

      const { headers, method, signal: signal_ } = fetchOptions

      try {
        const response = await withTimeout(
          async ({ signal }) => {
            const init: RequestInit = {
              ...fetchOptions,
              body: Array.isArray(body)
                ? stringify(
                    body.map((body) => ({
                      jsonrpc: '2.0',
                      id: body.id ?? idCache.take(),
                      ...body,
                    })),
                  )
                : stringify({
                    jsonrpc: '2.0',
                    id: body.id ?? idCache.take(),
                    ...body,
                  }),
              headers: {
                'Content-Type': 'application/json',
                ...headers,
              },
              method: method || 'POST',
              signal: signal_ || (timeout > 0 ? signal : null),
            }
            const request = new Request(url, init)
            const args = (await onRequest?.(request, init)) ?? { ...init, url }
            const response = await fetch(args.url ?? url, args)
            return response
          },
          {
            errorInstance: new TimeoutError({ body, url }),
            timeout,
            signal: true,
          },
        )

        if (onResponse) await onResponse(response)

        let data: any
        if (
          response.headers.get('Content-Type')?.startsWith('application/json')
        )
          data = await response.json()
        else {
          data = await response.text()
          try {
            data = JSON.parse(data || '{}')
          } catch (err) {
            if (response.ok) throw err
            data = { error: data }
          }
        }

        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url,
          })
        }

        return data
      } catch (err) {
        if (err instanceof HttpRequestError) throw err
        if (err instanceof TimeoutError) throw err
        throw new HttpRequestError({
          body,
          cause: err as Error,
          url,
        })
      }
    },
  }
}
</file>

<file path="src/utils/rpc/id.ts">
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++
    },
    reset() {
      this.current = 0
    },
  }
}

export const idCache = /*#__PURE__*/ createIdStore()
</file>

<file path="src/utils/rpc/ipc.ts">
import { type Socket as NetSocket, connect } from 'node:net'
import { WebSocketRequestError } from '../../index.js'
import {
  type GetSocketRpcClientParameters,
  type Socket,
  type SocketRpcClient,
  getSocketRpcClient,
} from './socket.js'

export type GetIpcRpcClientOptions = Pick<
  GetSocketRpcClientParameters,
  'reconnect'
>

const openingBrace = '{'.charCodeAt(0)
const closingBrace = '}'.charCodeAt(0)

/** @internal */
export function extractMessages(buffer: Buffer): [Buffer[], Buffer] {
  const messages: Buffer[] = []

  let cursor = 0
  let level = 0
  for (let i = 0; i < buffer.length; i++) {
    if (buffer[i] === openingBrace) level++
    if (buffer[i] === closingBrace) level--
    if (level === 0) {
      const message = buffer.subarray(cursor, i + 1)
      if (
        message[0] === openingBrace &&
        message[message.length - 1] === closingBrace
      )
        messages.push(message)
      cursor = i + 1
    }
  }

  return [messages, buffer.subarray(cursor)]
}

export type IpcRpcClient = SocketRpcClient<NetSocket>

export async function getIpcRpcClient(
  path: string,
  options: GetIpcRpcClientOptions = {},
): Promise<IpcRpcClient> {
  const { reconnect } = options

  return getSocketRpcClient({
    async getSocket({ onError, onOpen, onResponse }) {
      const socket = connect(path)

      function onClose() {
        socket.off('close', onClose)
        socket.off('message', onData)
        socket.off('error', onError)
        socket.off('connect', onOpen)
      }

      let lastRemaining = Buffer.alloc(0) as Buffer
      function onData(buffer: Buffer) {
        const [messages, remaining] = extractMessages(
          Buffer.concat([
            Uint8Array.from(lastRemaining),
            Uint8Array.from(buffer),
          ]),
        )
        for (const message of messages) {
          const response = JSON.parse(Buffer.from(message).toString())
          onResponse(response)
        }
        lastRemaining = remaining
      }

      socket.on('close', onClose)
      socket.on('data', onData)
      socket.on('error', onError)
      socket.on('connect', onOpen)

      // Wait for the socket to open.
      await new Promise<void>((resolve, reject) => {
        socket.on('ready', () => {
          resolve()
          socket.off('error', reject)
        })
        socket.on('error', reject)
      })

      return Object.assign(socket, {
        close() {
          socket.destroy()
          socket.end()
        },
        request({ body }) {
          if (socket.readyState !== 'open')
            throw new WebSocketRequestError({
              body,
              url: path,
              details: 'Socket is closed.',
            })

          return socket.write(JSON.stringify(body))
        },
      } as Socket<{}>)
    },
    reconnect,
    url: path,
  })
}
</file>

<file path="src/utils/rpc/socket.ts">
import { SocketClosedError, TimeoutError } from '../../errors/request.js'
import type { ErrorType } from '../../errors/utils.js'
import type { RpcRequest, RpcResponse } from '../../types/rpc.js'
import {
  type CreateBatchSchedulerErrorType,
  createBatchScheduler,
} from '../promise/createBatchScheduler.js'
import { withTimeout } from '../promise/withTimeout.js'
import { idCache } from './id.js'

type Id = string | number
type CallbackFn = {
  onResponse: (message: any) => void
  onError?: ((error?: Error | Event | undefined) => void) | undefined
}
type CallbackMap = Map<Id, CallbackFn>

export type GetSocketParameters = {
  onClose: () => void
  onError: (error?: Error | Event | undefined) => void
  onOpen: () => void
  onResponse: (data: RpcResponse) => void
}

export type Socket<socket extends {}> = socket & {
  close(): void
  ping?: (() => void) | undefined
  request(params: { body: RpcRequest }): void
}

export type SocketRpcClient<socket extends {}> = {
  close(): void
  socket: Socket<socket>
  request(params: {
    body: RpcRequest
    onError?: ((error?: Error | Event | undefined) => void) | undefined
    onResponse: (message: RpcResponse) => void
  }): void
  requestAsync(params: {
    body: RpcRequest
    timeout?: number | undefined
  }): Promise<RpcResponse>
  requests: CallbackMap
  subscriptions: CallbackMap
  url: string
}

export type GetSocketRpcClientParameters<socket extends {} = {}> = {
  getSocket(params: GetSocketParameters): Promise<Socket<socket>>
  /**
   * Whether or not to send keep-alive messages.
   * @default true
   */
  keepAlive?:
    | boolean
    | {
        /**
         * The interval (in ms) to send keep-alive messages.
         * @default 30_000
         */
        interval?: number | undefined
      }
    | undefined
  key?: string
  /**
   * Whether or not to attempt to reconnect on socket failure or closure.
   * @default true
   */
  reconnect?:
    | boolean
    | {
        /**
         * The maximum number of reconnection attempts.
         * @default 5
         */
        attempts?: number | undefined
        /**
         * The delay (in ms) between reconnection attempts.
         * @default 2_000
         */
        delay?: number | undefined
      }
    | undefined
  url: string
}

export type GetSocketRpcClientErrorType =
  | CreateBatchSchedulerErrorType
  | ErrorType

export const socketClientCache = /*#__PURE__*/ new Map<
  string,
  SocketRpcClient<Socket<{}>>
>()

export async function getSocketRpcClient<socket extends {}>(
  parameters: GetSocketRpcClientParameters<socket>,
): Promise<SocketRpcClient<socket>> {
  const {
    getSocket,
    keepAlive = true,
    key = 'socket',
    reconnect = true,
    url,
  } = parameters
  const { interval: keepAliveInterval = 30_000 } =
    typeof keepAlive === 'object' ? keepAlive : {}
  const { attempts = 5, delay = 2_000 } =
    typeof reconnect === 'object' ? reconnect : {}

  let socketClient = socketClientCache.get(`${key}:${url}`)

  // If the socket already exists, return it.
  if (socketClient) return socketClient as {} as SocketRpcClient<socket>

  let reconnectCount = 0
  const { schedule } = createBatchScheduler<
    undefined,
    [SocketRpcClient<socket>]
  >({
    id: `${key}:${url}`,
    fn: async () => {
      // Set up a cache for incoming "synchronous" requests.
      const requests = new Map<Id, CallbackFn>()

      // Set up a cache for subscriptions (eth_subscribe).
      const subscriptions = new Map<Id, CallbackFn>()

      let error: Error | Event | undefined
      let socket: Socket<{}>
      let keepAliveTimer: ReturnType<typeof setInterval> | undefined

      // Set up socket implementation.
      async function setup() {
        const result = await getSocket({
          onClose() {
            // Notify all requests and subscriptions of the closure error.
            for (const request of requests.values())
              request.onError?.(new SocketClosedError({ url }))
            for (const subscription of subscriptions.values())
              subscription.onError?.(new SocketClosedError({ url }))

            // Clear all requests and subscriptions.
            requests.clear()
            subscriptions.clear()

            // Attempt to reconnect.
            if (reconnect && reconnectCount < attempts)
              setTimeout(async () => {
                reconnectCount++
                await setup().catch(console.error)
              }, delay)
          },
          onError(error_) {
            error = error_

            // Notify all requests and subscriptions of the error.
            for (const request of requests.values()) request.onError?.(error)
            for (const subscription of subscriptions.values())
              subscription.onError?.(error)

            // Clear all requests and subscriptions.
            requests.clear()
            subscriptions.clear()

            // Make sure socket is definitely closed.
            socketClient?.close()

            // Attempt to reconnect.
            if (reconnect && reconnectCount < attempts)
              setTimeout(async () => {
                reconnectCount++
                await setup().catch(console.error)
              }, delay)
          },
          onOpen() {
            error = undefined
            reconnectCount = 0
          },
          onResponse(data) {
            const isSubscription = data.method === 'eth_subscription'
            const id = isSubscription ? data.params.subscription : data.id
            const cache = isSubscription ? subscriptions : requests
            const callback = cache.get(id)
            if (callback) callback.onResponse(data)
            if (!isSubscription) cache.delete(id)
          },
        })

        socket = result

        if (keepAlive) {
          if (keepAliveTimer) clearInterval(keepAliveTimer)
          keepAliveTimer = setInterval(() => socket.ping?.(), keepAliveInterval)
        }

        return result
      }
      await setup()
      error = undefined

      // Create a new socket instance.
      socketClient = {
        close() {
          keepAliveTimer && clearInterval(keepAliveTimer)
          socket.close()
          socketClientCache.delete(`${key}:${url}`)
        },
        get socket() {
          return socket
        },
        request({ body, onError, onResponse }) {
          if (error && onError) onError(error)

          const id = body.id ?? idCache.take()

          const callback = (response: RpcResponse) => {
            if (typeof response.id === 'number' && id !== response.id) return

            // If we are subscribing to a topic, we want to set up a listener for incoming
            // messages.
            if (
              body.method === 'eth_subscribe' &&
              typeof response.result === 'string'
            )
              subscriptions.set(response.result, {
                onResponse: callback,
                onError,
              })

            // If we are unsubscribing from a topic, we want to remove the listener.
            if (body.method === 'eth_unsubscribe')
              subscriptions.delete(body.params?.[0])

            onResponse(response)
          }

          requests.set(id, { onResponse: callback, onError })
          try {
            socket.request({
              body: {
                jsonrpc: '2.0',
                id,
                ...body,
              },
            })
          } catch (error) {
            onError?.(error as Error)
          }
        },
        requestAsync({ body, timeout = 10_000 }) {
          return withTimeout(
            () =>
              new Promise<RpcResponse>((onResponse, onError) =>
                this.request({
                  body,
                  onError,
                  onResponse,
                }),
              ),
            {
              errorInstance: new TimeoutError({ body, url }),
              timeout,
            },
          )
        },
        requests,
        subscriptions,
        url,
      }
      socketClientCache.set(`${key}:${url}`, socketClient)

      return [socketClient as {} as SocketRpcClient<socket>]
    },
  })

  const [_, [socketClient_]] = await schedule()
  return socketClient_
}
</file>

<file path="src/utils/rpc/webSocket.ts">
import type { MessageEvent } from 'isows'

import {
  SocketClosedError,
  WebSocketRequestError,
} from '../../errors/request.js'
import type { RpcRequest } from '../../types/rpc.js'
import {
  type GetSocketRpcClientParameters,
  type Socket,
  type SocketRpcClient,
  getSocketRpcClient,
} from './socket.js'

export type GetWebSocketRpcClientOptions = Pick<
  GetSocketRpcClientParameters,
  'keepAlive' | 'reconnect'
>

export async function getWebSocketRpcClient(
  url: string,
  options: GetWebSocketRpcClientOptions | undefined = {},
): Promise<SocketRpcClient<WebSocket>> {
  const { keepAlive, reconnect } = options

  return getSocketRpcClient({
    async getSocket({ onClose, onError, onOpen, onResponse }) {
      const WebSocket = await import('isows').then((module) => module.WebSocket)
      const socket = new WebSocket(url)

      function onClose_() {
        socket.removeEventListener('close', onClose_)
        socket.removeEventListener('message', onMessage)
        socket.removeEventListener('error', onError)
        socket.removeEventListener('open', onOpen)
        onClose()
      }
      function onMessage({ data }: MessageEvent) {
        try {
          const _data = JSON.parse(data)
          onResponse(_data)
        } catch (error) {
          onError(error as Error)
        }
      }

      // Setup event listeners for RPC & subscription responses.
      socket.addEventListener('close', onClose_)
      socket.addEventListener('message', onMessage)
      socket.addEventListener('error', onError)
      socket.addEventListener('open', onOpen)

      // Wait for the socket to open.
      if (socket.readyState === WebSocket.CONNECTING) {
        await new Promise((resolve, reject) => {
          if (!socket) return
          socket.onopen = resolve
          socket.onerror = reject
        })
      }

      const { close: close_ } = socket

      return Object.assign(socket, {
        close() {
          close_.bind(socket)()
          onClose_()
        },
        ping() {
          try {
            if (
              socket.readyState === socket.CLOSED ||
              socket.readyState === socket.CLOSING
            )
              throw new WebSocketRequestError({
                url: socket.url,
                cause: new SocketClosedError({ url: socket.url }),
              })

            const body: RpcRequest = {
              jsonrpc: '2.0',
              method: 'net_version',
              params: [],
            }
            socket.send(JSON.stringify(body))
          } catch (error) {
            onError(error as Error)
          }
        },
        request({ body }) {
          if (
            socket.readyState === socket.CLOSED ||
            socket.readyState === socket.CLOSING
          )
            throw new WebSocketRequestError({
              body,
              url: socket.url,
              cause: new SocketClosedError({ url: socket.url }),
            })

          return socket.send(JSON.stringify(body))
        },
      } as Socket<WebSocket>)
    },
    keepAlive,
    reconnect,
    url,
  })
}
</file>

<file path="src/utils/signature/compactSignatureToSignature.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { CompactSignature, Signature } from '../../types/misc.js'
import { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'
import { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'

export type CompactSignatureToSignatureErrorType =
  | BytesToHexErrorType
  | HexToBytesErrorType
  | ErrorType

/**
 * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into signature format.
 *
 * @param signature The compact signature to convert.
 * @returns The compact signature in signature format.
 *
 * @example
 * compactSignatureToSignature({
 *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 * })
 * // {
 * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 * //   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 * //   v: 27n
 * // }
 */
export function compactSignatureToSignature({
  r,
  yParityAndS,
}: CompactSignature): Signature {
  const yParityAndS_bytes = hexToBytes(yParityAndS)
  const yParity = yParityAndS_bytes[0] & 0x80 ? 1 : 0
  const s = yParityAndS_bytes
  if (yParity === 1) s[0] &= 0x7f
  return { r, s: bytesToHex(s), yParity }
}
</file>

<file path="src/utils/signature/hashMessage.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'
import { toPrefixedMessage } from './toPrefixedMessage.js'

type To = 'hex' | 'bytes'

export type HashMessageReturnType<to extends To> =
  | (to extends 'bytes' ? ByteArray : never)
  | (to extends 'hex' ? Hex : never)

export type HashMessageErrorType = Keccak256ErrorType | ErrorType

export function hashMessage<to extends To = 'hex'>(
  message: SignableMessage,
  to_?: to | undefined,
): HashMessageReturnType<to> {
  return keccak256(toPrefixedMessage(message), to_)
}
</file>

<file path="src/utils/signature/hashTypedData.ts">
// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts

import type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'

import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import type { TypedDataDefinition } from '../../types/typedData.js'
import {
  type EncodeAbiParametersErrorType,
  encodeAbiParameters,
} from '../abi/encodeAbiParameters.js'
import { concat } from '../data/concat.js'
import { type ToHexErrorType, toHex } from '../encoding/toHex.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'
import {
  type GetTypesForEIP712DomainErrorType,
  type ValidateTypedDataErrorType,
  getTypesForEIP712Domain,
  validateTypedData,
} from '../typedData.js'

type MessageTypeProperty = {
  name: string
  type: string
}

export type HashTypedDataParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
> = TypedDataDefinition<typedData, primaryType>

export type HashTypedDataReturnType = Hex

export type HashTypedDataErrorType =
  | GetTypesForEIP712DomainErrorType
  | HashDomainErrorType
  | HashStructErrorType
  | ValidateTypedDataErrorType
  | ErrorType

export function hashTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  parameters: HashTypedDataParameters<typedData, primaryType>,
): HashTypedDataReturnType {
  const {
    domain = {},
    message,
    primaryType,
  } = parameters as HashTypedDataParameters
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...parameters.types,
  }

  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
  // as we can't statically check this with TypeScript.
  validateTypedData({
    domain,
    message,
    primaryType,
    types,
  })

  const parts: Hex[] = ['0x1901']
  if (domain)
    parts.push(
      hashDomain({
        domain,
        types: types as Record<string, MessageTypeProperty[]>,
      }),
    )

  if (primaryType !== 'EIP712Domain')
    parts.push(
      hashStruct({
        data: message,
        primaryType,
        types: types as Record<string, MessageTypeProperty[]>,
      }),
    )

  return keccak256(concat(parts))
}

export type HashDomainErrorType = HashStructErrorType | ErrorType

export function hashDomain({
  domain,
  types,
}: {
  domain: TypedDataDomain
  types: Record<string, MessageTypeProperty[]>
}) {
  return hashStruct({
    data: domain,
    primaryType: 'EIP712Domain',
    types,
  })
}

export type HashStructErrorType =
  | EncodeDataErrorType
  | Keccak256ErrorType
  | ErrorType

export function hashStruct({
  data,
  primaryType,
  types,
}: {
  data: Record<string, unknown>
  primaryType: string
  types: Record<string, readonly MessageTypeProperty[]>
}) {
  const encoded = encodeData({
    data,
    primaryType,
    types,
  })
  return keccak256(encoded)
}

type EncodeDataErrorType =
  | EncodeAbiParametersErrorType
  | EncodeFieldErrorType
  | HashTypeErrorType
  | ErrorType

function encodeData({
  data,
  primaryType,
  types,
}: {
  data: Record<string, unknown>
  primaryType: string
  types: Record<string, readonly MessageTypeProperty[]>
}) {
  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]
  const encodedValues: unknown[] = [hashType({ primaryType, types })]

  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name],
    })
    encodedTypes.push(type)
    encodedValues.push(value)
  }

  return encodeAbiParameters(encodedTypes, encodedValues)
}

type HashTypeErrorType =
  | ToHexErrorType
  | EncodeTypeErrorType
  | Keccak256ErrorType
  | ErrorType

function hashType({
  primaryType,
  types,
}: {
  primaryType: string
  types: Record<string, readonly MessageTypeProperty[]>
}) {
  const encodedHashType = toHex(encodeType({ primaryType, types }))
  return keccak256(encodedHashType)
}

type EncodeTypeErrorType = FindTypeDependenciesErrorType

export function encodeType({
  primaryType,
  types,
}: {
  primaryType: string
  types: Record<string, readonly MessageTypeProperty[]>
}) {
  let result = ''
  const unsortedDeps = findTypeDependencies({ primaryType, types })
  unsortedDeps.delete(primaryType)

  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]
  for (const type of deps) {
    result += `${type}(${types[type]
      .map(({ name, type: t }) => `${t} ${name}`)
      .join(',')})`
  }

  return result
}

type FindTypeDependenciesErrorType = ErrorType

function findTypeDependencies(
  {
    primaryType: primaryType_,
    types,
  }: {
    primaryType: string
    types: Record<string, readonly MessageTypeProperty[]>
  },
  results: Set<string> = new Set(),
): Set<string> {
  const match = primaryType_.match(/^\w*/u)
  const primaryType = match?.[0]!
  if (results.has(primaryType) || types[primaryType] === undefined) {
    return results
  }

  results.add(primaryType)

  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results)
  }
  return results
}

type EncodeFieldErrorType =
  | Keccak256ErrorType
  | EncodeAbiParametersErrorType
  | ToHexErrorType
  | ErrorType

function encodeField({
  types,
  name,
  type,
  value,
}: {
  types: Record<string, readonly MessageTypeProperty[]>
  name: string
  type: string
  value: any
}): [type: AbiParameter, value: any] {
  if (types[type] !== undefined) {
    return [
      { type: 'bytes32' },
      keccak256(encodeData({ data: value, primaryType: type, types })),
    ]
  }

  if (type === 'bytes') {
    const prepend = value.length % 2 ? '0' : ''
    value = `0x${prepend + value.slice(2)}`
    return [{ type: 'bytes32' }, keccak256(value)]
  }

  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]

  if (type.lastIndexOf(']') === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf('['))
    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>
      encodeField({
        name,
        type: parsedType,
        types,
        value: item,
      }),
    )
    return [
      { type: 'bytes32' },
      keccak256(
        encodeAbiParameters(
          typeValuePairs.map(([t]) => t),
          typeValuePairs.map(([, v]) => v),
        ),
      ),
    ]
  }

  return [{ type }, value]
}
</file>

<file path="src/utils/signature/isErc6492Signature.ts">
import { erc6492MagicBytes } from '../../constants/bytes.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import { type SliceHexErrorType, sliceHex } from '../data/slice.js'

export type IsErc6492SignatureParameters = Hex
export type IsErc6492SignatureReturnType = boolean
export type IsErc6492SignatureErrorType = SliceHexErrorType | ErrorType

/** Whether or not the signature is an ERC-6492 formatted signature. */
export function isErc6492Signature(
  signature: IsErc6492SignatureParameters,
): IsErc6492SignatureReturnType {
  return sliceHex(signature, -32) === erc6492MagicBytes
}
</file>

<file path="src/utils/signature/parseCompactSignature.ts">
import { secp256k1 } from '@noble/curves/secp256k1'

import type { ErrorType } from '../../errors/utils.js'
import type { CompactSignature, Hex } from '../../types/misc.js'
import { type NumberToHexErrorType, numberToHex } from '../encoding/toHex.js'

export type ParseCompactSignatureErrorType = NumberToHexErrorType | ErrorType

/**
 * @description Parses a hex formatted compact signature into a structured compact signature.
 *
 * @param signatureHex Signature in hex format.
 * @returns The structured signature.
 *
 * @example
 * parseCompactSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')
 * // { r: '0x...', yParityAndS: '0x...' }
 */
export function parseCompactSignature(signatureHex: Hex): CompactSignature {
  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130))
  return {
    r: numberToHex(r, { size: 32 }),
    yParityAndS: numberToHex(s, { size: 32 }),
  }
}
</file>

<file path="src/utils/signature/parseErc6492Signature.ts">
import type { Address } from 'abitype'
import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import type { OneOf, Prettify } from '../../types/utils.js'
import {
  type DecodeAbiParametersErrorType,
  decodeAbiParameters,
} from '../abi/decodeAbiParameters.js'
import {
  type IsErc6492SignatureErrorType,
  isErc6492Signature,
} from './isErc6492Signature.js'

export type ParseErc6492SignatureParameters = Hex

export type ParseErc6492SignatureReturnType = Prettify<
  OneOf<
    | {
        /**
         * The ERC-4337 Account Factory or preparation address to use for counterfactual verification.
         * `undefined` if the signature is not in ERC-6492 format.
         */
        address: Address
        /**
         * Calldata to pass to deploy account (if not deployed) for counterfactual verification.
         * `undefined` if the signature is not in ERC-6492 format.
         */
        data: Hex
        /** The original signature. */
        signature: Hex
      }
    | {
        /** The original signature. */
        signature: Hex
      }
  >
>

export type ParseErc6492SignatureErrorType =
  | IsErc6492SignatureErrorType
  | DecodeAbiParametersErrorType
  | ErrorType

/**
 * @description Parses a hex-formatted ERC-6492 flavoured signature.
 * If the signature is not in ERC-6492 format, then the underlying (original) signature is returned.
 *
 * @param signature ERC-6492 signature in hex format.
 * @returns The parsed ERC-6492 signature.
 *
 * @example
 * parseSignature('0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492')
 * // { address: '0x...', data: '0x...', signature: '0x...' }
 */
export function parseErc6492Signature(
  signature: ParseErc6492SignatureParameters,
): ParseErc6492SignatureReturnType {
  if (!isErc6492Signature(signature)) return { signature }

  const [address, data, signature_] = decodeAbiParameters(
    [{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }],
    signature,
  )
  return { address, data, signature: signature_ }
}
</file>

<file path="src/utils/signature/parseSignature.ts">
import { secp256k1 } from '@noble/curves/secp256k1'

import type { ErrorType } from '../../errors/utils.js'
import type { Hex, Signature } from '../../types/misc.js'
import {
  type NumberToHexErrorType,
  numberToHex,
} from '../../utils/encoding/toHex.js'

export type ParseSignatureErrorType = NumberToHexErrorType | ErrorType

/**
 * @description Parses a hex formatted signature into a structured signature.
 *
 * @param signatureHex Signature in hex format.
 * @returns The structured signature.
 *
 * @example
 * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')
 * // { r: '0x...', s: '0x...', v: 28n }
 */
export function parseSignature(signatureHex: Hex) {
  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130))
  const yParityOrV = Number(`0x${signatureHex.slice(130)}`)
  const [v, yParity] = (() => {
    if (yParityOrV === 0 || yParityOrV === 1) return [undefined, yParityOrV]
    if (yParityOrV === 27) return [BigInt(yParityOrV), 0]
    if (yParityOrV === 28) return [BigInt(yParityOrV), 1]
    throw new Error('Invalid yParityOrV value')
  })()

  if (typeof v !== 'undefined')
    return {
      r: numberToHex(r, { size: 32 }),
      s: numberToHex(s, { size: 32 }),
      v,
      yParity,
    } satisfies Signature
  return {
    r: numberToHex(r, { size: 32 }),
    s: numberToHex(s, { size: 32 }),
    yParity,
  } satisfies Signature
}
</file>

<file path="src/utils/signature/recoverAddress.ts">
import type { Address } from 'abitype'

import { publicKeyToAddress } from '../../accounts/utils/publicKeyToAddress.js'
import type { ByteArray, Hex, Signature } from '../../types/misc.js'

import type { ErrorType } from '../../errors/utils.js'
import { recoverPublicKey } from './recoverPublicKey.js'

export type RecoverAddressParameters = {
  hash: Hex | ByteArray
  signature: Hex | ByteArray | Signature
}

export type RecoverAddressReturnType = Address

export type RecoverAddressErrorType = ErrorType

export async function recoverAddress({
  hash,
  signature,
}: RecoverAddressParameters): Promise<RecoverAddressReturnType> {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }))
}
</file>

<file path="src/utils/signature/recoverMessageAddress.ts">
import type { Address } from 'abitype'

import type {
  ByteArray,
  Hex,
  SignableMessage,
  Signature,
} from '../../types/misc.js'

import type { ErrorType } from '../../errors/utils.js'
import { type HashMessageErrorType, hashMessage } from './hashMessage.js'
import {
  type RecoverAddressErrorType,
  recoverAddress,
} from './recoverAddress.js'

export type RecoverMessageAddressParameters = {
  message: SignableMessage
  signature: Hex | ByteArray | Signature
}

export type RecoverMessageAddressReturnType = Address

export type RecoverMessageAddressErrorType =
  | HashMessageErrorType
  | RecoverAddressErrorType
  | ErrorType

export async function recoverMessageAddress({
  message,
  signature,
}: RecoverMessageAddressParameters): Promise<RecoverMessageAddressReturnType> {
  return recoverAddress({ hash: hashMessage(message), signature })
}
</file>

<file path="src/utils/signature/recoverPublicKey.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import { type IsHexErrorType, isHex } from '../data/isHex.js'
import { size } from '../data/size.js'
import {
  type HexToNumberErrorType,
  hexToBigInt,
  hexToNumber,
} from '../encoding/fromHex.js'
import { toHex } from '../encoding/toHex.js'

export type RecoverPublicKeyParameters = {
  hash: Hex | ByteArray
  signature: Hex | ByteArray | Signature
}

export type RecoverPublicKeyReturnType = Hex

export type RecoverPublicKeyErrorType =
  | HexToNumberErrorType
  | IsHexErrorType
  | ErrorType

export async function recoverPublicKey({
  hash,
  signature,
}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {
  const hashHex = isHex(hash) ? hash : toHex(hash)

  const { secp256k1 } = await import('@noble/curves/secp256k1')
  const signature_ = (() => {
    // typeof signature: `Signature`
    if (typeof signature === 'object' && 'r' in signature && 's' in signature) {
      const { r, s, v, yParity } = signature
      const yParityOrV = Number(yParity ?? v)!
      const recoveryBit = toRecoveryBit(yParityOrV)
      return new secp256k1.Signature(
        hexToBigInt(r),
        hexToBigInt(s),
      ).addRecoveryBit(recoveryBit)
    }

    // typeof signature: `Hex | ByteArray`
    const signatureHex = isHex(signature) ? signature : toHex(signature)
    if (size(signatureHex) !== 65) throw new Error('invalid signature length')
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`)
    const recoveryBit = toRecoveryBit(yParityOrV)
    return secp256k1.Signature.fromCompact(
      signatureHex.substring(2, 130),
    ).addRecoveryBit(recoveryBit)
  })()

  const publicKey = signature_
    .recoverPublicKey(hashHex.substring(2))
    .toHex(false)
  return `0x${publicKey}`
}

function toRecoveryBit(yParityOrV: number) {
  if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV
  if (yParityOrV === 27) return 0
  if (yParityOrV === 28) return 1
  throw new Error('Invalid yParityOrV value')
}
</file>

<file path="src/utils/signature/recoverTransactionAddress.ts">
import type { Address } from 'abitype'
import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import type { TransactionSerialized } from '../../types/transaction.js'
import { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'
import { parseTransaction } from '../transaction/parseTransaction.js'
import {
  type SerializeTransactionErrorType,
  serializeTransaction,
} from '../transaction/serializeTransaction.js'
import {
  type RecoverAddressErrorType,
  recoverAddress,
} from './recoverAddress.js'
import type { SerializeSignatureErrorType } from './serializeSignature.js'

export type RecoverTransactionAddressParameters = {
  serializedTransaction: TransactionSerialized
  signature?: Hex | ByteArray | Signature
}

export type RecoverTransactionAddressReturnType = Address

export type RecoverTransactionAddressErrorType =
  | SerializeTransactionErrorType
  | RecoverAddressErrorType
  | Keccak256ErrorType
  | SerializeSignatureErrorType
  | ErrorType

export async function recoverTransactionAddress(
  parameters: RecoverTransactionAddressParameters,
): Promise<RecoverTransactionAddressReturnType> {
  const { serializedTransaction, signature: signature_ } = parameters

  const transaction = parseTransaction(serializedTransaction)

  const signature = signature_ ?? {
    r: transaction.r!,
    s: transaction.s!,
    v: transaction.v!,
    yParity: transaction.yParity!,
  }

  const serialized = serializeTransaction({
    ...transaction,
    r: undefined,
    s: undefined,
    v: undefined,
    yParity: undefined,
    sidecars: undefined,
  })

  return await recoverAddress({
    hash: keccak256(serialized),
    signature,
  })
}
</file>

<file path="src/utils/signature/recoverTypedDataAddress.ts">
import type { Address, TypedData } from 'abitype'

import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import type { TypedDataDefinition } from '../../types/typedData.js'

import type { ErrorType } from '../../errors/utils.js'
import { type HashTypedDataErrorType, hashTypedData } from './hashTypedData.js'
import {
  type RecoverAddressErrorType,
  recoverAddress,
} from './recoverAddress.js'

export type RecoverTypedDataAddressParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
> = TypedDataDefinition<typedData, primaryType> & {
  signature: Hex | ByteArray | Signature
}

export type RecoverTypedDataAddressReturnType = Address

export type RecoverTypedDataAddressErrorType =
  | RecoverAddressErrorType
  | HashTypedDataErrorType
  | ErrorType

export async function recoverTypedDataAddress<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  parameters: RecoverTypedDataAddressParameters<typedData, primaryType>,
): Promise<RecoverTypedDataAddressReturnType> {
  const { domain, message, primaryType, signature, types } =
    parameters as unknown as RecoverTypedDataAddressParameters
  return recoverAddress({
    hash: hashTypedData({
      domain,
      message,
      primaryType,
      types,
    }),
    signature,
  })
}
</file>

<file path="src/utils/signature/serializeCompactSignature.ts">
import { secp256k1 } from '@noble/curves/secp256k1'
import type { ErrorType } from '../../errors/utils.js'
import type { CompactSignature, Hex } from '../../types/misc.js'
import { type HexToBigIntErrorType, hexToBigInt } from '../encoding/fromHex.js'

export type SerializeCompactSignatureErrorType =
  | HexToBigIntErrorType
  | ErrorType

/**
 * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into hex format.
 *
 * @param signature The compact signature to convert.
 * @returns The compact signature in hex format.
 *
 * @example
 * serializeCompactSignature({
 *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 * })
 * // "0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c"
 */
export function serializeCompactSignature({
  r,
  yParityAndS,
}: CompactSignature): Hex {
  return `0x${new secp256k1.Signature(
    hexToBigInt(r),
    hexToBigInt(yParityAndS),
  ).toCompactHex()}`
}
</file>

<file path="src/utils/signature/serializeErc6492Signature.ts">
import type { Address } from 'abitype'
import { erc6492MagicBytes } from '../../constants/bytes.js'
import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray, Hex } from '../../types/misc.js'
import { encodeAbiParameters } from '../abi/encodeAbiParameters.js'
import { concatHex } from '../data/concat.js'
import { hexToBytes } from '../encoding/toBytes.js'

type To = 'bytes' | 'hex'

export type SerializeErc6492SignatureParameters<to extends To = 'hex'> = {
  /** The ERC-4337 Account Factory address to use for counterfactual verification. */
  address: Address
  /** Calldata to pass to deploy account (if not deployed) for counterfactual verification. */
  data: Hex
  /** The original signature. */
  signature: Hex
  to?: to | To | undefined
}

export type SerializeErc6492SignatureReturnType<to extends To = 'hex'> =
  | (to extends 'hex' ? Hex : never)
  | (to extends 'bytes' ? ByteArray : never)

export type SerializeErc6492SignatureErrorType = ErrorType

/**
 * @description Serializes a ERC-6492 flavoured signature into hex format.
 *
 * @param signature ERC-6492 signature in object format.
 * @returns ERC-6492 signature in hex format.
 *
 * @example
 * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })
 * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'
 */
export function serializeErc6492Signature<to extends To = 'hex'>(
  parameters: SerializeErc6492SignatureParameters<to>,
): SerializeErc6492SignatureReturnType<to> {
  const { address, data, signature, to = 'hex' } = parameters
  const signature_ = concatHex([
    encodeAbiParameters(
      [{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }],
      [address, data, signature],
    ),
    erc6492MagicBytes,
  ])

  if (to === 'hex') return signature_ as SerializeErc6492SignatureReturnType<to>
  return hexToBytes(signature_) as SerializeErc6492SignatureReturnType<to>
}
</file>

<file path="src/utils/signature/serializeSignature.ts">
import { secp256k1 } from '@noble/curves/secp256k1'

import type { ErrorType } from '../../errors/utils.js'
import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import { type HexToBigIntErrorType, hexToBigInt } from '../encoding/fromHex.js'
import { hexToBytes } from '../encoding/toBytes.js'
import type { ToHexErrorType } from '../encoding/toHex.js'

type To = 'bytes' | 'hex'

export type SerializeSignatureParameters<to extends To = 'hex'> = Signature & {
  to?: to | To | undefined
}

export type SerializeSignatureReturnType<to extends To = 'hex'> =
  | (to extends 'hex' ? Hex : never)
  | (to extends 'bytes' ? ByteArray : never)

export type SerializeSignatureErrorType =
  | HexToBigIntErrorType
  | ToHexErrorType
  | ErrorType

/**
 * @description Converts a signature into hex format.
 *
 * @param signature The signature to convert.
 * @returns The signature in hex format.
 *
 * @example
 * serializeSignature({
 *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',
 *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',
 *   yParity: 1
 * })
 * // "0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c"
 */
export function serializeSignature<to extends To = 'hex'>({
  r,
  s,
  to = 'hex',
  v,
  yParity,
}: SerializeSignatureParameters<to>): SerializeSignatureReturnType<to> {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1) return yParity
    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0
    throw new Error('Invalid `v` or `yParity` value')
  })()
  const signature = `0x${new secp256k1.Signature(
    hexToBigInt(r),
    hexToBigInt(s),
  ).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}` as const

  if (to === 'hex') return signature as SerializeSignatureReturnType<to>
  return hexToBytes(signature) as SerializeSignatureReturnType<to>
}
</file>

<file path="src/utils/signature/signatureToCompactSignature.ts">
import type { ErrorType } from '../../errors/utils.js'
import type { CompactSignature, Signature } from '../../types/misc.js'
import { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'
import { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'

export type SignatureToCompactSignatureErrorType =
  | HexToBytesErrorType
  | BytesToHexErrorType
  | ErrorType

/**
 * @description Converts a signature into an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098).
 *
 * @param signature The signature to convert.
 * @returns The signature in compact format.
 *
 * @example
 * signatureToCompactSignature({
 *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 *   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 *   yParity: 0
 * })
 * // {
 * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 * //   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'
 * // }
 */
export function signatureToCompactSignature(
  signature: Signature,
): CompactSignature {
  const { r, s, v, yParity } = signature
  const yParity_ = Number(yParity ?? v! - 27n)
  let yParityAndS = s
  if (yParity_ === 1) {
    const bytes = hexToBytes(s)
    bytes[0] |= 0x80
    yParityAndS = bytesToHex(bytes)
  }
  return { r, yParityAndS }
}
</file>

<file path="src/utils/signature/toPrefixedMessage.ts">
import { presignMessagePrefix } from '../../constants/strings.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Hex, SignableMessage } from '../../types/misc.js'
import { type ConcatErrorType, concat } from '../data/concat.js'
import { size } from '../data/size.js'
import {
  type BytesToHexErrorType,
  type StringToHexErrorType,
  bytesToHex,
  stringToHex,
} from '../encoding/toHex.js'

export type ToPrefixedMessageErrorType =
  | ConcatErrorType
  | StringToHexErrorType
  | BytesToHexErrorType
  | ErrorType

export function toPrefixedMessage(message_: SignableMessage): Hex {
  const message = (() => {
    if (typeof message_ === 'string') return stringToHex(message_)
    if (typeof message_.raw === 'string') return message_.raw
    return bytesToHex(message_.raw)
  })()
  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)
  return concat([prefix, message])
}
</file>

<file path="src/utils/signature/verifyHash.ts">
import type { Address } from 'abitype'

import type { ByteArray, Hash, Hex, Signature } from '../../types/misc.js'
import { type GetAddressErrorType, getAddress } from '../address/getAddress.js'
import {
  type IsAddressEqualErrorType,
  isAddressEqual,
} from '../address/isAddressEqual.js'

import type { ErrorType } from '../../errors/utils.js'
import {
  type RecoverAddressErrorType,
  recoverAddress,
} from './recoverAddress.js'

export type VerifyHashParameters = {
  /** The address that signed the original message. */
  address: Address
  /** The hash to be verified. */
  hash: Hash
  /** The signature that was generated by signing the message with the address's private key. */
  signature: Hex | ByteArray | Signature
}

export type VerifyHashReturnType = boolean

export type VerifyHashErrorType =
  | IsAddressEqualErrorType
  | GetAddressErrorType
  | RecoverAddressErrorType
  | ErrorType

/**
 * Verify that a message was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyHash` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyHash}
 *
 * @param parameters - {@link VerifyHashParameters}
 * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}
 */
export async function verifyHash({
  address,
  hash,
  signature,
}: VerifyHashParameters): Promise<VerifyHashReturnType> {
  return isAddressEqual(
    getAddress(address),
    await recoverAddress({ hash, signature }),
  )
}
</file>

<file path="src/utils/signature/verifyMessage.ts">
import type { Address } from 'abitype'

import type {
  ByteArray,
  Hex,
  SignableMessage,
  Signature,
} from '../../types/misc.js'
import { type GetAddressErrorType, getAddress } from '../address/getAddress.js'
import {
  type IsAddressEqualErrorType,
  isAddressEqual,
} from '../address/isAddressEqual.js'

import type { ErrorType } from '../../errors/utils.js'
import {
  type RecoverMessageAddressErrorType,
  recoverMessageAddress,
} from './recoverMessageAddress.js'

export type VerifyMessageParameters = {
  /** The address that signed the original message. */
  address: Address
  /** The message to be verified. */
  message: SignableMessage
  /** The signature that was generated by signing the message with the address's private key. */
  signature: Hex | ByteArray | Signature
}

export type VerifyMessageReturnType = boolean

export type VerifyMessageErrorType =
  | IsAddressEqualErrorType
  | GetAddressErrorType
  | RecoverMessageAddressErrorType
  | ErrorType

/**
 * Verify that a message was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyMessage` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyMessage}
 *
 * @param parameters - {@link VerifyMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
 */
export async function verifyMessage({
  address,
  message,
  signature,
}: VerifyMessageParameters): Promise<VerifyMessageReturnType> {
  return isAddressEqual(
    getAddress(address),
    await recoverMessageAddress({ message, signature }),
  )
}
</file>

<file path="src/utils/signature/verifyTypedData.ts">
import type { Address, TypedData } from 'abitype'

import type { ByteArray, Hex, Signature } from '../../types/misc.js'
import type { TypedDataDefinition } from '../../types/typedData.js'
import { type GetAddressErrorType, getAddress } from '../address/getAddress.js'
import {
  type IsAddressEqualErrorType,
  isAddressEqual,
} from '../address/isAddressEqual.js'

import type { ErrorType } from '../../errors/utils.js'
import {
  type RecoverTypedDataAddressParameters,
  recoverTypedDataAddress,
} from './recoverTypedDataAddress.js'

export type VerifyTypedDataParameters<
  typedData extends TypedData | Record<string, unknown> = TypedData,
  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,
> = TypedDataDefinition<typedData, primaryType> & {
  /** The address to verify the typed data for. */
  address: Address
  /** The signature to verify */
  signature: Hex | ByteArray | Signature
}

export type VerifyTypedDataReturnType = boolean

export type VerifyTypedDataErrorType =
  | IsAddressEqualErrorType
  | GetAddressErrorType
  | RecoverTypedDataAddressParameters
  | ErrorType

/**
 * Verify that typed data was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyTypedData` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyTypedData}
 *
 * @param parameters - {@link VerifyTypedDataParameters}
 * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}
 */
export async function verifyTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(
  parameters: VerifyTypedDataParameters<typedData, primaryType>,
): Promise<VerifyTypedDataReturnType> {
  const { address, domain, message, primaryType, signature, types } =
    parameters as unknown as VerifyTypedDataParameters
  return isAddressEqual(
    getAddress(address),
    await recoverTypedDataAddress({
      domain,
      message,
      primaryType,
      signature,
      types,
    } as RecoverTypedDataAddressParameters),
  )
}
</file>

<file path="src/utils/transaction/assertRequest.ts">
import {
  type ParseAccountErrorType,
  parseAccount,
} from '../../accounts/utils/parseAccount.js'
import type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'
import { maxUint256 } from '../../constants/number.js'
import {
  InvalidAddressError,
  type InvalidAddressErrorType,
} from '../../errors/address.js'
import {
  FeeCapTooHighError,
  type FeeCapTooHighErrorType,
  TipAboveFeeCapError,
  type TipAboveFeeCapErrorType,
} from '../../errors/node.js'
import {
  FeeConflictError,
  type FeeConflictErrorType,
} from '../../errors/transaction.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Chain } from '../../types/chain.js'
import type { ExactPartial } from '../../types/utils.js'
import { isAddress } from '../address/isAddress.js'

export type AssertRequestParameters = ExactPartial<
  SendTransactionParameters<Chain>
>

export type AssertRequestErrorType =
  | InvalidAddressErrorType
  | FeeConflictErrorType
  | FeeCapTooHighErrorType
  | ParseAccountErrorType
  | TipAboveFeeCapErrorType
  | ErrorType

export function assertRequest(args: AssertRequestParameters) {
  const {
    account: account_,
    gasPrice,
    maxFeePerGas,
    maxPriorityFeePerGas,
    to,
  } = args
  const account = account_ ? parseAccount(account_) : undefined
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address })
  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })
  if (
    typeof gasPrice !== 'undefined' &&
    (typeof maxFeePerGas !== 'undefined' ||
      typeof maxPriorityFeePerGas !== 'undefined')
  )
    throw new FeeConflictError()

  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas })
  if (
    maxPriorityFeePerGas &&
    maxFeePerGas &&
    maxPriorityFeePerGas > maxFeePerGas
  )
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })
}
</file>

<file path="src/utils/transaction/assertTransaction.ts">
import { versionedHashVersionKzg } from '../../constants/kzg.js'
import { maxUint256 } from '../../constants/number.js'
import {
  InvalidAddressError,
  type InvalidAddressErrorType,
} from '../../errors/address.js'
import { BaseError, type BaseErrorType } from '../../errors/base.js'
import {
  EmptyBlobError,
  type EmptyBlobErrorType,
  InvalidVersionedHashSizeError,
  type InvalidVersionedHashSizeErrorType,
  InvalidVersionedHashVersionError,
  type InvalidVersionedHashVersionErrorType,
} from '../../errors/blob.js'
import {
  InvalidChainIdError,
  type InvalidChainIdErrorType,
} from '../../errors/chain.js'
import {
  FeeCapTooHighError,
  type FeeCapTooHighErrorType,
  TipAboveFeeCapError,
  type TipAboveFeeCapErrorType,
} from '../../errors/node.js'
import type { ErrorType } from '../../errors/utils.js'
import type {
  TransactionSerializableEIP1559,
  TransactionSerializableEIP2930,
  TransactionSerializableEIP4844,
  TransactionSerializableEIP7702,
  TransactionSerializableLegacy,
} from '../../types/transaction.js'
import { type IsAddressErrorType, isAddress } from '../address/isAddress.js'
import { size } from '../data/size.js'
import { slice } from '../data/slice.js'
import { hexToNumber } from '../encoding/fromHex.js'

export type AssertTransactionEIP7702ErrorType =
  | AssertTransactionEIP1559ErrorType
  | InvalidAddressErrorType
  | InvalidChainIdErrorType
  | ErrorType

export function assertTransactionEIP7702(
  transaction: TransactionSerializableEIP7702,
) {
  const { authorizationList } = transaction
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { chainId } = authorization
      const address = authorization.address
      if (!isAddress(address)) throw new InvalidAddressError({ address })
      if (chainId < 0) throw new InvalidChainIdError({ chainId })
    }
  }
  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)
}

export type AssertTransactionEIP4844ErrorType =
  | AssertTransactionEIP1559ErrorType
  | EmptyBlobErrorType
  | InvalidVersionedHashSizeErrorType
  | InvalidVersionedHashVersionErrorType
  | ErrorType

export function assertTransactionEIP4844(
  transaction: TransactionSerializableEIP4844,
) {
  const { blobVersionedHashes } = transaction
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()
    for (const hash of blobVersionedHashes) {
      const size_ = size(hash)
      const version = hexToNumber(slice(hash, 0, 1))
      if (size_ !== 32)
        throw new InvalidVersionedHashSizeError({ hash, size: size_ })
      if (version !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash,
          version,
        })
    }
  }
  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)
}

export type AssertTransactionEIP1559ErrorType =
  | BaseErrorType
  | IsAddressErrorType
  | InvalidAddressErrorType
  | InvalidChainIdErrorType
  | FeeCapTooHighErrorType
  | TipAboveFeeCapErrorType
  | ErrorType

export function assertTransactionEIP1559(
  transaction: TransactionSerializableEIP1559,
) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction
  if (chainId <= 0) throw new InvalidChainIdError({ chainId })
  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas })
  if (
    maxPriorityFeePerGas &&
    maxFeePerGas &&
    maxPriorityFeePerGas > maxFeePerGas
  )
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })
}

export type AssertTransactionEIP2930ErrorType =
  | BaseErrorType
  | IsAddressErrorType
  | InvalidAddressErrorType
  | InvalidChainIdErrorType
  | FeeCapTooHighErrorType
  | ErrorType

export function assertTransactionEIP2930(
  transaction: TransactionSerializableEIP2930,
) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =
    transaction
  if (chainId <= 0) throw new InvalidChainIdError({ chainId })
  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError(
      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',
    )
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })
}

export type AssertTransactionLegacyErrorType =
  | BaseErrorType
  | IsAddressErrorType
  | InvalidAddressErrorType
  | InvalidChainIdErrorType
  | FeeCapTooHighErrorType
  | ErrorType

export function assertTransactionLegacy(
  transaction: TransactionSerializableLegacy,
) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =
    transaction
  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })
  if (typeof chainId !== 'undefined' && chainId <= 0)
    throw new InvalidChainIdError({ chainId })
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError(
      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',
    )
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })
}
</file>

<file path="src/utils/transaction/getSerializedTransactionType.ts">
import {
  InvalidSerializedTransactionTypeError,
  type InvalidSerializedTransactionTypeErrorType,
} from '../../errors/transaction.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../index.js'
import type {
  TransactionSerialized,
  TransactionSerializedEIP1559,
  TransactionSerializedEIP2930,
  TransactionSerializedEIP4844,
  TransactionSerializedEIP7702,
  TransactionSerializedGeneric,
  TransactionSerializedLegacy,
  TransactionType,
} from '../../types/transaction.js'
import type { IsNarrowable, IsNever } from '../../types/utils.js'
import { type SliceHexErrorType, sliceHex } from '../data/slice.js'
import { type HexToNumberErrorType, hexToNumber } from '../encoding/fromHex.js'

export type GetSerializedTransactionType<
  serializedTransaction extends
    TransactionSerializedGeneric = TransactionSerialized,
  result =
    | (serializedTransaction extends TransactionSerializedEIP1559
        ? 'eip1559'
        : never)
    | (serializedTransaction extends TransactionSerializedEIP2930
        ? 'eip2930'
        : never)
    | (serializedTransaction extends TransactionSerializedEIP4844
        ? 'eip4844'
        : never)
    | (serializedTransaction extends TransactionSerializedEIP7702
        ? 'eip7702'
        : never)
    | (serializedTransaction extends TransactionSerializedLegacy
        ? 'legacy'
        : never),
> = IsNarrowable<serializedTransaction, Hex> extends true
  ? IsNever<result> extends false
    ? result
    : 'legacy'
  : TransactionType

export type GetSerializedTransactionTypeErrorType =
  | HexToNumberErrorType
  | InvalidSerializedTransactionTypeErrorType
  | SliceHexErrorType
  | ErrorType

export function getSerializedTransactionType<
  const serializedTransaction extends TransactionSerializedGeneric,
>(
  serializedTransaction: serializedTransaction,
): GetSerializedTransactionType<serializedTransaction> {
  const serializedType = sliceHex(serializedTransaction, 0, 1)

  if (serializedType === '0x04')
    return 'eip7702' as GetSerializedTransactionType<serializedTransaction>

  if (serializedType === '0x03')
    return 'eip4844' as GetSerializedTransactionType<serializedTransaction>

  if (serializedType === '0x02')
    return 'eip1559' as GetSerializedTransactionType<serializedTransaction>

  if (serializedType === '0x01')
    return 'eip2930' as GetSerializedTransactionType<serializedTransaction>

  if (serializedType !== '0x' && hexToNumber(serializedType) >= 0xc0)
    return 'legacy' as GetSerializedTransactionType<serializedTransaction>

  throw new InvalidSerializedTransactionTypeError({ serializedType })
}
</file>

<file path="src/utils/transaction/getTransactionType.test-d.ts">
import { expectTypeOf, test } from 'vitest'
import type {
  TransactionSerializable,
  TransactionSerializableEIP1559,
  TransactionSerializableEIP2930,
  TransactionSerializableLegacy,
} from '../../index.js'
import type {
  TransactionSerializableEIP4844,
  TransactionSerializableEIP7702,
} from '../../types/transaction.js'
import { getTransactionType } from './getTransactionType.js'

test('empty', () => {
  expectTypeOf(getTransactionType({})).toEqualTypeOf<string>()
})

test('opaque', () => {
  expectTypeOf(getTransactionType({} as TransactionSerializable)).toEqualTypeOf<
    'legacy' | 'eip1559' | 'eip2930' | 'eip4844' | 'eip7702'
  >()
  expectTypeOf(
    getTransactionType({} as TransactionSerializableLegacy),
  ).toEqualTypeOf<'legacy'>()
  expectTypeOf(
    getTransactionType({} as TransactionSerializableEIP1559),
  ).toEqualTypeOf<'eip1559'>()
  expectTypeOf(
    getTransactionType({} as TransactionSerializableEIP2930),
  ).toEqualTypeOf<'eip2930'>()
  expectTypeOf(
    getTransactionType({} as TransactionSerializableEIP4844),
  ).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({} as TransactionSerializableEIP7702),
  ).toEqualTypeOf<'eip7702'>()
})

test('const: type', () => {
  expectTypeOf(getTransactionType({ type: 'legacy' })).toEqualTypeOf<'legacy'>()
  expectTypeOf(
    getTransactionType({ type: 'eip1559' }),
  ).toEqualTypeOf<'eip1559'>()
  expectTypeOf(
    getTransactionType({ type: 'eip2930' }),
  ).toEqualTypeOf<'eip2930'>()
  expectTypeOf(
    getTransactionType({ type: 'eip4844' }),
  ).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({ type: 'eip7702' }),
  ).toEqualTypeOf<'eip7702'>()
})

test('const: legacy attributes', () => {
  expectTypeOf(getTransactionType({ gasPrice: 1n })).toEqualTypeOf<'legacy'>()
  expectTypeOf(
    getTransactionType({ gasPrice: 1n, maxFeePerGas: undefined }),
  ).toEqualTypeOf<'legacy'>()
  expectTypeOf(
    getTransactionType({ gasPrice: 1n, maxFeePerBlobGas: undefined }),
  ).toEqualTypeOf<'legacy'>()
})

test('const: eip1559 attributes', () => {
  expectTypeOf(
    getTransactionType({ maxFeePerGas: 1n }),
  ).toEqualTypeOf<'eip1559'>()
  expectTypeOf(
    getTransactionType({ maxPriorityFeePerGas: 1n }),
  ).toEqualTypeOf<'eip1559'>()
  expectTypeOf(
    getTransactionType({ maxFeePerGas: 1n, maxPriorityFeePerGas: 1n }),
  ).toEqualTypeOf<'eip1559'>()
  expectTypeOf(
    getTransactionType({ maxFeePerGas: 1n, gasPrice: undefined }),
  ).toEqualTypeOf<'eip1559'>()
  expectTypeOf(
    getTransactionType({ accessList: [], maxFeePerGas: 1n }),
  ).toEqualTypeOf<'eip1559'>()
})

test('const: eip2930 attributes', () => {
  expectTypeOf(
    getTransactionType({
      accessList: [
        {
          address: '0x',
          storageKeys: ['0x'],
        },
      ],
    }),
  ).toEqualTypeOf<'eip2930'>()
  expectTypeOf(
    getTransactionType({ accessList: [] }),
  ).toEqualTypeOf<'eip2930'>()
  expectTypeOf(
    getTransactionType({ accessList: [], maxFeePerGas: undefined }),
  ).toEqualTypeOf<'eip2930'>()
  expectTypeOf(
    getTransactionType({ accessList: [], gasPrice: undefined }),
  ).toEqualTypeOf<'eip2930'>()
  expectTypeOf(
    getTransactionType({ accessList: [], gasPrice: 1n }),
  ).toEqualTypeOf<'eip2930'>()
})

test('const: 4844 attributes', () => {
  expectTypeOf(getTransactionType({ blobs: [] })).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({ blobs: [], gasPrice: undefined }),
  ).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({ blobs: [], maxFeePerGas: undefined }),
  ).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({ blobs: [], maxFeePerGas: 1n }),
  ).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({ blobs: [], maxPriorityFeePerGas: undefined }),
  ).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({ blobs: [], maxPriorityFeePerGas: 1n }),
  ).toEqualTypeOf<'eip4844'>()
  expectTypeOf(getTransactionType({ sidecars: [] })).toEqualTypeOf<'eip4844'>()
  expectTypeOf(
    getTransactionType({ accessList: [], blobVersionedHashes: [] }),
  ).toEqualTypeOf<'eip4844'>()
})

test('const: 7702 attributes', () => {
  expectTypeOf(
    getTransactionType({ authorizationList: [] }),
  ).toEqualTypeOf<'eip7702'>()
  expectTypeOf(
    getTransactionType({ authorizationList: [], gasPrice: undefined }),
  ).toEqualTypeOf<'eip7702'>()
  expectTypeOf(
    getTransactionType({ authorizationList: [], maxFeePerGas: undefined }),
  ).toEqualTypeOf<'eip7702'>()
  expectTypeOf(
    getTransactionType({ authorizationList: [], maxFeePerGas: 1n }),
  ).toEqualTypeOf<'eip7702'>()
  expectTypeOf(
    getTransactionType({
      authorizationList: [],
      maxPriorityFeePerGas: undefined,
    }),
  ).toEqualTypeOf<'eip7702'>()
  expectTypeOf(
    getTransactionType({
      accessList: [],
      authorizationList: [],
      maxPriorityFeePerGas: 1n,
    }),
  ).toEqualTypeOf<'eip7702'>()
})
</file>

<file path="src/utils/transaction/getTransactionType.ts">
import {
  InvalidSerializableTransactionError,
  type InvalidSerializableTransactionErrorType,
} from '../../errors/transaction.js'
import type { ErrorType } from '../../errors/utils.js'
import type {
  FeeValuesEIP1559,
  FeeValuesEIP4844,
  FeeValuesLegacy,
} from '../../index.js'
import type {
  TransactionRequestGeneric,
  TransactionSerializableEIP2930,
  TransactionSerializableEIP4844,
  TransactionSerializableEIP7702,
  TransactionSerializableGeneric,
} from '../../types/transaction.js'
import type { Assign, ExactPartial, IsNever, OneOf } from '../../types/utils.js'

export type GetTransactionType<
  transaction extends OneOf<
    TransactionSerializableGeneric | TransactionRequestGeneric
  > = TransactionSerializableGeneric,
  result =
    | (transaction extends LegacyProperties ? 'legacy' : never)
    | (transaction extends EIP1559Properties ? 'eip1559' : never)
    | (transaction extends EIP2930Properties ? 'eip2930' : never)
    | (transaction extends EIP4844Properties ? 'eip4844' : never)
    | (transaction extends EIP7702Properties ? 'eip7702' : never)
    | (transaction['type'] extends TransactionSerializableGeneric['type']
        ? Extract<transaction['type'], string>
        : never),
> = IsNever<keyof transaction> extends true
  ? string
  : IsNever<result> extends false
    ? result
    : string

export type GetTransactionTypeErrorType =
  | InvalidSerializableTransactionErrorType
  | ErrorType

export function getTransactionType<
  const transaction extends OneOf<
    TransactionSerializableGeneric | TransactionRequestGeneric
  >,
>(transaction: transaction): GetTransactionType<transaction> {
  if (transaction.type)
    return transaction.type as GetTransactionType<transaction>

  if (typeof transaction.authorizationList !== 'undefined')
    return 'eip7702' as any

  if (
    typeof transaction.blobs !== 'undefined' ||
    typeof transaction.blobVersionedHashes !== 'undefined' ||
    typeof transaction.maxFeePerBlobGas !== 'undefined' ||
    typeof transaction.sidecars !== 'undefined'
  )
    return 'eip4844' as any

  if (
    typeof transaction.maxFeePerGas !== 'undefined' ||
    typeof transaction.maxPriorityFeePerGas !== 'undefined'
  ) {
    return 'eip1559' as any
  }

  if (typeof transaction.gasPrice !== 'undefined') {
    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any
    return 'legacy' as any
  }

  throw new InvalidSerializableTransactionError({ transaction })
}

////////////////////////////////////////////////////////////////////////////////////////////
// Types

type BaseProperties = {
  accessList?: undefined
  authorizationList?: undefined
  blobs?: undefined
  blobVersionedHashes?: undefined
  gasPrice?: undefined
  maxFeePerBlobGas?: undefined
  maxFeePerGas?: undefined
  maxPriorityFeePerGas?: undefined
  sidecars?: undefined
}

type LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>
type EIP1559Properties = Assign<
  BaseProperties,
  OneOf<
    | {
        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']
      }
    | {
        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']
      },
    FeeValuesEIP1559
  > & {
    accessList?: TransactionSerializableEIP2930['accessList'] | undefined
  }
>
type EIP2930Properties = Assign<
  ExactPartial<LegacyProperties>,
  {
    accessList: TransactionSerializableEIP2930['accessList']
  }
>
type EIP4844Properties = Assign<
  ExactPartial<EIP1559Properties>,
  ExactPartial<FeeValuesEIP4844> &
    OneOf<
      | {
          blobs: TransactionSerializableEIP4844['blobs']
        }
      | {
          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']
        }
      | {
          sidecars: TransactionSerializableEIP4844['sidecars']
        },
      TransactionSerializableEIP4844
    >
>
type EIP7702Properties = Assign<
  ExactPartial<EIP1559Properties>,
  {
    authorizationList: TransactionSerializableEIP7702['authorizationList']
  }
>
</file>

<file path="src/utils/transaction/parseTransaction.bench.ts">
import { Transaction } from 'ethers'

import { bench, describe } from 'vitest'

import { accounts } from '~test/src/constants.js'
import type { TransactionSerializableBase } from '../../types/transaction.js'
import { parseEther } from '../unit/parseEther.js'

import { parseTransaction } from './parseTransaction.js'
import { serializeTransaction } from './serializeTransaction.js'

const base = {
  to: accounts[1].address,
  nonce: 785,
  value: parseEther('1'),
} satisfies TransactionSerializableBase

const legacy = serializeTransaction(
  { ...base, gasPrice: 1n },
  { r: '0x1', s: '0x2', yParity: 1 },
)
const eip1559 = serializeTransaction(
  { ...base, chainId: 1, maxFeePerGas: 1n },
  { r: '0x1', s: '0x2', yParity: 1 },
)
const eip2930 = serializeTransaction(
  { ...base, chainId: 1, gasPrice: 1n, accessList: [] },
  { r: '0x1', s: '0x2', yParity: 1 },
)

describe('Parse Transaction (Legacy)', () => {
  bench('viem: `parseTransaction`', () => {
    parseTransaction(legacy)
  })

  bench('ethers: `Transaction.from`', () => {
    Transaction.from(legacy)
  })
})

describe('Parse Transaction (EIP1559)', () => {
  bench('viem: `parseTransaction`', () => {
    parseTransaction(eip1559)
  })

  bench('ethers: `Transaction.from`', () => {
    Transaction.from(eip1559)
  })
})

describe('Parse Transaction (EIP2930)', () => {
  bench('viem: `parseTransaction`', () => {
    parseTransaction(eip2930)
  })

  bench('ethers: `Transaction.from`', () => {
    Transaction.from(eip2930)
  })
})
</file>

<file path="src/utils/transaction/parseTransaction.ts">
import {
  InvalidAddressError,
  type InvalidAddressErrorType,
} from '../../errors/address.js'
import {
  InvalidLegacyVError,
  type InvalidLegacyVErrorType,
  InvalidSerializedTransactionError,
  type InvalidSerializedTransactionErrorType,
} from '../../errors/transaction.js'
import type { ErrorType } from '../../errors/utils.js'
import type {
  SerializedAuthorizationList,
  SignedAuthorizationList,
} from '../../types/authorization.js'
import type { Hex, Signature } from '../../types/misc.js'
import type {
  AccessList,
  TransactionRequestEIP2930,
  TransactionRequestLegacy,
  TransactionSerializable,
  TransactionSerializableEIP1559,
  TransactionSerializableEIP2930,
  TransactionSerializableEIP4844,
  TransactionSerializableEIP7702,
  TransactionSerializableLegacy,
  TransactionSerialized,
  TransactionSerializedEIP1559,
  TransactionSerializedEIP2930,
  TransactionSerializedEIP4844,
  TransactionSerializedEIP7702,
  TransactionSerializedGeneric,
  TransactionType,
} from '../../types/transaction.js'
import type { IsNarrowable, Mutable } from '../../types/utils.js'
import { type IsAddressErrorType, isAddress } from '../address/isAddress.js'
import { toBlobSidecars } from '../blob/toBlobSidecars.js'
import { type IsHexErrorType, isHex } from '../data/isHex.js'
import { type PadHexErrorType, padHex } from '../data/pad.js'
import { trim } from '../data/trim.js'
import {
  type HexToBigIntErrorType,
  type HexToNumberErrorType,
  hexToBigInt,
  hexToNumber,
} from '../encoding/fromHex.js'
import { type FromRlpErrorType, fromRlp } from '../encoding/fromRlp.js'
import type { RecursiveArray } from '../encoding/toRlp.js'
import { isHash } from '../hash/isHash.js'

import {
  type AssertTransactionEIP1559ErrorType,
  type AssertTransactionEIP2930ErrorType,
  type AssertTransactionEIP4844ErrorType,
  type AssertTransactionEIP7702ErrorType,
  type AssertTransactionLegacyErrorType,
  assertTransactionEIP1559,
  assertTransactionEIP2930,
  assertTransactionEIP4844,
  assertTransactionEIP7702,
  assertTransactionLegacy,
} from './assertTransaction.js'
import {
  type GetSerializedTransactionType,
  type GetSerializedTransactionTypeErrorType,
  getSerializedTransactionType,
} from './getSerializedTransactionType.js'

export type ParseTransactionReturnType<
  serialized extends TransactionSerializedGeneric = TransactionSerialized,
  type extends TransactionType = GetSerializedTransactionType<serialized>,
> = IsNarrowable<serialized, Hex> extends true
  ?
      | (type extends 'eip1559' ? TransactionSerializableEIP1559 : never)
      | (type extends 'eip2930' ? TransactionSerializableEIP2930 : never)
      | (type extends 'eip4844' ? TransactionSerializableEIP4844 : never)
      | (type extends 'eip7702' ? TransactionSerializableEIP7702 : never)
      | (type extends 'legacy' ? TransactionSerializableLegacy : never)
  : TransactionSerializable

export type ParseTransactionErrorType =
  | GetSerializedTransactionTypeErrorType
  | ParseTransactionEIP1559ErrorType
  | ParseTransactionEIP2930ErrorType
  | ParseTransactionEIP4844ErrorType
  | ParseTransactionEIP7702ErrorType
  | ParseTransactionLegacyErrorType

export function parseTransaction<
  const serialized extends TransactionSerializedGeneric,
>(serializedTransaction: serialized): ParseTransactionReturnType<serialized> {
  const type = getSerializedTransactionType(serializedTransaction)

  if (type === 'eip1559')
    return parseTransactionEIP1559(
      serializedTransaction as TransactionSerializedEIP1559,
    ) as ParseTransactionReturnType<serialized>

  if (type === 'eip2930')
    return parseTransactionEIP2930(
      serializedTransaction as TransactionSerializedEIP2930,
    ) as ParseTransactionReturnType<serialized>

  if (type === 'eip4844')
    return parseTransactionEIP4844(
      serializedTransaction as TransactionSerializedEIP4844,
    ) as ParseTransactionReturnType<serialized>

  if (type === 'eip7702')
    return parseTransactionEIP7702(
      serializedTransaction as TransactionSerializedEIP7702,
    ) as ParseTransactionReturnType<serialized>

  return parseTransactionLegacy(
    serializedTransaction,
  ) as ParseTransactionReturnType<serialized>
}

type ParseTransactionEIP7702ErrorType =
  | ToTransactionArrayErrorType
  | AssertTransactionEIP7702ErrorType
  | ToTransactionArrayErrorType
  | HexToBigIntErrorType
  | HexToNumberErrorType
  | InvalidLegacyVErrorType
  | InvalidSerializedTransactionErrorType
  | IsHexErrorType
  | ParseAuthorizationListErrorType
  | ParseEIP155SignatureErrorType
  | ErrorType

function parseTransactionEIP7702(
  serializedTransaction: TransactionSerializedEIP7702,
): TransactionSerializableEIP7702 {
  const transactionArray = toTransactionArray(serializedTransaction)

  const [
    chainId,
    nonce,
    maxPriorityFeePerGas,
    maxFeePerGas,
    gas,
    to,
    value,
    data,
    accessList,
    authorizationList,
    v,
    r,
    s,
  ] = transactionArray

  if (transactionArray.length !== 10 && transactionArray.length !== 13)
    throw new InvalidSerializedTransactionError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to,
        value,
        data,
        accessList,
        authorizationList,
        ...(transactionArray.length > 9
          ? {
              v,
              r,
              s,
            }
          : {}),
      },
      serializedTransaction,
      type: 'eip7702',
    })

  const transaction = {
    chainId: hexToNumber(chainId as Hex),
    type: 'eip7702',
  } as TransactionSerializableEIP7702
  if (isHex(to) && to !== '0x') transaction.to = to
  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)
  if (isHex(data) && data !== '0x') transaction.data = data
  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)
  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)
  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')
    transaction.maxFeePerGas = hexToBigInt(maxFeePerGas)
  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
    transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas)
  if (accessList.length !== 0 && accessList !== '0x')
    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)
  if (authorizationList.length !== 0 && authorizationList !== '0x')
    transaction.authorizationList = parseAuthorizationList(
      authorizationList as SerializedAuthorizationList,
    )

  assertTransactionEIP7702(transaction)

  const signature =
    transactionArray.length === 13
      ? parseEIP155Signature(transactionArray as RecursiveArray<Hex>)
      : undefined

  return { ...signature, ...transaction }
}

type ParseTransactionEIP4844ErrorType =
  | ToTransactionArrayErrorType
  | AssertTransactionEIP4844ErrorType
  | ToTransactionArrayErrorType
  | HexToBigIntErrorType
  | HexToNumberErrorType
  | InvalidLegacyVErrorType
  | InvalidSerializedTransactionErrorType
  | IsHexErrorType
  | ParseEIP155SignatureErrorType
  | ErrorType

function parseTransactionEIP4844(
  serializedTransaction: TransactionSerializedEIP4844,
): TransactionSerializableEIP4844 {
  const transactionOrWrapperArray = toTransactionArray(serializedTransaction)

  const hasNetworkWrapper = transactionOrWrapperArray.length === 4

  const transactionArray = hasNetworkWrapper
    ? transactionOrWrapperArray[0]
    : transactionOrWrapperArray
  const wrapperArray = hasNetworkWrapper
    ? transactionOrWrapperArray.slice(1)
    : []

  const [
    chainId,
    nonce,
    maxPriorityFeePerGas,
    maxFeePerGas,
    gas,
    to,
    value,
    data,
    accessList,
    maxFeePerBlobGas,
    blobVersionedHashes,
    v,
    r,
    s,
  ] = transactionArray
  const [blobs, commitments, proofs] = wrapperArray

  if (!(transactionArray.length === 11 || transactionArray.length === 14))
    throw new InvalidSerializedTransactionError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to,
        value,
        data,
        accessList,
        ...(transactionArray.length > 9
          ? {
              v,
              r,
              s,
            }
          : {}),
      },
      serializedTransaction,
      type: 'eip4844',
    })

  const transaction = {
    blobVersionedHashes: blobVersionedHashes as Hex[],
    chainId: hexToNumber(chainId as Hex),
    type: 'eip4844',
  } as TransactionSerializableEIP4844
  if (isHex(to) && to !== '0x') transaction.to = to
  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)
  if (isHex(data) && data !== '0x') transaction.data = data
  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)
  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)
  if (isHex(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')
    transaction.maxFeePerBlobGas = hexToBigInt(maxFeePerBlobGas)
  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')
    transaction.maxFeePerGas = hexToBigInt(maxFeePerGas)
  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
    transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas)
  if (accessList.length !== 0 && accessList !== '0x')
    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)
  if (blobs && commitments && proofs)
    transaction.sidecars = toBlobSidecars({
      blobs: blobs as Hex[],
      commitments: commitments as Hex[],
      proofs: proofs as Hex[],
    })

  assertTransactionEIP4844(transaction)

  const signature =
    transactionArray.length === 14
      ? parseEIP155Signature(transactionArray as RecursiveArray<Hex>)
      : undefined

  return { ...signature, ...transaction }
}

type ParseTransactionEIP1559ErrorType =
  | ToTransactionArrayErrorType
  | AssertTransactionEIP1559ErrorType
  | ToTransactionArrayErrorType
  | HexToBigIntErrorType
  | HexToNumberErrorType
  | InvalidLegacyVErrorType
  | InvalidSerializedTransactionErrorType
  | IsHexErrorType
  | ParseEIP155SignatureErrorType
  | ParseAccessListErrorType
  | ErrorType

function parseTransactionEIP1559(
  serializedTransaction: TransactionSerializedEIP1559,
): TransactionSerializableEIP1559 {
  const transactionArray = toTransactionArray(serializedTransaction)

  const [
    chainId,
    nonce,
    maxPriorityFeePerGas,
    maxFeePerGas,
    gas,
    to,
    value,
    data,
    accessList,
    v,
    r,
    s,
  ] = transactionArray

  if (!(transactionArray.length === 9 || transactionArray.length === 12))
    throw new InvalidSerializedTransactionError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to,
        value,
        data,
        accessList,
        ...(transactionArray.length > 9
          ? {
              v,
              r,
              s,
            }
          : {}),
      },
      serializedTransaction,
      type: 'eip1559',
    })

  const transaction: TransactionSerializableEIP1559 = {
    chainId: hexToNumber(chainId as Hex),
    type: 'eip1559',
  }
  if (isHex(to) && to !== '0x') transaction.to = to
  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)
  if (isHex(data) && data !== '0x') transaction.data = data
  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)
  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)
  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')
    transaction.maxFeePerGas = hexToBigInt(maxFeePerGas)
  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
    transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas)
  if (accessList.length !== 0 && accessList !== '0x')
    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)

  assertTransactionEIP1559(transaction)

  const signature =
    transactionArray.length === 12
      ? parseEIP155Signature(transactionArray)
      : undefined

  return { ...signature, ...transaction }
}

type ParseTransactionEIP2930ErrorType =
  | ToTransactionArrayErrorType
  | AssertTransactionEIP2930ErrorType
  | ToTransactionArrayErrorType
  | HexToBigIntErrorType
  | HexToNumberErrorType
  | InvalidLegacyVErrorType
  | InvalidSerializedTransactionErrorType
  | IsHexErrorType
  | ParseEIP155SignatureErrorType
  | ParseAccessListErrorType
  | ErrorType

function parseTransactionEIP2930(
  serializedTransaction: TransactionSerializedEIP2930,
): Omit<TransactionRequestEIP2930, 'from'> &
  ({ chainId: number } | ({ chainId: number } & Signature)) {
  const transactionArray = toTransactionArray(serializedTransaction)

  const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] =
    transactionArray

  if (!(transactionArray.length === 8 || transactionArray.length === 11))
    throw new InvalidSerializedTransactionError({
      attributes: {
        chainId,
        nonce,
        gasPrice,
        gas,
        to,
        value,
        data,
        accessList,
        ...(transactionArray.length > 8
          ? {
              v,
              r,
              s,
            }
          : {}),
      },
      serializedTransaction,
      type: 'eip2930',
    })

  const transaction: TransactionSerializableEIP2930 = {
    chainId: hexToNumber(chainId as Hex),
    type: 'eip2930',
  }
  if (isHex(to) && to !== '0x') transaction.to = to
  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)
  if (isHex(data) && data !== '0x') transaction.data = data
  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)
  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)
  if (isHex(gasPrice) && gasPrice !== '0x')
    transaction.gasPrice = hexToBigInt(gasPrice)
  if (accessList.length !== 0 && accessList !== '0x')
    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)

  assertTransactionEIP2930(transaction)

  const signature =
    transactionArray.length === 11
      ? parseEIP155Signature(transactionArray)
      : undefined

  return { ...signature, ...transaction }
}

type ParseTransactionLegacyErrorType =
  | AssertTransactionLegacyErrorType
  | FromRlpErrorType
  | HexToBigIntErrorType
  | HexToNumberErrorType
  | InvalidLegacyVErrorType
  | InvalidSerializedTransactionErrorType
  | IsHexErrorType
  | ErrorType

function parseTransactionLegacy(
  serializedTransaction: Hex,
): Omit<TransactionRequestLegacy, 'from'> &
  ({ chainId?: number | undefined } | ({ chainId: number } & Signature)) {
  const transactionArray = fromRlp(serializedTransaction, 'hex')

  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] =
    transactionArray

  if (!(transactionArray.length === 6 || transactionArray.length === 9))
    throw new InvalidSerializedTransactionError({
      attributes: {
        nonce,
        gasPrice,
        gas,
        to,
        value,
        data,
        ...(transactionArray.length > 6
          ? {
              v: chainIdOrV_,
              r,
              s,
            }
          : {}),
      },
      serializedTransaction,
      type: 'legacy',
    })

  const transaction: TransactionSerializableLegacy = {
    type: 'legacy',
  }
  if (isHex(to) && to !== '0x') transaction.to = to
  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)
  if (isHex(data) && data !== '0x') transaction.data = data
  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)
  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)
  if (isHex(gasPrice) && gasPrice !== '0x')
    transaction.gasPrice = hexToBigInt(gasPrice)

  assertTransactionLegacy(transaction)

  if (transactionArray.length === 6) return transaction

  const chainIdOrV =
    isHex(chainIdOrV_) && chainIdOrV_ !== '0x'
      ? hexToBigInt(chainIdOrV_ as Hex)
      : 0n

  if (s === '0x' && r === '0x') {
    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV)
    return transaction
  }

  const v = chainIdOrV

  const chainId: number | undefined = Number((v - 35n) / 2n)
  if (chainId > 0) transaction.chainId = chainId
  else if (v !== 27n && v !== 28n) throw new InvalidLegacyVError({ v })

  transaction.v = v
  transaction.s = s as Hex
  transaction.r = r as Hex
  transaction.yParity = v % 2n === 0n ? 1 : 0

  return transaction
}

type ToTransactionArrayErrorType = FromRlpErrorType | ErrorType

export function toTransactionArray(serializedTransaction: string) {
  return fromRlp(`0x${serializedTransaction.slice(4)}` as Hex, 'hex')
}

type ParseAccessListErrorType =
  | InvalidAddressErrorType
  | IsAddressErrorType
  | ErrorType

export function parseAccessList(accessList_: RecursiveArray<Hex>): AccessList {
  const accessList: Mutable<AccessList> = []
  for (let i = 0; i < accessList_.length; i++) {
    const [address, storageKeys] = accessList_[i] as [Hex, Hex[]]

    if (!isAddress(address, { strict: false }))
      throw new InvalidAddressError({ address })

    accessList.push({
      address: address,
      storageKeys: storageKeys.map((key) => (isHash(key) ? key : trim(key))),
    })
  }
  return accessList
}

type ParseAuthorizationListErrorType =
  | HexToNumberErrorType
  | ParseEIP155SignatureErrorType
  | ErrorType

function parseAuthorizationList(
  serializedAuthorizationList: SerializedAuthorizationList,
): SignedAuthorizationList {
  const authorizationList: Mutable<SignedAuthorizationList> = []
  for (let i = 0; i < serializedAuthorizationList.length; i++) {
    const [chainId, address, nonce, yParity, r, s] =
      serializedAuthorizationList[i]

    authorizationList.push({
      address,
      chainId: hexToNumber(chainId),
      nonce: hexToNumber(nonce),
      ...parseEIP155Signature([yParity, r, s]),
    })
  }
  return authorizationList
}

type ParseEIP155SignatureErrorType =
  | HexToBigIntErrorType
  | PadHexErrorType
  | ErrorType

function parseEIP155Signature(
  transactionArray: RecursiveArray<Hex>,
): Signature & { yParity: number } {
  const signature = transactionArray.slice(-3)
  const v =
    signature[0] === '0x' || hexToBigInt(signature[0] as Hex) === 0n ? 27n : 28n
  return {
    r: padHex(signature[1] as Hex, { size: 32 }),
    s: padHex(signature[2] as Hex, { size: 32 }),
    v,
    yParity: v === 27n ? 0 : 1,
  }
}
</file>

<file path="src/utils/transaction/serializeAccessList.ts">
import {
  InvalidAddressError,
  type InvalidAddressErrorType,
} from '../../errors/address.js'
import {
  InvalidStorageKeySizeError,
  type InvalidStorageKeySizeErrorType,
} from '../../errors/transaction.js'
import type { ErrorType } from '../../errors/utils.js'
import type { Hex } from '../../types/misc.js'
import type { AccessList } from '../../types/transaction.js'
import { type IsAddressErrorType, isAddress } from '../address/isAddress.js'
import type { RecursiveArray } from '../encoding/toRlp.js'

export type SerializeAccessListErrorType =
  | InvalidStorageKeySizeErrorType
  | InvalidAddressErrorType
  | IsAddressErrorType
  | ErrorType

/*
 * Serialize an  EIP-2930 access list
 * @remarks
 * Use to create a transaction serializer with support for EIP-2930 access lists
 *
 * @param accessList - Array of objects of address and arrays of Storage Keys
 * @throws InvalidAddressError, InvalidStorageKeySizeError
 * @returns Array of hex strings
 */
export function serializeAccessList(
  accessList?: AccessList | undefined,
): RecursiveArray<Hex> {
  if (!accessList || accessList.length === 0) return []

  const serializedAccessList = []
  for (let i = 0; i < accessList.length; i++) {
    const { address, storageKeys } = accessList[i]

    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })
      }
    }

    if (!isAddress(address, { strict: false })) {
      throw new InvalidAddressError({ address })
    }

    serializedAccessList.push([address, storageKeys])
  }
  return serializedAccessList
}
</file>

<file path="src/utils/transaction/serializeTransaction.bench.ts">
import { Transaction } from 'ethers'

import { bench, describe } from 'vitest'

import { accounts } from '~test/src/constants.js'
import type { TransactionSerializableBase } from '../../types/transaction.js'
import { parseEther } from '../unit/parseEther.js'

import { serializeTransaction } from './serializeTransaction.js'

const base = {
  to: accounts[1].address,
  nonce: 785,
  value: parseEther('1'),
} satisfies TransactionSerializableBase

describe('Serialize Transaction (Legacy)', () => {
  bench('viem: `serializeTransaction`', () => {
    serializeTransaction(
      { ...base, gasPrice: 1n },
      { r: '0x1', s: '0x2', v: 28n },
    )
  })

  bench('ethers: `Transaction.serialized`', () => {
    Transaction.from({
      ...base,
      gasPrice: 1n,
      type: 0,
      signature: { r: '0x1', s: '0x2', v: 28 },
    }).serialized
  })
})

describe('Serialize Transaction (EIP1559)', () => {
  bench('viem: `serializeTransaction`', () => {
    serializeTransaction(
      { ...base, chainId: 1, maxFeePerGas: 1n },
      { r: '0x1', s: '0x2', v: 28n },
    )
  })

  bench('ethers: `Transaction.serialized`', () => {
    Transaction.from({
      ...base,
      chainId: 1,
      maxFeePerGas: 1n,
      type: 2,
      signature: { r: '0x1', s: '0x2', v: 28 },
    }).serialized
  })
})

describe('Serialize Transaction (EIP2930)', () => {
  bench('viem: `serializeTransaction`', () => {
    serializeTransaction(
      { ...base, chainId: 1, gasPrice: 1n, accessList: [] },
      { r: '0x1', s: '0x2', v: 28n },
    )
  })

  bench('ethers: `Transaction.serialized`', () => {
    Transaction.from({
      ...base,
      chainId: 1,
      gasPrice: 1n,
      accessList: [],
      signature: { r: '0x1', s: '0x2', v: 28 },
    }).serialized
  })
})
</file>

<file path="src/utils/transaction/serializeTransaction.ts">
import {
  InvalidLegacyVError,
  type InvalidLegacyVErrorType,
} from '../../errors/transaction.js'
import type { ErrorType } from '../../errors/utils.js'
import type {
  ByteArray,
  Hex,
  Signature,
  SignatureLegacy,
} from '../../types/misc.js'
import type {
  TransactionSerializable,
  TransactionSerializableEIP1559,
  TransactionSerializableEIP2930,
  TransactionSerializableEIP4844,
  TransactionSerializableEIP7702,
  TransactionSerializableGeneric,
  TransactionSerializableLegacy,
  TransactionSerialized,
  TransactionSerializedEIP1559,
  TransactionSerializedEIP2930,
  TransactionSerializedEIP4844,
  TransactionSerializedEIP7702,
  TransactionSerializedLegacy,
  TransactionType,
} from '../../types/transaction.js'
import type { OneOf } from '../../types/utils.js'
import {
  type SerializeAuthorizationListErrorType,
  serializeAuthorizationList,
} from '../authorization/serializeAuthorizationList.js'
import {
  type BlobsToCommitmentsErrorType,
  blobsToCommitments,
} from '../blob/blobsToCommitments.js'
import {
  blobsToProofs,
  type blobsToProofsErrorType,
} from '../blob/blobsToProofs.js'
import {
  type CommitmentsToVersionedHashesErrorType,
  commitmentsToVersionedHashes,
} from '../blob/commitmentsToVersionedHashes.js'
import {
  type ToBlobSidecarsErrorType,
  toBlobSidecars,
} from '../blob/toBlobSidecars.js'
import { type ConcatHexErrorType, concatHex } from '../data/concat.js'
import { trim } from '../data/trim.js'
import { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'
import { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'

import {
  type AssertTransactionEIP1559ErrorType,
  type AssertTransactionEIP2930ErrorType,
  type AssertTransactionEIP4844ErrorType,
  type AssertTransactionEIP7702ErrorType,
  type AssertTransactionLegacyErrorType,
  assertTransactionEIP1559,
  assertTransactionEIP2930,
  assertTransactionEIP4844,
  assertTransactionEIP7702,
  assertTransactionLegacy,
} from './assertTransaction.js'
import {
  type GetTransactionType,
  type GetTransactionTypeErrorType,
  getTransactionType,
} from './getTransactionType.js'
import {
  type SerializeAccessListErrorType,
  serializeAccessList,
} from './serializeAccessList.js'

export type SerializedTransactionReturnType<
  transaction extends TransactionSerializable = TransactionSerializable,
  ///
  _transactionType extends TransactionType = GetTransactionType<transaction>,
> = TransactionSerialized<_transactionType>

export type SerializeTransactionFn<
  transaction extends TransactionSerializableGeneric = TransactionSerializable,
  ///
  _transactionType extends TransactionType = never,
> = typeof serializeTransaction<
  OneOf<TransactionSerializable | transaction>,
  _transactionType
>

export type SerializeTransactionErrorType =
  | GetTransactionTypeErrorType
  | SerializeTransactionEIP1559ErrorType
  | SerializeTransactionEIP2930ErrorType
  | SerializeTransactionEIP4844ErrorType
  | SerializeTransactionEIP7702ErrorType
  | SerializeTransactionLegacyErrorType
  | ErrorType

export function serializeTransaction<
  const transaction extends TransactionSerializable,
  ///
  _transactionType extends TransactionType = GetTransactionType<transaction>,
>(
  transaction: transaction,
  signature?: Signature | undefined,
): SerializedTransactionReturnType<transaction, _transactionType> {
  const type = getTransactionType(transaction) as GetTransactionType

  if (type === 'eip1559')
    return serializeTransactionEIP1559(
      transaction as TransactionSerializableEIP1559,
      signature,
    ) as SerializedTransactionReturnType<transaction>

  if (type === 'eip2930')
    return serializeTransactionEIP2930(
      transaction as TransactionSerializableEIP2930,
      signature,
    ) as SerializedTransactionReturnType<transaction>

  if (type === 'eip4844')
    return serializeTransactionEIP4844(
      transaction as TransactionSerializableEIP4844,
      signature,
    ) as SerializedTransactionReturnType<transaction>

  if (type === 'eip7702')
    return serializeTransactionEIP7702(
      transaction as TransactionSerializableEIP7702,
      signature,
    ) as SerializedTransactionReturnType<transaction>

  return serializeTransactionLegacy(
    transaction as TransactionSerializableLegacy,
    signature as SignatureLegacy,
  ) as SerializedTransactionReturnType<transaction>
}

type SerializeTransactionEIP7702ErrorType =
  | AssertTransactionEIP7702ErrorType
  | SerializeAuthorizationListErrorType
  | ConcatHexErrorType
  | InvalidLegacyVErrorType
  | ToHexErrorType
  | ToRlpErrorType
  | SerializeAccessListErrorType
  | ErrorType

function serializeTransactionEIP7702(
  transaction: TransactionSerializableEIP7702,
  signature?: Signature | undefined,
): TransactionSerializedEIP7702 {
  const {
    authorizationList,
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data,
  } = transaction

  assertTransactionEIP7702(transaction)

  const serializedAccessList = serializeAccessList(accessList)
  const serializedAuthorizationList =
    serializeAuthorizationList(authorizationList)

  return concatHex([
    '0x04',
    toRlp([
      toHex(chainId),
      nonce ? toHex(nonce) : '0x',
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',
      maxFeePerGas ? toHex(maxFeePerGas) : '0x',
      gas ? toHex(gas) : '0x',
      to ?? '0x',
      value ? toHex(value) : '0x',
      data ?? '0x',
      serializedAccessList,
      serializedAuthorizationList,
      ...toYParitySignatureArray(transaction, signature),
    ]),
  ]) as TransactionSerializedEIP7702
}

type SerializeTransactionEIP4844ErrorType =
  | AssertTransactionEIP4844ErrorType
  | BlobsToCommitmentsErrorType
  | CommitmentsToVersionedHashesErrorType
  | blobsToProofsErrorType
  | ToBlobSidecarsErrorType
  | ConcatHexErrorType
  | InvalidLegacyVErrorType
  | ToHexErrorType
  | ToRlpErrorType
  | SerializeAccessListErrorType
  | ErrorType

function serializeTransactionEIP4844(
  transaction: TransactionSerializableEIP4844,
  signature?: Signature | undefined,
): TransactionSerializedEIP4844 {
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerBlobGas,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data,
  } = transaction

  assertTransactionEIP4844(transaction)

  let blobVersionedHashes = transaction.blobVersionedHashes
  let sidecars = transaction.sidecars
  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.
  if (
    transaction.blobs &&
    (typeof blobVersionedHashes === 'undefined' ||
      typeof sidecars === 'undefined')
  ) {
    const blobs = (
      typeof transaction.blobs[0] === 'string'
        ? transaction.blobs
        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))
    ) as Hex[]
    const kzg = transaction.kzg!
    const commitments = blobsToCommitments({
      blobs,
      kzg,
    })

    if (typeof blobVersionedHashes === 'undefined')
      blobVersionedHashes = commitmentsToVersionedHashes({
        commitments,
      })
    if (typeof sidecars === 'undefined') {
      const proofs = blobsToProofs({ blobs, commitments, kzg })
      sidecars = toBlobSidecars({ blobs, commitments, proofs })
    }
  }

  const serializedAccessList = serializeAccessList(accessList)

  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : '0x',
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',
    maxFeePerGas ? toHex(maxFeePerGas) : '0x',
    gas ? toHex(gas) : '0x',
    to ?? '0x',
    value ? toHex(value) : '0x',
    data ?? '0x',
    serializedAccessList,
    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',
    blobVersionedHashes ?? [],
    ...toYParitySignatureArray(transaction, signature),
  ] as const

  const blobs: Hex[] = []
  const commitments: Hex[] = []
  const proofs: Hex[] = []
  if (sidecars)
    for (let i = 0; i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i]
      blobs.push(blob)
      commitments.push(commitment)
      proofs.push(proof)
    }

  return concatHex([
    '0x03',
    sidecars
      ? // If sidecars are enabled, envelope turns into a "wrapper":
        toRlp([serializedTransaction, blobs, commitments, proofs])
      : // If sidecars are disabled, standard envelope is used:
        toRlp(serializedTransaction),
  ]) as TransactionSerializedEIP4844
}

type SerializeTransactionEIP1559ErrorType =
  | AssertTransactionEIP1559ErrorType
  | ConcatHexErrorType
  | InvalidLegacyVErrorType
  | ToHexErrorType
  | ToRlpErrorType
  | SerializeAccessListErrorType
  | ErrorType

function serializeTransactionEIP1559(
  transaction: TransactionSerializableEIP1559,
  signature?: Signature | undefined,
): TransactionSerializedEIP1559 {
  const {
    chainId,
    gas,
    nonce,
    to,
    value,
    maxFeePerGas,
    maxPriorityFeePerGas,
    accessList,
    data,
  } = transaction

  assertTransactionEIP1559(transaction)

  const serializedAccessList = serializeAccessList(accessList)

  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : '0x',
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',
    maxFeePerGas ? toHex(maxFeePerGas) : '0x',
    gas ? toHex(gas) : '0x',
    to ?? '0x',
    value ? toHex(value) : '0x',
    data ?? '0x',
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature),
  ]

  return concatHex([
    '0x02',
    toRlp(serializedTransaction),
  ]) as TransactionSerializedEIP1559
}

type SerializeTransactionEIP2930ErrorType =
  | AssertTransactionEIP2930ErrorType
  | ConcatHexErrorType
  | InvalidLegacyVErrorType
  | ToHexErrorType
  | ToRlpErrorType
  | SerializeAccessListErrorType
  | ErrorType

function serializeTransactionEIP2930(
  transaction: TransactionSerializableEIP2930,
  signature?: Signature | undefined,
): TransactionSerializedEIP2930 {
  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =
    transaction

  assertTransactionEIP2930(transaction)

  const serializedAccessList = serializeAccessList(accessList)

  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : '0x',
    gasPrice ? toHex(gasPrice) : '0x',
    gas ? toHex(gas) : '0x',
    to ?? '0x',
    value ? toHex(value) : '0x',
    data ?? '0x',
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature),
  ]

  return concatHex([
    '0x01',
    toRlp(serializedTransaction),
  ]) as TransactionSerializedEIP2930
}

type SerializeTransactionLegacyErrorType =
  | AssertTransactionLegacyErrorType
  | InvalidLegacyVErrorType
  | ToHexErrorType
  | ToRlpErrorType
  | ErrorType

function serializeTransactionLegacy(
  transaction: TransactionSerializableLegacy,
  signature?: SignatureLegacy | undefined,
): TransactionSerializedLegacy {
  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction

  assertTransactionLegacy(transaction)

  let serializedTransaction = [
    nonce ? toHex(nonce) : '0x',
    gasPrice ? toHex(gasPrice) : '0x',
    gas ? toHex(gas) : '0x',
    to ?? '0x',
    value ? toHex(value) : '0x',
    data ?? '0x',
  ]

  if (signature) {
    const v = (() => {
      // EIP-155 (inferred chainId)
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n
        if (inferredChainId > 0) return signature.v
        return 27n + (signature.v === 35n ? 0n : 1n)
      }

      // EIP-155 (explicit chainId)
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)

      // Pre-EIP-155 (no chainId)
      const v = 27n + (signature.v === 27n ? 0n : 1n)
      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })
      return v
    })()

    const r = trim(signature.r)
    const s = trim(signature.s)

    serializedTransaction = [
      ...serializedTransaction,
      toHex(v),
      r === '0x00' ? '0x' : r,
      s === '0x00' ? '0x' : s,
    ]
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex(chainId),
      '0x',
      '0x',
    ]
  }

  return toRlp(serializedTransaction) as TransactionSerializedLegacy
}

export function toYParitySignatureArray(
  transaction: TransactionSerializableGeneric,
  signature_?: Signature | undefined,
) {
  const signature = signature_ ?? transaction
  const { v, yParity } = signature

  if (typeof signature.r === 'undefined') return []
  if (typeof signature.s === 'undefined') return []
  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []

  const r = trim(signature.r)
  const s = trim(signature.s)

  const yParity_ = (() => {
    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'
    if (v === 0n) return '0x'
    if (v === 1n) return toHex(1)

    return v === 27n ? '0x' : toHex(1)
  })()

  return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s]
}
</file>

<file path="src/utils/buildRequest.ts">
import { BaseError } from '../errors/base.js'
import {
  HttpRequestError,
  type HttpRequestErrorType,
  type RpcRequestErrorType,
  type TimeoutErrorType,
  type WebSocketRequestErrorType,
} from '../errors/request.js'
import {
  AtomicReadyWalletRejectedUpgradeError,
  type AtomicReadyWalletRejectedUpgradeErrorType,
  AtomicityNotSupportedError,
  type AtomicityNotSupportedErrorType,
  BundleTooLargeError,
  type BundleTooLargeErrorType,
  ChainDisconnectedError,
  type ChainDisconnectedErrorType,
  DuplicateIdError,
  type DuplicateIdErrorType,
  InternalRpcError,
  type InternalRpcErrorType,
  InvalidInputRpcError,
  type InvalidInputRpcErrorType,
  InvalidParamsRpcError,
  type InvalidParamsRpcErrorType,
  InvalidRequestRpcError,
  type InvalidRequestRpcErrorType,
  JsonRpcVersionUnsupportedError,
  type JsonRpcVersionUnsupportedErrorType,
  LimitExceededRpcError,
  type LimitExceededRpcErrorType,
  MethodNotFoundRpcError,
  type MethodNotFoundRpcErrorType,
  MethodNotSupportedRpcError,
  type MethodNotSupportedRpcErrorType,
  ParseRpcError,
  type ParseRpcErrorType,
  ProviderDisconnectedError,
  type ProviderDisconnectedErrorType,
  type ProviderRpcErrorCode,
  ResourceNotFoundRpcError,
  type ResourceNotFoundRpcErrorType,
  ResourceUnavailableRpcError,
  type ResourceUnavailableRpcErrorType,
  type RpcError,
  type RpcErrorCode,
  type RpcErrorType,
  SwitchChainError,
  type SwitchChainErrorType,
  TransactionRejectedRpcError,
  type TransactionRejectedRpcErrorType,
  UnauthorizedProviderError,
  type UnauthorizedProviderErrorType,
  UnknownBundleIdError,
  type UnknownBundleIdErrorType,
  UnknownRpcError,
  type UnknownRpcErrorType,
  UnsupportedChainIdError,
  type UnsupportedChainIdErrorType,
  UnsupportedNonOptionalCapabilityError,
  type UnsupportedNonOptionalCapabilityErrorType,
  UnsupportedProviderMethodError,
  type UnsupportedProviderMethodErrorType,
  UserRejectedRequestError,
  type UserRejectedRequestErrorType,
} from '../errors/rpc.js'
import type { ErrorType } from '../errors/utils.js'
import type {
  EIP1193RequestFn,
  EIP1193RequestOptions,
} from '../types/eip1193.js'
import { stringToHex } from './encoding/toHex.js'
import type { CreateBatchSchedulerErrorType } from './promise/createBatchScheduler.js'
import { withDedupe } from './promise/withDedupe.js'
import { type WithRetryErrorType, withRetry } from './promise/withRetry.js'
import type { GetSocketRpcClientErrorType } from './rpc/socket.js'
import { stringify } from './stringify.js'

export type RequestErrorType =
  | AtomicityNotSupportedErrorType
  | AtomicReadyWalletRejectedUpgradeErrorType
  | BundleTooLargeErrorType
  | ChainDisconnectedErrorType
  | CreateBatchSchedulerErrorType
  | DuplicateIdErrorType
  | HttpRequestErrorType
  | InternalRpcErrorType
  | InvalidInputRpcErrorType
  | InvalidParamsRpcErrorType
  | InvalidRequestRpcErrorType
  | GetSocketRpcClientErrorType
  | JsonRpcVersionUnsupportedErrorType
  | LimitExceededRpcErrorType
  | MethodNotFoundRpcErrorType
  | MethodNotSupportedRpcErrorType
  | ParseRpcErrorType
  | ProviderDisconnectedErrorType
  | ResourceNotFoundRpcErrorType
  | ResourceUnavailableRpcErrorType
  | RpcErrorType
  | RpcRequestErrorType
  | SwitchChainErrorType
  | TimeoutErrorType
  | TransactionRejectedRpcErrorType
  | UnauthorizedProviderErrorType
  | UnknownBundleIdErrorType
  | UnknownRpcErrorType
  | UnsupportedChainIdErrorType
  | UnsupportedNonOptionalCapabilityErrorType
  | UnsupportedProviderMethodErrorType
  | UserRejectedRequestErrorType
  | WebSocketRequestErrorType
  | WithRetryErrorType
  | ErrorType

export function buildRequest<request extends (args: any) => Promise<any>>(
  request: request,
  options: EIP1193RequestOptions = {},
): EIP1193RequestFn {
  return async (args, overrideOptions = {}) => {
    const {
      dedupe = false,
      methods,
      retryDelay = 150,
      retryCount = 3,
      uid,
    } = {
      ...options,
      ...overrideOptions,
    }

    const { method } = args
    if (methods?.exclude?.includes(method))
      throw new MethodNotSupportedRpcError(new Error('method not supported'), {
        method,
      })
    if (methods?.include && !methods.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error('method not supported'), {
        method,
      })

    const requestId = dedupe
      ? stringToHex(`${uid}.${stringify(args)}`)
      : undefined
    return withDedupe(
      () =>
        withRetry(
          async () => {
            try {
              return await request(args)
            } catch (err_) {
              const err = err_ as unknown as RpcError<
                RpcErrorCode | ProviderRpcErrorCode
              >
              switch (err.code) {
                // -32700
                case ParseRpcError.code:
                  throw new ParseRpcError(err)
                // -32600
                case InvalidRequestRpcError.code:
                  throw new InvalidRequestRpcError(err)
                // -32601
                case MethodNotFoundRpcError.code:
                  throw new MethodNotFoundRpcError(err, { method: args.method })
                // -32602
                case InvalidParamsRpcError.code:
                  throw new InvalidParamsRpcError(err)
                // -32603
                case InternalRpcError.code:
                  throw new InternalRpcError(err)
                // -32000
                case InvalidInputRpcError.code:
                  throw new InvalidInputRpcError(err)
                // -32001
                case ResourceNotFoundRpcError.code:
                  throw new ResourceNotFoundRpcError(err)
                // -32002
                case ResourceUnavailableRpcError.code:
                  throw new ResourceUnavailableRpcError(err)
                // -32003
                case TransactionRejectedRpcError.code:
                  throw new TransactionRejectedRpcError(err)
                // -32004
                case MethodNotSupportedRpcError.code:
                  throw new MethodNotSupportedRpcError(err, {
                    method: args.method,
                  })
                // -32005
                case LimitExceededRpcError.code:
                  throw new LimitExceededRpcError(err)
                // -32006
                case JsonRpcVersionUnsupportedError.code:
                  throw new JsonRpcVersionUnsupportedError(err)

                // 4001
                case UserRejectedRequestError.code:
                  throw new UserRejectedRequestError(err)
                // 4100
                case UnauthorizedProviderError.code:
                  throw new UnauthorizedProviderError(err)
                // 4200
                case UnsupportedProviderMethodError.code:
                  throw new UnsupportedProviderMethodError(err)
                // 4900
                case ProviderDisconnectedError.code:
                  throw new ProviderDisconnectedError(err)
                // 4901
                case ChainDisconnectedError.code:
                  throw new ChainDisconnectedError(err)
                // 4902
                case SwitchChainError.code:
                  throw new SwitchChainError(err)

                // 5700
                case UnsupportedNonOptionalCapabilityError.code:
                  throw new UnsupportedNonOptionalCapabilityError(err)
                // 5710
                case UnsupportedChainIdError.code:
                  throw new UnsupportedChainIdError(err)
                // 5720
                case DuplicateIdError.code:
                  throw new DuplicateIdError(err)
                // 5730
                case UnknownBundleIdError.code:
                  throw new UnknownBundleIdError(err)
                // 5740
                case BundleTooLargeError.code:
                  throw new BundleTooLargeError(err)
                // 5750
                case AtomicReadyWalletRejectedUpgradeError.code:
                  throw new AtomicReadyWalletRejectedUpgradeError(err)
                // 5760
                case AtomicityNotSupportedError.code:
                  throw new AtomicityNotSupportedError(err)

                // CAIP-25: User Rejected Error
                // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
                case 5000:
                  throw new UserRejectedRequestError(err)

                default:
                  if (err_ instanceof BaseError) throw err_
                  throw new UnknownRpcError(err as Error)
              }
            }
          },
          {
            delay: ({ count, error }) => {
              // If we find a Retry-After header, let's retry after the given time.
              if (error && error instanceof HttpRequestError) {
                const retryAfter = error?.headers?.get('Retry-After')
                if (retryAfter?.match(/\d/))
                  return Number.parseInt(retryAfter) * 1000
              }

              // Otherwise, let's retry with an exponential backoff.
              return ~~(1 << count) * retryDelay
            },
            retryCount,
            shouldRetry: ({ error }) => shouldRetry(error),
          },
        ),
      { enabled: dedupe, id: requestId },
    )
  }
}

/** @internal */
export function shouldRetry(error: Error) {
  if ('code' in error && typeof error.code === 'number') {
    if (error.code === -1) return true // Unknown error
    if (error.code === LimitExceededRpcError.code) return true
    if (error.code === InternalRpcError.code) return true
    return false
  }
  if (error instanceof HttpRequestError && error.status) {
    // Forbidden
    if (error.status === 403) return true
    // Request Timeout
    if (error.status === 408) return true
    // Request Entity Too Large
    if (error.status === 413) return true
    // Too Many Requests
    if (error.status === 429) return true
    // Internal Server Error
    if (error.status === 500) return true
    // Bad Gateway
    if (error.status === 502) return true
    // Service Unavailable
    if (error.status === 503) return true
    // Gateway Timeout
    if (error.status === 504) return true
    return false
  }
  return true
}
</file>

<file path="src/utils/ccip.ts">
import type { Abi, Address } from 'abitype'

import { type CallParameters, call } from '../actions/public/call.js'
import type { Transport } from '../clients/transports/createTransport.js'
import type { BaseError } from '../errors/base.js'
import {
  OffchainLookupError,
  type OffchainLookupErrorType as OffchainLookupErrorType_,
  OffchainLookupResponseMalformedError,
  type OffchainLookupResponseMalformedErrorType,
  OffchainLookupSenderMismatchError,
} from '../errors/ccip.js'
import {
  HttpRequestError,
  type HttpRequestErrorType,
} from '../errors/request.js'
import type { Chain } from '../types/chain.js'
import type { Hex } from '../types/misc.js'

import type { Client } from '../clients/createClient.js'
import type { ErrorType } from '../errors/utils.js'
import { decodeErrorResult } from './abi/decodeErrorResult.js'
import { encodeAbiParameters } from './abi/encodeAbiParameters.js'
import { isAddressEqual } from './address/isAddressEqual.js'
import { concat } from './data/concat.js'
import { isHex } from './data/isHex.js'
import {
  localBatchGatewayRequest,
  localBatchGatewayUrl,
} from './ens/localBatchGatewayRequest.js'
import { stringify } from './stringify.js'

export const offchainLookupSignature = '0x556f1830'
export const offchainLookupAbiItem = {
  name: 'OffchainLookup',
  type: 'error',
  inputs: [
    {
      name: 'sender',
      type: 'address',
    },
    {
      name: 'urls',
      type: 'string[]',
    },
    {
      name: 'callData',
      type: 'bytes',
    },
    {
      name: 'callbackFunction',
      type: 'bytes4',
    },
    {
      name: 'extraData',
      type: 'bytes',
    },
  ],
} as const satisfies Abi[number]

export type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType

export async function offchainLookup<chain extends Chain | undefined>(
  client: Client<Transport, chain>,
  {
    blockNumber,
    blockTag,
    data,
    to,
  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {
    data: Hex
    to: Address
  },
): Promise<Hex> {
  const { args } = decodeErrorResult({
    data,
    abi: [offchainLookupAbiItem],
  })
  const [sender, urls, callData, callbackSelector, extraData] = args

  const { ccipRead } = client
  const ccipRequest_ =
    ccipRead && typeof ccipRead?.request === 'function'
      ? ccipRead.request
      : ccipRequest

  try {
    if (!isAddressEqual(to, sender))
      throw new OffchainLookupSenderMismatchError({ sender, to })

    const result = urls.includes(localBatchGatewayUrl)
      ? await localBatchGatewayRequest({
          data: callData,
          ccipRequest: ccipRequest_,
        })
      : await ccipRequest_({ data: callData, sender, urls })

    const { data: data_ } = await call(client, {
      blockNumber,
      blockTag,
      data: concat([
        callbackSelector,
        encodeAbiParameters(
          [{ type: 'bytes' }, { type: 'bytes' }],
          [result, extraData],
        ),
      ]),
      to,
    } as CallParameters)

    return data_!
  } catch (err) {
    throw new OffchainLookupError({
      callbackSelector,
      cause: err as BaseError,
      data,
      extraData,
      sender,
      urls,
    })
  }
}

export type CcipRequestParameters = {
  data: Hex
  sender: Address
  urls: readonly string[]
}

export type CcipRequestReturnType = Hex

export type CcipRequestErrorType =
  | HttpRequestErrorType
  | OffchainLookupResponseMalformedErrorType
  | ErrorType

export async function ccipRequest({
  data,
  sender,
  urls,
}: CcipRequestParameters): Promise<CcipRequestReturnType> {
  let error = new Error('An unknown error occurred.')

  for (let i = 0; i < urls.length; i++) {
    const url = urls[i]
    const method = url.includes('{data}') ? 'GET' : 'POST'
    const body = method === 'POST' ? { data, sender } : undefined
    const headers: HeadersInit =
      method === 'POST' ? { 'Content-Type': 'application/json' } : {}

    try {
      const response = await fetch(
        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),
        {
          body: JSON.stringify(body),
          headers,
          method,
        },
      )

      let result: any
      if (
        response.headers.get('Content-Type')?.startsWith('application/json')
      ) {
        result = (await response.json()).data
      } else {
        result = (await response.text()) as any
      }

      if (!response.ok) {
        error = new HttpRequestError({
          body,
          details: result?.error
            ? stringify(result.error)
            : response.statusText,
          headers: response.headers,
          status: response.status,
          url,
        })
        continue
      }

      if (!isHex(result)) {
        error = new OffchainLookupResponseMalformedError({
          result,
          url,
        })
        continue
      }

      return result
    } catch (err) {
      error = new HttpRequestError({
        body,
        details: (err as Error).message,
        url,
      })
    }
  }

  throw error
}
</file>

<file path="src/utils/cursor.ts">
import {
  NegativeOffsetError,
  type NegativeOffsetErrorType,
  PositionOutOfBoundsError,
  type PositionOutOfBoundsErrorType,
  RecursiveReadLimitExceededError,
  type RecursiveReadLimitExceededErrorType,
} from '../errors/cursor.js'
import type { ErrorType } from '../errors/utils.js'
import type { ByteArray } from '../types/misc.js'

export type Cursor = {
  bytes: ByteArray
  dataView: DataView
  position: number
  positionReadCount: Map<number, number>
  recursiveReadCount: number
  recursiveReadLimit: number
  remaining: number
  assertReadLimit(position?: number): void
  assertPosition(position: number): void
  decrementPosition(offset: number): void
  getReadCount(position?: number): number
  incrementPosition(offset: number): void
  inspectByte(position?: number): ByteArray[number]
  inspectBytes(length: number, position?: number): ByteArray
  inspectUint8(position?: number): number
  inspectUint16(position?: number): number
  inspectUint24(position?: number): number
  inspectUint32(position?: number): number
  pushByte(byte: ByteArray[number]): void
  pushBytes(bytes: ByteArray): void
  pushUint8(value: number): void
  pushUint16(value: number): void
  pushUint24(value: number): void
  pushUint32(value: number): void
  readByte(): ByteArray[number]
  readBytes(length: number, size?: number): ByteArray
  readUint8(): number
  readUint16(): number
  readUint24(): number
  readUint32(): number
  setPosition(position: number): () => void
  _touch(): void
}

type CursorErrorType =
  | CursorAssertPositionErrorType
  | CursorDecrementPositionErrorType
  | CursorIncrementPositionErrorType
  | ErrorType

type CursorAssertPositionErrorType = PositionOutOfBoundsErrorType | ErrorType

type CursorDecrementPositionErrorType = NegativeOffsetErrorType | ErrorType

type CursorIncrementPositionErrorType = NegativeOffsetErrorType | ErrorType

type StaticCursorErrorType =
  | NegativeOffsetErrorType
  | RecursiveReadLimitExceededErrorType

const staticCursor: Cursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit,
      })
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position,
      })
  },
  decrementPosition(offset) {
    if (offset < 0) throw new NegativeOffsetError({ offset })
    const position = this.position - offset
    this.assertPosition(position)
    this.position = position
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0
  },
  incrementPosition(offset) {
    if (offset < 0) throw new NegativeOffsetError({ offset })
    const position = this.position + offset
    this.assertPosition(position)
    this.position = position
  },
  inspectByte(position_) {
    const position = position_ ?? this.position
    this.assertPosition(position)
    return this.bytes[position]
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position
    this.assertPosition(position + length - 1)
    return this.bytes.subarray(position, position + length)
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position
    this.assertPosition(position)
    return this.bytes[position]
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position
    this.assertPosition(position + 1)
    return this.dataView.getUint16(position)
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position
    this.assertPosition(position + 2)
    return (
      (this.dataView.getUint16(position) << 8) +
      this.dataView.getUint8(position + 2)
    )
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position
    this.assertPosition(position + 3)
    return this.dataView.getUint32(position)
  },
  pushByte(byte: ByteArray[number]) {
    this.assertPosition(this.position)
    this.bytes[this.position] = byte
    this.position++
  },
  pushBytes(bytes: ByteArray) {
    this.assertPosition(this.position + bytes.length - 1)
    this.bytes.set(bytes, this.position)
    this.position += bytes.length
  },
  pushUint8(value: number) {
    this.assertPosition(this.position)
    this.bytes[this.position] = value
    this.position++
  },
  pushUint16(value: number) {
    this.assertPosition(this.position + 1)
    this.dataView.setUint16(this.position, value)
    this.position += 2
  },
  pushUint24(value: number) {
    this.assertPosition(this.position + 2)
    this.dataView.setUint16(this.position, value >> 8)
    this.dataView.setUint8(this.position + 2, value & ~4294967040)
    this.position += 3
  },
  pushUint32(value: number) {
    this.assertPosition(this.position + 3)
    this.dataView.setUint32(this.position, value)
    this.position += 4
  },
  readByte() {
    this.assertReadLimit()
    this._touch()
    const value = this.inspectByte()
    this.position++
    return value
  },
  readBytes(length, size) {
    this.assertReadLimit()
    this._touch()
    const value = this.inspectBytes(length)
    this.position += size ?? length
    return value
  },
  readUint8() {
    this.assertReadLimit()
    this._touch()
    const value = this.inspectUint8()
    this.position += 1
    return value
  },
  readUint16() {
    this.assertReadLimit()
    this._touch()
    const value = this.inspectUint16()
    this.position += 2
    return value
  },
  readUint24() {
    this.assertReadLimit()
    this._touch()
    const value = this.inspectUint24()
    this.position += 3
    return value
  },
  readUint32() {
    this.assertReadLimit()
    this._touch()
    const value = this.inspectUint32()
    this.position += 4
    return value
  },
  get remaining() {
    return this.bytes.length - this.position
  },
  setPosition(position) {
    const oldPosition = this.position
    this.assertPosition(position)
    this.position = position
    return () => (this.position = oldPosition)
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return
    const count = this.getReadCount()
    this.positionReadCount.set(this.position, count + 1)
    if (count > 0) this.recursiveReadCount++
  },
}

type CursorConfig = { recursiveReadLimit?: number | undefined }

export type CreateCursorErrorType =
  | CursorErrorType
  | StaticCursorErrorType
  | ErrorType

export function createCursor(
  bytes: ByteArray,
  { recursiveReadLimit = 8_192 }: CursorConfig = {},
): Cursor {
  const cursor: Cursor = Object.create(staticCursor)
  cursor.bytes = bytes
  cursor.dataView = new DataView(
    bytes.buffer,
    bytes.byteOffset,
    bytes.byteLength,
  )
  cursor.positionReadCount = new Map()
  cursor.recursiveReadLimit = recursiveReadLimit
  return cursor
}
</file>

<file path="src/utils/getAction.ts">
import type { Client } from '../clients/createClient.js'
import type { PublicActions } from '../clients/decorators/public.js'
import type { WalletActions } from '../clients/decorators/wallet.js'
import type { Transport } from '../clients/transports/createTransport.js'
import type { Account } from '../types/account.js'
import type { Chain } from '../types/chain.js'
import type { RpcSchema } from '../types/eip1193.js'

/**
 * Retrieves and returns an action from the client (if exists), and falls
 * back to the tree-shakable action.
 *
 * Useful for extracting overridden actions from a client (ie. if a consumer
 * wants to override the `sendTransaction` implementation).
 */
export function getAction<
  transport extends Transport,
  chain extends Chain | undefined,
  account extends Account | undefined,
  rpcSchema extends RpcSchema | undefined,
  extended extends { [key: string]: unknown },
  client extends Client<transport, chain, account, rpcSchema, extended>,
  parameters,
  returnType,
>(
  client: client,
  actionFn: (_: any, parameters: parameters) => returnType,
  // Some minifiers drop `Function.prototype.name`, or replace it with short letters,
  // meaning that `actionFn.name` will not always work. For that case, the consumer
  // needs to pass the name explicitly.
  name: keyof PublicActions | keyof WalletActions | (string & {}),
): (parameters: parameters) => returnType {
  const action_implicit = client[actionFn.name]
  if (typeof action_implicit === 'function')
    return action_implicit as (params: parameters) => returnType

  const action_explicit = client[name]
  if (typeof action_explicit === 'function')
    return action_explicit as (params: parameters) => returnType

  return (params) => actionFn(client, params)
}
</file>

<file path="src/utils/index.ts">
// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type RequestErrorType,
  buildRequest,
} from './buildRequest.js'

export {
  type OffchainLookupErrorType,
  ccipRequest,
  /** @deprecated Use `ccipRequest`. */
  ccipRequest as ccipFetch,
  offchainLookup,
  offchainLookupAbiItem,
  offchainLookupSignature,
} from './ccip.js'

export {
  type AssertCurrentChainErrorType,
  type AssertCurrentChainParameters,
  assertCurrentChain,
} from './chain/assertCurrentChain.js'
export { defineChain } from './chain/defineChain.js'
export {
  type ExtractChainErrorType,
  type ExtractChainParameters,
  type ExtractChainReturnType,
  extractChain,
} from './chain/extractChain.js'
export {
  type GetChainContractAddressErrorType,
  getChainContractAddress,
} from './chain/getChainContractAddress.js'

export { arrayRegex, bytesRegex, integerRegex } from './regex.js'

export {
  type WebSocketAsyncErrorType,
  type WebSocketAsyncOptions,
  type WebSocketAsyncReturnType,
  type WebSocketErrorType,
  type WebSocketOptions,
  type WebSocketReturnType,
  getSocket,
  rpc,
} from './rpc/compat.js'
export {
  type HttpRpcClient,
  type HttpRpcClientOptions,
  type HttpRequestErrorType,
  type HttpRequestParameters,
  type HttpRequestReturnType,
  getHttpRpcClient,
} from './rpc/http.js'
export {
  type GetSocketRpcClientErrorType,
  type GetSocketRpcClientParameters,
  type GetSocketParameters,
  type Socket,
  type SocketRpcClient,
  getSocketRpcClient,
  socketClientCache,
} from './rpc/socket.js'
export { getWebSocketRpcClient } from './rpc/webSocket.js'
export { type StringifyErrorType, stringify } from './stringify.js'
export {
  type DomainSeparatorErrorType,
  type SerializeTypedDataErrorType,
  type ValidateTypedDataErrorType,
  serializeTypedData,
  validateTypedData,
} from './typedData.js'
export {
  type DecodeAbiParametersErrorType,
  type DecodeAbiParametersReturnType,
  decodeAbiParameters,
} from './abi/decodeAbiParameters.js'
export {
  type DecodeErrorResultErrorType,
  type DecodeErrorResultParameters,
  type DecodeErrorResultReturnType,
  decodeErrorResult,
} from './abi/decodeErrorResult.js'
export {
  type DecodeEventLogErrorType,
  type DecodeEventLogParameters,
  type DecodeEventLogReturnType,
  decodeEventLog,
} from './abi/decodeEventLog.js'
export {
  type DecodeFunctionDataErrorType,
  type DecodeFunctionDataParameters,
  type DecodeFunctionDataReturnType,
  decodeFunctionData,
} from './abi/decodeFunctionData.js'
export {
  type DecodeFunctionResultErrorType,
  type DecodeFunctionResultParameters,
  type DecodeFunctionResultReturnType,
  decodeFunctionResult,
} from './abi/decodeFunctionResult.js'
export {
  type EncodeAbiParametersErrorType,
  type EncodeAbiParametersReturnType,
  encodeAbiParameters,
} from './abi/encodeAbiParameters.js'
export {
  type EncodeDeployDataErrorType,
  type EncodeDeployDataParameters,
  encodeDeployData,
} from './abi/encodeDeployData.js'
export {
  type EncodeErrorResultErrorType,
  type EncodeErrorResultParameters,
  encodeErrorResult,
} from './abi/encodeErrorResult.js'
export {
  type EncodeArgErrorType,
  type EncodeEventTopicsParameters,
  type EncodeEventTopicsReturnType,
  encodeEventTopics,
} from './abi/encodeEventTopics.js'
export {
  type EncodeFunctionDataErrorType,
  type EncodeFunctionDataParameters,
  encodeFunctionData,
} from './abi/encodeFunctionData.js'
export {
  type EncodeFunctionResultErrorType,
  type EncodeFunctionResultParameters,
  encodeFunctionResult,
} from './abi/encodeFunctionResult.js'
export {
  type ParseEventLogsErrorType,
  type ParseEventLogsParameters,
  type ParseEventLogsReturnType,
  parseEventLogs,
} from './abi/parseEventLogs.js'
export {
  type GetAbiItemErrorType,
  type GetAbiItemParameters,
  getAbiItem,
} from './abi/getAbiItem.js'
export {
  type ParseAbi,
  type ParseAbiItem,
  type ParseAbiParameter,
  type ParseAbiParameters,
  parseAbi,
  parseAbiItem,
  parseAbiParameter,
  parseAbiParameters,
} from 'abitype'
export { type EncodePackedErrorType, encodePacked } from './abi/encodePacked.js'
export {
  type FormatAbiItemWithArgsErrorType,
  formatAbiItemWithArgs,
} from './abi/formatAbiItemWithArgs.js'
export {
  type FormatAbiItemErrorType,
  type FormatAbiParamErrorType,
  type FormatAbiParamsErrorType,
  formatAbiItem,
  formatAbiParams,
} from './abi/formatAbiItem.js'
export {
  type HashAuthorizationErrorType,
  type HashAuthorizationParameters,
  type HashAuthorizationReturnType,
  hashAuthorization,
} from './authorization/hashAuthorization.js'
export {
  type RecoverAuthorizationAddressErrorType,
  type RecoverAuthorizationAddressParameters,
  type RecoverAuthorizationAddressReturnType,
  recoverAuthorizationAddress,
} from './authorization/recoverAuthorizationAddress.js'
export {
  type SerializeAuthorizationListErrorType,
  type SerializeAuthorizationListReturnType,
  serializeAuthorizationList,
} from './authorization/serializeAuthorizationList.js'
export {
  type VerifyAuthorizationErrorType,
  type VerifyAuthorizationParameters,
  type VerifyAuthorizationReturnType,
  verifyAuthorization,
} from './authorization/verifyAuthorization.js'
export {
  type ParseAccountErrorType,
  parseAccount,
} from '../accounts/utils/parseAccount.js'
export {
  type PublicKeyToAddressErrorType,
  publicKeyToAddress,
} from '../accounts/utils/publicKeyToAddress.js'
export {
  type GetContractAddressOptions,
  type GetCreate2AddressErrorType,
  type GetCreate2AddressOptions,
  type GetCreateAddressErrorType,
  type GetCreateAddressOptions,
  getContractAddress,
  getCreateAddress,
  getCreate2Address,
} from './address/getContractAddress.js'
export {
  type ChecksumAddressErrorType,
  getAddress,
} from './address/getAddress.js'
export { type IsAddressErrorType, isAddress } from './address/isAddress.js'
export {
  type IsAddressEqualErrorType,
  isAddressEqual,
} from './address/isAddressEqual.js'
export {
  type ConcatBytesErrorType,
  type ConcatErrorType,
  type ConcatHexErrorType,
  concat,
  concatBytes,
  concatHex,
} from './data/concat.js'
export { type IsBytesErrorType, isBytes } from './data/isBytes.js'
export { type IsHexErrorType, isHex } from './data/isHex.js'
export {
  type PadBytesErrorType,
  type PadErrorType,
  type PadHexErrorType,
  pad,
  padBytes,
  padHex,
} from './data/pad.js'
export { type SizeErrorType, size } from './data/size.js'
export {
  type AssertEndOffsetErrorType,
  type AssertStartOffsetErrorType,
  type SliceBytesErrorType,
  type SliceErrorType,
  type SliceHexErrorType,
  type SliceReturnType,
  slice,
  sliceBytes,
  sliceHex,
} from './data/slice.js'
export { type TrimErrorType, type TrimReturnType, trim } from './data/trim.js'
export {
  type DefineBlockErrorType,
  type FormattedBlock,
  type FormatBlockErrorType,
  defineBlock,
  formatBlock,
} from './formatters/block.js'
export {
  type DefineTransactionErrorType,
  type FormattedTransaction,
  type FormatTransactionErrorType,
  defineTransaction,
  formatTransaction,
  transactionType,
} from './formatters/transaction.js'
export { type FormatLogErrorType, formatLog } from './formatters/log.js'
export {
  type DefineTransactionReceiptErrorType,
  type FormatTransactionReceiptErrorType,
  type FormattedTransactionReceipt,
  defineTransactionReceipt,
} from './formatters/transactionReceipt.js'
export {
  type DefineTransactionRequestErrorType,
  type FormatTransactionRequestErrorType,
  type FormattedTransactionRequest,
  defineTransactionRequest,
  formatTransactionRequest,
} from './formatters/transactionRequest.js'
export { type ExtractErrorType, extract } from './formatters/extract.js'
export {
  type BytesToRlpErrorType,
  type HexToRlpErrorType,
  type ToRlpErrorType,
  type ToRlpReturnType,
  toRlp,
} from './encoding/toRlp.js'
export {
  type BoolToBytesErrorType,
  type BoolToBytesOpts,
  type HexToBytesErrorType,
  type HexToBytesOpts,
  type NumberToBytesErrorType,
  type StringToBytesErrorType,
  type StringToBytesOpts,
  type ToBytesErrorType,
  type ToBytesParameters,
  boolToBytes,
  toBytes,
  hexToBytes,
  numberToBytes,
  stringToBytes,
} from './encoding/toBytes.js'
export {
  type BoolToHexErrorType,
  type BoolToHexOpts,
  type BytesToHexErrorType,
  type BytesToHexOpts,
  type NumberToHexErrorType,
  type NumberToHexOpts,
  type StringToHexErrorType,
  type StringToHexOpts,
  type ToHexErrorType,
  type ToHexParameters,
  boolToHex,
  bytesToHex,
  toHex,
  numberToHex,
  stringToHex,
} from './encoding/toHex.js'
export {
  type BytesToBigIntErrorType,
  type BytesToBigIntOpts,
  type BytesToBoolErrorType,
  type BytesToBoolOpts,
  type BytesToNumberErrorType,
  type BytesToNumberOpts,
  type BytesToStringErrorType,
  type BytesToStringOpts,
  type FromBytesErrorType,
  type FromBytesParameters,
  type FromBytesReturnType,
  bytesToBigInt,
  bytesToBigInt as bytesToBigint,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  fromBytes,
} from './encoding/fromBytes.js'
export {
  type AssertSizeErrorType,
  type FromHexErrorType,
  type FromHexParameters,
  type FromHexReturnType,
  type HexToBigIntErrorType,
  type HexToBigIntOpts,
  type HexToBoolErrorType,
  type HexToBoolOpts,
  type HexToNumberErrorType,
  type HexToNumberOpts,
  type HexToStringErrorType,
  type HexToStringOpts,
  fromHex,
  hexToBool,
  hexToBigInt,
  hexToNumber,
  hexToString,
} from './encoding/fromHex.js'
export {
  type FromRlpErrorType,
  fromRlp,
} from './encoding/fromRlp.js'
export {
  type GetNodeErrorParameters,
  type GetNodeErrorReturnType,
  containsNodeError,
  getNodeError,
} from './errors/getNodeError.js'
export {
  type GetCallErrorReturnType,
  getCallError,
} from './errors/getCallError.js'
export {
  type GetContractErrorReturnType,
  getContractError,
} from './errors/getContractError.js'
export {
  type GetEstimateGasErrorReturnType,
  getEstimateGasError,
} from './errors/getEstimateGasError.js'
export {
  type GetTransactionErrorParameters,
  type GetTransactionErrorReturnType,
  getTransactionError,
} from './errors/getTransactionError.js'
export { getAction } from './getAction.js'
export {
  type DefineFormatterErrorType,
  defineFormatter,
} from './formatters/formatter.js'
export {
  type ToEventSelectorErrorType,
  toEventSelector,
  /** @deprecated use `ToEventSelectorErrorType`. */
  type ToEventSelectorErrorType as GetEventSelectorErrorType,
  /** @deprecated use `toEventSelector`. */
  toEventSelector as getEventSelector,
} from './hash/toEventSelector.js'
export {
  type ToFunctionSelectorErrorType,
  toFunctionSelector,
  /** @deprecated use `ToFunctionSelectorErrorType`. */
  type ToFunctionSelectorErrorType as GetFunctionSelectorErrorType,
  /** @deprecated use `toFunctionSelector`. */
  toFunctionSelector as getFunctionSelector,
} from './hash/toFunctionSelector.js'
export {
  type ToEventSignatureErrorType,
  toEventSignature,
  /** @deprecated use `ToEventSignatureErrorType`. */
  type ToEventSignatureErrorType as GetEventSignatureErrorType,
  /** @deprecated use `toEventSignature`. */
  toEventSignature as getEventSignature,
} from './hash/toEventSignature.js'
export {
  type ToFunctionSignatureErrorType,
  toFunctionSignature,
  /** @deprecated use `ToFunctionSignatureErrorType`. */
  type ToFunctionSignatureErrorType as GetFunctionSignatureErrorType,
  /** @deprecated use `toFunctionSignature`. */
  toFunctionSignature as getFunctionSignature,
} from './hash/toFunctionSignature.js'
export {
  type ToEventHashErrorType,
  toEventHash,
} from './hash/toEventHash.js'
export {
  type ToFunctionHashErrorType,
  toFunctionHash,
} from './hash/toFunctionHash.js'
export { type IsHashErrorType, isHash } from './hash/isHash.js'
export { type Keccak256ErrorType, keccak256 } from './hash/keccak256.js'
export { type Sha256ErrorType, sha256 } from './hash/sha256.js'
export { type Ripemd160ErrorType, ripemd160 } from './hash/ripemd160.js'
export {
  type HashDomainErrorType,
  type HashStructErrorType,
  type HashTypedDataParameters,
  type HashTypedDataReturnType,
  hashStruct,
  hashTypedData,
} from './signature/hashTypedData.js'
export {
  type RecoverAddressErrorType,
  type RecoverAddressParameters,
  type RecoverAddressReturnType,
  recoverAddress,
} from './signature/recoverAddress.js'
export {
  type RecoverMessageAddressErrorType,
  type RecoverMessageAddressParameters,
  type RecoverMessageAddressReturnType,
  recoverMessageAddress,
} from './signature/recoverMessageAddress.js'
export {
  type RecoverPublicKeyErrorType,
  type RecoverPublicKeyParameters,
  type RecoverPublicKeyReturnType,
  recoverPublicKey,
} from './signature/recoverPublicKey.js'
export {
  type RecoverTypedDataAddressErrorType,
  type RecoverTypedDataAddressParameters,
  type RecoverTypedDataAddressReturnType,
  recoverTypedDataAddress,
} from './signature/recoverTypedDataAddress.js'
export {
  type VerifyHashErrorType,
  type VerifyHashParameters,
  type VerifyHashReturnType,
  verifyHash,
} from './signature/verifyHash.js'
export {
  type VerifyMessageErrorType,
  type VerifyMessageParameters,
  type VerifyMessageReturnType,
  verifyMessage,
} from './signature/verifyMessage.js'
export {
  type VerifyTypedDataErrorType,
  type VerifyTypedDataParameters,
  type VerifyTypedDataReturnType,
  verifyTypedData,
} from './signature/verifyTypedData.js'
export {
  type HashMessageReturnType,
  type HashMessageErrorType,
  hashMessage,
} from './signature/hashMessage.js'
export {
  type ParseErc6492SignatureErrorType,
  type ParseErc6492SignatureParameters,
  type ParseErc6492SignatureReturnType,
  parseErc6492Signature,
} from './signature/parseErc6492Signature.js'
export {
  type IsErc6492SignatureErrorType,
  type IsErc6492SignatureParameters,
  type IsErc6492SignatureReturnType,
  isErc6492Signature,
} from './signature/isErc6492Signature.js'
export {
  type SerializeErc6492SignatureErrorType,
  type SerializeErc6492SignatureParameters,
  type SerializeErc6492SignatureReturnType,
  serializeErc6492Signature,
} from './signature/serializeErc6492Signature.js'
export {
  type GetSerializedTransactionTypeErrorType,
  type GetSerializedTransactionType,
  getSerializedTransactionType,
} from './transaction/getSerializedTransactionType.js'
export {
  type GetTransactionTypeErrorType,
  type GetTransactionType,
  getTransactionType,
} from './transaction/getTransactionType.js'
export {
  type AssertRequestErrorType,
  assertRequest,
} from './transaction/assertRequest.js'
export {
  type AssertTransactionEIP1559ErrorType,
  type AssertTransactionEIP2930ErrorType,
  type AssertTransactionLegacyErrorType,
  assertTransactionEIP1559,
  assertTransactionEIP2930,
  assertTransactionLegacy,
} from './transaction/assertTransaction.js'
export {
  type ParseTransactionErrorType,
  parseTransaction,
} from './transaction/parseTransaction.js'
export {
  serializeTransaction,
  type SerializeTransactionErrorType,
  type SerializeTransactionFn,
} from './transaction/serializeTransaction.js'
export {
  type SerializeAccessListErrorType,
  serializeAccessList,
} from './transaction/serializeAccessList.js'
export { type FormatEtherErrorType, formatEther } from './unit/formatEther.js'
export { type FormatGweiErrorType, formatGwei } from './unit/formatGwei.js'
export { type FormatUnitsErrorType, formatUnits } from './unit/formatUnits.js'
export { type ParseUnitsErrorType, parseUnits } from './unit/parseUnits.js'
export { type ParseEtherErrorType, parseEther } from './unit/parseEther.js'
export { type ParseGweiErrorType, parseGwei } from './unit/parseGwei.js'
export {
  type CreateNonceManagerParameters,
  type NonceManager,
  type NonceManagerSource,
  createNonceManager,
  nonceManager,
} from './nonceManager.js'
</file>

<file path="src/utils/nonceManager.ts">
import type { Address } from 'abitype'

import { getTransactionCount } from '../actions/public/getTransactionCount.js'
import type { Client } from '../clients/createClient.js'
import type { MaybePromise } from '../types/utils.js'
import { LruMap } from './lru.js'

export type CreateNonceManagerParameters = {
  source: NonceManagerSource
}

type FunctionParameters = {
  address: Address
  chainId: number
}

export type NonceManager = {
  /** Get and increment a nonce. */
  consume: (
    parameters: FunctionParameters & { client: Client },
  ) => Promise<number>
  /** Increment a nonce. */
  increment: (chainId: FunctionParameters) => void
  /** Get a nonce. */
  get: (chainId: FunctionParameters & { client: Client }) => Promise<number>
  /** Reset a nonce. */
  reset: (chainId: FunctionParameters) => void
}

/**
 * Creates a nonce manager for auto-incrementing transaction nonces.
 *
 * - Docs: https://viem.sh/docs/accounts/createNonceManager
 *
 * @example
 * ```ts
 * const nonceManager = createNonceManager({
 *   source: jsonRpc(),
 * })
 * ```
 */
export function createNonceManager(
  parameters: CreateNonceManagerParameters,
): NonceManager {
  const { source } = parameters

  const deltaMap = new Map()
  const nonceMap = new LruMap<number>(8192)
  const promiseMap = new Map<string, Promise<number>>()

  const getKey = ({ address, chainId }: FunctionParameters) =>
    `${address}.${chainId}`

  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId })
      const promise = this.get({ address, chainId, client })

      this.increment({ address, chainId })
      const nonce = await promise

      await source.set({ address, chainId }, nonce)
      nonceMap.set(key, nonce)

      return nonce
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId })
      const delta = deltaMap.get(key) ?? 0
      deltaMap.set(key, delta + 1)
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId })

      let promise = promiseMap.get(key)
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client })
            const previousNonce = nonceMap.get(key) ?? 0
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1
            nonceMap.delete(key)
            return nonce
          } finally {
            this.reset({ address, chainId })
          }
        })()
        promiseMap.set(key, promise)
      }

      const delta = deltaMap.get(key) ?? 0
      return delta + (await promise)
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId })
      deltaMap.delete(key)
      promiseMap.delete(key)
    },
  }
}

////////////////////////////////////////////////////////////////////////////////////////////
// Sources

export type NonceManagerSource = {
  /** Get a nonce. */
  get(parameters: FunctionParameters & { client: Client }): MaybePromise<number>
  /** Set a nonce. */
  set(parameters: FunctionParameters, nonce: number): MaybePromise<void>
}

/** JSON-RPC source for a nonce manager. */
export function jsonRpc(): NonceManagerSource {
  return {
    async get(parameters) {
      const { address, client } = parameters
      return getTransactionCount(client, {
        address,
        blockTag: 'pending',
      })
    },
    set() {},
  }
}

////////////////////////////////////////////////////////////////////////////////////////////
// Default

/** Default Nonce Manager with a JSON-RPC source. */
export const nonceManager = /*#__PURE__*/ createNonceManager({
  source: jsonRpc(),
})
</file>

<file path="src/utils/observe.ts">
import type { ErrorType } from '../errors/utils.js'
import type { MaybePromise } from '../types/utils.js'

type Callback = ((...args: any[]) => any) | undefined
type Callbacks = Record<string, Callback>

export type ObserveErrorType = ErrorType

/** @internal */
export const listenersCache = /*#__PURE__*/ new Map<
  string,
  { id: number; fns: Callbacks }[]
>()
/** @internal */
export const cleanupCache = /*#__PURE__*/ new Map<string, () => void>()

type EmitFunction<callbacks extends Callbacks> = (
  emit: callbacks,
) => MaybePromise<void | (() => void)>

let callbackCount = 0

/**
 * @description Sets up an observer for a given function. If another function
 * is set up under the same observer id, the function will only be called once
 * for both instances of the observer.
 */
export function observe<callbacks extends Callbacks>(
  observerId: string,
  callbacks: callbacks,
  fn: EmitFunction<callbacks>,
) {
  const callbackId = ++callbackCount

  const getListeners = () => listenersCache.get(observerId) || []

  const unsubscribe = () => {
    const listeners = getListeners()
    listenersCache.set(
      observerId,
      listeners.filter((cb: any) => cb.id !== callbackId),
    )
  }

  const unwatch = () => {
    const listeners = getListeners()
    if (!listeners.some((cb: any) => cb.id === callbackId)) return
    const cleanup = cleanupCache.get(observerId)
    if (listeners.length === 1 && cleanup) cleanup()
    unsubscribe()
  }

  const listeners = getListeners()
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks },
  ])

  if (listeners && listeners.length > 0) return unwatch

  const emit: callbacks = {} as callbacks
  for (const key in callbacks) {
    emit[key] = ((
      ...args: Parameters<NonNullable<callbacks[keyof callbacks]>>
    ) => {
      const listeners = getListeners()
      if (listeners.length === 0) return
      for (const listener of listeners) listener.fns[key]?.(...args)
    }) as callbacks[Extract<keyof callbacks, string>]
  }

  const cleanup = fn(emit)
  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup)

  return unwatch
}
</file>

<file path="src/utils/poll.ts">
import type { ErrorType } from '../errors/utils.js'
import { wait } from './wait.js'

type PollOptions<data> = {
  // Whether or not to emit when the polling starts.
  emitOnBegin?: boolean | undefined
  // The initial wait time (in ms) before polling.
  initialWaitTime?: ((data: data | void) => Promise<number>) | undefined
  // The interval (in ms).
  interval: number
}

export type PollErrorType = ErrorType

/**
 * @description Polls a function at a specified interval.
 */
export function poll<data>(
  fn: ({ unpoll }: { unpoll: () => void }) => Promise<data | void>,
  { emitOnBegin, initialWaitTime, interval }: PollOptions<data>,
) {
  let active = true

  const unwatch = () => (active = false)

  const watch = async () => {
    let data: data | void = undefined
    if (emitOnBegin) data = await fn({ unpoll: unwatch })

    const initialWait = (await initialWaitTime?.(data)) ?? interval
    await wait(initialWait)

    const poll = async () => {
      if (!active) return
      await fn({ unpoll: unwatch })
      await wait(interval)
      poll()
    }

    poll()
  }
  watch()

  return unwatch
}
</file>

<file path="src/utils/stringify.ts">
import type { ErrorType } from '../errors/utils.js'

export type StringifyErrorType = ErrorType

export const stringify: typeof JSON.stringify = (value, replacer, space) =>
  JSON.stringify(
    value,
    (key, value_) => {
      const value = typeof value_ === 'bigint' ? value_.toString() : value_
      return typeof replacer === 'function' ? replacer(key, value) : value
    },
    space,
  )
</file>

<file path="src/utils/typedData.ts">
import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'

import { BytesSizeMismatchError } from '../errors/abi.js'
import { InvalidAddressError } from '../errors/address.js'
import {
  InvalidDomainError,
  InvalidPrimaryTypeError,
  InvalidStructTypeError,
} from '../errors/typedData.js'
import type { ErrorType } from '../errors/utils.js'
import type { Hex } from '../types/misc.js'
import type { TypedDataDefinition } from '../types/typedData.js'
import { type IsAddressErrorType, isAddress } from './address/isAddress.js'
import { type SizeErrorType, size } from './data/size.js'
import { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'
import { bytesRegex, integerRegex } from './regex.js'
import {
  type HashDomainErrorType,
  hashDomain,
} from './signature/hashTypedData.js'
import { stringify } from './stringify.js'

export type SerializeTypedDataErrorType =
  | HashDomainErrorType
  | IsAddressErrorType
  | NumberToHexErrorType
  | SizeErrorType
  | ErrorType

export function serializeTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(parameters: TypedDataDefinition<typedData, primaryType>) {
  const {
    domain: domain_,
    message: message_,
    primaryType,
    types,
  } = parameters as unknown as TypedDataDefinition

  const normalizeData = (
    struct: readonly TypedDataParameter[],
    data_: Record<string, unknown>,
  ) => {
    const data = { ...data_ }
    for (const param of struct) {
      const { name, type } = param
      if (type === 'address') data[name] = (data[name] as string).toLowerCase()
    }
    return data
  }

  const domain = (() => {
    if (!types.EIP712Domain) return {}
    if (!domain_) return {}
    return normalizeData(types.EIP712Domain, domain_)
  })()

  const message = (() => {
    if (primaryType === 'EIP712Domain') return undefined
    return normalizeData(types[primaryType], message_)
  })()

  return stringify({ domain, message, primaryType, types })
}

export type ValidateTypedDataErrorType =
  | HashDomainErrorType
  | IsAddressErrorType
  | NumberToHexErrorType
  | SizeErrorType
  | ErrorType

export function validateTypedData<
  const typedData extends TypedData | Record<string, unknown>,
  primaryType extends keyof typedData | 'EIP712Domain',
>(parameters: TypedDataDefinition<typedData, primaryType>) {
  const { domain, message, primaryType, types } =
    parameters as unknown as TypedDataDefinition

  const validateData = (
    struct: readonly TypedDataParameter[],
    data: Record<string, unknown>,
  ) => {
    for (const param of struct) {
      const { name, type } = param
      const value = data[name]

      const integerMatch = type.match(integerRegex)
      if (
        integerMatch &&
        (typeof value === 'number' || typeof value === 'bigint')
      ) {
        const [_type, base, size_] = integerMatch
        // If number cannot be cast to a sized hex value, it is out of range
        // and will throw.
        numberToHex(value, {
          signed: base === 'int',
          size: Number.parseInt(size_) / 8,
        })
      }

      if (type === 'address' && typeof value === 'string' && !isAddress(value))
        throw new InvalidAddressError({ address: value })

      const bytesMatch = type.match(bytesRegex)
      if (bytesMatch) {
        const [_type, size_] = bytesMatch
        if (size_ && size(value as Hex) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size(value as Hex),
          })
      }

      const struct = types[type]
      if (struct) {
        validateReference(type)
        validateData(struct, value as Record<string, unknown>)
      }
    }
  }

  // Validate domain types.
  if (types.EIP712Domain && domain) {
    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })
    validateData(types.EIP712Domain, domain)
  }

  // Validate message types.
  if (primaryType !== 'EIP712Domain') {
    if (types[primaryType]) validateData(types[primaryType], message)
    else throw new InvalidPrimaryTypeError({ primaryType, types })
  }
}

export type GetTypesForEIP712DomainErrorType = ErrorType

export function getTypesForEIP712Domain({
  domain,
}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {
  return [
    typeof domain?.name === 'string' && { name: 'name', type: 'string' },
    domain?.version && { name: 'version', type: 'string' },
    (typeof domain?.chainId === 'number' ||
      typeof domain?.chainId === 'bigint') && {
      name: 'chainId',
      type: 'uint256',
    },
    domain?.verifyingContract && {
      name: 'verifyingContract',
      type: 'address',
    },
    domain?.salt && { name: 'salt', type: 'bytes32' },
  ].filter(Boolean) as TypedDataParameter[]
}

export type DomainSeparatorErrorType =
  | GetTypesForEIP712DomainErrorType
  | HashDomainErrorType
  | ErrorType

export function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {
  return hashDomain({
    domain,
    types: {
      EIP712Domain: getTypesForEIP712Domain({ domain }),
    },
  })
}

/** @internal */
function validateReference(type: string) {
  // Struct type must not be a Solidity type.
  if (
    type === 'address' ||
    type === 'bool' ||
    type === 'string' ||
    type.startsWith('bytes') ||
    type.startsWith('uint') ||
    type.startsWith('int')
  )
    throw new InvalidStructTypeError({ type })
}
</file>

<file path="src/window/index.ts">
import '../types/window.js'
</file>

<file path="src/index.ts">
// biome-ignore lint/performance/noBarrelFile: entrypoint module
export {
  type Abi,
  type AbiFunction,
  type AbiParameter,
  type AbiEvent,
  type AbiStateMutability,
  type AbiParameterKind,
  type AbiParameterToPrimitiveType,
  type Address,
  type Narrow,
  type ParseAbi,
  type ParseAbiItem,
  type ParseAbiParameter,
  type ParseAbiParameters,
  type ResolvedRegister,
  type TypedData,
  type TypedDataDomain,
  type TypedDataParameter,
  CircularReferenceError,
  InvalidAbiParameterError,
  InvalidAbiParametersError,
  InvalidAbiItemError,
  InvalidAbiTypeParameterError,
  InvalidFunctionModifierError,
  InvalidModifierError,
  InvalidParameterError,
  InvalidParenthesisError,
  InvalidSignatureError,
  InvalidStructSignatureError,
  SolidityProtectedKeywordError,
  UnknownTypeError,
  UnknownSignatureError,
  parseAbi,
  parseAbiItem,
  parseAbiParameter,
  parseAbiParameters,
} from 'abitype'
export type {
  BlockOverrides,
  Rpc as RpcBlockOverrides,
} from 'ox/BlockOverrides'

export {
  getContract,
  type GetContractErrorType,
  type GetContractParameters,
  type GetContractReturnType,
} from './actions/getContract.js'
export type {
  GetContractEventsErrorType,
  GetContractEventsParameters,
  GetContractEventsReturnType,
} from './actions/public/getContractEvents.js'
export type {
  GetEip712DomainErrorType,
  GetEip712DomainParameters,
  GetEip712DomainReturnType,
} from './actions/public/getEip712Domain.js'
export type {
  AddChainErrorType,
  AddChainParameters,
} from './actions/wallet/addChain.js'
export type {
  CallErrorType,
  CallParameters,
  CallReturnType,
} from './actions/public/call.js'
export type {
  CreateAccessListParameters,
  CreateAccessListReturnType,
  CreateAccessListErrorType,
} from './actions/public/createAccessList.js'
export type {
  CreateBlockFilterErrorType,
  CreateBlockFilterReturnType,
} from './actions/public/createBlockFilter.js'
export type {
  CreateContractEventFilterErrorType,
  CreateContractEventFilterParameters,
  CreateContractEventFilterReturnType,
} from './actions/public/createContractEventFilter.js'
export type {
  CreateEventFilterErrorType,
  CreateEventFilterParameters,
  CreateEventFilterReturnType,
} from './actions/public/createEventFilter.js'
export type {
  CreatePendingTransactionFilterErrorType,
  CreatePendingTransactionFilterReturnType,
} from './actions/public/createPendingTransactionFilter.js'
export type {
  DeployContractErrorType,
  DeployContractParameters,
  DeployContractReturnType,
} from './actions/wallet/deployContract.js'
export type {
  DropTransactionErrorType,
  DropTransactionParameters,
} from './actions/test/dropTransaction.js'
export type {
  DumpStateErrorType,
  DumpStateReturnType,
} from './actions/test/dumpState.js'
export type {
  GetAutomineErrorType,
  GetAutomineReturnType,
} from './actions/test/getAutomine.js'
export type {
  EstimateContractGasErrorType,
  EstimateContractGasParameters,
  EstimateContractGasReturnType,
} from './actions/public/estimateContractGas.js'
export type {
  EstimateGasErrorType,
  EstimateGasParameters,
  EstimateGasReturnType,
} from './actions/public/estimateGas.js'
export type {
  EstimateFeesPerGasErrorType,
  EstimateFeesPerGasParameters,
  EstimateFeesPerGasReturnType,
} from './actions/public/estimateFeesPerGas.js'
export type {
  EstimateMaxPriorityFeePerGasErrorType,
  EstimateMaxPriorityFeePerGasParameters,
  EstimateMaxPriorityFeePerGasReturnType,
} from './actions/public/estimateMaxPriorityFeePerGas.js'
export type {
  GetAddressesErrorType,
  GetAddressesReturnType,
} from './actions/wallet/getAddresses.js'
export type {
  GetBalanceErrorType,
  GetBalanceParameters,
  GetBalanceReturnType,
} from './actions/public/getBalance.js'
export type {
  GetBlobBaseFeeErrorType,
  GetBlobBaseFeeReturnType,
} from './actions/public/getBlobBaseFee.js'
export type {
  GetBlockNumberErrorType,
  GetBlockNumberParameters,
  GetBlockNumberReturnType,
} from './actions/public/getBlockNumber.js'
export type {
  GetBlockErrorType,
  GetBlockParameters,
  GetBlockReturnType,
} from './actions/public/getBlock.js'
export type {
  GetBlockTransactionCountErrorType,
  GetBlockTransactionCountParameters,
  GetBlockTransactionCountReturnType,
} from './actions/public/getBlockTransactionCount.js'
export type {
  /** @deprecated Use `GetCodeErrorType` instead */
  GetCodeErrorType as GetBytecodeErrorType,
  /** @deprecated Use `GetCodeParameters` instead */
  GetCodeParameters as GetBytecodeParameters,
  /** @deprecated Use `GetCodeReturnType` instead  */
  GetCodeReturnType as GetBytecodeReturnType,
  GetCodeErrorType,
  GetCodeParameters,
  GetCodeReturnType,
} from './actions/public/getCode.js'
export type {
  GetChainIdErrorType,
  GetChainIdReturnType,
} from './actions/public/getChainId.js'
export type {
  GetEnsAddressErrorType,
  GetEnsAddressParameters,
  GetEnsAddressReturnType,
} from './actions/ens/getEnsAddress.js'
export type {
  GetEnsAvatarErrorType,
  GetEnsAvatarParameters,
  GetEnsAvatarReturnType,
} from './actions/ens/getEnsAvatar.js'
export type {
  GetEnsNameErrorType,
  GetEnsNameParameters,
  GetEnsNameReturnType,
} from './actions/ens/getEnsName.js'
export type {
  GetEnsResolverErrorType,
  GetEnsResolverParameters,
  GetEnsResolverReturnType,
} from './actions/ens/getEnsResolver.js'
export type {
  GetEnsTextErrorType,
  GetEnsTextParameters,
  GetEnsTextReturnType,
} from './actions/ens/getEnsText.js'
export type {
  GetFeeHistoryErrorType,
  GetFeeHistoryParameters,
  GetFeeHistoryReturnType,
} from './actions/public/getFeeHistory.js'
export type {
  GetFilterChangesErrorType,
  GetFilterChangesParameters,
  GetFilterChangesReturnType,
} from './actions/public/getFilterChanges.js'
export type {
  GetFilterLogsErrorType,
  GetFilterLogsParameters,
  GetFilterLogsReturnType,
} from './actions/public/getFilterLogs.js'
export type {
  GetGasPriceErrorType,
  GetGasPriceReturnType,
} from './actions/public/getGasPrice.js'
export type {
  GetLogsErrorType,
  GetLogsParameters,
  GetLogsReturnType,
} from './actions/public/getLogs.js'
export type {
  GetPermissionsErrorType,
  GetPermissionsReturnType,
} from './actions/wallet/getPermissions.js'
export type {
  GetProofErrorType,
  GetProofParameters,
  GetProofReturnType,
} from './actions/public/getProof.js'
export type {
  GetStorageAtErrorType,
  GetStorageAtParameters,
  GetStorageAtReturnType,
} from './actions/public/getStorageAt.js'
export type {
  GetTransactionConfirmationsErrorType,
  GetTransactionConfirmationsParameters,
  GetTransactionConfirmationsReturnType,
} from './actions/public/getTransactionConfirmations.js'
export type {
  GetTransactionCountErrorType,
  GetTransactionCountParameters,
  GetTransactionCountReturnType,
} from './actions/public/getTransactionCount.js'
export type {
  GetTransactionErrorType,
  GetTransactionParameters,
  GetTransactionReturnType,
} from './actions/public/getTransaction.js'
export type {
  GetTransactionReceiptErrorType,
  GetTransactionReceiptParameters,
  GetTransactionReceiptReturnType,
} from './actions/public/getTransactionReceipt.js'
export type {
  ImpersonateAccountErrorType,
  ImpersonateAccountParameters,
} from './actions/test/impersonateAccount.js'
export type {
  IncreaseTimeErrorType,
  IncreaseTimeParameters,
} from './actions/test/increaseTime.js'
export type {
  LoadStateErrorType,
  LoadStateParameters,
  LoadStateReturnType,
} from './actions/test/loadState.js'
export type { MineErrorType, MineParameters } from './actions/test/mine.js'
export type {
  MulticallErrorType,
  MulticallParameters,
  MulticallReturnType,
} from './actions/public/multicall.js'
export type { SnapshotErrorType } from './actions/test/snapshot.js'
export type {
  SimulateBlocksParameters,
  SimulateBlocksReturnType,
  SimulateBlocksErrorType,
} from './actions/public/simulateBlocks.js'
export type {
  SimulateCallsParameters,
  SimulateCallsReturnType,
  SimulateCallsErrorType,
} from './actions/public/simulateCalls.js'
export type {
  GetMutabilityAwareValue,
  SimulateContractParameters,
  SimulateContractReturnType,
  SimulateContractErrorType,
} from './actions/public/simulateContract.js'
export type {
  OnBlock,
  OnBlockParameter,
  WatchBlocksErrorType,
  WatchBlocksParameters,
  WatchBlocksReturnType,
} from './actions/public/watchBlocks.js'
export type {
  OnBlockNumberFn,
  OnBlockNumberParameter,
  WatchBlockNumberErrorType,
  WatchBlockNumberParameters,
  WatchBlockNumberReturnType,
} from './actions/public/watchBlockNumber.js'
export type {
  WatchEventOnLogsFn,
  WatchEventOnLogsParameter,
  WatchEventErrorType,
  WatchEventParameters,
  WatchEventReturnType,
} from './actions/public/watchEvent.js'
export type {
  OnTransactionsFn,
  OnTransactionsParameter,
  WatchPendingTransactionsErrorType,
  WatchPendingTransactionsParameters,
  WatchPendingTransactionsReturnType,
} from './actions/public/watchPendingTransactions.js'
export type {
  ReadContractErrorType,
  ReadContractParameters,
  ReadContractReturnType,
} from './actions/public/readContract.js'
export type {
  ReplacementReason,
  ReplacementReturnType,
  WaitForTransactionReceiptErrorType,
  WaitForTransactionReceiptParameters,
  WaitForTransactionReceiptReturnType,
} from './actions/public/waitForTransactionReceipt.js'
export type {
  RequestAddressesErrorType,
  RequestAddressesReturnType,
} from './actions/wallet/requestAddresses.js'
export type {
  RequestPermissionsErrorType,
  RequestPermissionsReturnType,
  RequestPermissionsParameters,
} from './actions/wallet/requestPermissions.js'
export type {
  GetTxpoolContentErrorType,
  GetTxpoolContentReturnType,
} from './actions/test/getTxpoolContent.js'
export type {
  GetTxpoolStatusErrorType,
  GetTxpoolStatusReturnType,
} from './actions/test/getTxpoolStatus.js'
export type {
  InspectTxpoolErrorType,
  InspectTxpoolReturnType,
} from './actions/test/inspectTxpool.js'
export type { RemoveBlockTimestampIntervalErrorType } from './actions/test/removeBlockTimestampInterval.js'
export type { ResetErrorType, ResetParameters } from './actions/test/reset.js'
export type {
  RevertErrorType,
  RevertParameters,
} from './actions/test/revert.js'
export type {
  SendRawTransactionErrorType,
  SendRawTransactionParameters,
  SendRawTransactionReturnType,
} from './actions/wallet/sendRawTransaction.js'
export type {
  SendTransactionErrorType,
  SendTransactionParameters,
  SendTransactionRequest,
  SendTransactionReturnType,
} from './actions/wallet/sendTransaction.js'
export type {
  SignTransactionErrorType,
  SignTransactionParameters,
  SignTransactionReturnType,
} from './actions/wallet/signTransaction.js'
export type {
  PrepareTransactionRequestErrorType,
  PrepareTransactionRequestParameters,
  PrepareTransactionRequestParameterType,
  PrepareTransactionRequestRequest,
  PrepareTransactionRequestReturnType,
} from './actions/wallet/prepareTransactionRequest.js'
export type {
  GetCapabilitiesParameters,
  GetCapabilitiesErrorType,
  GetCapabilitiesReturnType,
} from './actions/wallet/getCapabilities.js'
export type {
  SendCallsErrorType,
  SendCallsParameters,
  SendCallsReturnType,
} from './actions/wallet/sendCalls.js'
export type {
  GetCallsStatusErrorType,
  GetCallsStatusParameters,
  GetCallsStatusReturnType,
} from './actions/wallet/getCallsStatus.js'
export type {
  ShowCallsStatusErrorType,
  ShowCallsStatusParameters,
  ShowCallsStatusReturnType,
} from './actions/wallet/showCallsStatus.js'
export { WaitForCallsStatusTimeoutError } from './actions/wallet/waitForCallsStatus.js'
export type {
  WaitForCallsStatusErrorType,
  WaitForCallsStatusParameters,
  WaitForCallsStatusReturnType,
  WaitForCallsStatusTimeoutErrorType,
} from './actions/wallet/waitForCallsStatus.js'
export type {
  SendUnsignedTransactionErrorType,
  SendUnsignedTransactionParameters,
  SendUnsignedTransactionReturnType,
} from './actions/test/sendUnsignedTransaction.js'
export type { SetAutomineErrorType } from './actions/test/setAutomine.js'
export type {
  SetBalanceErrorType,
  SetBalanceParameters,
} from './actions/test/setBalance.js'
export type {
  SetBlockGasLimitErrorType,
  SetBlockGasLimitParameters,
} from './actions/test/setBlockGasLimit.js'
export type {
  SetBlockTimestampIntervalErrorType,
  SetBlockTimestampIntervalParameters,
} from './actions/test/setBlockTimestampInterval.js'
export type {
  SetCodeErrorType,
  SetCodeParameters,
} from './actions/test/setCode.js'
export type {
  SetCoinbaseErrorType,
  SetCoinbaseParameters,
} from './actions/test/setCoinbase.js'
export type {
  SetIntervalMiningErrorType,
  SetIntervalMiningParameters,
} from './actions/test/setIntervalMining.js'
export type { SetLoggingEnabledErrorType } from './actions/test/setLoggingEnabled.js'
export type {
  SetMinGasPriceErrorType,
  SetMinGasPriceParameters,
} from './actions/test/setMinGasPrice.js'
export type {
  SetNextBlockBaseFeePerGasErrorType,
  SetNextBlockBaseFeePerGasParameters,
} from './actions/test/setNextBlockBaseFeePerGas.js'
export type {
  SetNextBlockTimestampErrorType,
  SetNextBlockTimestampParameters,
} from './actions/test/setNextBlockTimestamp.js'
export type {
  SetNonceErrorType,
  SetNonceParameters,
} from './actions/test/setNonce.js'
export type { SetRpcUrlErrorType } from './actions/test/setRpcUrl.js'
export type {
  SetStorageAtErrorType,
  SetStorageAtParameters,
} from './actions/test/setStorageAt.js'
export type {
  SignMessageErrorType,
  SignMessageParameters,
  SignMessageReturnType,
} from './actions/wallet/signMessage.js'
export type {
  SignTypedDataErrorType,
  SignTypedDataParameters,
  SignTypedDataReturnType,
} from './actions/wallet/signTypedData.js'
export type {
  StopImpersonatingAccountErrorType,
  StopImpersonatingAccountParameters,
} from './actions/test/stopImpersonatingAccount.js'
export type {
  SwitchChainErrorType,
  SwitchChainParameters,
} from './actions/wallet/switchChain.js'
export type {
  UninstallFilterErrorType,
  UninstallFilterParameters,
  UninstallFilterReturnType,
} from './actions/public/uninstallFilter.js'
export type {
  WatchAssetErrorType,
  WatchAssetParameters,
  WatchAssetReturnType,
} from './actions/wallet/watchAsset.js'
export type {
  VerifyHashErrorType as VerifyHashActionErrorType,
  VerifyHashParameters as VerifyHashActionParameters,
  VerifyHashReturnType as VerifyHashActionReturnType,
} from './actions/public/verifyHash.js'
export type {
  VerifyTypedDataErrorType as VerifyTypedDataActionErrorType,
  VerifyTypedDataParameters as VerifyTypedDataActionParameters,
  VerifyTypedDataReturnType as VerifyTypedDataActionReturnType,
} from './actions/public/verifyTypedData.js'
export type {
  VerifyMessageErrorType as VerifyMessageActionErrorType,
  VerifyMessageParameters as VerifyMessageActionParameters,
  VerifyMessageReturnType as VerifyMessageActionReturnType,
} from './actions/public/verifyMessage.js'
export type {
  WatchContractEventOnLogsFn,
  WatchContractEventOnLogsParameter,
  WatchContractEventErrorType,
  WatchContractEventParameters,
  WatchContractEventReturnType,
} from './actions/public/watchContractEvent.js'
export type {
  WriteContractErrorType,
  WriteContractParameters,
  WriteContractReturnType,
} from './actions/wallet/writeContract.js'
export type { Call, Calls } from './types/calls.js'
export type {
  Chain,
  ChainConfig,
  ChainContract,
  ChainEstimateFeesPerGasFn,
  ChainFees,
  ChainFeesFnParameters,
  ChainFormatter,
  ChainEstimateFeesPerGasFnParameters,
  ChainMaxPriorityFeePerGasFn,
  DeriveChain,
  GetChainParameter,
  ChainFormatters,
  ChainSerializers,
  ExtractChainFormatterExclude,
  ExtractChainFormatterParameters,
  ExtractChainFormatterReturnType,
} from './types/chain.js'
export type { GetTransactionRequestKzgParameter, Kzg } from './types/kzg.js'
export {
  type Client,
  type ClientConfig,
  type CreateClientErrorType,
  type MulticallBatchOptions,
  createClient,
  rpcSchema,
} from './clients/createClient.js'
export {
  type CustomTransport,
  type CustomTransportConfig,
  type CustomTransportErrorType,
  custom,
} from './clients/transports/custom.js'
export {
  type FallbackTransport,
  type FallbackTransportConfig,
  type FallbackTransportErrorType,
  fallback,
  shouldThrow,
} from './clients/transports/fallback.js'
export {
  type HttpTransport,
  type HttpTransportConfig,
  type HttpTransportErrorType,
  http,
} from './clients/transports/http.js'
export {
  type PublicClient,
  type PublicClientConfig,
  type CreatePublicClientErrorType,
  createPublicClient,
} from './clients/createPublicClient.js'
export {
  type TestClient,
  type TestClientConfig,
  type CreateTestClientErrorType,
  createTestClient,
} from './clients/createTestClient.js'
export {
  type PublicActions,
  publicActions,
} from './clients/decorators/public.js'
export {
  type TestActions,
  testActions,
} from './clients/decorators/test.js'
export {
  type WalletActions,
  walletActions,
} from './clients/decorators/wallet.js'
export {
  type Transport,
  type TransportConfig,
  type CreateTransportErrorType,
  createTransport,
} from './clients/transports/createTransport.js'
export {
  type WalletClient,
  type WalletClientConfig,
  type CreateWalletClientErrorType,
  createWalletClient,
} from './clients/createWalletClient.js'
export {
  type WebSocketTransport,
  type WebSocketTransportConfig,
  type WebSocketTransportErrorType,
  webSocket,
} from './clients/transports/webSocket.js'
export {
  multicall3Abi,
  erc20Abi,
  erc20Abi_bytes32,
  erc721Abi,
  erc1155Abi,
  erc4626Abi,
  universalSignatureValidatorAbi,
} from './constants/abis.js'
export { ethAddress, zeroAddress } from './constants/address.js'
export {
  deploylessCallViaBytecodeBytecode,
  deploylessCallViaFactoryBytecode,
  universalSignatureValidatorByteCode,
} from './constants/contracts.js'
export { etherUnits, gweiUnits, weiUnits } from './constants/unit.js'
export {
  maxInt8,
  maxInt16,
  maxInt24,
  maxInt32,
  maxInt40,
  maxInt48,
  maxInt56,
  maxInt64,
  maxInt72,
  maxInt80,
  maxInt88,
  maxInt96,
  maxInt104,
  maxInt112,
  maxInt120,
  maxInt128,
  maxInt136,
  maxInt144,
  maxInt152,
  maxInt160,
  maxInt168,
  maxInt176,
  maxInt184,
  maxInt192,
  maxInt200,
  maxInt208,
  maxInt216,
  maxInt224,
  maxInt232,
  maxInt240,
  maxInt248,
  maxInt256,
  maxUint8,
  maxUint16,
  maxUint24,
  maxUint32,
  maxUint40,
  maxUint48,
  maxUint56,
  maxUint64,
  maxUint72,
  maxUint80,
  maxUint88,
  maxUint96,
  maxUint104,
  maxUint112,
  maxUint120,
  maxUint128,
  maxUint136,
  maxUint144,
  maxUint152,
  maxUint160,
  maxUint168,
  maxUint176,
  maxUint184,
  maxUint192,
  maxUint200,
  maxUint208,
  maxUint216,
  maxUint224,
  maxUint232,
  maxUint240,
  maxUint248,
  maxUint256,
  minInt8,
  minInt16,
  minInt24,
  minInt32,
  minInt40,
  minInt48,
  minInt56,
  minInt64,
  minInt72,
  minInt80,
  minInt88,
  minInt96,
  minInt104,
  minInt112,
  minInt120,
  minInt128,
  minInt136,
  minInt144,
  minInt152,
  minInt160,
  minInt168,
  minInt176,
  minInt184,
  minInt192,
  minInt200,
  minInt208,
  minInt216,
  minInt224,
  minInt232,
  minInt240,
  minInt248,
  minInt256,
} from './constants/number.js'
export { zeroHash } from './constants/bytes.js'
export { presignMessagePrefix } from './constants/strings.js'
export {
  AbiConstructorNotFoundError,
  type AbiConstructorNotFoundErrorType,
  AbiConstructorParamsNotFoundError,
  type AbiConstructorParamsNotFoundErrorType,
  AbiDecodingDataSizeInvalidError,
  type AbiDecodingDataSizeInvalidErrorType,
  AbiDecodingDataSizeTooSmallError,
  type AbiDecodingDataSizeTooSmallErrorType,
  AbiDecodingZeroDataError,
  type AbiDecodingZeroDataErrorType,
  AbiEncodingArrayLengthMismatchError,
  type AbiEncodingArrayLengthMismatchErrorType,
  AbiEncodingLengthMismatchError,
  type AbiEncodingLengthMismatchErrorType,
  AbiEncodingBytesSizeMismatchError,
  type AbiEncodingBytesSizeMismatchErrorType,
  AbiErrorInputsNotFoundError,
  type AbiErrorInputsNotFoundErrorType,
  AbiErrorNotFoundError,
  type AbiErrorNotFoundErrorType,
  AbiErrorSignatureNotFoundError,
  type AbiErrorSignatureNotFoundErrorType,
  AbiEventNotFoundError,
  type AbiEventNotFoundErrorType,
  AbiEventSignatureEmptyTopicsError,
  type AbiEventSignatureEmptyTopicsErrorType,
  AbiEventSignatureNotFoundError,
  type AbiEventSignatureNotFoundErrorType,
  AbiFunctionNotFoundError,
  type AbiFunctionNotFoundErrorType,
  AbiFunctionOutputsNotFoundError,
  type AbiFunctionOutputsNotFoundErrorType,
  AbiFunctionSignatureNotFoundError,
  type AbiFunctionSignatureNotFoundErrorType,
  BytesSizeMismatchError,
  type BytesSizeMismatchErrorType,
  DecodeLogDataMismatch,
  type DecodeLogDataMismatchErrorType,
  DecodeLogTopicsMismatch,
  type DecodeLogTopicsMismatchErrorType,
  InvalidAbiDecodingTypeError,
  type InvalidAbiDecodingTypeErrorType,
  InvalidAbiEncodingTypeError,
  type InvalidAbiEncodingTypeErrorType,
  InvalidArrayError,
  type InvalidArrayErrorType,
  InvalidDefinitionTypeError,
  type InvalidDefinitionTypeErrorType,
  UnsupportedPackedAbiType,
  type UnsupportedPackedAbiTypeErrorType,
} from './errors/abi.js'
export { BaseError, type BaseErrorType, setErrorConfig } from './errors/base.js'
export {
  BlockNotFoundError,
  type BlockNotFoundErrorType,
} from './errors/block.js'
export {
  CallExecutionError,
  type CallExecutionErrorType,
  ContractFunctionExecutionError,
  type ContractFunctionExecutionErrorType,
  ContractFunctionRevertedError,
  type ContractFunctionRevertedErrorType,
  ContractFunctionZeroDataError,
  type ContractFunctionZeroDataErrorType,
  RawContractError,
  type RawContractErrorType,
  CounterfactualDeploymentFailedError,
  type CounterfactualDeploymentFailedErrorType,
} from './errors/contract.js'
export {
  BaseFeeScalarError,
  type BaseFeeScalarErrorType,
  Eip1559FeesNotSupportedError,
  type Eip1559FeesNotSupportedErrorType,
  MaxFeePerGasTooLowError,
  type MaxFeePerGasTooLowErrorType,
} from './errors/fee.js'
export {
  AtomicReadyWalletRejectedUpgradeError,
  type AtomicReadyWalletRejectedUpgradeErrorType,
  AtomicityNotSupportedError,
  type AtomicityNotSupportedErrorType,
  BundleTooLargeError,
  type BundleTooLargeErrorType,
  ChainDisconnectedError,
  type ChainDisconnectedErrorType,
  DuplicateIdError,
  type DuplicateIdErrorType,
  InternalRpcError,
  type InternalRpcErrorType,
  InvalidInputRpcError,
  type InvalidInputRpcErrorType,
  InvalidParamsRpcError,
  type InvalidParamsRpcErrorType,
  InvalidRequestRpcError,
  type InvalidRequestRpcErrorType,
  JsonRpcVersionUnsupportedError,
  type JsonRpcVersionUnsupportedErrorType,
  LimitExceededRpcError,
  type LimitExceededRpcErrorType,
  MethodNotFoundRpcError,
  type MethodNotFoundRpcErrorType,
  MethodNotSupportedRpcError,
  type MethodNotSupportedRpcErrorType,
  ParseRpcError,
  type ParseRpcErrorType,
  ProviderDisconnectedError,
  type ProviderDisconnectedErrorType,
  ProviderRpcError,
  type ProviderRpcErrorCode,
  type ProviderRpcErrorType,
  ResourceNotFoundRpcError,
  type ResourceNotFoundRpcErrorType,
  ResourceUnavailableRpcError,
  type ResourceUnavailableRpcErrorType,
  RpcError,
  type RpcErrorType,
  type RpcErrorCode,
  SwitchChainError,
  TransactionRejectedRpcError,
  type TransactionRejectedRpcErrorType,
  UnauthorizedProviderError,
  type UnauthorizedProviderErrorType,
  UnknownBundleIdError,
  type UnknownBundleIdErrorType,
  UnknownRpcError,
  type UnknownRpcErrorType,
  UnsupportedChainIdError,
  type UnsupportedChainIdErrorType,
  UnsupportedNonOptionalCapabilityError,
  type UnsupportedNonOptionalCapabilityErrorType,
  UnsupportedProviderMethodError,
  type UnsupportedProviderMethodErrorType,
  UserRejectedRequestError,
  type UserRejectedRequestErrorType,
} from './errors/rpc.js'
export {
  ChainDoesNotSupportContract,
  type ChainDoesNotSupportContractErrorType,
  ChainMismatchError,
  type ChainMismatchErrorType,
  ChainNotFoundError,
  type ChainNotFoundErrorType,
  ClientChainNotConfiguredError,
  type ClientChainNotConfiguredErrorType,
  InvalidChainIdError,
  type InvalidChainIdErrorType,
} from './errors/chain.js'
export {
  InvalidBytesBooleanError,
  type InvalidBytesBooleanErrorType,
  IntegerOutOfRangeError,
  type IntegerOutOfRangeErrorType,
  InvalidHexBooleanError,
  type InvalidHexBooleanErrorType,
  InvalidHexValueError,
  type InvalidHexValueErrorType,
  SizeOverflowError,
  type SizeOverflowErrorType,
} from './errors/encoding.js'
export {
  type EnsAvatarInvalidMetadataError,
  EnsAvatarUriResolutionError,
  type EnsAvatarInvalidMetadataErrorType,
  EnsAvatarInvalidNftUriError,
  type EnsAvatarInvalidNftUriErrorType,
  EnsAvatarUnsupportedNamespaceError,
  type EnsAvatarUnsupportedNamespaceErrorType,
  type EnsAvatarUriResolutionErrorType,
} from './errors/ens.js'
export {
  type InvalidDecimalNumberErrorType,
  InvalidDecimalNumberError,
} from './errors/unit.js'
export {
  EstimateGasExecutionError,
  type EstimateGasExecutionErrorType,
} from './errors/estimateGas.js'
export {
  ExecutionRevertedError,
  type ExecutionRevertedErrorType,
  FeeCapTooHighError,
  type FeeCapTooHighErrorType,
  FeeCapTooLowError,
  type FeeCapTooLowErrorType,
  InsufficientFundsError,
  type InsufficientFundsErrorType,
  IntrinsicGasTooHighError,
  type IntrinsicGasTooHighErrorType,
  IntrinsicGasTooLowError,
  type IntrinsicGasTooLowErrorType,
  NonceMaxValueError,
  type NonceMaxValueErrorType,
  NonceTooHighError,
  type NonceTooHighErrorType,
  NonceTooLowError,
  type NonceTooLowErrorType,
  TipAboveFeeCapError,
  type TipAboveFeeCapErrorType,
  TransactionTypeNotSupportedError,
  type TransactionTypeNotSupportedErrorType,
  UnknownNodeError,
  type UnknownNodeErrorType,
} from './errors/node.js'
export {
  FilterTypeNotSupportedError,
  type FilterTypeNotSupportedErrorType,
} from './errors/log.js'
export {
  HttpRequestError,
  type HttpRequestErrorType,
  RpcRequestError,
  type RpcRequestErrorType,
  TimeoutError,
  type TimeoutErrorType,
  SocketClosedError,
  type SocketClosedErrorType,
  WebSocketRequestError,
  type WebSocketRequestErrorType,
} from './errors/request.js'
export {
  InvalidAddressError,
  type InvalidAddressErrorType,
} from './errors/address.js'
export {
  FeeConflictError,
  type FeeConflictErrorType,
  InvalidLegacyVError,
  type InvalidLegacyVErrorType,
  InvalidSerializableTransactionError,
  type InvalidSerializableTransactionErrorType,
  InvalidSerializedTransactionError,
  type InvalidSerializedTransactionErrorType,
  InvalidSerializedTransactionTypeError,
  type InvalidSerializedTransactionTypeErrorType,
  InvalidStorageKeySizeError,
  type InvalidStorageKeySizeErrorType,
  TransactionExecutionError,
  type TransactionExecutionErrorType,
  TransactionNotFoundError,
  type TransactionNotFoundErrorType,
  TransactionReceiptNotFoundError,
  type TransactionReceiptNotFoundErrorType,
  WaitForTransactionReceiptTimeoutError,
  type WaitForTransactionReceiptTimeoutErrorType,
} from './errors/transaction.js'
export {
  SizeExceedsPaddingSizeError,
  type SizeExceedsPaddingSizeErrorType,
  SliceOffsetOutOfBoundsError,
  type SliceOffsetOutOfBoundsErrorType,
} from './errors/data.js'
export {
  UrlRequiredError,
  type UrlRequiredErrorType,
} from './errors/transport.js'
export {
  AccountStateConflictError,
  type AccountStateConflictErrorType,
  StateAssignmentConflictError,
  type StateAssignmentConflictErrorType,
} from './errors/stateOverride.js'
export {
  InvalidDomainError,
  type InvalidDomainErrorType,
  InvalidPrimaryTypeError,
  type InvalidPrimaryTypeErrorType,
  InvalidStructTypeError,
  type InvalidStructTypeErrorType,
} from './errors/typedData.js'
export type {
  AbiEventParameterToPrimitiveType,
  AbiEventParametersToPrimitiveTypes,
  AbiEventTopicToPrimitiveType,
  AbiItem,
  AbiItemArgs,
  AbiItemName,
  ContractConstructorArgs,
  ContractEventArgsFromTopics,
  EventDefinition,
  ExtractAbiFunctionForArgs,
  ExtractAbiItem,
  ExtractAbiItemForArgs,
  ExtractAbiItemNames,
  ContractErrorArgs,
  ContractErrorName,
  ContractEventArgs,
  ContractEventName,
  ContractFunctionParameters,
  ContractFunctionReturnType,
  ContractFunctionArgs,
  ContractFunctionName,
  GetEventArgs,
  GetValue,
  LogTopicType,
  MaybeAbiEventName,
  MaybeExtractEventArgsFromAbi,
  UnionWiden,
  Widen,
} from './types/contract.js'
export type {
  AccessList,
  Transaction,
  TransactionBase,
  TransactionEIP1559,
  TransactionEIP2930,
  TransactionEIP4844,
  TransactionEIP7702,
  TransactionLegacy,
  TransactionReceipt,
  TransactionRequest,
  TransactionRequestBase,
  TransactionRequestEIP1559,
  TransactionRequestEIP2930,
  TransactionRequestEIP4844,
  TransactionRequestEIP7702,
  TransactionRequestGeneric,
  TransactionRequestLegacy,
  TransactionSerializable,
  TransactionSerializableBase,
  TransactionSerializableEIP1559,
  TransactionSerializableEIP2930,
  TransactionSerializableEIP4844,
  TransactionSerializableEIP7702,
  TransactionSerializableGeneric,
  TransactionSerializableLegacy,
  TransactionSerialized,
  TransactionSerializedEIP1559,
  TransactionSerializedEIP2930,
  TransactionSerializedEIP4844,
  TransactionSerializedEIP7702,
  TransactionSerializedGeneric,
  TransactionSerializedLegacy,
  TransactionType,
} from './types/transaction.js'
export type {
  Assign,
  Branded,
  Evaluate,
  IsNarrowable,
  IsUndefined,
  IsUnion,
  LooseOmit,
  MaybePartial,
  MaybePromise,
  MaybeRequired,
  Mutable,
  NoInfer,
  NoUndefined,
  Omit,
  Or,
  PartialBy,
  RequiredBy,
  Some,
  UnionEvaluate,
  UnionLooseOmit,
  ValueOf,
  Prettify,
  ExactPartial,
  ExactRequired,
  IsNever,
  OneOf,
  UnionOmit,
  UnionPartialBy,
  UnionPick,
  UnionRequiredBy,
  UnionToTuple,
} from './types/utils.js'
export type {
  Account,
  AccountSource,
  CustomSource,
  HDAccount,
  HDOptions,
  JsonRpcAccount,
  LocalAccount,
  PrivateKeyAccount,
} from './accounts/types.js'
export type { AssetGateway, AssetGatewayUrls } from './types/ens.js'
export type {
  Block,
  BlockIdentifier,
  BlockNumber,
  BlockTag,
  Uncle,
} from './types/block.js'
export type {
  ByteArray,
  Hash,
  Hex,
  LogTopic,
  Signature,
  CompactSignature,
  SignableMessage,
} from './types/misc.js'
export type {
  AddEthereumChainParameter,
  BundlerRpcSchema,
  DebugBundlerRpcSchema,
  EIP1193EventMap,
  EIP1193Events,
  EIP1193Parameters,
  EIP1193Provider,
  EIP1193RequestFn,
  EIP1474Methods,
  ProviderRpcErrorType as EIP1193ProviderRpcErrorType,
  ProviderConnectInfo,
  ProviderMessage,
  PublicRpcSchema,
  PaymasterRpcSchema,
  NetworkSync,
  RpcSchema,
  RpcSchemaOverride,
  TestRpcSchema,
  WalletCapabilities,
  WalletCapabilitiesRecord,
  WalletCallReceipt,
  WalletGetCallsStatusReturnType,
  WalletGrantPermissionsParameters,
  WalletGrantPermissionsReturnType,
  WalletSendCallsParameters,
  WalletSendCallsReturnType,
  WalletPermissionCaveat,
  WalletPermission,
  WalletRpcSchema,
  WatchAssetParams,
} from './types/eip1193.js'
export { ProviderRpcError as EIP1193ProviderRpcError } from './types/eip1193.js'
export type { BlobSidecar, BlobSidecars } from './types/eip4844.js'
export type {
  FeeHistory,
  FeeValues,
  FeeValuesEIP1559,
  FeeValuesEIP4844,
  FeeValuesLegacy,
  FeeValuesType,
} from './types/fee.js'
export type { Filter, FilterType } from './types/filter.js'
export type { TypedDataDefinition } from './types/typedData.js'
export type { GetTransportConfig, GetPollOptions } from './types/transport.js'
export type { Log } from './types/log.js'
export type {
  MulticallContracts,
  MulticallResponse,
  MulticallResults,
} from './types/multicall.js'
export type {
  ParseAccount,
  DeriveAccount,
  HDKey,
} from './types/account.js'
export type {
  Authorization,
  AuthorizationList,
  SerializedAuthorization,
  SerializedAuthorizationList,
  SignedAuthorization,
  SignedAuthorizationList,
} from './types/authorization.js'
export type {
  Index,
  Quantity,
  RpcAuthorization,
  RpcAuthorizationList,
  RpcBlock,
  RpcBlockIdentifier,
  RpcBlockNumber,
  RpcFeeHistory,
  RpcFeeValues,
  RpcLog,
  RpcTransaction,
  RpcTransactionReceipt,
  RpcTransactionRequest,
  RpcUncle,
  Status,
  RpcProof,
  RpcAccountStateOverride,
  RpcStateOverride,
  RpcStateMapping,
} from './types/rpc.js'
export type { Withdrawal } from './types/withdrawal.js'
export type {
  StateMapping,
  StateOverride,
} from './types/stateOverride.js'
export { labelhash, type LabelhashErrorType } from './utils/ens/labelhash.js'
export { namehash, type NamehashErrorType } from './utils/ens/namehash.js'
export {
  type FormattedBlock,
  defineBlock,
  type DefineBlockErrorType,
  formatBlock,
  type FormatBlockErrorType,
} from './utils/formatters/block.js'
export { formatLog, type FormatLogErrorType } from './utils/formatters/log.js'
export {
  type DecodeAbiParametersErrorType,
  type DecodeAbiParametersReturnType,
  decodeAbiParameters,
} from './utils/abi/decodeAbiParameters.js'
export {
  type DecodeDeployDataErrorType,
  type DecodeDeployDataParameters,
  type DecodeDeployDataReturnType,
  decodeDeployData,
} from './utils/abi/decodeDeployData.js'
export {
  type DecodeErrorResultErrorType,
  type DecodeErrorResultParameters,
  type DecodeErrorResultReturnType,
  decodeErrorResult,
} from './utils/abi/decodeErrorResult.js'
export {
  type DecodeEventLogErrorType,
  type DecodeEventLogParameters,
  type DecodeEventLogReturnType,
  decodeEventLog,
} from './utils/abi/decodeEventLog.js'
export {
  type DecodeFunctionDataErrorType,
  type DecodeFunctionDataParameters,
  type DecodeFunctionDataReturnType,
  decodeFunctionData,
} from './utils/abi/decodeFunctionData.js'
export {
  type DecodeFunctionResultErrorType,
  type DecodeFunctionResultParameters,
  type DecodeFunctionResultReturnType,
  decodeFunctionResult,
} from './utils/abi/decodeFunctionResult.js'
export {
  type EncodeAbiParametersErrorType,
  type EncodeAbiParametersReturnType,
  encodeAbiParameters,
} from './utils/abi/encodeAbiParameters.js'
export {
  type EncodeDeployDataErrorType,
  type EncodeDeployDataParameters,
  type EncodeDeployDataReturnType,
  encodeDeployData,
} from './utils/abi/encodeDeployData.js'
export {
  type EncodeErrorResultErrorType,
  type EncodeErrorResultParameters,
  type EncodeErrorResultReturnType,
  encodeErrorResult,
} from './utils/abi/encodeErrorResult.js'
export {
  type EncodeEventTopicsErrorType,
  type EncodeEventTopicsParameters,
  type EncodeEventTopicsReturnType,
  encodeEventTopics,
} from './utils/abi/encodeEventTopics.js'
export {
  type EncodeFunctionDataErrorType,
  type EncodeFunctionDataParameters,
  type EncodeFunctionDataReturnType,
  encodeFunctionData,
} from './utils/abi/encodeFunctionData.js'
export {
  type PrepareEncodeFunctionDataErrorType,
  type PrepareEncodeFunctionDataParameters,
  type PrepareEncodeFunctionDataReturnType,
  prepareEncodeFunctionData,
} from './utils/abi/prepareEncodeFunctionData.js'
export {
  type EncodeFunctionResultErrorType,
  type EncodeFunctionResultParameters,
  type EncodeFunctionResultReturnType,
  encodeFunctionResult,
} from './utils/abi/encodeFunctionResult.js'
export {
  type ParseEventLogsErrorType,
  type ParseEventLogsParameters,
  type ParseEventLogsReturnType,
  parseEventLogs,
} from './utils/abi/parseEventLogs.js'
export {
  type FormattedTransaction,
  defineTransaction,
  type DefineTransactionErrorType,
  formatTransaction,
  type FormatTransactionErrorType,
  transactionType,
} from './utils/formatters/transaction.js'
export {
  type FormattedTransactionReceipt,
  defineTransactionReceipt,
  type DefineTransactionReceiptErrorType,
  formatTransactionReceipt,
  type FormatTransactionReceiptErrorType,
} from './utils/formatters/transactionReceipt.js'
export {
  type FormattedTransactionRequest,
  defineTransactionRequest,
  type DefineTransactionRequestErrorType,
  formatTransactionRequest,
  type FormatTransactionRequestErrorType,
  rpcTransactionType,
} from './utils/formatters/transactionRequest.js'
export {
  type GetAbiItemErrorType,
  type GetAbiItemParameters,
  type GetAbiItemReturnType,
  getAbiItem,
} from './utils/abi/getAbiItem.js'
export {
  type GetContractAddressOptions,
  type GetCreate2AddressOptions,
  type GetCreate2AddressErrorType,
  type GetCreateAddressOptions,
  type GetCreateAddressErrorType,
  getContractAddress,
  getCreate2Address,
  getCreateAddress,
} from './utils/address/getContractAddress.js'
export {
  type GetSerializedTransactionType,
  type GetSerializedTransactionTypeErrorType,
  getSerializedTransactionType,
} from './utils/transaction/getSerializedTransactionType.js'
export {
  type GetTransactionType,
  type GetTransactionTypeErrorType,
  getTransactionType,
} from './utils/transaction/getTransactionType.js'
export {
  type HashDomainErrorType,
  type HashStructErrorType,
  type HashTypedDataErrorType,
  type HashTypedDataParameters,
  type HashTypedDataReturnType,
  hashDomain,
  hashStruct,
  hashTypedData,
} from './utils/signature/hashTypedData.js'
export {
  type CompactSignatureToSignatureErrorType,
  compactSignatureToSignature,
} from './utils/signature/compactSignatureToSignature.js'
export {
  /** @deprecated Use `ParseCompactSignatureErrorType`. */
  type ParseCompactSignatureErrorType as HexToCompactSignatureErrorType,
  /** @deprecated Use `parseCompactSignature`. */
  parseCompactSignature as hexToCompactSignature,
  type ParseCompactSignatureErrorType,
  parseCompactSignature,
} from './utils/signature/parseCompactSignature.js'
export {
  /** @deprecated Use `ParseSignatureErrorType`. */
  type ParseSignatureErrorType as HexToSignatureErrorType,
  /** @deprecated Use `parseSignature`. */
  parseSignature as hexToSignature,
  type ParseSignatureErrorType,
  parseSignature,
} from './utils/signature/parseSignature.js'
export {
  type RecoverAddressErrorType,
  type RecoverAddressParameters,
  type RecoverAddressReturnType,
  recoverAddress,
} from './utils/signature/recoverAddress.js'
export {
  type RecoverMessageAddressErrorType,
  type RecoverMessageAddressParameters,
  type RecoverMessageAddressReturnType,
  recoverMessageAddress,
} from './utils/signature/recoverMessageAddress.js'
export {
  type RecoverPublicKeyErrorType,
  type RecoverPublicKeyParameters,
  type RecoverPublicKeyReturnType,
  recoverPublicKey,
} from './utils/signature/recoverPublicKey.js'
export {
  type RecoverTransactionAddressErrorType,
  type RecoverTransactionAddressParameters,
  type RecoverTransactionAddressReturnType,
  recoverTransactionAddress,
} from './utils/signature/recoverTransactionAddress.js'
export {
  type RecoverTypedDataAddressErrorType,
  type RecoverTypedDataAddressParameters,
  type RecoverTypedDataAddressReturnType,
  recoverTypedDataAddress,
} from './utils/signature/recoverTypedDataAddress.js'
export {
  type SignatureToCompactSignatureErrorType,
  signatureToCompactSignature,
} from './utils/signature/signatureToCompactSignature.js'
export {
  /** @deprecated Use `SignatureToHexErrorType` instead. */
  type SerializeCompactSignatureErrorType as CompactSignatureToHexErrorType,
  /** @deprecated Use `serializeCompactSignature` instead. */
  serializeCompactSignature as compactSignatureToHex,
  type SerializeCompactSignatureErrorType,
  serializeCompactSignature,
} from './utils/signature/serializeCompactSignature.js'
export {
  /** @deprecated Use `SignatureToHexErrorType` instead. */
  type SerializeSignatureErrorType as SignatureToHexErrorType,
  /** @deprecated Use `serializeSignature` instead. */
  serializeSignature as signatureToHex,
  type SerializeSignatureParameters,
  type SerializeSignatureReturnType,
  type SerializeSignatureErrorType,
  serializeSignature,
} from './utils/signature/serializeSignature.js'
export {
  bytesToRlp,
  type BytesToRlpErrorType,
  hexToRlp,
  type HexToRlpErrorType,
  toRlp,
  type ToRlpErrorType,
  type ToRlpReturnType,
} from './utils/encoding/toRlp.js'
export {
  type VerifyHashErrorType,
  type VerifyHashParameters,
  type VerifyHashReturnType,
  verifyHash,
} from './utils/signature/verifyHash.js'
export {
  type VerifyMessageErrorType,
  type VerifyMessageParameters,
  type VerifyMessageReturnType,
  verifyMessage,
} from './utils/signature/verifyMessage.js'
export {
  type VerifyTypedDataErrorType,
  type VerifyTypedDataParameters,
  type VerifyTypedDataReturnType,
  verifyTypedData,
} from './utils/signature/verifyTypedData.js'
export {
  type ParseErc6492SignatureErrorType,
  type ParseErc6492SignatureParameters,
  type ParseErc6492SignatureReturnType,
  parseErc6492Signature,
} from './utils/signature/parseErc6492Signature.js'
export {
  type IsErc6492SignatureErrorType,
  type IsErc6492SignatureParameters,
  type IsErc6492SignatureReturnType,
  isErc6492Signature,
} from './utils/signature/isErc6492Signature.js'
export {
  type SerializeErc6492SignatureErrorType,
  type SerializeErc6492SignatureParameters,
  type SerializeErc6492SignatureReturnType,
  serializeErc6492Signature,
} from './utils/signature/serializeErc6492Signature.js'
export {
  type AssertRequestErrorType,
  assertRequest,
} from './utils/transaction/assertRequest.js'
export {
  type AssertTransactionEIP1559ErrorType,
  assertTransactionEIP1559,
  type AssertTransactionEIP2930ErrorType,
  assertTransactionEIP2930,
  type AssertTransactionLegacyErrorType,
  assertTransactionLegacy,
} from './utils/transaction/assertTransaction.js'
export {
  type BoolToBytesErrorType,
  type BoolToBytesOpts,
  boolToBytes,
  type HexToBytesErrorType,
  type HexToBytesOpts,
  hexToBytes,
  type NumberToBytesErrorType,
  numberToBytes,
  type StringToBytesErrorType,
  type StringToBytesOpts,
  stringToBytes,
  type ToBytesErrorType,
  type ToBytesParameters,
  toBytes,
} from './utils/encoding/toBytes.js'
export {
  type BoolToHexErrorType,
  type BoolToHexOpts,
  boolToHex,
  type BytesToHexErrorType,
  type BytesToHexOpts,
  bytesToHex,
  type NumberToHexErrorType,
  type NumberToHexOpts,
  numberToHex,
  type StringToHexErrorType,
  type StringToHexOpts,
  stringToHex,
  type ToHexErrorType,
  type ToHexParameters,
  toHex,
} from './utils/encoding/toHex.js'
export {
  type BytesToBigIntErrorType,
  type BytesToBigIntOpts,
  bytesToBigInt,
  type BytesToBoolErrorType,
  type BytesToBoolOpts,
  bytesToBool,
  type BytesToNumberErrorType,
  type BytesToNumberOpts,
  bytesToNumber,
  type BytesToStringErrorType,
  type BytesToStringOpts,
  bytesToString,
  type FromBytesErrorType,
  type FromBytesParameters,
  fromBytes,
} from './utils/encoding/fromBytes.js'
export {
  type CcipRequestParameters,
  type CcipRequestErrorType,
  ccipRequest,
  /** @deprecated Use `ccipRequest`. */
  ccipRequest as ccipFetch,
  type OffchainLookupErrorType,
  offchainLookup,
  offchainLookupAbiItem,
  offchainLookupSignature,
} from './utils/ccip.js'
export {
  type BlobsToCommitmentsErrorType,
  type BlobsToCommitmentsParameters,
  type BlobsToCommitmentsReturnType,
  blobsToCommitments,
} from './utils/blob/blobsToCommitments.js'
export {
  type CommitmentToVersionedHashErrorType,
  type CommitmentToVersionedHashParameters,
  type CommitmentToVersionedHashReturnType,
  commitmentToVersionedHash,
} from './utils/blob/commitmentToVersionedHash.js'
export {
  type CommitmentsToVersionedHashesErrorType,
  type CommitmentsToVersionedHashesParameters,
  type CommitmentsToVersionedHashesReturnType,
  commitmentsToVersionedHashes,
} from './utils/blob/commitmentsToVersionedHashes.js'
export {
  type SidecarsToVersionedHashesErrorType,
  type SidecarsToVersionedHashesParameters,
  type SidecarsToVersionedHashesReturnType,
  sidecarsToVersionedHashes,
} from './utils/blob/sidecarsToVersionedHashes.js'
export {
  type blobsToProofsErrorType,
  type blobsToProofsParameters,
  type blobsToProofsReturnType,
  blobsToProofs,
} from './utils/blob/blobsToProofs.js'
export {
  type FromBlobsErrorType,
  type FromBlobsParameters,
  type FromBlobsReturnType,
  fromBlobs,
} from './utils/blob/fromBlobs.js'
export {
  type ToBlobSidecarsErrorType,
  type ToBlobSidecarsParameters,
  type ToBlobSidecarsReturnType,
  toBlobSidecars,
} from './utils/blob/toBlobSidecars.js'
export {
  type ToBlobsErrorType,
  type ToBlobsParameters,
  type ToBlobsReturnType,
  toBlobs,
} from './utils/blob/toBlobs.js'
export {
  type DefineKzgErrorType,
  type DefineKzgParameters,
  type DefineKzgReturnType,
  defineKzg,
} from './utils/kzg/defineKzg.js'
export {
  type SetupKzgErrorType,
  type SetupKzgParameters,
  type SetupKzgReturnType,
  setupKzg,
} from './utils/kzg/setupKzg.js'
export {
  type ConcatBytesErrorType,
  type ConcatErrorType,
  type ConcatHexErrorType,
  type ConcatReturnType,
  concat,
  concatBytes,
  concatHex,
} from './utils/data/concat.js'
export {
  type AssertCurrentChainErrorType,
  type AssertCurrentChainParameters,
  assertCurrentChain,
} from './utils/chain/assertCurrentChain.js'
export { defineChain } from './utils/chain/defineChain.js'
export {
  type ExtractChainErrorType,
  type ExtractChainParameters,
  type ExtractChainReturnType,
  extractChain,
} from './utils/chain/extractChain.js'
export {
  type GetChainContractAddressErrorType,
  getChainContractAddress,
} from './utils/chain/getChainContractAddress.js'
export {
  type EncodePackedErrorType,
  encodePacked,
} from './utils/abi/encodePacked.js'
export { withCache } from './utils/promise/withCache.js'
export {
  type WithRetryErrorType,
  withRetry,
} from './utils/promise/withRetry.js'
export {
  type WithTimeoutErrorType,
  withTimeout,
} from './utils/promise/withTimeout.js'
export {
  type FormatEtherErrorType,
  formatEther,
} from './utils/unit/formatEther.js'
export {
  type FormatGweiErrorType,
  formatGwei,
} from './utils/unit/formatGwei.js'
export {
  type FormatUnitsErrorType,
  formatUnits,
} from './utils/unit/formatUnits.js'
export {
  type FromHexErrorType,
  fromHex,
  type HexToBigIntErrorType,
  hexToBigInt,
  type HexToBoolErrorType,
  hexToBool,
  type HexToNumberErrorType,
  hexToNumber,
  type HexToStringErrorType,
  hexToString,
} from './utils/encoding/fromHex.js'
export {
  type FromRlpErrorType,
  type FromRlpReturnType,
  fromRlp,
} from './utils/encoding/fromRlp.js'
export {
  type ChecksumAddressErrorType,
  type GetAddressErrorType,
  checksumAddress,
  getAddress,
} from './utils/address/getAddress.js'
export {
  type GetContractErrorReturnType,
  getContractError,
} from './utils/errors/getContractError.js'
export {
  type ToEventSelectorErrorType,
  toEventSelector,
  /** @deprecated use `ToEventSelectorErrorType`. */
  type ToEventSelectorErrorType as GetEventSelectorErrorType,
  /** @deprecated use `toEventSelector`. */
  toEventSelector as getEventSelector,
} from './utils/hash/toEventSelector.js'
export {
  type ToFunctionSelectorErrorType,
  toFunctionSelector,
  /** @deprecated use `ToFunctionSelectorErrorType`. */
  type ToFunctionSelectorErrorType as GetFunctionSelectorErrorType,
  /** @deprecated use `toFunctionSelector`. */
  toFunctionSelector as getFunctionSelector,
} from './utils/hash/toFunctionSelector.js'
export {
  type ToEventSignatureErrorType,
  toEventSignature,
  /** @deprecated use `ToEventSignatureErrorType`. */
  type ToEventSignatureErrorType as GetEventSignatureErrorType,
  /** @deprecated use `toEventSignature`. */
  toEventSignature as getEventSignature,
} from './utils/hash/toEventSignature.js'
export {
  type ToFunctionSignatureErrorType,
  toFunctionSignature,
  /** @deprecated use `ToFunctionSignatureErrorType`. */
  type ToFunctionSignatureErrorType as GetFunctionSignatureErrorType,
  /** @deprecated use `toFunctionSignature`. */
  toFunctionSignature as getFunctionSignature,
} from './utils/hash/toFunctionSignature.js'
export {
  type ToEventHashErrorType,
  toEventHash,
} from './utils/hash/toEventHash.js'
export {
  type ToFunctionHashErrorType,
  toFunctionHash,
} from './utils/hash/toFunctionHash.js'
export {
  type HashMessageErrorType,
  hashMessage,
} from './utils/signature/hashMessage.js'
export {
  type ToPrefixedMessageErrorType,
  toPrefixedMessage,
} from './utils/signature/toPrefixedMessage.js'
export {
  type IsAddressOptions,
  type IsAddressErrorType,
  isAddress,
} from './utils/address/isAddress.js'
export {
  type IsAddressEqualReturnType,
  type IsAddressEqualErrorType,
  isAddressEqual,
} from './utils/address/isAddressEqual.js'
export { type IsBytesErrorType, isBytes } from './utils/data/isBytes.js'
export { type IsHashErrorType, isHash } from './utils/hash/isHash.js'
export { type IsHexErrorType, isHex } from './utils/data/isHex.js'
export {
  type Keccak256Hash,
  type Keccak256ErrorType,
  keccak256,
} from './utils/hash/keccak256.js'
export {
  type Sha256Hash,
  type Sha256ErrorType,
  sha256,
} from './utils/hash/sha256.js'
export {
  type Ripemd160Hash,
  type Ripemd160ErrorType,
  ripemd160,
} from './utils/hash/ripemd160.js'
export {
  type PadBytesErrorType,
  type PadErrorType,
  type PadHexErrorType,
  type PadReturnType,
  pad,
  padBytes,
  padHex,
} from './utils/data/pad.js'
export {
  type ParseEtherErrorType,
  parseEther,
} from './utils/unit/parseEther.js'
export { type ParseGweiErrorType, parseGwei } from './utils/unit/parseGwei.js'
export {
  type ParseTransactionErrorType,
  type ParseTransactionReturnType,
  parseTransaction,
} from './utils/transaction/parseTransaction.js'
export {
  type ParseUnitsErrorType,
  parseUnits,
} from './utils/unit/parseUnits.js'
export {
  type SerializeAccessListErrorType,
  serializeAccessList,
} from './utils/transaction/serializeAccessList.js'
export {
  serializeTransaction,
  type SerializeTransactionErrorType,
  type SerializedTransactionReturnType,
  type SerializeTransactionFn,
} from './utils/transaction/serializeTransaction.js'
export { type SizeErrorType, size } from './utils/data/size.js'
export {
  type SliceBytesErrorType,
  type SliceErrorType,
  type SliceHexErrorType,
  slice,
  sliceBytes,
  sliceHex,
} from './utils/data/slice.js'
export { type StringifyErrorType, stringify } from './utils/stringify.js'
export {
  type TrimErrorType,
  type TrimReturnType,
  trim,
} from './utils/data/trim.js'
export {
  type DomainSeparatorErrorType,
  type GetTypesForEIP712DomainErrorType,
  type SerializeTypedDataErrorType,
  type ValidateTypedDataErrorType,
  serializeTypedData,
  validateTypedData,
  domainSeparator,
  getTypesForEIP712Domain,
} from './utils/typedData.js'
export {
  type CreateNonceManagerParameters,
  type NonceManager,
  type NonceManagerSource,
  createNonceManager,
  nonceManager,
} from './utils/nonceManager.js'
export type {
  RpcEstimateUserOperationGasReturnType,
  RpcGetUserOperationByHashReturnType,
  RpcUserOperation,
  RpcUserOperationReceipt,
  RpcUserOperationRequest,
} from './account-abstraction/types/rpc.js'
</file>

<file path="src/LICENSE">
MIT License

Copyright (c) 2023-present weth, LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="src/README.md">
<!-- > [!IMPORTANT] -->
<!-- > Viem is participating in Gitcoin Grants round 21. Consider <a href="https://explorer.gitcoin.co/#/round/42161/389/73">supporting the project</a>. Thank you.  -->

<br/>

<p align="center">
  <a href="https://viem.sh">
      <picture>
        <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/viem/main/.github/gh-logo-dark.svg">
        <img alt="viem logo" src="https://raw.githubusercontent.com/wevm/viem/main/.github/gh-logo-light.svg" width="auto" height="60">
      </picture>
</a>
</p>

<p align="center">
  TypeScript Interface for Ethereum
<p>

<p align="center">
  <a href="https://www.npmjs.com/package/viem">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/v/viem?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/v/viem?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="Version">
    </picture>
  </a>
  <a href="https://app.codecov.io/gh/wevm/viem">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/codecov/c/github/wevm/viem?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/codecov/c/github/wevm/viem?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="Code coverage">
    </picture>
  </a>
  <a href="https://github.com/wevm/viem/blob/main/LICENSE">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/l/viem?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/l/viem?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="MIT License">
    </picture>
  </a>
  <a href="https://www.npmjs.com/package/viem">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/npm/dm/viem?colorA=21262d&colorB=21262d&style=flat">
      <img src="https://img.shields.io/npm/dm/viem?colorA=f6f8fa&colorB=f6f8fa&style=flat" alt="Downloads per month">
    </picture>
  </a>
  <a href="https://bestofjs.org/projects/viem">
    <picture>
      <source media="(prefers-color-scheme: dark)" srcset="https://img.shields.io/endpoint?colorA=21262d&colorB=21262d&style=flat&url=https://bestofjs-serverless.now.sh/api/project-badge?fullName=wevm%2Fviem%26since=daily">
      <img src="https://img.shields.io/endpoint?colorA=f6f8fa&colorB=f6f8fa&style=flat&url=https://bestofjs-serverless.now.sh/api/project-badge?fullName=wevm%2Fviem%26since=daily" alt="Best of JS">
    </picture>
  </a>
</p>

<br>

## Features

- Abstractions over the [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) to make your life easier
- First-class APIs for interacting with [Smart Contracts](https://ethereum.org/en/glossary/#smart-contract)
- Language closely aligned to official [Ethereum terminology](https://ethereum.org/en/glossary/)
- Import your Browser Extension, WalletConnect or Private Key Wallet
- Browser native [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt), instead of large BigNumber libraries
- Utilities for working with [ABIs](https://ethereum.org/en/glossary/#abi) (encoding/decoding/inspection)
- TypeScript ready ([infer types](https://viem.sh/docs/typescript) from ABIs and EIP-712 Typed Data)
- First-class support for [Anvil](https://book.getfoundry.sh/), [Hardhat](https://hardhat.org/) & [Ganache](https://trufflesuite.com/ganache/)
- Test suite running against [forked](https://ethereum.org/en/glossary/#fork) Ethereum network

... and a lot more.

## Overview

```ts
// 1. Import modules.
import { createPublicClient, http } from 'viem';
import { mainnet } from 'viem/chains';

// 2. Set up your client with desired chain & transport.
const client = createPublicClient({
  chain: mainnet,
  transport: http(),
});

// 3. Consume an action!
const blockNumber = await client.getBlockNumber();
```

## Documentation

[Head to the documentation](https://viem.sh/docs/getting-started) to read and learn more about viem.

## Community

Check out the following places for more viem-related content:

- Follow [@wevm_dev](https://twitter.com/wevm_dev), [@_jxom](https://twitter.com/_jxom), and [@awkweb](https://twitter.com/awkweb) on Twitter for project updates
- Join the [discussions on GitHub](https://github.com/wevm/viem/discussions)
- [Share your project/organization](https://github.com/wevm/viem/discussions/104) that uses viem

## Support

- [GitHub Sponsors](https://github.com/sponsors/wevm?metadata_campaign=docs_support)
- [Gitcoin Grant](https://wagmi.sh/gitcoin)
- [wevm.eth](https://etherscan.io/name-lookup-search?id=wevm.eth)

## Sponsors

<a href="https://paradigm.xyz">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/paradigm-dark.svg">
    <img alt="paradigm logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/paradigm-light.svg" width="auto" height="70">
  </picture>
</a>
<a href="https://ithaca.xyz">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/ithaca-dark.svg">
    <img alt="ithaca logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/ithaca-light.svg" width="auto" height="70">
  </picture>
</a>

<br>

<a href="https://twitter.com/family">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/family-dark.svg">
    <img alt="family logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/family-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://twitter.com/context">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/context-dark.svg">
    <img alt="context logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/context-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://walletconnect.com">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/walletconnect-dark.svg">
    <img alt="WalletConnect logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/walletconnect-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://twitter.com/prtyDAO">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/partydao-dark.svg">
    <img alt="PartyDAO logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/partydao-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://dynamic.xyz">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/dynamic-dark.svg">
    <img alt="Dynamic logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/dynamic-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://sushi.com">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/sushi-dark.svg">
    <img alt="Sushi logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/sushi-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://stripe.com">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/stripe-dark.svg">
    <img alt="Stripe logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/stripe-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://privy.io">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/privy-dark.svg">
    <img alt="Privy logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/privy-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://pancakeswap.finance">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/pancake-dark.svg">
    <img alt="pancake logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/pancake-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://celo.org">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/celo-dark.svg">
    <img alt="celo logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/celo-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://rainbow.me">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/rainbow-dark.svg">
    <img alt="rainbow logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/rainbow-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://pimlico.io">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/pimlico-dark.svg">
    <img alt="pimlico logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/pimlico-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://zora.co">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/zora-dark.svg">
    <img alt="zora logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/zora-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://lattice.xyz">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/lattice-dark.svg">
    <img alt="lattice logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/lattice-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://twitter.com/supafinance">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/supa-dark.svg">
    <img alt="supa logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/supa-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://zksync.io">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/zksync-dark.svg">
    <img alt="ZKsync logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/zksync-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://syndicate.io">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/syndicate-dark.svg">
    <img alt="syndicate logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/syndicate-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://reservoir.tools">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/reservoir-dark.svg">
    <img alt="reservoir logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/reservoir-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://linea.build">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/linea-dark.svg">
    <img alt="linea logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/linea-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://uniswap.org">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/uniswap-dark.svg">
    <img alt="uniswap logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/uniswap-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://biconomy.io">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/b0276d897be98a4c94ad1d1c72ce99a1020eeb58/content/sponsors/biconomy-dark.svg">
    <img alt="biconomy logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/biconomy-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://thirdweb.com">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/thirdweb-dark.svg">
    <img alt="thirdweb logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/thirdweb-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://polymarket.com">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/polymarket-dark.svg">
    <img alt="polymarket logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/polymarket-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://routescan.io">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/routescan-dark.svg">
    <img alt="routescan logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/routescan-light.svg" width="auto" height="50">
  </picture>
</a>
<a href="https://sequence.xyz">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/sequence-dark.svg">
    <img alt="sequence logo" src="https://raw.githubusercontent.com/wevm/.github/main/content/sponsors/sequence-light.svg" width="auto" height="50">
  </picture>
</a>

## Contributing

If you're interested in contributing, please read the [contributing docs](/.github/CONTRIBUTING.md) **before submitting a pull request**.

## Authors

- [@jxom](https://github.com/jxom) (jxom.eth, [Twitter](https://twitter.com/_jxom))
- [@tmm](https://github.com/tmm) (awkweb.eth, [Twitter](https://twitter.com/awkweb))

## License

[MIT](/LICENSE) License


<br />
<br />

<a href="https://vercel.com/?utm_source=wevm&utm_campaign=oss">
  <img src="https://www.datocms-assets.com/31049/1618983297-powered-by-vercel.svg" alt="Powered by Vercel" height="35">
</a>
</file>

</files>
