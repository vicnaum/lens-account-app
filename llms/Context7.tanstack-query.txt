TITLE: Using TanStack Query useQuery Hook in TypeScript
DESCRIPTION: Complete implementation example of the useQuery hook showing all possible return values and configuration options. The hook is used for fetching, caching, and managing server state in React applications with TypeScript support.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useQuery.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  promise,
  refetch,
  status,
} = useQuery(
  {
    queryKey,
    queryFn,
    gcTime,
    enabled,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    notifyOnChangeProps,
    placeholderData,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    select,
    staleTime,
    structuralSharing,
    subscribed,
    throwOnError,
  },
  queryClient,
)

----------------------------------------

TITLE: Initializing a Basic Query with useQuery Hook in React
DESCRIPTION: Demonstrates how to create a basic query using the useQuery hook from TanStack Query. It shows the minimal setup required, including the queryKey and queryFn parameters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/react-query'

function App() {
  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
}

----------------------------------------

TITLE: Using useMutation Hook in TanStack Query
DESCRIPTION: Example showing the complete usage of useMutation hook with all available options and return values. The hook accepts mutation configuration options and an optional QueryClient instance, returning various mutation state and control functions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useMutation.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const {
  data,
  error,
  isError,
  isIdle,
  isPending,
  isPaused,
  isSuccess,
  failureCount,
  failureReason,
  mutate,
  mutateAsync,
  reset,
  status,
  submittedAt,
  variables,
} = useMutation(
  {
    mutationFn,
    gcTime,
    meta,
    mutationKey,
    networkMode,
    onError,
    onMutate,
    onSettled,
    onSuccess,
    retry,
    retryDelay,
    scope,
    throwOnError,
  },
  queryClient,
)

LANGUAGE: tsx
CODE:
mutate(variables, {
  onError,
  onSettled,
  onSuccess,
})

----------------------------------------

TITLE: Implementing Vue Query with Composition API
DESCRIPTION: Demonstrates how to set up queries and mutations using Vue Query in a Vue component. Shows usage of useQuery for data fetching, useMutation for data updates, and proper handling of loading and error states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/quick-start.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup>
import { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'

// Access QueryClient instance
const queryClient = useQueryClient()

// Query
const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})

// Mutation
const mutation = useMutation({
  mutationFn: postTodo,
  onSuccess: () => {
    // Invalidate and refetch
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})

function onButtonClick() {
  mutation.mutate({
    id: Date.now(),
    title: 'Do Laundry',
  })
}
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else>
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
  <button @click="onButtonClick">Add Todo</button>
</template>

----------------------------------------

TITLE: Implementing Basic GitHub Repository Data Fetching with TanStack Query
DESCRIPTION: Demonstrates setting up TanStack Query to fetch and display GitHub repository statistics. Shows core concepts including QueryClient setup, QueryClientProvider wrapper, and useQuery hook implementation with error handling and loading states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/overview.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const { isPending, error, data } = useQuery({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/TanStack/query').then((res) =>
        res.json(),
      ),
  })

  if (isPending) return 'Loading...'

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
    </div>
  )
}

----------------------------------------

TITLE: Creating Paginated Query Component in Angular with TanStack Query
DESCRIPTION: This snippet shows a comprehensive Angular component implementation for paginated queries using TanStack Query. It includes pagination controls, data fetching, error handling, and prefetching of the next page. The component uses signals for reactivity and demonstrates how to handle placeholder data and background fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/paginated-queries.md#2025-04-16_snippet_1

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'pagination-example',
  template: `
    <div>
      <p>
        In this example, each page of data remains visible as the next page is
        fetched. The buttons and capability to proceed to the next page are also
        suppressed until the next page cursor is known. Each page is cached as a
        normal query too, so when going to previous pages, you'll see them
        instantaneously while they are also re-fetched invisibly in the
        background.
      </p>
      @if (query.status() === 'pending') {
        <div>Loading...</div>
      } @else if (query.status() === 'error') {
        <div>Error: {{ query.error().message }}</div>
      } @else {
        <!-- 'data' will either resolve to the latest page's data -->
        <!-- or if fetching a new page, the last successful page's data -->
        <div>
          @for (project of query.data().projects; track project.id) {
            <p>{{ project.name }}</p>
          }
        </div>
      }

      <div>Current Page: {{ page() + 1 }}</div>
      <button (click)="previousPage()" [disabled]="page() === 0">
        Previous Page
      </button>
      <button
        (click)="nextPage()"
        [disabled]="query.isPlaceholderData() || !query.data()?.hasMore"
      >
        Next Page
      </button>
      <!-- Since the last page's data potentially sticks around between page requests, -->
      <!-- we can use 'isFetching' to show a background loading -->
      <!-- indicator since our status === 'pending' state won't be triggered -->
      @if (query.isFetching()) {
        <span> Loading...</span>
      }
    </div>
  `,
})
export class PaginationExampleComponent {
  page = signal(0)
  queryClient = inject(QueryClient)

  query = injectQuery(() => ({
    queryKey: ['projects', this.page()],
    queryFn: () => lastValueFrom(fetchProjects(this.page())),
    placeholderData: keepPreviousData,
    staleTime: 5000,
  }))

  constructor() {
    effect(() => {
      // Prefetch the next page!
      if (!this.query.isPlaceholderData() && this.query.data()?.hasMore) {
        this.#queryClient.prefetchQuery({
          queryKey: ['projects', this.page() + 1],
          queryFn: () => lastValueFrom(fetchProjects(this.page() + 1)),
        })
      }
    })
  }

  previousPage() {
    this.page.update((old) => Math.max(old - 1, 0))
  }

  nextPage() {
    this.page.update((old) => (this.query.data()?.hasMore ? old + 1 : old))
  }
}

----------------------------------------

TITLE: Mutation Lifecycle Callbacks
DESCRIPTION: Example showing the complete mutation lifecycle with callbacks for mutate, error, success, and settled states. Includes context passing between callbacks.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onMutate: (variables) => {
    // A mutation is about to happen!

    // Optionally return a context containing data to use when for example rolling back
    return { id: 1 }
  },
  onError: (error, variables, context) => {
    // An error happened!
    console.log(`rolling back optimistic update with id ${context.id}`)
  },
  onSuccess: (data, variables, context) => {
    // Boom baby!
  },
  onSettled: (data, error, variables, context) => {
    // Error or success... doesn't matter!
  },
}))

----------------------------------------

TITLE: Mutation Callback Override
DESCRIPTION: Shows how mutation callbacks can be overridden when calling mutate, with inline callback definitions taking precedence.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onSuccess: (data, variables, context) => {
    // I will fire first
  },
  onError: (error, variables, context) => {
    // I will fire first
  },
  onSettled: (data, error, variables, context) => {
    // I will fire first
  },
}))

mutation.mutate(todo, {
  onSuccess: (data, variables, context) => {
    // I will fire second!
  },
  onError: (error, variables, context) => {
    // I will fire second!
  },
  onSettled: (data, error, variables, context) => {
    // I will fire second!
  },
})

----------------------------------------

TITLE: Using Status Enum for Query State Management in React
DESCRIPTION: Demonstrates an alternative approach to handling query states using the status enum provided by the useQuery hook. This method can be preferred when working with more complex state logic.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
function Todos() {
  const { status, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  if (status === 'pending') {
    return <span>Loading...</span>
  }

  if (status === 'error') {
    return <span>Error: {error.message}</span>
  }

  // also status === 'success', but "else" logic works, too
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

----------------------------------------

TITLE: Initializing QueryClient in TypeScript/React
DESCRIPTION: Creates a new QueryClient instance with default options for query stale time set to Infinity. Shows basic setup and prefetching of queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { QueryClient } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
    },
  },
})

await queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })

----------------------------------------

TITLE: Vue Mutation with Error Reset Functionality
DESCRIPTION: Shows how to implement error handling and reset functionality in Vue mutations using TanStack Query. Includes error display and reset button implementation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-16_snippet_1

LANGUAGE: vue
CODE:
<script>
import { useMutation } from '@tanstack/vue-query'

const { error, mutate, reset } = useMutation({
  mutationFn: (newTodo) => axios.post('/todos', newTodo),
})

function addTodo() {
  mutate({ id: new Date(), title: 'Do Laundry' })
}
</script>

<template>
  <span v-else-if="error">
    <span>An error occurred: {{ error.message }}</span>
    <button @click="reset">Reset error</button>
  </span>
  <button @click="addTodo">Create Todo</button>
</template>

----------------------------------------

TITLE: Fetching Data with Solid Query
DESCRIPTION: This snippet shows how to use Solid Query to fetch data from an API. It demonstrates the use of useQuery hook, QueryClient, and QueryClientProvider. The example includes caching configuration, error handling, and integration with SolidJS's Suspense and ErrorBoundary.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/overview.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { ErrorBoundary, Suspense } from 'solid-js'
import {
  useQuery,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/solid-query'

function App() {
  const repositoryQuery = useQuery(() => ({
    queryKey: ['TanStack Query'],
    queryFn: async () => {
      const result = await fetch('https://api.github.com/repos/TanStack/query')
      if (!result.ok) throw new Error('Failed to fetch data')
      return result.json()
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
    throwOnError: true, // Throw an error if the query fails
  }))

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          {/* 
            The `data` property on a query is a SolidJS resource  
            so it will work with Suspense and transitions out of the box! 
          */}
          <div>{repositoryQuery.data?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')
const client = new QueryClient()

render(
  () => (
    <QueryClientProvider client={client}>
      <App />
    </QueryClientProvider>
  ),
  root!,
)

----------------------------------------

TITLE: Rendering Query Results with Status Checks in React
DESCRIPTION: Illustrates a common pattern for rendering query results in a React component. It demonstrates how to handle loading, error, and success states using the properties provided by the useQuery hook.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
function Todos() {
  const { isPending, isError, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  if (isPending) {
    return <span>Loading...</span>
  }

  if (isError) {
    return <span>Error: {error.message}</span>
  }

  // We can assume by this point that `isSuccess === true`
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

----------------------------------------

TITLE: Implementing Optimistic Updates for Todo List in Angular Query
DESCRIPTION: This comprehensive example demonstrates how to implement optimistic updates for a todo list. It includes mutation setup, optimistic update logic, error handling, and query invalidation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
queryClient = inject(QueryClient)

updateTodo = injectMutation(() => ({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await this.queryClient.cancelQueries({ queryKey: ['todos'] })

    // Snapshot the previous value
    const previousTodos = client.getQueryData(['todos'])

    // Optimistically update to the new value
    this.queryClient.setQueryData(['todos'], (old) => [...old, newTodo])

    // Return a context object with the snapshotted value
    return { previousTodos }
  },
  // If the mutation fails,
  // use the context returned from onMutate to roll back
  onError: (err, newTodo, context) => {
    client.setQueryData(['todos'], context.previousTodos)
  },
  // Always refetch after error or success:
  onSettled: () => {
    this.queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
}))

----------------------------------------

TITLE: Fetching Paginated Projects with Cursor-based API in TypeScript React
DESCRIPTION: This example demonstrates how to use useInfiniteQuery to fetch paginated projects from an API that returns data with a cursor. It includes handling loading states, errors, and implementing a 'Load More' button.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useInfiniteQuery } from '@tanstack/react-query'

function Projects() {
  const fetchProjects = async ({ pageParam }) => {
    const res = await fetch('/api/projects?cursor=' + pageParam)
    return res.json()
  }

  const {
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  })

  return status === 'pending' ? (
    <p>Loading...</p>
  ) : status === 'error' ? (
    <p>Error: {error.message}</p>
  ) : (
    <>
      {data.pages.map((group, i) => (
        <React.Fragment key={i}>
          {group.data.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </React.Fragment>
      ))}
      <div>
        <button
          onClick={() => fetchNextPage()}
          disabled={!hasNextPage || isFetchingNextPage}
        >
          {isFetchingNextPage
            ? 'Loading more...'
            : hasNextPage
              ? 'Load More'
              : 'Nothing more to load'}
        </button>
      </div>
      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
    </>
  )
}

----------------------------------------

TITLE: Implementing React Query in a Todo Application
DESCRIPTION: This snippet demonstrates how to set up and use React Query in a Todo application. It shows the creation of a QueryClient, setting up the QueryClientProvider, and implementing queries and mutations for fetching and adding todos.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/quick-start.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import {
  useQuery,
  useMutation,
  useQueryClient,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import { getTodos, postTodo } from '../my-api'

// Create a client
const queryClient = new QueryClient()

function App() {
  return (
    // Provide the client to your App
    <QueryClientProvider client={queryClient}>
      <Todos />
    </QueryClientProvider>
  )
}

function Todos() {
  // Access the client
  const queryClient = useQueryClient()

  // Queries
  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })

  // Mutations
  const mutation = useMutation({
    mutationFn: postTodo,
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <div>
      <ul>{query.data?.map((todo) => <li key={todo.id}>{todo.title}</li>)}</ul>

      <button
        onClick={() => {
          mutation.mutate({
            id: Date.now(),
            title: 'Do Laundry',
          })
        }}
      >
        Add Todo
      </button>
    </div>
  )
}

render(<App />, document.getElementById('root'))

----------------------------------------

TITLE: Implementing Dynamic Parallel Queries with useQueries in TanStack Query
DESCRIPTION: This snippet shows how to use the useQueries hook to dynamically execute multiple queries in parallel. It maps over a list of users and creates a query for each user.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/parallel-queries.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
function App({ users }) {
  const userQueries = useQueries({
    queries: users.map((user) => {
      return {
        queryKey: ['user', user.id],
        queryFn: () => fetchUserById(user.id),
      }
    }),
  })
}

----------------------------------------

TITLE: Providing TanStack Query Client in Standalone Angular Apps
DESCRIPTION: This snippet shows how to provide the TanStack Query client to a standalone Angular application using the provideTanStackQuery function. It demonstrates bootstrapping the application with HTTP client and Query client providers.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/quick-start.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideHttpClient(), provideTanStackQuery(new QueryClient())],
})

----------------------------------------

TITLE: Using Array Keys with Variables in TanStack Query (TSX)
DESCRIPTION: Shows how to use array keys with variables for hierarchical resources or queries with additional parameters. These keys can include IDs, indexes, or objects with options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
// An individual todo
useQuery({ queryKey: ['todo', 5], ... })

// An individual todo in a "preview" format
useQuery({ queryKey: ['todo', 5, { preview: true }], ...})

// A list of todos that are "done"
useQuery({ queryKey: ['todos', { type: 'done' }], ... })

----------------------------------------

TITLE: Basic Mutation Example with TanStack Query
DESCRIPTION: Demonstrates basic usage of useMutation hook to add a new todo item with loading, error, and success states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
function App() {
  const mutation = useMutation({
    mutationFn: (newTodo) => {
      return axios.post('/todos', newTodo)
    },
  })

  return (
    <div>
      {mutation.isPending ? (
        'Adding todo...'
      ) : (
        <>
          {mutation.isError ? (
            <div>An error occurred: {mutation.error.message}</div>
          ) : null}

          {mutation.isSuccess ? <div>Todo added!</div> : null}

          <button
            onClick={() => {
              mutation.mutate({ id: new Date(), title: 'Do Laundry' })
            }}
          >
            Create Todo
          </button>
        </>
      )}
    </div>
  )
}

----------------------------------------

TITLE: Basic Query Implementation in Vue with TypeScript
DESCRIPTION: Demonstrates the basic setup of a query using TanStack Query in a Vue application. Shows the minimal implementation using useQuery hook with a query key and fetch function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import { useQuery } from '@tanstack/vue-query'

const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })

----------------------------------------

TITLE: Vue Query Implementation with Loading and Error States
DESCRIPTION: Shows a complete Vue component implementation using TanStack Query with isPending and isError flags for handling loading and error states. Demonstrates proper template rendering based on query status.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-16_snippet_1

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>

----------------------------------------

TITLE: Accessing Query Function Variables in TanStack Query (TSX)
DESCRIPTION: Shows how to access query key variables within the query function in TanStack Query. This allows for the extraction of query functions and the use of dynamic variables passed through the query key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
function Todos({ status, page }) {
  const result = useQuery({
    queryKey: ['todos', { status, page }],
    queryFn: fetchTodoList,
  })
}

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}

----------------------------------------

TITLE: Simplified Query Implementation
DESCRIPTION: Demonstrates a minimal query implementation without imports, showing just the core query configuration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))

----------------------------------------

TITLE: Advanced Paginated Query with keepPreviousData in TanStack Query
DESCRIPTION: Comprehensive example demonstrating pagination implementation with placeholder data support. Shows how to maintain previous data while fetching new pages, handle loading states, and implement next/previous navigation with proper error handling.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/paginated-queries.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { keepPreviousData, useQuery } from '@tanstack/react-query'
import React from 'react'

function Todos() {
  const [page, setPage] = React.useState(0)

  const fetchProjects = (page = 0) =>
    fetch('/api/projects?page=' + page).then((res) => res.json())

  const { isPending, isError, error, data, isFetching, isPlaceholderData } =
    useQuery({
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
      placeholderData: keepPreviousData,
    })

  return (
    <div>
      {isPending ? (
        <div>Loading...</div>
      ) : isError ? (
        <div>Error: {error.message}</div>
      ) : (
        <div>
          {data.projects.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </div>
      )}
      <span>Current Page: {page + 1}</span>
      <button
        onClick={() => setPage((old) => Math.max(old - 1, 0))}
        disabled={page === 0}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          if (!isPlaceholderData && data.hasMore) {
            setPage((old) => old + 1)
          }
        }}
        // Disable the Next Page button until we know a next page is available
        disabled={isPlaceholderData || !data?.hasMore}
      >
        Next Page
      </button>
      {isFetching ? <span> Loading...</span> : null}
    </div>
  )

----------------------------------------

TITLE: Using useMutationState for Cross-Component Updates
DESCRIPTION: Shows how to access mutation state across different components using useMutationState hook with mutation keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
// somewhere in your app
const { mutate } = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
  mutationKey: ['addTodo'],
})

// access variables somewhere else
const variables = useMutationState<string>({
  filters: { mutationKey: ['addTodo'], status: 'pending' },
  select: (mutation) => mutation.state.variables,
})

----------------------------------------

TITLE: Limiting Maximum Pages in Infinite Queries
DESCRIPTION: Configuring infinite queries with a maximum number of pages using the maxPages option. This limits memory usage and improves performance by keeping only a fixed number of pages in memory.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-16_snippet_5

LANGUAGE: ts
CODE:
injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
  maxPages: 3,
}))

----------------------------------------

TITLE: Implementing Query and Mutation in an Angular Todo Application
DESCRIPTION: This comprehensive example demonstrates a complete implementation of TanStack Query in an Angular todo application. It shows how to use injectQuery for data fetching, injectMutation for data updates, and includes a service for HTTP requests along with the component template that displays the data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/quick-start.md#2025-04-16_snippet_2

LANGUAGE: angular-ts
CODE:
import { Component, Injectable, inject } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { lastValueFrom } from 'rxjs'

import {
  injectMutation,
  injectQuery,
  QueryClient
} from '@tanstack/angular-query-experimental'

@Component({
  standalone: true,
  template: `
    <div>
      <button (click)="onAddTodo()">Add Todo</button>

      <ul>
        @for (todo of query.data(); track todo.title) {
          <li>{{ todo.title }}</li>
        }
      </ul>
    </div>
  `,
})
export class TodosComponent {
  todoService = inject(TodoService)
  queryClient = inject(QueryClient)

  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => this.todoService.getTodos(),
  }))

  mutation = injectMutation(() => ({
    mutationFn: (todo: Todo) => this.todoService.addTodo(todo),
    onSuccess: () => {
      this.queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  }))

  onAddTodo() {
    this.mutation.mutate({
      id: Date.now().toString(),
      title: 'Do Laundry',
    })
  }
}

@Injectable({ providedIn: 'root' })
export class TodoService {
  private http = inject(HttpClient)

  getTodos(): Promise<Todo[]> {
    return lastValueFrom(
      this.http.get<Todo[]>('https://jsonplaceholder.typicode.com/todos'),
    )
  }

  addTodo(todo: Todo): Promise<Todo> {
    return lastValueFrom(
      this.http.post<Todo>('https://jsonplaceholder.typicode.com/todos', todo),
    )
  }
}

interface Todo {
  id: string
  title: string
}

----------------------------------------

TITLE: Mutation with Query Invalidation in TanStack Angular Query
DESCRIPTION: This example demonstrates how to set up a mutation that invalidates related queries upon success. It uses injectMutation to define a mutation that adds a todo item and then invalidates 'todos' and 'reminders' queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/invalidations-from-mutations.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
import {
  injectMutation,
  QueryClient,
} from '@tanstack/angular-query-experimental'

export class TodosComponent {
  queryClient = inject(QueryClient)

  // When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
  mutation = injectMutation(() => ({
    mutationFn: addTodo,
    onSuccess: () => {
      this.queryClient.invalidateQueries({ queryKey: ['todos'] })
      this.queryClient.invalidateQueries({ queryKey: ['reminders'] })
    },
  }))
}

----------------------------------------

TITLE: Implementing Manual Parallel Queries with useQuery in TanStack Query
DESCRIPTION: This snippet demonstrates how to execute multiple queries in parallel using individual useQuery hooks. It fetches users, teams, and projects simultaneously.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/parallel-queries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
function App () {
  // The following queries will execute in parallel
  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
  ...
}

----------------------------------------

TITLE: Implementing QueryClientProvider in React with TanStack Query
DESCRIPTION: This snippet demonstrates how to create a QueryClient instance and use the QueryClientProvider component to wrap the application. It shows the basic setup required to integrate TanStack Query into a React application.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/QueryClientProvider.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}

----------------------------------------

TITLE: Basic Query with Initial Data
DESCRIPTION: Demonstrates how to set up a basic query with initial data using useQuery hook.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})

----------------------------------------

TITLE: Fetching Multiple Users' Messages with Dependent Queries in React
DESCRIPTION: This TypeScript snippet shows how to fetch user IDs first, then use those IDs to create multiple queries for fetching each user's messages. It uses 'useQueries' to execute multiple queries dynamically based on the fetched user IDs.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/dependent-queries.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
// Get the users ids
const { data: userIds } = useQuery({
  queryKey: ['users'],
  queryFn: getUsersData,
  select: (users) => users.map((user) => user.id),
})

const queries = computed(() => {
  return userIds.value.length
    ? userIds.value.map((id) => {
        return {
          queryKey: ['messages', id],
          queryFn: () => getMessagesByUsers(id),
        }
      })
    : []
})

// Then get the users messages
const usersMessages = useQueries({
  queries, // if users is undefined, an empty array will be returned
})

----------------------------------------

TITLE: Exact Query Invalidation in TanStack Query (TSX)
DESCRIPTION: This example demonstrates how to use the exact option in invalidateQueries to invalidate only queries that match the exact query key, without any additional variables or subkeys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos'],
  exact: true,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Invalidating Specific Queries with Variables in TanStack Query (TSX)
DESCRIPTION: This snippet illustrates how to invalidate queries with specific variables by passing a more detailed query key to the invalidateQueries method.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos', { type: 'done' }],
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Persisting Offline Mutations with TanStack Query
DESCRIPTION: This snippet shows how to persist offline mutations using the persistQueryClient plugin. It sets up a default mutation function to allow resuming mutations after a page reload, and uses PersistQueryClientProvider to manage persistence.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_10

LANGUAGE: tsx
CODE:
const persister = createSyncStoragePersister({
  storage: window.localStorage,
})
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

// we need a default mutation function so that paused mutations can resume after a page reload
queryClient.setMutationDefaults(['todos'], {
  mutationFn: ({ id, data }) => {
    return api.updateTodo(id, data)
  },
})

export default function App() {
  return (
    <PersistQueryClientProvider
      client={queryClient}
      persistOptions={{ persister }}
      onSuccess={() => {
        // resume mutations after initial restore from localStorage was successful
        queryClient.resumePausedMutations()
      }}
    >
      <RestOfTheApp />
    </PersistQueryClientProvider>
  )
}

----------------------------------------

TITLE: Initializing TanStack Query with Todos Example
DESCRIPTION: This snippet demonstrates how to use the useQuery hook to fetch and cache todo data. It shows the basic usage of the hook with a query key and query function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/caching.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
useQuery({ queryKey: ['todos'], queryFn: fetchTodos })

----------------------------------------

TITLE: Configuring Default Query Function in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to define a default query function, set it up with QueryClient, and use it in React components. The default function uses axios to fetch data from a placeholder API based on the provided query key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/default-query-function.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// Define a default query function that will receive the query key
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  )
}

// All you have to do now is pass a key!
function Posts() {
  const { status, data, error, isFetching } = useQuery({ queryKey: ['/posts'] })

  // ...
}

// You can even leave out the queryFn and just go straight into options
function Post({ postId }) {
  const { status, data, error, isFetching } = useQuery({
    queryKey: [`/posts/${postId}`],
    enabled: !!postId,
  })

  // ...
}

----------------------------------------

TITLE: Using Suspense Query Hook in React TypeScript
DESCRIPTION: Demonstrates the basic usage of useSuspenseQuery hook. This version differs from useQuery by excluding throwOnError, enabled, and placeholderData options, while guaranteeing defined data and simplified status states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useSuspenseQuery.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const result = useSuspenseQuery(options)

----------------------------------------

TITLE: Angular Component with Query and Template Logic
DESCRIPTION: Complete example of an Angular component implementing a query with conditional rendering for loading, error, and success states using Angular's template syntax.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-16_snippet_2

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  standalone: true,
  template: `
    @if (todos.isPending()) {
      <span>Loading...</span>
    } @else if (todos.isError()) {
      <span>Error: {{ todos.error()?.message }}</span>
    } @else {
      <!-- We can assume by this point that status === 'success' -->
      @for (todo of todos.data(); track todo.id) {
        <li>{{ todo.title }}</li>
      } @empty {
        <li>No todos found</li>
      }
    }
  `,
})
export class PostsComponent {
  todos = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  }))
}

----------------------------------------

TITLE: Implementing Component-Level Background Fetching Indicators in Angular with TanStack Query
DESCRIPTION: This snippet shows how to display different states (loading, error, success, refreshing) in an Angular component using TanStack Query's state indicators. It demonstrates how to conditionally render content based on the query state and display refreshing indicators during background fetches.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/background-fetching-indicators.md#2025-04-16_snippet_0

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  template: `
    @if (todosQuery.isPending()) {
      Loading...
    } @else if (todosQuery.isError()) {
      An error has occurred: {{ todosQuery.error().message }}
    } @else if (todosQuery.isSuccess()) {
      @if (todosQuery.isFetching()) {
        Refreshing...
      }
      @for (todos of todosQuery.data(); track todo.id) {
        <todo [todo]="todo" />
      }
    }
  `,
})
class TodosComponent {
  todosQuery = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))
}

----------------------------------------

TITLE: Query Matching with invalidateQueries in TanStack Query (TSX)
DESCRIPTION: This example shows how to invalidate multiple queries by their prefix using the invalidateQueries method. It demonstrates invalidating queries that start with 'todos' in their query key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { useQuery, useQueryClient } from '@tanstack/react-query'

// Get QueryClient from the context
const queryClient = useQueryClient()

queryClient.invalidateQueries({ queryKey: ['todos'] })

// Both queries below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
const todoListQuery = useQuery({
  queryKey: ['todos', { page: 1 }],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Implementing Lazy Queries with Conditional Enabling in TanStack Query (TSX)
DESCRIPTION: This example shows how to implement a lazy query that only executes when a filter is applied. The query is enabled conditionally based on the presence of a filter value, demonstrating a more declarative approach to query management.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
function Todos() {
  const [filter, setFilter] = React.useState('')

  const { data } = useQuery({
    queryKey: ['todos', filter],
    queryFn: () => fetchTodos(filter),
    // ‚¨áÔ∏è disabled as long as the filter is empty
    enabled: !!filter,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}

----------------------------------------

TITLE: Basic Paginated Query Implementation in TanStack Query
DESCRIPTION: Simple example showing how to implement a paginated query by including page information in the query key. This demonstrates the basic usage of useQuery hook for pagination.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/paginated-queries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['projects', page],
  queryFn: fetchProjects,
})

----------------------------------------

TITLE: Rendering Optimistic UI Updates in React Query
DESCRIPTION: Shows how to render a temporary list item while the mutation is pending using the mutation's variables.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
<ul>
  {todoQuery.items.map((todo) => (
    <li key={todo.id}>{todo.text}</li>
  ))}
  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
</ul>

----------------------------------------

TITLE: Accessing Query Result in React Component
DESCRIPTION: Shows how to access the result object returned by the useQuery hook. This result object contains important information about the query's state and data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/queries.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })

----------------------------------------

TITLE: Using Mutation Scopes in TanStack Query
DESCRIPTION: This snippet demonstrates how to use mutation scopes in TanStack Query. Scopes allow mutations with the same scope.id to run serially, preventing parallel execution of related mutations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_11

LANGUAGE: tsx
CODE:
const mutation = useMutation({
  mutationFn: addTodo,
  scope: {
    id: 'todo',
  },
})

----------------------------------------

TITLE: Handling Errors in TanStack Query Functions (TSX)
DESCRIPTION: Illustrates how to properly handle and throw errors in query functions for TanStack Query. The function must either throw an error or return a rejected Promise for TanStack Query to recognize it as an error state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const { error } = useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    if (somethingGoesWrong) {
      throw new Error('Oh no!')
    }
    if (somethingElseGoesWrong) {
      return Promise.reject(new Error('Oh no!'))
    }

    return data
  },
})

----------------------------------------

TITLE: Basic Query Invalidation in Angular
DESCRIPTION: Demonstrates basic query invalidation for todos queries using TanStack Query's invalidateQueries method. Shows how invalidation affects queries with matching base keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import { injectQuery, QueryClient } from '@tanstack/angular-query-experimental'

class QueryInvalidationExample {
  queryClient = inject(QueryClient)

  invalidateQueries() {
    this.queryClient.invalidateQueries({ queryKey: ['todos'] })
  }

  // Both queries below will be invalidated
  todoListQuery = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  }))
  todoListQuery = injectQuery(() => ({
    queryKey: ['todos', { page: 1 }],
    queryFn: fetchTodoList,
  }))
}

----------------------------------------

TITLE: Fetching GitHub Repository Data with TanStack Query in Angular
DESCRIPTION: This snippet demonstrates how to use TanStack Query in an Angular component to fetch GitHub repository data. It includes error handling, loading state, and data display using Angular's template syntax.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/overview.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import { ChangeDetectionStrategy, Component, inject } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { CommonModule } from '@angular/common'
import { injectQuery } from '@tanstack/angular-query-experimental'
import { lastValueFrom } from 'rxjs'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'simple-example',
  standalone: true,
  template: `
    @if (query.isPending()) {
      Loading...
    }
    @if (query.error()) {
      An error has occurred: {{ query.error().message }}
    }
    @if (query.data(); as data) {
      <h1>{{ data.name }}</h1>
      <p>{{ data.description }}</p>
      <strong>üëÄ {{ data.subscribers_count }}</strong>
      <strong>‚ú® {{ data.stargazers_count }}</strong>
      <strong>üç¥ {{ data.forks_count }}</strong>
    }
  `
})
export class SimpleExampleComponent {
  http = inject(HttpClient)

  query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      lastValueFrom(
        this.http.get<Response>('https://api.github.com/repos/tanstack/query'),
      ),
  }))
}

interface Response {
  name: string
  description: string
  subscribers_count: number
  stargazers_count: number
  forks_count: number
}

----------------------------------------

TITLE: Implementing Basic Mutation with UI Updates in React Query
DESCRIPTION: Example of creating a mutation that adds a todo item with optimistic UI updates using the mutation's variables and pending state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const addTodoMutation = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation

----------------------------------------

TITLE: Optimistic Updates with Cache Manipulation
DESCRIPTION: Example of updating a list of todos with optimistic updates using cache manipulation and rollback functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
const queryClient = useQueryClient()

useMutation({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Snapshot the previous value
    const previousTodos = queryClient.getQueryData(['todos'])

    // Optimistically update to the new value
    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])

    // Return a context object with the snapshotted value
    return { previousTodos }
  },
  // If the mutation fails,
  // use the context returned from onMutate to roll back
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(['todos'], context.previousTodos)
  },
  // Always refetch after error or success:
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

----------------------------------------

TITLE: Immutable Updates with setQueryData in TanStack Query
DESCRIPTION: This snippet illustrates the correct way to perform immutable updates when using setQueryData in TanStack Query. It contrasts an incorrect mutable approach with the correct immutable update method.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
queryClient.setQueryData(['posts', { id }], (oldData) => {
  if (oldData) {
    // ‚ùå do not try this
    oldData.title = 'my new post title'
  }
  return oldData
})

queryClient.setQueryData(
  ['posts', { id }],
  // ‚úÖ this is the way
  (oldData) =>
    oldData
      ? {
          ...oldData,
          title: 'my new post title',
        }
      : oldData,
)

----------------------------------------

TITLE: Implementing Default Query Function with Vue Query Plugin
DESCRIPTION: Shows how to define a default query function that works with axios, configure it in Vue Query Plugin options, and use it in queries. The function automatically handles GET requests to JSONPlaceholder API based on the provided query key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/default-query-function.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// Define a default query function that will receive the query key
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: { queries: { queryFn: defaultQueryFn } },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

// All you have to do now is pass a key!
const { status, data, error, isFetching } = useQuery({
  queryKey: [`/posts/${postId}`],
})

----------------------------------------

TITLE: Implementing Query Functions in TanStack Query (TSX)
DESCRIPTION: Demonstrates various ways to implement query functions using useQuery hook in TanStack Query. These examples show different approaches to fetching data, including using standalone functions and inline async functions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const data = await fetchTodoById(todoId)
    return data
  },
})
useQuery({
  queryKey: ['todos', todoId],
  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
})

----------------------------------------

TITLE: Implementing Type-Safe GraphQL Queries with React Query
DESCRIPTION: Demonstrates how to create a type-safe GraphQL query using React Query, graphql-request, and GraphQL Code Generator. The example shows a query to fetch film data with typed variables and response data. Uses the Star Wars API as an example endpoint.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/graphql.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import request from 'graphql-request'
import { useQuery } from '@tanstack/react-query'

import { graphql } from './gql/gql'

const allFilmsWithVariablesQueryDocument = graphql(/* GraphQL */ `
  query allFilmsWithVariablesQuery($first: Int!) {
    allFilms(first: $first) {
      edges {
        node {
          id
          title
        }
      }
    }
  }
`)

function App() {
  // `data` is fully typed!
  const { data } = useQuery({
    queryKey: ['films'],
    queryFn: async () =>
      request(
        'https://swapi-graphql.netlify.app/.netlify/functions/index',
        allFilmsWithVariablesQueryDocument,
        // variables are type-checked too!
        { first: 10 },
      ),
  })
  // ...
}

----------------------------------------

TITLE: Fetch API Implementation with Error Handling
DESCRIPTION: Demonstrates using the Fetch API within a query function, including checking for a successful response and throwing an error for non-OK responses. Shows how to properly convert the response to JSON.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
todos = injectQuery(() => ({
  queryKey: ['todos', todoId()],
  queryFn: async () => {
    const response = await fetch('/todos/' + todoId)
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()
  },
}))

----------------------------------------

TITLE: Flattening Nested Component Waterfall in React Query
DESCRIPTION: This example shows how to flatten a nested component waterfall by hoisting the child component's query to the parent. This allows both queries to run in parallel, improving performance.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
function Article({ id }) {
  const { data: articleData, isPending: articlePending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  const { data: commentsData, isPending: commentsPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  if (articlePending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      {commentsPending ? (
        'Loading comments...'
      ) : (
        <Comments commentsData={commentsData} />
      )}
    </>
  )
}

----------------------------------------

TITLE: Infinite Query Template with Loading and Error States in Angular
DESCRIPTION: The HTML template that pairs with the infinite query component. It handles different states of the query (loading, error, success) and displays project data with a load more button.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-16_snippet_1

LANGUAGE: angular-html
CODE:
<div>
  @if (query.isPending()) {
  <p>Loading...</p>
  } @else if (query.isError()) {
  <span>Error: {{ query?.error().message }}</span>
  } @else { @for (page of query?.data().pages; track $index) { @for (project of
  page.data; track project.id) {
  <p>{{ project.name }} {{ project.id }}</p>
  } }
  <div>
    <button (click)="query.fetchNextPage()" [disabled]="nextButtonDisabled()">
      {{ nextButtonText() }}
    </button>
  </div>
  }
</div>

----------------------------------------

TITLE: Basic Mutation Component with Status Handling in Angular
DESCRIPTION: Demonstrates a basic mutation implementation in an Angular component with status indicators for pending, error and success states. Uses injectMutation to create a todo item.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_0

LANGUAGE: angular-ts
CODE:
@Component({
  template: `
    <div>
      @if (mutation.isPending()) {
        <span>Adding todo...</span>
      } @else if (mutation.isError()) {
        <div>An error occurred: {{ mutation.error()?.message }}</div>
      } @else if (mutation.isSuccess()) {
        <div>Todo added!</div>
      }
      <button (click)="mutation.mutate(1)">Create Todo</button>
    </div>
  `,
})
export class TodosComponent {
  todoService = inject(TodoService)
  mutation = injectMutation(() => ({
    mutationFn: (todoId: number) =>
      lastValueFrom(this.todoService.create(todoId)),
  }))
}

----------------------------------------

TITLE: Optimistic Updates with Rollback in React Query Mutations
DESCRIPTION: This example shows how to implement optimistic updates in React Query mutations. It updates the cache immediately on mutation call, then rolls back if the mutation fails. The onMutate callback is used to capture previous state for potential rollback.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/updates-from-mutation-responses.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
const mutation = useMutation(editTodo, {
  onMutate: async (newTodo) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries(['todos', newTodo.id])
    // Snapshot the previous value
    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])
    // Optimistically update to the new value
    queryClient.setQueryData(['todos', newTodo.id], newTodo)
    // Return a context object with the snapshotted value
    return { previousTodo }
  },
  onError: (err, newTodo, context) => {
    // If mutation fails, use context to roll back
    queryClient.setQueryData(['todos', newTodo.id], context.previousTodo)
  },
  onSettled: (newTodo) => {
    // Always refetch after error or success
    queryClient.invalidateQueries(['todos', newTodo.id])
  },
})

----------------------------------------

TITLE: Additional Mutation Callbacks
DESCRIPTION: Shows how to add additional callbacks when calling mutate function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: addTodo,
  onSuccess: (data, variables, context) => {
    // I will fire first
  },
  onError: (error, variables, context) => {
    // I will fire first
  },
  onSettled: (data, error, variables, context) => {
    // I will fire first
  },
})

mutate(todo, {
  onSuccess: (data, variables, context) => {
    // I will fire second!
  },
  onError: (error, variables, context) => {
    // I will fire second!
  },
  onSettled: (data, error, variables, context) => {
    // I will fire second!
  },
})

----------------------------------------

TITLE: Implementing Limited Infinite Query with Max Pages
DESCRIPTION: This example shows how to limit the number of pages stored in the query data using the maxPages option, which can improve performance for large datasets.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_7

LANGUAGE: tsx
CODE:
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
  maxPages: 3,
})

----------------------------------------

TITLE: Deriving Placeholder Data from Cache in TanStack Query with Angular
DESCRIPTION: This example shows how to derive placeholder data from existing cached query results. It finds a related item from a list query to use as placeholder data for a detail query, providing a seamless user experience when navigating between list and detail views.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
export class BlogPostComponent {
  // Until Angular supports signal-based inputs, we have to set a signal
  @Input({ required: true, alias: 'postId' })
  set _postId(value: number) {
    this.postId.set(value)
  }
  postId = signal(0)
  queryClient = inject(QueryClient)

  result = injectQuery(() => ({
    queryKey: ['blogPost', this.postId()],
    queryFn: () => fetch(`/blogPosts/${this.postId()}`),
    placeholderData: () => {
      // Use the smaller/preview version of the blogPost from the 'blogPosts'
      // query as the placeholder data for this blogPost query
      return queryClient
        .getQueryData(['blogPosts'])
        ?.find((d) => d.id === this.postId())
    },
  }))
}

----------------------------------------

TITLE: Initializing useQuery Hook in Solid Query
DESCRIPTION: This snippet demonstrates the structure and available options for the useQuery hook. It shows all possible return values and configuration options that can be passed to the hook.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  refetch,
  status,
} = useQuery(
  () => ({
    queryKey,
    queryFn,
    enabled,
    select,
    placeholderData,
    deferStream,
    reconcile,
    gcTime,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    staleTime,
    throwOnError,
  }),
  () => queryClient,
)

----------------------------------------

TITLE: Implementing Basic Filtering with TanStack Query in React
DESCRIPTION: This code snippet demonstrates how to implement basic filtering functionality using TanStack Query in a React application. It shows the setup of a filter state, a query function that incorporates the filter, and the integration with UI components.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/filters.md#2025-04-16_snippet_0

LANGUAGE: jsx
CODE:
import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'

function App() {
  const [filter, setFilter] = useState('')
  const { data } = useQuery({
    queryKey: ['todos', filter],
    queryFn: () =>
      fetch('/api/data?filter=' + filter).then((response) =>
        response.json(),
      ),
  })

  return (
    <div>
      <input value={filter} onChange={(e) => setFilter(e.target.value)} />
      {data.map((row) => (
        <div key={row.id}>{row.title}</div>
      ))}
    </div>
  )
}

----------------------------------------

TITLE: Advanced Mutation with Optimistic Updates
DESCRIPTION: Comprehensive example showing mutation defaults, optimistic updates, offline support, and hydration/dehydration of mutation state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_8

LANGUAGE: typescript
CODE:
const queryClient = new QueryClient()

// Define the "addTodo" mutation
queryClient.setMutationDefaults(['addTodo'], {
  mutationFn: addTodo,
  onMutate: async (variables) => {
    // Cancel current queries for the todos list
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Create optimistic todo
    const optimisticTodo = { id: uuid(), title: variables.title }

    // Add optimistic todo to todos list
    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])

    // Return context with the optimistic todo
    return { optimisticTodo }
  },
  onSuccess: (result, variables, context) => {
    // Replace optimistic todo in the todos list with the result
    queryClient.setQueryData(['todos'], (old) =>
      old.map((todo) =>
        todo.id === context.optimisticTodo.id ? result : todo,
      ),
    )
  },
  onError: (error, variables, context) => {
    // Remove optimistic todo from the todos list
    queryClient.setQueryData(['todos'], (old) =>
      old.filter((todo) => todo.id !== context.optimisticTodo.id),
    )
  },
  retry: 3,
})

class someComponent {
  // Start mutation in some component:
  mutation = injectMutation(() => ({ mutationKey: ['addTodo'] }))

  someMethod() {
    mutation.mutate({ title: 'title' })
  }
}

// If the mutation has been paused because the device is for example offline,
// Then the paused mutation can be dehydrated when the application quits:
const state = dehydrate(queryClient)

// The mutation can then be hydrated again when the application is started:
hydrate(queryClient, state)

// Resume the paused mutations:
queryClient.resumePausedMutations()

----------------------------------------

TITLE: Using useInfiniteQuery Hook in React with TanStack Query
DESCRIPTION: This snippet demonstrates how to use the useInfiniteQuery hook to implement infinite scrolling or pagination. It shows the destructured return values and the basic configuration options including queryKey, queryFn, initialPageParam, and methods for getting next and previous page parameters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useInfiniteQuery.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const {
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
  promise,
  ...result
} = useInfiniteQuery({
  queryKey,
  queryFn: ({ pageParam }) => fetchPage(pageParam),
  initialPageParam: 1,
  ...options,
  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
    lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
    firstPage.prevCursor,
})

----------------------------------------

TITLE: Using Angular HttpClient with TanStack Query in TypeScript
DESCRIPTION: This snippet demonstrates how to use Angular's HttpClient within a TanStack Query queryFn. It shows the conversion of an HttpClient observable to a promise using lastValueFrom from rxjs.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/angular-httpclient-and-other-data-fetching-clients.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
@Component({
  // ...
})
class ExampleComponent {
  private readonly http = inject(HttpClient)

  readonly query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      lastValueFrom(
        this.http.get('https://api.github.com/repos/tanstack/query'),
      ),
  }))
}

----------------------------------------

TITLE: Using queryClient.invalidateQueries
DESCRIPTION: The invalidateQueries method invalidates and optionally refetches queries based on query keys or other properties. Options control whether active/inactive queries are refetched.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_11

LANGUAGE: tsx
CODE:
await queryClient.invalidateQueries(
  {
    queryKey: ['posts'],
    exact,
    refetchType: 'active',
  },
  { throwOnError, cancelRefetch },
)

----------------------------------------

TITLE: Implementing Custom Hook with Select Option in React Query
DESCRIPTION: This snippet demonstrates how to create a custom hook using React Query's useQuery hook with a select option. It shows how to select a subset of data and create a specialized hook for counting todos.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
export const useTodos = (select) => {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select,
  })
}

export const useTodoCount = () => {
  return useTodos((data) => data.length)
}

----------------------------------------

TITLE: Implementing Query Cancellation with Fetch in TanStack Query
DESCRIPTION: This snippet demonstrates how to use the AbortSignal with fetch in a TanStack Query queryFn. It shows passing the signal to both single and multiple fetch calls within the same query function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const todosResponse = await fetch('/todos', {
      // Pass the signal to one fetch
      signal,
    })
    const todos = await todosResponse.json()

    const todoDetails = todos.map(async ({ details }) => {
      const response = await fetch(details, {
        // Or pass it to several
        signal,
      })
      return response.json()
    })

    return Promise.all(todoDetails)
  },
})

----------------------------------------

TITLE: Type Narrowing in React Query with TypeScript
DESCRIPTION: Shows how to use TypeScript's discriminated union types to narrow the query result based on the status field.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/typescript.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const { data, isSuccess } = useQuery({
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})

if (isSuccess) {
  data
  //  ^? const data: number
}

----------------------------------------

TITLE: Implementing Dependent Queries with Solid Query
DESCRIPTION: This snippet demonstrates how to create a dependent query using Solid Query. It shows a query for a user that depends on the result of a query for a project ID. The user query is only executed when the project ID is available.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/dependent-queries.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
const { data: projectId } = useQuery(() => ['project'], fetchProjectId)

const { data: user } = useQuery(() => ['user', projectId], fetchUser, {
  // The query will not execute until the projectId exists
  enabled: !!projectId,
})

----------------------------------------

TITLE: Demonstrating Deterministic Hashing of Query Keys in TanStack Query (TSX)
DESCRIPTION: Illustrates that query keys are hashed deterministically, meaning that the order of keys in objects doesn't affect equality. All examples in this snippet are considered equal.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
useQuery({ queryKey: ['todos', { status, page }], ... })
useQuery({ queryKey: ['todos', { page, status }], ...})
useQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })

----------------------------------------

TITLE: Complete GitHub Repository Query Example
DESCRIPTION: Demonstrates a full example of querying GitHub repository data using TanStack Query with SolidJS, showing proper store usage and reactive data handling.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
function Example() {
  const query = useQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
        (res) => res.json(),
      ),
  }))

  return (
    <Switch>
      <Match when={query.isPending}>Loading...</Match>
      <Match when={query.isError}>Error: {query.error.message}</Match>
      <Match when={query.isSuccess}>
        <div>
          <h1>{query.data.name}</h1>
          <p>{query.data.description}</p>
          <strong>üëÄ {query.data.subscribers_count}</strong>{' '}
          <strong>‚ú® {query.data.stargazers_count}</strong>{' '}
          <strong>üç¥ {query.data.forks_count}</strong>
        </div>
      </Match>
    </Switch>
  )

----------------------------------------

TITLE: Basic TanStack Query Setup with SolidJS
DESCRIPTION: Demonstrates the basic setup of TanStack Query in a SolidJS application with a simple todo list example. Shows QueryClient initialization and basic query usage with loading/error states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/solid-query'
import { Switch, Match, For } from 'solid-js'

const queryClient = new QueryClient()

function Example() {
  const query = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))

  return (
    <div>
      <Switch>
        <Match when={query.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={query.isError}>
          <p>Error: {query.error.message}</p>
        </Match>
        <Match when={query.isSuccess}>
          <For each={query.data}>{(todo) => <p>{todo.title}</p>}</For>
        </Match>
      </Switch>
    </div>
  )
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Fixing Serial Queries with useSuspenseQueries in React Query
DESCRIPTION: This example demonstrates how to use useSuspenseQueries to execute multiple suspense queries in parallel, avoiding the serial execution waterfall that occurs with individual useSuspenseQuery calls.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({
  queries: [
    { queryKey: ['users'], queryFn: fetchUsers },
    { queryKey: ['teams'], queryFn: fetchTeams },
    { queryKey: ['projects'], queryFn: fetchProjects },
  ],
})

----------------------------------------

TITLE: Basic Query Prefetching in TypeScript
DESCRIPTION: Demonstrates how to use prefetchQuery to cache todos data ahead of time. Shows basic usage of the queryClient prefetch functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const prefetchTodos = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })
}

----------------------------------------

TITLE: Type Inference in React Query with TypeScript
DESCRIPTION: Demonstrates how React Query automatically infers types from the queryFn return value and select function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/typescript.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const { data } = useQuery({
  //    ^? const data: number | undefined
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})

LANGUAGE: tsx
CODE:
const { data } = useQuery({
  //      ^? const data: string | undefined
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
})

LANGUAGE: tsx
CODE:
const fetchGroups = (): Promise<Group[]> =>
  axios.get('/groups').then((response) => response.data)

const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const data: Group[] | undefined

----------------------------------------

TITLE: Accessing Mutation Data by MutationKey
DESCRIPTION: Demonstrates how to access mutation data for specific mutations using mutationKey filters and combining useMutation with useMutationState.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useMutationState.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { useMutation, useMutationState } from '@tanstack/react-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})

----------------------------------------

TITLE: Including Dependent Variables in Query Keys for TanStack Query (TSX)
DESCRIPTION: Demonstrates the importance of including variables that the query function depends on in the query key. This ensures proper caching and automatic refetching when variables change.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
function Todos({ todoId }) {
  const result = useQuery({
    queryKey: ['todos', todoId],
    queryFn: () => fetchTodoById(todoId),
  })
}

----------------------------------------

TITLE: Initializing Mutation Function for Adding Todo in Angular Query
DESCRIPTION: This snippet demonstrates how to set up a mutation function for adding a todo item using Angular Query. It includes the mutation function, API call, and query invalidation for data refetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
addTodo = injectMutation(() => ({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: async () => {
    return await queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
}))

----------------------------------------

TITLE: Demonstrating Inequality in Query Keys with Different Array Orders (TSX)
DESCRIPTION: Shows examples of query keys that are not considered equal due to different array item orders, emphasizing that array order matters in query keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
useQuery({ queryKey: ['todos', status, page], ... })
useQuery({ queryKey: ['todos', page, status], ...})
useQuery({ queryKey: ['todos', undefined, page, status], ...})

----------------------------------------

TITLE: SolidJS Suspense Integration with TanStack Query
DESCRIPTION: Shows how to properly use Suspense boundaries with TanStack Query in SolidJS, demonstrating both correct and incorrect implementations of data access within Suspense boundaries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { For, Suspense } from 'solid-js'

function Example() {
  const query = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))
  return (
    <div>
      <Suspense fallback={'Loading...'}>
        <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
      </Suspense>
      <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
    </div>
  )
}

----------------------------------------

TITLE: Initializing React Query Provider with Server Components
DESCRIPTION: Sets up a QueryClientProvider with specific server-side rendering configurations. Handles both server and browser environments while maintaining a singleton query client instance on the browser.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    return makeQueryClient()
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

----------------------------------------

TITLE: Implementing Paginated Queries with TanStack Query in Vue.js
DESCRIPTION: This Vue.js component demonstrates paginated queries using TanStack Query. It fetches posts from JSONPlaceholder API, displays them in a list, and provides pagination controls. The component uses the keepPreviousData option to maintain previous results while fetching new data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/paginated-queries.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup lang="ts">
import { ref, Ref } from 'vue'
import { useQuery, keepPreviousData } from '@tanstack/vue-query'

const fetcher = (page: Ref<number>) =>
  fetch(
    `https://jsonplaceholder.typicode.com/posts?_page=${page.value}&_limit=10`,
  ).then((response) => response.json())

const page = ref(1)
const { isPending, isError, data, error, isFetching, isPlaceholderData } =
  useQuery({
    queryKey: ['projects', page],
    queryFn: () => fetcher(page),
    placeholderData: keepPreviousData,
  })
const prevPage = () => {
  page.value = Math.max(page.value - 1, 1)
}
const nextPage = () => {
  if (!isPlaceholderData.value) {
    page.value = page.value + 1
  }
}
</script>

<template>
  <h1>Posts</h1>
  <p>Current Page: {{ page }} | Previous data: {{ isPlaceholderData }}</p>
  <button @click="prevPage">Prev Page</button>
  <button @click="nextPage">Next Page</button>
  <div v-if="isPending">Loading...</div>
  <div v-else-if="isError">An error has occurred: {{ error }}</div>
  <div v-else-if="data">
    <ul>
      <li v-for="item in data" :key="item.id">
        {{ item.title }}
      </li>
    </ul>
  </div>
</template>

----------------------------------------

TITLE: Updating Multiple Queries After Mutation in Solid Query
DESCRIPTION: This snippet illustrates how to update multiple queries after a successful mutation in Solid Query. It updates both the list of todos and a specific todo item.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/updates-from-mutation-responses.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
const mutation = useMutation(() => updateTodo, {
  onSuccess: (data, variables) => {
    queryClient.setQueryData(['todos'], (old) =>
      old.map((todo) => (todo.id === variables.id ? data : todo)),
    )
    queryClient.setQueryData(['todo', variables.id], data)
  },
})

----------------------------------------

TITLE: Mutation Side Effects Callbacks
DESCRIPTION: Shows implementation of mutation lifecycle callbacks including onMutate, onError, onSuccess, and onSettled.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: addTodo,
  onMutate: (variables) => {
    // A mutation is about to happen!

    // Optionally return a context containing data to use when for example rolling back
    return { id: 1 }
  },
  onError: (error, variables, context) => {
    // An error happened!
    console.log(`rolling back optimistic update with id ${context.id}`)
  },
  onSuccess: (data, variables, context) => {
    // Boom baby!
  },
  onSettled: (data, error, variables, context) => {
    // Error or success... doesn't matter!
  },
})

----------------------------------------

TITLE: Optimizing Dependent Queries with Conditional Prefetching in React
DESCRIPTION: This snippet shows how to optimize dependent queries using conditional prefetching in React. It prefetches graph data for relevant feed items within the query function, improving performance by loading code and data in parallel.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
function Feed() {
  const queryClient = useQueryClient()
  const { data, isPending } = useQuery({
    queryKey: ['feed'],
    queryFn: async (...args) => {
      const feed = await getFeed(...args)

      for (const feedItem of feed) {
        if (feedItem.type === 'GRAPH') {
          queryClient.prefetchQuery({
            queryKey: ['graph', feedItem.id],
            queryFn: getGraphDataById,
          })
        }
      }

      return feed
    }
  })

  ...
}

----------------------------------------

TITLE: Implementing Basic Infinite Query Component in Angular
DESCRIPTION: A complete Angular component implementing infinite queries with UI controls. This example shows how to configure the query with page parameters, handle loading/error states, and implement a load more button with reactive disabled state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-16_snippet_0

LANGUAGE: angular-ts
CODE:
import { Component, computed, inject } from '@angular/core'
import { injectInfiniteQuery } from '@tanstack/angular-query-experimental'
import { lastValueFrom } from 'rxjs'
import { ProjectsService } from './projects-service'

@Component({
  selector: 'example',
  templateUrl: './example.component.html',
})
export class Example {
  projectsService = inject(ProjectsService)

  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
    initialPageParam: 0,
    getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
    getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
    maxPages: 3,
  }))

  nextButtonDisabled = computed(
    () => !this.#hasNextPage() || this.#isFetchingNextPage(),
  )
  nextButtonText = computed(() =>
    this.#isFetchingNextPage()
      ? 'Loading more...'
      : this.#hasNextPage()
        ? 'Load newer'
        : 'Nothing more to load',
  )

  #hasNextPage = this.query.hasNextPage
  #isFetchingNextPage = this.query.isFetchingNextPage
}

----------------------------------------

TITLE: Updating API Calls to Single Object Signature in TanStack Query v5
DESCRIPTION: This snippet demonstrates the migration from multiple parameter signatures to a single object parameter for various TanStack Query v5 API calls. It includes examples for useQuery, useInfiniteQuery, useMutation, and other related functions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
useQuery(key, fn, options) // [!code --]
useQuery({ queryKey, queryFn, ...options }) // [!code ++]
useInfiniteQuery(key, fn, options) // [!code --]
useInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
useMutation(fn, options) // [!code --]
useMutation({ mutationFn, ...options }) // [!code ++]
useIsFetching(key, filters) // [!code --]
useIsFetching({ queryKey, ...filters }) // [!code ++]
useIsMutating(key, filters) // [!code --]
useIsMutating({ mutationKey, ...filters }) // [!code ++]

----------------------------------------

TITLE: Configuring Network Mode in TanStack Query for React
DESCRIPTION: This snippet demonstrates how to configure the network mode for TanStack Query in a React application. It shows setting the mode to 'online' or 'always' at the QueryClient level.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/network-mode.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      networkMode: 'online',
    },
    mutations: {
      networkMode: 'online',
    },
  },
})

----------------------------------------

TITLE: Implementing Query Cancellation with XMLHttpRequest in TanStack Query
DESCRIPTION: This example illustrates how to use the AbortSignal with XMLHttpRequest in a TanStack Query queryFn. It sets up event listeners for both load and abort events to handle successful responses and cancellations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    return new Promise((resolve, reject) => {
      var oReq = new XMLHttpRequest()
      oReq.addEventListener('load', () => {
        resolve(JSON.parse(oReq.responseText))
      })
      signal?.addEventListener('abort', () => {
        oReq.abort()
        reject()
      })
      oReq.open('GET', '/todos')
      oReq.send()
    })
  },
})

----------------------------------------

TITLE: Query Cancellation with Fetch API
DESCRIPTION: Demonstrates how to implement query cancellation using the Fetch API by passing the abort signal to multiple fetch requests.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
query = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const todosResponse = await fetch('/todos', {
      // Pass the signal to one fetch
      signal,
    })
    const todos = await todosResponse.json()

    const todoDetails = todos.map(async ({ details }) => {
      const response = await fetch(details, {
        // Or pass it to several
        signal,
      })
      return response.json()
    })

    return Promise.all(todoDetails)
  },
}))

----------------------------------------

TITLE: Using useSuspenseInfiniteQuery Hook in React TypeScript
DESCRIPTION: Demonstrates the basic usage of useSuspenseInfiniteQuery hook. This hook is a Suspense-enabled version of useInfiniteQuery that guarantees defined data and simplified status states. It excludes options like suspense, throwOnError, enabled, and placeholderData from the standard useInfiniteQuery hook.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useSuspenseInfiniteQuery.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const result = useSuspenseInfiniteQuery(options)

----------------------------------------

TITLE: PlaceholderData Identity Function Example
DESCRIPTION: Demonstrates the implementation of a placeholderData identity function that preserves previous query data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_10

LANGUAGE: ts
CODE:
useQuery({
  queryKey,
  queryFn,
  placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`
})

----------------------------------------

TITLE: Implementing Simplified Optimistic Updates in React
DESCRIPTION: Shows how to perform optimistic updates using the new simplified approach in TanStack Query v5.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_15

LANGUAGE: tsx
CODE:
const queryInfo = useTodos()
const addTodoMutation = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
})

if (queryInfo.data) {
  return (
    <ul>
      {queryInfo.data.items.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
      {addTodoMutation.isPending && (
        <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>
          {addTodoMutation.variables}
        </li>
      )}
    </ul>
  )
}

----------------------------------------

TITLE: Initializing Streamed Query with TanStack Query
DESCRIPTION: Demonstrates how to create a query function that streams data using streamedQuery helper. The query will remain in a pending state until the first chunk arrives, then transition to success while continuing to fetch until the stream ends.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/streamedQuery.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const query = queryOptions({
  queryKey: ['data'],
  queryFn: streamedQuery({
    queryFn: fetchDataInChunks,
  }),
})

----------------------------------------

TITLE: Implementing Background Fetching Indicator for Individual Query in React with TanStack Query
DESCRIPTION: This snippet demonstrates how to use the 'isFetching' boolean to display a background fetching indicator for an individual query. It shows a 'Refreshing...' message when data is being fetched in the background.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/background-fetching-indicators.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
function Todos() {
  const {
    status,
    data: todos,
    error,
    isFetching,
  } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })

  return status === 'pending' ? (
    <span>Loading...</span>
  ) : status === 'error' ? (
    <span>Error: {error.message}</span>
  ) : (
    <>
      {isFetching ? <div>Refreshing...</div> : null}

      <div>
        {todos.map((todo) => (
          <Todo todo={todo} />
        ))}
      </div>
    </>
  )
}

----------------------------------------

TITLE: Configuring Vue Query Plugin for Nuxt 3
DESCRIPTION: Sets up the Vue Query plugin for Nuxt 3, including hydration and dehydration of query state. It creates a QueryClient with default options and handles server-side rendering.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import type {
  DehydratedState,
  VueQueryPluginOptions,
} from '@tanstack/vue-query'
import {
  VueQueryPlugin,
  QueryClient,
  hydrate,
  dehydrate,
} from '@tanstack/vue-query'
// Nuxt 3 app aliases
import { defineNuxtPlugin, useState } from '#imports'

export default defineNuxtPlugin((nuxt) => {
  const vueQueryState = useState<DehydratedState | null>('vue-query')

  // Modify your Vue Query global settings here
  const queryClient = new QueryClient({
    defaultOptions: { queries: { staleTime: 5000 } },
  })
  const options: VueQueryPluginOptions = { queryClient }

  nuxt.vueApp.use(VueQueryPlugin, options)

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      vueQueryState.value = dehydrate(queryClient)
    })
  }

  if (import.meta.client) {
    hydrate(queryClient, vueQueryState.value)
  }
})

----------------------------------------

TITLE: Testing Basic React Query Hook
DESCRIPTION: Example showing how to test a custom React Query hook using renderHook and QueryClientProvider wrapper.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
import { renderHook, waitFor } from '@testing-library/react'

const queryClient = new QueryClient()
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

const { result } = renderHook(() => useCustomHook(), { wrapper })

await waitFor(() => expect(result.current.isSuccess).toBe(true))

expect(result.current.data).toEqual('Hello')

----------------------------------------

TITLE: Using Stable Function Reference for Select in React Query
DESCRIPTION: This snippet demonstrates an alternative approach to optimizing the select function in React Query by extracting it to a stable function reference. This method is useful when the select function doesn't have any dependencies.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
const selectTodoCount = (data) => data.length

export const useTodoCount = () => {
  return useTodos(selectTodoCount)
}

----------------------------------------

TITLE: Integrating TanStack Router with React Query for Data Prefetching
DESCRIPTION: This snippet demonstrates how to integrate TanStack Router with React Query for data prefetching. It configures an article route to prefetch article data and comments, showing how to block rendering until critical data is loaded.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_7

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient()
const routerContext = new RouterContext()
const rootRoute = routerContext.createRootRoute({
  component: () => { ... }
})

const articleRoute = new Route({
  getParentRoute: () => rootRoute,
  path: 'article',
  beforeLoad: () => {
    return {
      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },
      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },
    }
  },
  loader: async ({
    context: { queryClient },
    routeContext: { articleQueryOptions, commentsQueryOptions },
  }) => {
    // Fetch comments asap, but don't block
    queryClient.prefetchQuery(commentsQueryOptions)

    // Don't render the route at all until article has been fetched
    await queryClient.prefetchQuery(articleQueryOptions)
  },
  component: ({ useRouteContext }) => {
    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()
    const articleQuery = useQuery(articleQueryOptions)
    const commentsQuery = useQuery(commentsQueryOptions)

    return (
      ...
    )
  },
  errorComponent: () => 'Oh crap!',
})

----------------------------------------

TITLE: Implementing QueryErrorResetBoundary with ErrorBoundary in React
DESCRIPTION: This snippet demonstrates how to use QueryErrorResetBoundary from TanStack Query in combination with ErrorBoundary from react-error-boundary. It sets up error handling for queries, allowing errors to be reset and the query to be retried.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/QueryErrorResetBoundary.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => (
  <QueryErrorResetBoundary>
    {({ reset }) => (
      <ErrorBoundary
        onReset={reset}
        fallbackRender={({ resetErrorBoundary }) => (
          <div>
            There was an error!
            <Button onClick={() => resetErrorBoundary()}>Try again</Button>
          </div>
        )}
      >
        <Page />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
)

----------------------------------------

TITLE: Form-based Mutation with Reactive Forms
DESCRIPTION: Shows integration of mutations with Angular's reactive forms. Includes form validation and error handling with reset capability.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_1

LANGUAGE: angular-ts
CODE:
@Component({
  standalone: true,
  selector: 'todo-item',
  imports: [ReactiveFormsModule],
  template: `
    <form [formGroup]="todoForm" (ngSubmit)="onCreateTodo()">
      @if (mutation.error()) {
        <h5 (click)="mutation.reset()">{{ mutation.error() }}</h5>
      }
      <input type="text" formControlName="title" />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  `,
})
export class TodosComponent {
  mutation = injectMutation(() => ({
    mutationFn: createTodo,
  }))

  fb = inject(NonNullableFormBuilder)

  todoForm = this.fb.group({
    title: this.fb.control('', {
      validators: [Validators.required],
    }),
  })

  title = toSignal(this.todoForm.controls.title.valueChanges, {
    initialValue: '',
  })

  onCreateTodo = () => {
    this.mutation.mutate(this.title())
  }
}

----------------------------------------

TITLE: Using queryOptions with TypeScript in TanStack/query
DESCRIPTION: Example showing how to use queryOptions() to create type-safe query configuration. The queryKey is tagged with the type from queryFn, allowing TypeScript to infer the correct type when retrieving query data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
const { queryKey } = queryOptions({
  queryKey: ['key'],
  queryFn: () => Promise.resolve(5),
  //  ^?  Promise<number>
})

const queryClient = new QueryClient()
const data = queryClient.getQueryData(queryKey)
//    ^?  number | undefined

----------------------------------------

TITLE: Implementing Infinite Query without API Cursor
DESCRIPTION: This example demonstrates how to implement an infinite query when the API doesn't return a cursor. It uses the pageParam to calculate the next and previous page parameters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_8

LANGUAGE: tsx
CODE:
return useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    if (lastPage.length === 0) {
      return undefined
    }
    return lastPageParam + 1
  },
  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
    if (firstPageParam <= 1) {
      return undefined
    }
    return firstPageParam - 1
  },
})

----------------------------------------

TITLE: Accessing QueryClient with useQueryClient Hook in React Query
DESCRIPTION: Demonstrates how to import and use the useQueryClient hook to access the QueryClient instance. The hook can either use the QueryClient from the nearest context or accept a custom QueryClient instance as an optional parameter.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useQueryClient.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useQueryClient } from '@tanstack/react-query'

const queryClient = useQueryClient(queryClient?: QueryClient)

----------------------------------------

TITLE: Basic Query Function Implementations with injectQuery
DESCRIPTION: Demonstrates several basic ways to implement query functions using injectQuery. Shows query key definition and various function styles for fetchTodoById, including direct calls, arrow functions, and using queryKey parameter.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchAllTodos }))
injectQuery(() => ({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) }))
injectQuery(() => ({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const data = await fetchTodoById(todoId)
    return data
  },
}))
injectQuery(() => ({
  queryKey: ['todos', todoId],
  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
}))

----------------------------------------

TITLE: Initial Data with Immediate Refetch in TanStack Query
DESCRIPTION: Example demonstrating how to provide initial data that will be shown immediately, while also triggering a background refetch when the component or service is initialized.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
// Will show initialTodos immediately, but also immediately refetch todos
// when an instance of the component or service is created
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
}))

----------------------------------------

TITLE: Updating Query Data with Mutation Response in React Query
DESCRIPTION: This snippet demonstrates how to use the onSuccess callback of a mutation to update the query data with the response from the mutation. It shows how to access the queryClient and use invalidateQueries to refetch the updated data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/updates-from-mutation-responses.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
const mutation = useMutation(editTodo, {
  onSuccess: (data, variables, context) => {
    // Query invalidation
    queryClient.invalidateQueries(['todos'])
    // Or update a particular todo
    queryClient.setQueryData(['todo', { id: variables.id }], data)
  },
})

----------------------------------------

TITLE: Basic Suspense Query Implementation in TypeScript
DESCRIPTION: Demonstrates how to use the useSuspenseQuery hook to enable Suspense mode for data fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useSuspenseQuery } from '@tanstack/react-query'

const { data } = useSuspenseQuery({ queryKey, queryFn })

----------------------------------------

TITLE: Next.js Page Route with React Query Hydration
DESCRIPTION: Implements server-side data fetching and hydration in a Next.js page route using getStaticProps. Shows how to prefetch queries and handle both server-prefetched and client-only queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
// pages/posts.tsx
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
  useQuery,
} from '@tanstack/react-query'

export async function getStaticProps() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  }
}

function Posts() {
  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })

  const { data: commentsData } = useQuery({
    queryKey: ['posts-comments'],
    queryFn: getComments,
  })

  // ...
}

export default function PostsRoute({ dehydratedState }) {
  return (
    <HydrationBoundary state={dehydratedState}>
      <Posts />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Using useSuspenseQueries Hook in TanStack Query
DESCRIPTION: Demonstrates the basic usage of useSuspenseQueries hook for handling multiple suspense-enabled queries. The hook returns query results with guaranteed defined data and simplified status states. Note that it excludes suspense, throwOnError, enabled, and placeholderData options from individual queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useSuspenseQueries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const result = useSuspenseQueries(options)

----------------------------------------

TITLE: Prefetching Query Data
DESCRIPTION: Shows how to prefetch query data before it's needed. Works similar to fetchQuery but doesn't throw or return data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
await queryClient.prefetchQuery({ queryKey, queryFn })

----------------------------------------

TITLE: Implementing Simple Query Keys in TanStack Query (TSX)
DESCRIPTION: Demonstrates the usage of simple query keys for generic list resources and non-hierarchical data. These keys are arrays with constant values.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-keys.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// A list of todos
useQuery({ queryKey: ['todos'], ... })

// Something else, whatever!
useQuery({ queryKey: ['something', 'special'], ... })

----------------------------------------

TITLE: Using Cached Data as Placeholder in TanStack Query
DESCRIPTION: This example demonstrates how to use cached data from one query as placeholder data for another in TanStack Query. It searches the cache for a preview version of a blog post to use as placeholder data for an individual post query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
function Todo({ blogPostId }) {
  const queryClient = useQueryClient()
  const result = useQuery({
    queryKey: ['blogPost', blogPostId],
    queryFn: () => fetch(`/blogPosts/${blogPostId}`),
    placeholderData: () => {
      // Use the smaller/preview version of the blogPost from the 'blogPosts'
      // query as the placeholder data for this blogPost query
      return queryClient
        .getQueryData(['blogPosts'])
        ?.find((d) => d.id === blogPostId)
    },
  })
}

----------------------------------------

TITLE: Using queryClient.setQueryData to Update Cache
DESCRIPTION: The setQueryData method is used to synchronously update a query's cached data. It accepts a queryKey and an updater (either a new value or a function that returns a new value based on old data).
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
queryClient.setQueryData(queryKey, updater)

----------------------------------------

TITLE: Implementing Static Parallel Queries in Angular
DESCRIPTION: Demonstrates how to execute multiple static queries in parallel using injectQuery. This example shows three simultaneous queries for users, teams, and projects data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/parallel-queries.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
export class AppComponent {
  // The following queries will execute in parallel
  usersQuery = injectQuery(() => ({ queryKey: ['users'], queryFn: fetchUsers }))
  teamsQuery = injectQuery(() => ({ queryKey: ['teams'], queryFn: fetchTeams }))
  projectsQuery = injectQuery(() => ({
    queryKey: ['projects'],
    queryFn: fetchProjects,
  }))
}

----------------------------------------

TITLE: Implementing Query Cancellation with TanStack Query in TypeScript
DESCRIPTION: Demonstrates how to implement query cancellation using TanStack Query. The example shows both the query setup with a signal parameter for fetch abortion and manual cancellation using queryClient.cancelQueries(). The signal parameter is automatically handled by the AbortController when cancellation is triggered.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/query-cancellation.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

function onButtonClick() {
  queryClient.cancelQueries({ queryKey: ['todos'] })
}

----------------------------------------

TITLE: Implementing Query-Specific Background Fetching Indicator in Vue
DESCRIPTION: This snippet demonstrates how to use the useQuery hook from TanStack Query to manage the state of a specific query and display loading, error, and success states in a Vue component. It shows how to handle different query states and render appropriate UI elements.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/background-fetching-indicators.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isFetching, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})
</script>

<template>
  <div v-if="isFetching">Refreshing...</div>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>

----------------------------------------

TITLE: Using Fetch API with TanStack Query (TSX)
DESCRIPTION: Demonstrates how to use the Fetch API with TanStack Query, including manual error throwing for unsuccessful HTTP responses. This is necessary because Fetch doesn't automatically throw errors for non-2xx status codes.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-functions.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const response = await fetch('/todos/' + todoId)
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()
  },
})

----------------------------------------

TITLE: Configuring Vue Query Plugin for Nuxt 2
DESCRIPTION: Sets up the Vue Query plugin for Nuxt 2, handling both server-side and client-side initialization. It creates a QueryClient and manages hydration of query state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
import Vue from 'vue'
import { VueQueryPlugin, QueryClient, hydrate } from '@tanstack/vue-query'

export default (context) => {
  // Modify your Vue Query global settings here
  const queryClient = new QueryClient({
    defaultOptions: { queries: { staleTime: 5000 } },
  })

  if (process.server) {
    context.ssrContext.VueQuery = queryClient
  }

  if (process.client) {
    Vue.use(VueQueryPlugin, { queryClient })

    if (context.nuxtState && context.nuxtState.vueQueryState) {
      hydrate(queryClient, context.nuxtState.vueQueryState)
    }
  }
}

----------------------------------------

TITLE: Implementing Dependent Queries with injectQuery in Angular Query
DESCRIPTION: This snippet demonstrates how to create dependent queries using injectQuery in Angular Query. It first queries for a user by email, then uses the returned user ID to query for the user's projects. The second query is only enabled when the user ID is available.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/dependent-queries.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
// Get the user
userQuery = injectQuery(() => ({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
}))

// Then get the user's projects
projectsQuery = injectQuery(() => ({
  queryKey: ['projects', this.userQuery.data()?.id],
  queryFn: getProjectsByUser,
  // The query will not execute until the user id exists
  enabled: !!this.userQuery.data()?.id,
}))

----------------------------------------

TITLE: Using queryClient.setQueriesData
DESCRIPTION: The setQueriesData method updates cached data for multiple queries by using a filter function or partially matching query keys. It calls setQueryData for each matching query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_10

LANGUAGE: tsx
CODE:
queryClient.setQueriesData(filters, updater)

----------------------------------------

TITLE: Configuring Query Options with TanStack Query in TypeScript
DESCRIPTION: This snippet demonstrates how to use the queryOptions function to set up query configurations. It allows passing a queryKey and additional options, which can include all parameters available in useQuery. The function also supports an experimental prefetch option.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/queryOptions.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
queryOptions({
  queryKey,
  ...options,
})

----------------------------------------

TITLE: Fetching User Data and Projects with Dependent Queries in React
DESCRIPTION: This snippet demonstrates how to use TanStack Query to fetch user data first, and then use that data to fetch the user's projects. It uses the 'enabled' option to control when the second query should execute.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/dependent-queries.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: () => getUserByEmail(email.value),
})

const userId = computed(() => user.value?.id)
const enabled = computed(() => !!user.value?.id)

// Then get the user's projects
const { isIdle, data: projects } = useQuery({
  queryKey: ['projects', userId],
  queryFn: () => getProjectsByUser(userId.value),
  enabled, // The query will not execute until `enabled == true`
})

----------------------------------------

TITLE: Creating a Reusable Mutation Hook in TanStack Query
DESCRIPTION: This example shows how to create a custom hook for a reusable mutation that updates the query cache on success. It uses the QueryClient's setQueryData method and accesses mutation variables.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const useMutateTodo = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: editTodo,
    // Notice the second argument is the variables object that the `mutate` function receives
    onSuccess: (data, variables) => {
      queryClient.setQueryData(['todo', { id: variables.id }], data)
    },
  })
}

----------------------------------------

TITLE: Synchronizing Queries with Initial Data from Cache in TanStack Query
DESCRIPTION: Example showing how to derive initial data for a single todo query from the cached data of a todos list query. This synchronizes data between related queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_5

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todo', this.todoId()],
  queryFn: () => fetch('/todos'),
  initialData: () => {
    // Use a todo from the 'todos' query as the initial data for this todo query
    return this.queryClient
      .getQueryData(['todos'])
      ?.find((d) => d.id === this.todoId())
  },
}))

----------------------------------------

TITLE: Persisting and Resuming Mutations in TanStack Query
DESCRIPTION: This snippet demonstrates how to persist mutations, dehydrate the query client state, hydrate it later, and resume paused mutations. It includes setting up mutation defaults, optimistic updates, and error handling.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_9

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient()

// Define the "addTodo" mutation
queryClient.setMutationDefaults(['addTodo'], {
  mutationFn: addTodo,
  onMutate: async (variables) => {
    // Cancel current queries for the todos list
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Create optimistic todo
    const optimisticTodo = { id: uuid(), title: variables.title }

    // Add optimistic todo to todos list
    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])

    // Return context with the optimistic todo
    return { optimisticTodo }
  },
  onSuccess: (result, variables, context) => {
    // Replace optimistic todo in the todos list with the result
    queryClient.setQueryData(['todos'], (old) =>
      old.map((todo) =>
        todo.id === context.optimisticTodo.id ? result : todo,
      ),
    )
  },
  onError: (error, variables, context) => {
    // Remove optimistic todo from the todos list
    queryClient.setQueryData(['todos'], (old) =>
      old.filter((todo) => todo.id !== context.optimisticTodo.id),
    )
  },
  retry: 3,
})

// Start mutation in some component:
const mutation = useMutation({ mutationKey: ['addTodo'] })
mutation.mutate({ title: 'title' })

// If the mutation has been paused because the device is for example offline,
// Then the paused mutation can be dehydrated when the application quits:
const state = dehydrate(queryClient)

// The mutation can then be hydrated again when the application is started:
hydrate(queryClient, state)

// Resume the paused mutations:
queryClient.resumePausedMutations()

----------------------------------------

TITLE: Resetting Mutation State
DESCRIPTION: Demonstrates how to reset mutation state using the reset function to clear error or data states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const CreateTodo = () => {
  const [title, setTitle] = useState('')
  const mutation = useMutation({ mutationFn: createTodo })

  const onCreateTodo = (e) => {
    e.preventDefault()
    mutation.mutate({ title })
  }

  return (
    <form onSubmit={onCreateTodo}>
      {mutation.error && (
        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
      )}
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  )
}

----------------------------------------

TITLE: Implementing Posts Page with Query Prefetching
DESCRIPTION: Server component that prefetches post data without awaiting and sets up hydration boundary for client components.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_8

LANGUAGE: typescript
CODE:
import { dehydrate, HydrationBoundary } from '@tanstack/react-query'
import { getQueryClient } from './get-query-client'
import Posts from './posts'

export default function PostsPage() {
  const queryClient = getQueryClient()

  queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Query with Enabled Option
DESCRIPTION: Example showing how to use the enabled option with reactive values for conditional fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-16_snippet_6

LANGUAGE: typescript
CODE:
export function useUserProjects(userId: MaybeRef<string>) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(toValue(userId)),
    enabled: () => userId.value === activeUserId.value,
  );
}

----------------------------------------

TITLE: Basic useQueries Implementation in TypeScript
DESCRIPTION: Demonstrates how to use useQueries hook to fetch multiple posts using an array of IDs. The hook accepts an array of query configurations and returns results in the same order.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useQueries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const ids = [1, 2, 3]
const results = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
    staleTime: Infinity,
  })),
})

----------------------------------------

TITLE: Query Keys with Object Parameters
DESCRIPTION: Demonstrates how to use object parameters in query keys with consistent ordering. Shows equivalent ways to structure object parameters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
injectQuery(() => ({ queryKey: ['todos', { status, page }], ... }))
injectQuery(() => ({ queryKey: ['todos', { page, status }], ...}))
injectQuery(() => ({ queryKey: ['todos', { page, status, other: undefined }], ... }))

----------------------------------------

TITLE: Using useIsFetching Hook in React with TanStack Query
DESCRIPTION: Demonstrates how to use the useIsFetching hook to get the count of fetching queries. It shows two examples: one for all queries and another for queries with a specific prefix.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useIsFetching.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useIsFetching } from '@tanstack/react-query'
// How many queries are fetching?
const isFetching = useIsFetching()
// How many queries matching the posts prefix are fetching?
const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })

----------------------------------------

TITLE: Memoizing Placeholder Data in TanStack Query
DESCRIPTION: This example shows how to memoize placeholder data in TanStack Query using useMemo. This approach is useful when generating placeholder data is computationally expensive or should not be performed on every render.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
function Todos() {
  const placeholderData = useMemo(() => generateFakeTodos(), [])
  const result = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData,
  })
}

----------------------------------------

TITLE: Fetching Data with SolidJS createResource
DESCRIPTION: This snippet demonstrates how to fetch data from an API using SolidJS's createResource API. It includes error handling with ErrorBoundary and loading state management with Suspense.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/overview.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { createResource, ErrorBoundary, Suspense } from 'solid-js'
import { render } from 'solid-js/web'

function App() {
  const [repository] = createResource(async () => {
    const result = await fetch('https://api.github.com/repos/TanStack/query')
    if (!result.ok) throw new Error('Failed to fetch data')
    return result.json()
  })

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          <div>{repository()?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')

render(() => <App />, root!)

----------------------------------------

TITLE: Demonstrating Serial Queries in React Query
DESCRIPTION: This snippet shows how dependent queries can create a request waterfall within a single component. It fetches user data first, then uses the user ID to fetch projects, creating sequential requests.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

// Then get the user's projects
const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
})

----------------------------------------

TITLE: Implementing Global Background Fetching Indicator in React with TanStack Query
DESCRIPTION: This snippet shows how to use the 'useIsFetching' hook from TanStack Query to create a global loading indicator. It displays a message when any queries are fetching in the background.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/background-fetching-indicators.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { useIsFetching } from '@tanstack/react-query'

function GlobalLoadingIndicator() {
  const isFetching = useIsFetching()

  return isFetching ? (
    <div>Queries are fetching in the background...</div>
  ) : null
}

----------------------------------------

TITLE: Implementing Global Background Fetching Indicator in Vue
DESCRIPTION: This snippet shows how to use the useIsFetching hook from TanStack Query to track the global fetching state across all queries in a Vue application. It demonstrates a simple way to display a global loading indicator when any query is fetching data in the background.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/background-fetching-indicators.md#2025-04-16_snippet_1

LANGUAGE: vue
CODE:
<script setup>
import { useIsFetching } from '@tanstack/vue-query'

const isFetching = useIsFetching()
</script>

<template>
  <div v-if="isFetching">Queries are fetching in the background...</div>
</template>

----------------------------------------

TITLE: Testing a query hook with TanStack Query
DESCRIPTION: This snippet demonstrates how to test a query hook using the custom render function. It shows how to mock the query function and assert the expected behavior of the hook.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/testing.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
import { renderHook, waitFor } from '@testing-library/react'
import { useQuery } from '@tanstack/react-query'

const fetchData = async () => {
  return { data: 'Hello' }
}

const useDataQuery = () =>
  useQuery({ queryKey: ['data'], queryFn: fetchData })

test('useDataQuery hook', async () => {
  const { result } = renderHook(() => useDataQuery(), {
    wrapper: createWrapper(),
  })

  await waitFor(() => expect(result.current.isSuccess).toBe(true))

  expect(result.current.data).toEqual({ data: 'Hello' })
})

----------------------------------------

TITLE: Conditional Initial Data with Freshness Check in TanStack Query
DESCRIPTION: Advanced example demonstrating how to conditionally provide initial data only if the source data is fresh (less than 10 seconds old). This ensures stale data isn't used as initial data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_7

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todo', this.todoId()],
  queryFn: () => fetch(`/todos/${this.todoId()}`),
  initialData: () => {
    // Get the query state
    const state = queryClient.getQueryState(['todos'])

    // If the query exists and has data that is no older than 10 seconds...
    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
      // return the individual todo
      return state.data.find((d) => d.id === this.todoId())
    }

    // Otherwise, return undefined and let it fetch from a hard loading state!
  },
}))

----------------------------------------

TITLE: Implementing Query Cancellation with Axios in TanStack Query
DESCRIPTION: This example shows how to use the AbortSignal with Axios v0.22.0 or higher in a TanStack Query queryFn. The signal is passed directly to the Axios configuration object.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import axios from 'axios'

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) =>
    axios.get('/todos', {
      // Pass the signal to `axios`
      signal,
    }),
})

----------------------------------------

TITLE: Using createQuery in a Svelte Component
DESCRIPTION: This example shows how to use the createQuery function in a Svelte component. It demonstrates querying for todos and handling different query states (loading, error, success) in the template.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/overview.md#2025-04-16_snippet_1

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  const query = createQuery({
    queryKey: ['todos'],
    queryFn: () => fetchTodos(),
  })
</script>

<div>
  {#if $query.isLoading}
    <p>Loading...</p>
  {:else if $query.isError}
    <p>Error: {$query.error.message}</p>
  {:else if $query.isSuccess}
    {#each $query.data as todo}
      <p>{todo.title}</p>
    {/each}
  {/if}
</div>

----------------------------------------

TITLE: Using queryClient.cancelQueries
DESCRIPTION: The cancelQueries method cancels outgoing queries based on query keys or other properties. Useful for optimistic updates to prevent ongoing fetches from overwriting optimistic data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_13

LANGUAGE: tsx
CODE:
await queryClient.cancelQueries({ queryKey: ['posts'], exact: true })

----------------------------------------

TITLE: Fetching Query Data with Error Handling
DESCRIPTION: Demonstrates how to fetch and cache query data using fetchQuery method with error handling. Returns the data or throws an error.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
try {
  const data = await queryClient.fetchQuery({ queryKey, queryFn })
} catch (error) {
  console.log(error)
}

----------------------------------------

TITLE: Creating and Configuring a Persister with QueryClient in TypeScript
DESCRIPTION: Example of creating a persister using experimental_createPersister and configuring it with a QueryClient. This setup uses AsyncStorage from React Native and sets default options for all queries, including a garbage collection time of 30 seconds and a maximum age of 12 hours for persisted data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/createPersister.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/react-query'
import { experimental_createPersister } from '@tanstack/query-persist-client-core'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: experimental_createPersister({
        storage: AsyncStorage,
        maxAge: 1000 * 60 * 60 * 12, // 12 hours
      }),
    },
  },
})

----------------------------------------

TITLE: Implementing Default Query Function in TanStack Query with TypeScript
DESCRIPTION: This snippet demonstrates how to define a default query function, configure it with QueryClient, and use it in React components. It shows how to simplify query definitions by allowing components to specify only the query key, with the default function handling the actual data fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/default-query-function.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
// Define a default query function that will receive the query key
const defaultQueryFn: QueryFunction = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

bootstrapApplication(MyAppComponent, {
  providers: [provideTanStackQuery(queryClient)],
})

export class PostsComponent {
  // All you have to do now is pass a key!
  postsQuery = injectQuery<Array<Post>>(() => ({
    queryKey: ['/posts'],
  }))
  // ...
}

export class PostComponent {
  // You can even leave out the queryFn and just go straight into options
  postQuery = injectQuery<Post>(() => ({
    enabled: this.postIdSignal() > 0,
    queryKey: [`/posts/${this.postIdSignal()}`],
  }))
  // ...
}

----------------------------------------

TITLE: Implementing Dependent Query with useQuery in TanStack Query
DESCRIPTION: This snippet demonstrates how to create a dependent query using the useQuery hook. It first fetches user data, then uses the user ID to fetch the user's projects. The second query is enabled only when the user ID is available.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/dependent-queries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

// Then get the user's projects
const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
})

----------------------------------------

TITLE: Using useQueries Hook for Parallel Queries in React Query v3
DESCRIPTION: Demonstrates the use of the new useQueries hook to execute multiple queries in parallel, allowing for dynamic query generation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-16_snippet_12

LANGUAGE: tsx
CODE:
import { useQueries } from 'react-query'

function Overview() {
  const results = useQueries([
    { queryKey: ['post', 1], queryFn: fetchPost },
    { queryKey: ['post', 2], queryFn: fetchPost },
  ])
  return (
    <ul>
      {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}
    </ul>
  )
}

----------------------------------------

TITLE: Optimistic Updates for Single Todo Item in Angular Query
DESCRIPTION: This example shows how to implement optimistic updates for a single todo item. It includes cancelling queries, snapshotting previous data, optimistic updates, error handling, and query invalidation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-16_snippet_5

LANGUAGE: typescript
CODE:
queryClient = inject(QueryClient)

updateTodo = injectMutation(() => ({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await this.queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })

    // Snapshot the previous value
    const previousTodo = this.queryClient.getQueryData(['todos', newTodo.id])

    // Optimistically update to the new value
    this.queryClient.setQueryData(['todos', newTodo.id], newTodo)

    // Return a context with the previous and new todo
    return { previousTodo, newTodo }
  },
  // If the mutation fails, use the context we returned above
  onError: (err, newTodo, context) => {
    this.queryClient.setQueryData(
      ['todos', context.newTodo.id],
      context.previousTodo,
    )
  },
  // Always refetch after error or success:
  onSettled: (newTodo) => {
    this.queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] })
  },
}))

----------------------------------------

TITLE: Type Narrowing with Success State
DESCRIPTION: Shows how to narrow types using the isSuccess flag with reactive wrapper. When isSuccess is true, the data type is narrowed to the resolved value type.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/typescript.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
const { data, isSuccess } = reactive(
  useQuery({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }),
)

if (isSuccess) {
  data
  // ^? const data: number
}

----------------------------------------

TITLE: Optimizing Select Function with useCallback in React Query
DESCRIPTION: This example shows how to optimize the select function in a custom React Query hook by wrapping it with useCallback. This prevents unnecessary re-renders by maintaining referential stability of the select function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/render-optimizations.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
export const useTodoCount = () => {
  return useTodos(useCallback((data) => data.length, []))
}

----------------------------------------

TITLE: Custom Hook for Screen Focus Refresh
DESCRIPTION: Custom hook implementation that triggers data refetch when a React Navigation screen comes into focus, excluding the initial mount.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/react-native.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
import React from 'react'
import { useFocusEffect } from '@react-navigation/native'

export function useRefreshOnFocus<T>(refetch: () => Promise<T>) {
  const firstTimeRef = React.useRef(true)

  useFocusEffect(
    React.useCallback(() => {
      if (firstTimeRef.current) {
        firstTimeRef.current = false
        return
      }

      refetch()
    }, [refetch]),
  )
}

----------------------------------------

TITLE: Implementing Suspense Wrapper Component in Vue
DESCRIPTION: Example showing how to wrap a suspendable component with Vue's Suspense component. Demonstrates the basic template structure with default and fallback slots.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/suspense.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup>
import SuspendableComponent from './SuspendableComponent.vue'
</script>

<template>
  <Suspense>
    <template #default>
      <SuspendableComponent />
    </template>
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>

----------------------------------------

TITLE: Initializing InfiniteQueryObserver in TanStack Query
DESCRIPTION: Demonstrates how to create and use an InfiniteQueryObserver instance for paginated data fetching. The observer is configured with query parameters and pagination controls through getNextPageParam and getPreviousPageParam functions. Shows how to subscribe to query results and handle unsubscription.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/InfiniteQueryObserver.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const observer = new InfiniteQueryObserver(queryClient, {
  queryKey: ['posts'],
  queryFn: fetchPosts,
  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
})

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})

----------------------------------------

TITLE: Configuring Cursor-based Pagination with injectInfiniteQuery
DESCRIPTION: A configuration for cursor-based pagination using TanStack Query. It demonstrates how to use getNextPageParam and getPreviousPageParam to implement bidirectional infinite scrolling with cursor values.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-16_snippet_3

LANGUAGE: ts
CODE:
query = injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
}))

----------------------------------------

TITLE: Rendering Todo List with Optimistic UI in Angular
DESCRIPTION: This Angular component template shows how to render a list of todos, including an optimistic UI update for a pending todo item. It demonstrates the use of Angular's template syntax with Query's mutation state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-16_snippet_1

LANGUAGE: angular-ts
CODE:
@Component({
  template: `
    @for (todo of todos.data(); track todo.id) {
      <li>{{ todo.title }}</li>
    }
    @if (addTodo.isPending()) {
      <li style="opacity: 0.5">{{ addTodo.variables() }}</li>
    }
  `,
})
class TodosComponent {}

----------------------------------------

TITLE: Initial Data with Custom Data Update Timestamp in TanStack Query
DESCRIPTION: Example showing how to provide both initial data and a custom initialDataUpdatedAt timestamp. This allows TanStack Query to calculate the correct stale time based on when the data was actually last updated.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
// Show initialTodos immediately, but won't refetch until
// another interaction event is encountered after 1000 ms
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 1 minute
  // This could be 10 seconds ago or 10 minutes ago
  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
}))

----------------------------------------

TITLE: Using mutationOptions Helper with TypeScript in TanStack Query
DESCRIPTION: This snippet demonstrates how to use the mutationOptions helper in a QueriesService class to define reusable mutation configurations with type safety. It shows configuration of a mutation function, key, and success handler that updates query data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutation-options.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
export class QueriesService {
  private http = inject(HttpClient)

  updatePost(id: number) {
    return mutationOptions({
      mutationFn: (post: Post) => Promise.resolve(post),
      mutationKey: ['updatePost', id],
      onSuccess: (newPost) => {
        //           ^? newPost: Post
        this.queryClient.setQueryData(['posts', id], newPost)
      },
    })
  }
}

----------------------------------------

TITLE: Basic Usage of useQuery in Solid Query
DESCRIPTION: This example shows the basic usage of useQuery to fetch data from an API. It demonstrates how to handle loading, error, and success states using Solid's Show component.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/solid-query'

function App() {
  const todos = useQuery(() => ({
    queryKey: 'todos',
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
  }))

  return (
    <div>
      <Show when={todos.isError}>
        <div>Error: {todos.error.message}</div>
      </Show>
      <Show when={todos.isLoading}>
        <div>Loading...</div>
      </Show>
      <Show when={todos.isSuccess}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Show>
    </div>
  )
}

----------------------------------------

TITLE: Updating QueryCache Methods to Single Object Signature in TanStack Query v5
DESCRIPTION: This snippet demonstrates the migration of QueryCache methods to use a single object parameter instead of multiple parameters. It includes examples for the find and findAll methods.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
queryCache.find(key, filters) // [!code --]
queryCache.find({ queryKey, ...filters }) // [!code ++]
queryCache.findAll(key, filters) // [!code --]
queryCache.findAll({ queryKey, ...filters }) // [!code ++]

----------------------------------------

TITLE: Structured Query Keys with Parameters
DESCRIPTION: Shows how to create query keys with additional parameters and nested objects. Examples include querying individual items and filtered lists.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
// An individual todo
injectQuery(() => ({queryKey: ['todo', 5], ...}))

// An individual todo in a "preview" format
injectQuery(() => ({queryKey: ['todo', 5, {preview: true}], ...}))

// A list of todos that are "done"
injectQuery(() => ({queryKey: ['todos', {type: 'done'}], ...}))

----------------------------------------

TITLE: Implementing React Query Providers with Streamed Hydration in Next.js
DESCRIPTION: Setup code for initializing QueryClient and implementing ReactQueryStreamedHydration in a Next.js application. Includes logic for handling server/client environments and preventing query client recreation during React suspense.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_12

LANGUAGE: tsx
CODE:
// app/providers.tsx
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import * as React from 'react'
import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient()
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export function Providers(props: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>
        {props.children}
      </ReactQueryStreamedHydration>
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Basic Type Inference with useQuery
DESCRIPTION: Demonstrates basic type inference for query results using useQuery hook. The data property is automatically inferred as a Ref<number> | Ref<undefined>.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/typescript.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const { data } = useQuery({
  //    ^? const data: Ref<number> | Ref<undefined>
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})

----------------------------------------

TITLE: Using HydrationBoundary Component in React Query
DESCRIPTION: Example demonstrating the HydrationBoundary component usage, which provides a React component-based approach to hydrating dehydrated state into a QueryClient.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
import { HydrationBoundary } from '@tanstack/react-query'

function App() {
  return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>
}

----------------------------------------

TITLE: Defining and Using Query Options with TypeScript in TanStack Query
DESCRIPTION: This snippet demonstrates how to define query options using the queryOptions helper and use them with various query hooks and client methods. It shows the creation of a groupOptions function that returns queryOptions for fetching groups.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-options.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import { queryOptions } from '@tanstack/react-query'

function groupOptions(id: number) {
  return queryOptions({
    queryKey: ['groups', id],
    queryFn: () => fetchGroups(id),
    staleTime: 5 * 1000,
  })
}

// usage:

useQuery(groupOptions(1))
useSuspenseQuery(groupOptions(5))
useQueries({
  queries: [groupOptions(1), groupOptions(2)],
})
queryClient.prefetchQuery(groupOptions(23))
queryClient.setQueryData(groupOptions(42).queryKey, newGroups)

----------------------------------------

TITLE: Error Boundary with useQueryErrorResetBoundary Hook
DESCRIPTION: Demonstrates using the useQueryErrorResetBoundary hook for error handling within error boundaries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { useQueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => {
  const { reset } = useQueryErrorResetBoundary()
  return (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ resetErrorBoundary }) => (
        <div>
          There was an error!
          <Button onClick={() => resetErrorBoundary()}>Try again</Button>
        </div>
      )}
    >
      <Page />
    </ErrorBoundary>
  )
}

----------------------------------------

TITLE: Basic Mutation Example in TanStack Query
DESCRIPTION: Simple example showing the basic usage of useMutation hook for posting a todo item.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/invalidations-from-mutations.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const mutation = useMutation({ mutationFn: postTodo })

----------------------------------------

TITLE: Specific Variable Query Invalidation
DESCRIPTION: Shows how to invalidate queries with specific variables by providing a more detailed query key. Demonstrates selective invalidation based on query key matching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos', { type: 'done' }],
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
}))

----------------------------------------

TITLE: Defining Query Properties in TanStack Query
DESCRIPTION: This snippet defines various properties of a query in TanStack Query, including status indicators, data handling, and refetch functionality. It covers derived booleans, timestamps, error handling, and fetch statuses.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useQuery.md#2025-04-16_snippet_1

LANGUAGE: markdown
CODE:
- `error` if the query attempt resulted in an error. The corresponding `error` property has the error received from the attempted fetch
- `success` if the query has received a response with no errors and is ready to display its data. The corresponding `data` property on the query is the data received from the successful fetch or if the query's `enabled` property is set to `false` and has not been fetched yet `data` is the first `initialData` supplied to the query on initialization.
- `isPending: boolean`
  - A derived boolean from the `status` variable above, provided for convenience.
- `isSuccess: boolean`
  - A derived boolean from the `status` variable above, provided for convenience.
- `isError: boolean`
  - A derived boolean from the `status` variable above, provided for convenience.
- `isLoadingError: boolean`
  - Will be `true` if the query failed while fetching for the first time.
- `isRefetchError: boolean`
  - Will be `true` if the query failed while refetching.
- `data: TData`
  - Defaults to `undefined`.
  - The last successfully resolved data for the query.
- `dataUpdatedAt: number`
  - The timestamp for when the query most recently returned the `status` as `"success"`.
- `error: null | TError`
  - Defaults to `null`
  - The error object for the query, if an error was thrown.
- `errorUpdatedAt: number`
  - The timestamp for when the query most recently returned the `status` as `"error"`.
- `isStale: boolean`
  - Will be `true` if the data in the cache is invalidated or if the data is older than the given `staleTime`.
- `isPlaceholderData: boolean`
  - Will be `true` if the data shown is the placeholder data.
- `isFetched: boolean`
  - Will be `true` if the query has been fetched.
- `isFetchedAfterMount: boolean`
  - Will be `true` if the query has been fetched after the component mounted.
  - This property can be used to not show any previously cached data.
- `fetchStatus: FetchStatus`
  - `fetching`: Is `true` whenever the queryFn is executing, which includes initial `pending` as well as background refetches.
  - `paused`: The query wanted to fetch, but has been `paused`.
  - `idle`: The query is not fetching.
  - see [Network Mode](../guides/network-mode) for more information.
- `isFetching: boolean`
  - A derived boolean from the `fetchStatus` variable above, provided for convenience.
- `isPaused: boolean`
  - A derived boolean from the `fetchStatus` variable above, provided for convenience.
- `isRefetching: boolean`
  - Is `true` whenever a background refetch is in-flight, which _does not_ include initial `pending`
  - Is the same as `isFetching && !isPending`
- `isLoading: boolean`
  - Is `true` whenever the first fetch for a query is in-flight
  - Is the same as `isFetching && isPending`
- `isInitialLoading: boolean`
  - **deprecated**
  - An alias for `isLoading`, will be removed in the next major version.
- `failureCount: number`
  - The failure count for the query.
  - Incremented every time the query fails.
  - Reset to `0` when the query succeeds.
- `failureReason: null | TError`
  - The failure reason for the query retry.
  - Reset to `null` when the query succeeds.
- `errorUpdateCount: number`
  - The sum of all errors.
- `refetch: (options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult>`
  - A function to manually refetch the query.
  - If the query errors, the error will only be logged. If you want an error to be thrown, pass the `throwOnError: true` option
  - `cancelRefetch?: boolean`
    - Defaults to `true`
      - Per default, a currently running request will be cancelled before a new request is made
    - When set to `false`, no refetch will be made if there is already a request running.
- `promise: Promise<TData>`
  - A stable promise that will be resolved with the data of the query.
  - Requires the `experimental_prefetchInRender` feature flag to be enabled on the `QueryClient`.

----------------------------------------

TITLE: Using Function for Lazy Initial Data Computation in TanStack Query
DESCRIPTION: Demonstrates how to use a function for the initialData property to lazily compute expensive initial data. The function is only called when the query is created rather than during render.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: () => getExpensiveTodos(),
}))

----------------------------------------

TITLE: Query Default Configuration - Stale Time
DESCRIPTION: Default configuration where cached data is considered stale by useQuery and useInfiniteQuery. Can be modified using the staleTime option globally or per-query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/important-defaults.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 // Example: 1 minute
    }
  }
})

----------------------------------------

TITLE: Updating Loading Check for Disabled Queries
DESCRIPTION: Example of changing isLoading to isInitialLoading for a better loading indicator with disabled queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_8

LANGUAGE: tsx
CODE:
-isLoading
+isInitialLoading

----------------------------------------

TITLE: TanStack Query Client Configuration with Persistence
DESCRIPTION: Configuration setup for TanStack Query client including default options, mutation defaults, and persistence setup. Implements local storage persistence and mutation resumption.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
const client = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

// we need a default mutation function so that paused mutations can resume after a page reload
queryClient.setMutationDefaults({
  mutationKey: ['todos'],
  mutationFn: ({ id, data }) => {
    return api.updateTodo(id, data)
  },
})

const vueQueryOptions: VueQueryPluginOptions = {
  queryClient: client,
  clientPersister: (queryClient) => {
    return persistQueryClient({
      queryClient,
      persister: createSyncStoragePersister({ storage: localStorage }),
    })
  },
  clientPersisterOnSuccess: (queryClient) => {
    queryClient.resumePausedMutations()
  },
}

createApp(App).use(VueQueryPlugin, vueQueryOptions).mount('#app')

----------------------------------------

TITLE: Prefetching Queries in Nuxt 3 Component
DESCRIPTION: Demonstrates how to prefetch queries in a Nuxt 3 component using onServerPrefetch and the suspense function from useQuery.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
export default defineComponent({
  setup() {
    const { data, suspense } = useQuery({
      queryKey: ['test'],
      queryFn: fetcher,
    })

    onServerPrefetch(async () => {
      await suspense()
    })

    return { data }
  },
})

----------------------------------------

TITLE: Initializing MutationCache with Callbacks - TSX
DESCRIPTION: Creates a new MutationCache instance with error and success callback handlers. Shows basic setup with logging functionality for mutation results.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/MutationCache.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { MutationCache } from '@tanstack/react-query'

const mutationCache = new MutationCache({
  onError: (error) => {
    console.log(error)
  },
  onSuccess: (data) => {
    console.log(data)
  },
})

----------------------------------------

TITLE: Updating useQueries API
DESCRIPTION: Example of the new API for useQueries, which now accepts an object with a queries prop.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_9

LANGUAGE: tsx
CODE:
-useQueries([
  { queryKey1, queryFn1, options1 },
  { queryKey2, queryFn2, options2 },
])
+useQueries({
  queries: [
    { queryKey1, queryFn1, options1 },
    { queryKey2, queryFn2, options2 },
  ],
})

----------------------------------------

TITLE: Using queryClient.refetchQueries - Various Examples
DESCRIPTION: The refetchQueries method refetches queries based on certain conditions. Examples show refetching all queries, stale queries, or queries matching specific keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_12

LANGUAGE: tsx
CODE:
// refetch all queries:
await queryClient.refetchQueries()

// refetch all stale queries:
await queryClient.refetchQueries({ stale: true })

// refetch all active queries partially matching a query key:
await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })

// refetch all active queries exactly matching a query key:
await queryClient.refetchQueries({
  queryKey: ['posts', 1],
  type: 'active',
  exact: true,
})

----------------------------------------

TITLE: Implementing Infinite Queries with TanStack Query in Vue
DESCRIPTION: This snippet demonstrates how to use the useInfiniteQuery hook from TanStack Query to fetch paginated data in a Vue component. It includes a function to fetch projects, query configuration, and a template to display the results with a 'Load More' button.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/infinite-queries.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup>
import { useInfiniteQuery } from '@tanstack/vue-query'

const fetchProjects = async ({ pageParam = 0 }) => {
  const res = await fetch('/api/projects?cursor=' + pageParam)
  return res.json()
}

const {
  data,
  error,
  fetchNextPage,
  hasNextPage,
  isFetching,
  isFetchingNextPage,
  isPending,
  isError,
} = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
})
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <div v-else-if="data">
    <span v-if="isFetching && !isFetchingNextPage">Fetching...</span>
    <ul v-for="(group, index) in data.pages" :key="index">
      <li v-for="project in group.projects" :key="project.id">
        {{ project.name }}
      </li>
    </ul>
    <button
      @click="() => fetchNextPage()"
      :disabled="!hasNextPage || isFetchingNextPage"
    >
      <span v-if="isFetchingNextPage">Loading more...</span>
      <span v-else-if="hasNextPage">Load More</span>
      <span v-else>Nothing more to load</span>
    </button>
  </div>
</template>

----------------------------------------

TITLE: Reactive Options with useQuery in Solid Query
DESCRIPTION: This example demonstrates how to use reactive options with useQuery. It shows how to update the query based on a filter signal, allowing for dynamic data fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/solid-query'

function App() {
  const [filter, setFilter] = createSignal('all')

  const todos = useQuery(() => ({
    queryKey: ['todos', filter()],
    queryFn: async () => {
      const response = await fetch(`/api/todos?filter=${filter()}`)
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
  }))

  return (
    <div>
      <div>
        <button onClick={() => setFilter('all')}>All</button>
        <button onClick={() => setFilter('active')}>Active</button>
        <button onClick={() => setFilter('completed')}>Completed</button>
      </div>
      <Show when={todos.isError}>
        <div>Error: {todos.error.message}</div>
      </Show>
      <Show when={todos.isLoading}>
        <div>Loading...</div>
      </Show>
      <Show when={todos.isSuccess}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Show>
    </div>
  )
}

----------------------------------------

TITLE: Implementing Query Cancellation with Axios (Pre-v0.22.0) in TanStack Query
DESCRIPTION: This snippet demonstrates how to implement query cancellation with Axios versions lower than v0.22.0 in TanStack Query. It uses a CancelToken source and listens for the abort event on the signal.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import axios from 'axios'

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    // Create a new CancelToken source for this request
    const CancelToken = axios.CancelToken
    const source = CancelToken.source()

    const promise = axios.get('/todos', {
      // Pass the source token to your request
      cancelToken: source.token,
    })

    // Cancel the request if TanStack Query signals to abort
    signal?.addEventListener('abort', () => {
      source.cancel('Query was cancelled by TanStack Query')
    })

    return promise
  },
})

----------------------------------------

TITLE: Server Component Data Prefetching
DESCRIPTION: Demonstrates how to prefetch data in a Server Component using React Query and handle hydration. Uses the Next.js app router pattern.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import Posts from './posts'

export default async function PostsPage() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Basic Query Implementation in Angular
DESCRIPTION: Shows how to import and implement a basic query in an Angular component using injectQuery. The query fetches a todo list using a specified query key and fetch function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import { injectQuery } from '@tanstack/angular-query-experimental'

export class TodosComponent {
  info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
}

----------------------------------------

TITLE: Invalidating Queries with QueryClient in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to invalidate all queries or queries with specific keys using the QueryClient's invalidateQueries method.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// Invalidate every query in the cache
queryClient.invalidateQueries()
// Invalidate every query with a key that starts with `todos`
queryClient.invalidateQueries({ queryKey: ['todos'] })

----------------------------------------

TITLE: Using QueryObserver in React Query v3
DESCRIPTION: Demonstrates how to use the new QueryObserver to create and watch a query outside of React components.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-16_snippet_14

LANGUAGE: tsx
CODE:
const observer = new QueryObserver(queryClient, { queryKey: 'posts' })

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})

----------------------------------------

TITLE: Implementing Dynamic Parallel Queries in Angular
DESCRIPTION: Shows how to use injectQueries to dynamically execute multiple queries based on a signal array of users. Note that this feature is under development.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/parallel-queries.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
export class AppComponent {
  users = signal<Array<User>>([])

  // Please note injectQueries is under development and this code does not work yet
  userQueries = injectQueries(() => ({
    queries: users().map((user) => {
      return {
        queryKey: ['user', user.id],
        queryFn: () => fetchUserById(user.id),
      }
    }),
  }))
}

----------------------------------------

TITLE: Infinite Query Prefetching in TypeScript
DESCRIPTION: Shows how to prefetch multiple pages of an infinite query using prefetchInfiniteQuery with pagination parameters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const prefetchProjects = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // prefetch the first 3 pages
  })
}

----------------------------------------

TITLE: Initializing QueryClient in Next.js Pages Router
DESCRIPTION: Example showing how to properly initialize QueryClient in a Next.js _app.tsx file to ensure each request has its own cache and avoid data sharing between users.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// _app.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Initializing BroadcastQueryClient - Basic Setup
DESCRIPTION: Basic setup example showing how to initialize broadcastQueryClient with a QueryClient instance and optional broadcast channel.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'

const queryClient = new QueryClient()

broadcastQueryClient({
  queryClient,
  broadcastChannel: 'my-app',
})

----------------------------------------

TITLE: Removing Single Value from Individual Page in Infinite Query
DESCRIPTION: This example shows how to manually remove a single value from an individual page in the infinite query data, maintaining the structure required by TanStack Query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
const newPagesArray =
  oldPagesArray?.pages.map((page) =>
    page.filter((val) => val.id !== updatedId),
  ) ?? []

queryClient.setQueryData(['projects'], (data) => ({
  pages: newPagesArray,
  pageParams: data.pageParams,
}))

----------------------------------------

TITLE: Error Handling in Query Functions
DESCRIPTION: Shows proper error handling within a query function, demonstrating two ways to handle errors: throwing an Error directly and using Promise.reject. The example uses a reactive todoId from a function call.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
todos = injectQuery(() => ({
  queryKey: ['todos', todoId()],
  queryFn: async () => {
    if (somethingGoesWrong) {
      throw new Error('Oh no!')
    }
    if (somethingElseGoesWrong) {
      return Promise.reject(new Error('Oh no!'))
    }

    return data
  },
}))

----------------------------------------

TITLE: Query Invalidation with Mutation Success Handler
DESCRIPTION: Example demonstrating how to invalidate multiple queries after a successful mutation using the onSuccess callback and queryClient.invalidateQueries. Shows invalidation of both 'todos' and 'reminders' query keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/invalidations-from-mutations.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { useMutation, useQueryClient } from '@tanstack/react-query'

const queryClient = useQueryClient()

// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
const mutation = useMutation({
  mutationFn: addTodo,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    queryClient.invalidateQueries({ queryKey: ['reminders'] })
  },
})

----------------------------------------

TITLE: Implementing Dynamic Parallel Dependent Queries with useQueries in TanStack Query
DESCRIPTION: This snippet demonstrates how to create dynamic parallel dependent queries using the useQueries hook. It first fetches user IDs, then uses these IDs to fetch messages for each user in parallel.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/dependent-queries.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
// Get the users ids
const { data: userIds } = useQuery({
  queryKey: ['users'],
  queryFn: getUsersData,
  select: (users) => users.map((user) => user.id),
})

// Then get the users messages
const usersMessages = useQueries({
  queries: userIds
    ? userIds.map((id) => {
        return {
          queryKey: ['messages', id],
          queryFn: () => getMessagesByUsers(id),
        }
      })
    : [], // if users is undefined, an empty array will be returned
})

----------------------------------------

TITLE: Managing Data Freshness with initialDataUpdatedAt Function in TanStack Query
DESCRIPTION: Shows how to synchronize both data and update timestamps between related queries using initialData and initialDataUpdatedAt as functions. This helps maintain accurate stale time calculations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_6

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos', this.todoId()],
  queryFn: () => fetch(`/todos/${this.todoId()}`),
  initialData: () =>
    queryClient.getQueryData(['todos'])?.find((d) => d.id === this.todoId()),
  initialDataUpdatedAt: () =>
    queryClient.getQueryState(['todos'])?.dataUpdatedAt,
}))

----------------------------------------

TITLE: Configuring QueryClient with SvelteKit Browser Detection
DESCRIPTION: Setup for the QueryClient in SvelteKit with SSR considerations by using the browser module to disable queries during server-side rendering while preserving prefetchQuery functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-16_snippet_0

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { browser } from '$app/environment'
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'

  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })
</script>

<QueryClientProvider client={queryClient}>
  <slot />
</QueryClientProvider>

----------------------------------------

TITLE: Configuring Individual Query Retries in Vue Query
DESCRIPTION: Shows how to set retry attempts for a specific query using the useQuery hook. The example demonstrates setting a fixed number of retry attempts for a todo list fetch operation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/query-retries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/vue-query'

// Make a specific query retry a certain number of times
const result = useQuery({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
})

----------------------------------------

TITLE: Using Placeholder Data as a Function in TanStack Query
DESCRIPTION: This snippet illustrates how to use a function as placeholder data in TanStack Query. The function has access to previous data and query information, allowing for dynamic placeholder data based on previous query results.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos', id],
  queryFn: () => fetch(`/todos/${id}`),
  placeholderData: (previousData, previousQuery) => previousData,
})

----------------------------------------

TITLE: Creating IndexedDB Persister for TanStack Query in TypeScript
DESCRIPTION: This function creates an IndexedDB persister for TanStack Query. It uses the 'idb-keyval' library to interact with IndexedDB and implements the Persister interface from '@tanstack/react-query-persist-client'. The persister provides methods to persist, restore, and remove client data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
import { get, set, del } from 'idb-keyval'
import {
  PersistedClient,
  Persister,
} from '@tanstack/react-query-persist-client'

/**
 * Creates an Indexed DB persister
 * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
 */
export function createIDBPersister(idbValidKey: IDBValidKey = 'reactQuery') {
  return {
    persistClient: async (client: PersistedClient) => {
      await set(idbValidKey, client)
    },
    restoreClient: async () => {
      return await get<PersistedClient>(idbValidKey)
    },
    removeClient: async () => {
      await del(idbValidKey)
    },
  } satisfies Persister
}

----------------------------------------

TITLE: Type Narrowing in Angular Query
DESCRIPTION: Shows how to use type narrowing with isSuccess() method in Angular Query template.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/typescript.md#2025-04-16_snippet_3

LANGUAGE: angular-ts
CODE:
@Component({
  // ...
  template: `
    @if (query.isSuccess()) {
      @let data = query.data();
      //    ^? data: number
    }
  `,
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }))
}

----------------------------------------

TITLE: Conditional Query Enabling with Signal
DESCRIPTION: Shows how to conditionally enable a query based on a signal value. The query only executes when the filter signal has a value.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-16_snippet_1

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  template: `
    <div>
      // üöÄ applying the filter will enable and execute the query
      <filters-form onApply="filter.set" />
      <todos-table data="query.data()" />
    </div>
  `,
})
export class TodosComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: () => fetchTodos(this.filter()),
    enabled: !!this.filter(),
  }))
}

----------------------------------------

TITLE: Implementing Basic Paginated Query in React with TanStack Query
DESCRIPTION: This snippet demonstrates a basic implementation of a paginated query using the injectQuery function from TanStack Query in a React environment. It fetches projects based on the current page.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/paginated-queries.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
const result = injectQuery(() => ({
  queryKey: ['projects', page()],
  queryFn: fetchProjects,
}))

----------------------------------------

TITLE: Preventing Simultaneous Fetches in React List Component
DESCRIPTION: This snippet shows how to prevent simultaneous fetches when implementing infinite scrolling in a React list component. It checks if the next page is already being fetched before triggering a new fetch.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_1

LANGUAGE: jsx
CODE:
<List onEndReached={() => !isFetchingNextPage && fetchNextPage()} />

----------------------------------------

TITLE: Initializing QueryClient in React Query v3
DESCRIPTION: Shows how to create a new QueryClient instance, which is a core change in v3 replacing the previous QueryCache.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { QueryClient } from 'react-query'

const queryClient = new QueryClient()

----------------------------------------

TITLE: Reversing Page Order in Infinite Query Results
DESCRIPTION: This snippet shows how to use the select option to reverse the order of pages in the infinite query results, which can be useful for certain UI implementations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  select: (data) => ({
    pages: [...data.pages].reverse(),
    pageParams: [...data.pageParams].reverse(),
  }),
})

----------------------------------------

TITLE: Installing Vue Query via NPM
DESCRIPTION: Commands for installing Vue Query package using different package managers (npm, pnpm, yarn, bun).
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/installation.md#2025-04-16_snippet_0

LANGUAGE: bash
CODE:
npm i @tanstack/vue-query

LANGUAGE: bash
CODE:
pnpm add @tanstack/vue-query

LANGUAGE: bash
CODE:
yarn add @tanstack/vue-query

LANGUAGE: bash
CODE:
bun add @tanstack/vue-query

----------------------------------------

TITLE: Initializing Infinite Query with Required Parameters
DESCRIPTION: Shows the new requirement of specifying initialPageParam in infinite queries and the simplified queryFn signature.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_11

LANGUAGE: tsx
CODE:
useInfiniteQuery({
   queryKey,
-  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]
+  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]
+  initialPageParam: 0, // [!code ++]
   getNextPageParam: (lastPage) => lastPage.next,
})

----------------------------------------

TITLE: Migrating from keepPreviousData to placeholderData
DESCRIPTION: Shows how to replace keepPreviousData with placeholderData using the new keepPreviousData identity function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_9

LANGUAGE: tsx
CODE:
import {
   useQuery,
+  keepPreviousData // [!code ++]
} from "@tanstack/react-query";

const {
   data,
-  isPreviousData, // [!code --]
+  isPlaceholderData, // [!code ++]
} = useQuery({
  queryKey,
  queryFn,
- keepPreviousData: true, // [!code --]
+ placeholderData: keepPreviousData // [!code ++]
});

----------------------------------------

TITLE: Using useIsMutating Hook in React Query
DESCRIPTION: Demonstrates how to use the useIsMutating hook to track active mutations globally and with specific mutation keys. The hook returns a number indicating how many mutations are currently in progress.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useIsMutating.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useIsMutating } from '@tanstack/react-query'
// How many mutations are fetching?
const isMutating = useIsMutating()
// How many mutations matching the posts prefix are fetching?
const isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })

----------------------------------------

TITLE: Advanced Error Typing with Axios
DESCRIPTION: Shows how to use Axios error typing with Angular Query and type narrowing.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/typescript.md#2025-04-16_snippet_5

LANGUAGE: ts
CODE:
import axios from 'axios'

query = injectQuery(() => ({ queryKey: ['groups'], queryFn: fetchGroups }))

computed(() => {
  const error = query.error()
  //     ^? error: Error | null

  if (axios.isAxiosError(error)) {
    error
    // ^? const error: AxiosError
  }
})

----------------------------------------

TITLE: queryOptions Implementation for Defined Initial Data
DESCRIPTION: Function signature for queryOptions with defined initial data. Similar to the undefined initial data version but works with DefinedInitialDataOptions type, ensuring type safety for queries with initial data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object

----------------------------------------

TITLE: Using Vue Query in a Vite SSR Component
DESCRIPTION: Demonstrates how to use Vue Query in a component with Vite SSR, including prefetching queries on the server using onServerPrefetch.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-16_snippet_5

LANGUAGE: vue
CODE:
<template>
  <div>
    <button @click="refetch">Refetch</button>
    <p>{{ data }}</p>
  </div>
</template>

<script setup>
  import { useQuery } from '@tanstack/vue-query'
  import { onServerPrefetch } from 'vue'

  // This will be prefetched and sent from the server
  const { refetch, data, suspense } = useQuery({
    queryKey: ['todos'],
    queryFn: getTodos,
  })

  onServerPrefetch(suspense)
</script>

----------------------------------------

TITLE: Prefetching Regular Queries with TanStack Query in TypeScript
DESCRIPTION: This snippet demonstrates how to prefetch a regular query using the prefetchQuery method. It caches the results of a 'todos' query for future use, optimizing data loading.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/prefetching.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const prefetchTodos = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })
}

----------------------------------------

TITLE: Production Devtools Implementation
DESCRIPTION: Example of implementing lazy-loaded React Query devtools in production environment with toggle functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/devtools.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
import * as React from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { Example } from './Example'

const queryClient = new QueryClient()

const ReactQueryDevtoolsProduction = React.lazy(() =>
  import('@tanstack/react-query-devtools/build/modern/production.js').then(
    (d) => ({
      default: d.ReactQueryDevtools,
    }),
  ),
)

function App() {
  const [showDevtools, setShowDevtools] = React.useState(false)

  React.useEffect(() => {
    // @ts-expect-error
    window.toggleDevtools = () => setShowDevtools((old) => !old)
  }, [])

  return (
    <QueryClientProvider client={queryClient}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
      {showDevtools && (
        <React.Suspense fallback={null}>
          <ReactQueryDevtoolsProduction />
        </React.Suspense>
      )}
    </QueryClientProvider>
  )

----------------------------------------

TITLE: Error Boundary Implementation with QueryErrorResetBoundary
DESCRIPTION: Shows how to implement error boundaries with React Query's QueryErrorResetBoundary component for error handling and recovery.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => (
  <QueryErrorResetBoundary>
    {({ reset }) => (
      <ErrorBoundary
        onReset={reset}
        fallbackRender={({ resetErrorBoundary }) => (
          <div>
            There was an error!
            <Button onClick={() => resetErrorBoundary()}>Try again</Button>
          </div>
        )}
      >
        <Page />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
)

----------------------------------------

TITLE: Prefetching with Default Query Function
DESCRIPTION: Demonstrates prefetching queries using a default query function configured in the client.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
await queryClient.prefetchQuery({ queryKey })

----------------------------------------

TITLE: Error Handling with Retry Button in React Query
DESCRIPTION: Demonstrates how to handle mutation errors and provide a retry mechanism in the UI.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
{
  isError && (
    <li style={{ color: 'red' }}>
      {variables}
      <button onClick={() => mutate(variables)}>Retry</button>
    </li>
  )
}

----------------------------------------

TITLE: Error Type Narrowing with Axios
DESCRIPTION: Demonstrates how to narrow the error type to a specific error class (AxiosError) using type guards.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/typescript.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
import axios from 'axios'

const query = useQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.error
//    ^? (property) error: Error | null

if (axios.isAxiosError(query.error)) {
  query.error
  //    ^? (property) error: AxiosError
}

----------------------------------------

TITLE: Combining Query Results with useQueries in TypeScript
DESCRIPTION: Shows how to use the combine option to merge multiple query results into a single value. The example combines post data and creates a pending status flag.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useQueries.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const ids = [1, 2, 3]
const combinedQueries = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
  })),
  combine: (results) => {
    return {
      data: results.map((result) => result.data),
      pending: results.some((result) => result.isPending),
    }
  },
})

----------------------------------------

TITLE: Overriding Query Options with Select Function in TanStack Query
DESCRIPTION: This snippet shows how to override query options at the component level using a select function. It demonstrates how to use the spread operator to include the base options while adding a custom select function for data transformation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-options.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
// Type inference still works, so query.data will be the return type of select instead of queryFn

const query = useQuery({
  ...groupOptions(1),
  select: (data) => data.groupName,
})

----------------------------------------

TITLE: Working with Complex Query Keys and Parameters
DESCRIPTION: Shows how to use complex query keys with objects and reactive functions, and how to access those parameters within the query function. Demonstrates destructuring the queryKey parameter to extract nested objects with status and page properties.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-functions.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos', { status: status(), page: page() }],
  queryFn: fetchTodoList,
}))

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}

----------------------------------------

TITLE: Nested Server Components with TanStack Query
DESCRIPTION: Demonstrates how to implement nested Server Components with TanStack Query, showing prefetching data at different levels of the component tree using multiple QueryClient instances.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
// app/posts/page.tsx
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import Posts from './posts'
import CommentsServerComponent from './comments-server'

export default async function PostsPage() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
      <CommentsServerComponent />
    </HydrationBoundary>
  )
}

// app/posts/comments-server.tsx
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import Comments from './comments'

export default async function CommentsServerComponent() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts-comments'],
    queryFn: getComments,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Comments />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Single Todo Optimistic Update
DESCRIPTION: Demonstrates optimistic updates for a single todo item with proper error handling and rollback functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })

    // Snapshot the previous value
    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])

    // Optimistically update to the new value
    queryClient.setQueryData(['todos', newTodo.id], newTodo)

    // Return a context with the previous and new todo
    return { previousTodo, newTodo }
  },
  // If the mutation fails, use the context we returned above
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(
      ['todos', context.newTodo.id],
      context.previousTodo,
    )
  },
  // Always refetch after error or success:
  onSettled: (newTodo) =>
    queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] }),
})

----------------------------------------

TITLE: Updating Query Data with Mutation Response in TanStack Query
DESCRIPTION: This snippet demonstrates how to use the QueryClient's setQueryData method to update existing query data with the response from a successful mutation, avoiding unnecessary refetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/updates-from-mutation-responses.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const queryClient = useQueryClient()

const mutation = useMutation({
  mutationFn: editTodo,
  onSuccess: (data) => {
    queryClient.setQueryData(['todo', { id: 5 }], data)
  },
})

mutation.mutate({
  id: 5,
  name: 'Do the laundry',
})

// The query below will be updated with the response from the
// successful mutation
const { status, data, error } = useQuery({
  queryKey: ['todo', { id: 5 }],
  queryFn: fetchTodoById,
})

----------------------------------------

TITLE: Configuring Per-Query Window Focus Refetching
DESCRIPTION: Shows how to disable window focus refetching for a specific query using the useQuery hook configuration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false,
})

----------------------------------------

TITLE: Infinite Query with Event-based Pagination in Angular
DESCRIPTION: An Angular component that implements infinite query with pagination triggered by an event (endReached). This pattern is useful for implementing infinite scrolling in list components.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-16_snippet_2

LANGUAGE: angular-ts
CODE:
@Component({
  template: ` <list-component (endReached)="fetchNextPage()" /> `,
})
export class Example {
  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
  }))

  fetchNextPage() {
    // Do nothing if already fetching
    if (this.query.isFetching()) return
    this.query.fetchNextPage()
  }
}

----------------------------------------

TITLE: Initializing Vue Query Plugin
DESCRIPTION: Setup code for initializing Vue Query by installing the VueQueryPlugin in a Vue application.
SOURCE: https://github.com/TanStack/query/blob/main/packages/vue-query/README.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { createApp } from 'vue'
import { VueQueryPlugin } from '@tanstack/vue-query'

import App from './App.vue'

createApp(App).use(VueQueryPlugin).mount('#app')

----------------------------------------

TITLE: Dehydrating Query Client State in React Query
DESCRIPTION: Example showing how to dehydrate a QueryClient's cache state. The dehydrate function creates a frozen representation of the cache that can be transferred or persisted.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { dehydrate } from '@tanstack/react-query'

const dehydratedState = dehydrate(queryClient, {
  shouldDehydrateQuery,
  shouldDehydrateMutation,
})

----------------------------------------

TITLE: Resuming Paused Mutations
DESCRIPTION: Shows how to resume mutations that were paused due to network connectivity issues.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_27

LANGUAGE: tsx
CODE:
queryClient.resumePausedMutations()

----------------------------------------

TITLE: Initializing QueryClient with Extended GC Time in TypeScript
DESCRIPTION: Creates a new QueryClient instance with an extended garbage collection time of 24 hours for queries. This is important for proper persistence functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

----------------------------------------

TITLE: Initial Data Function Implementation
DESCRIPTION: Illustrates using a function for initialData to optimize performance for expensive operations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: () => getExpensiveTodos(),
})

----------------------------------------

TITLE: Optimistic Updates with Rollback in Solid Query
DESCRIPTION: This example shows how to implement optimistic updates with rollback functionality using Solid Query. It updates the todo list optimistically and rolls back if the mutation fails.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/updates-from-mutation-responses.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
const mutation = useMutation(() => updateTodo, {
  onMutate: async (newTodo) => {
    await queryClient.cancelQueries(['todos'])
    const previousTodos = queryClient.getQueryData(['todos'])
    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])
    return { previousTodos }
  },
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(['todos'], context.previousTodos)
  },
  onSettled: () => {
    queryClient.invalidateQueries(['todos'])
  },
})

----------------------------------------

TITLE: Event Handler Prefetching Example
DESCRIPTION: Demonstrates prefetching data on mouse enter and focus events using a button component with staleTime configuration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
function ShowDetailsButton() {
  const queryClient = useQueryClient()

  const prefetch = () => {
    queryClient.prefetchQuery({
      queryKey: ['details'],
      queryFn: getDetailsData,
      // Prefetch only fires when data is older than the staleTime,
      // so in a case like this you definitely want to set one
      staleTime: 60000,
    })
  }

  return (
    <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>
      Show Details
    </button>
  )
}

----------------------------------------

TITLE: Manual Prefetching with SolidJS Query
DESCRIPTION: Shows how to manually prefetch data using the queryClient.fetchQuery method in SolidJS Query. This approach allows for more control over when and how data is fetched.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/prefetching.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
const prefetchTodo = async (id) => {
  const todo = await queryClient.fetchQuery(() => ['todo', id], () =>
    fetchTodoById(id)
  )
  setTodoPreview(todo)
}

----------------------------------------

TITLE: Type Narrowing in Solid Query
DESCRIPTION: Demonstrates how Solid Query uses discriminated union types to narrow the query result type based on the query status.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/typescript.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
const query = useQuery(() => ({
  queryKey: ['number'],
  queryFn: () => Promise.resolve(5),
}))

if (query.isSuccess) {
  const data = query.data
  //     ^? const data: number
}

----------------------------------------

TITLE: Configuring Default Network Mode
DESCRIPTION: Example of how to set the default network mode to 'offlineFirst' for both queries and mutations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_10

LANGUAGE: javascript
CODE:
new QueryClient({
  defaultOptions: {
    queries: {
      networkMode: 'offlineFirst',
    },
    mutations: {
      networkMode: 'offlineFirst',
    },
  },
})

----------------------------------------

TITLE: Manually Priming a Query in React Query
DESCRIPTION: This snippet shows how to manually prime a query in React Query using the setQueryData method. It directly adds or updates a query's cached result by key when data is already available synchronously.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_8

LANGUAGE: tsx
CODE:
queryClient.setQueryData(['todos'], todos)

----------------------------------------

TITLE: Advanced Page Param Handling in Infinite Queries
DESCRIPTION: A more complex configuration for infinite queries that handles numeric pagination with checks for boundaries. It demonstrates how to access the current page parameter in the pagination functions and implement custom logic for determining next/previous pages.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-16_snippet_6

LANGUAGE: ts
CODE:
injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    if (lastPage.length === 0) {
      return undefined
    }
    return lastPageParam + 1
  },
  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
    if (firstPageParam <= 1) {
      return undefined
    }
    return firstPageParam - 1
  },
}))

----------------------------------------

TITLE: Implementing Query Function with Parameter Access in TanStack Query
DESCRIPTION: Shows how to define a query using useQuery hook and access query parameters through queryKey in the query function. The example demonstrates passing status and page parameters and destructuring them in the fetchTodoList function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/query-functions.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
const result = useQuery({
  queryKey: ['todos', { status, page }],
  queryFn: fetchTodoList,
})

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}

----------------------------------------

TITLE: Implementing Prefetch Query in Page Route
DESCRIPTION: Example of prefetching data in a page route using QueryClient, demonstrating the integration with SvelteKit's load function and fetch API.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
export async function load({ parent, fetch }) {
  const { queryClient } = await parent()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: async () => (await fetch('/api/posts')).json(),
  })
}

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  const query = createQuery({
    queryKey: ['posts'],
    queryFn: async () => (await fetch('/api/posts')).json(),
  })
</script>

----------------------------------------

TITLE: Using PersistQueryClientProvider with React in TypeScript
DESCRIPTION: Sets up a PersistQueryClientProvider to handle query client persistence in a React application. It uses a sync storage persister with localStorage and wraps the entire app.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const persister = createSyncStoragePersister({
  storage: window.localStorage,
})

ReactDOM.createRoot(rootElement).render(
  <PersistQueryClientProvider
    client={queryClient}
    persistOptions={{ persister }}
  >
    <App />
  </PersistQueryClientProvider>,
)

----------------------------------------

TITLE: Using the refetch function in useQuery with SolidJS
DESCRIPTION: Example of the refetch function signature from useQuery return value. This function allows manual refetching of the query with options to control error throwing and request cancellation behavior.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-16_snippet_7

LANGUAGE: typescript
CODE:
refetch: (options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult>

----------------------------------------

TITLE: Basic Custom React Query Hook Definition
DESCRIPTION: Example of a simple custom hook using React Query to fetch data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
export function useCustomHook() {
  return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })
}

----------------------------------------

TITLE: Implementing Dynamic Parallel Queries with Computed Properties in Vue
DESCRIPTION: This snippet shows how to create dynamic parallel queries using computed properties in Vue.js. It generates multiple queries based on a list of users, demonstrating the use of useQueries for batch query execution.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/parallel-queries.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
const users = computed(...)
const queries = computed(() => users.value.map(user => {
    return {
      queryKey: ['user', user.id],
      queryFn: () => fetchUserById(user.id),
    }
  })
);
const userQueries = useQueries({queries: queries})

----------------------------------------

TITLE: Creating Suspendable Query Component in Vue
DESCRIPTION: Demonstrates how to create a suspendable component using useQuery from solid-query, including data fetching and suspense handling.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/suspense.md#2025-04-16_snippet_1

LANGUAGE: vue
CODE:
<script>
import { defineComponent } from 'vue'
import { useQuery } from '@tanstack/solid-query'

const todoFetcher = async () =>
  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
    response.json(),
  )
export default defineComponent({
  name: 'SuspendableComponent',
  async setup() {
    const { data, suspense } = useQuery(() => ['todos'], todoFetcher)
    await suspense()

    return { data }
  },
})
</script>

----------------------------------------

TITLE: Posts Page with Data Serialization
DESCRIPTION: Server component implementation that includes data serialization before sending to the client.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_11

LANGUAGE: typescript
CODE:
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import { getQueryClient } from './get-query-client'
import { serialize } from './transformer'
import Posts from './posts'

export default function PostsPage() {
  const queryClient = getQueryClient()

  queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: () => getPosts().then(serialize),
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Type Inference with Data Transformation
DESCRIPTION: Shows type inference when using the select option to transform query results. The data type is inferred as Ref<string> | Ref<undefined> after transformation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/typescript.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const { data } = useQuery({
  //      ^? const data: Ref<string> | Ref<undefined>
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
})

----------------------------------------

TITLE: Configuring React Query Provider in Next.js _app.tsx
DESCRIPTION: Sets up the QueryClient provider with SSR-optimized configuration in Next.js application wrapper. Includes staleTime configuration to prevent immediate client-side refetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
// _app.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Using Dynamic Placeholder Data from Cache in TanStack Query with React
DESCRIPTION: This example demonstrates using a function to derive placeholder data from an existing query cache. It fetches a specific blog post and uses a smaller version from a previous 'blogPosts' query as placeholder data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/placeholder-query-data.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['blogPost', blogPostId],
  queryFn: () => fetch(`/blogPosts/${blogPostId}`),
  placeholderData: () => {
    // Use the smaller/preview version of the blogPost from the 'blogPosts'
    // query as the placeholder data for this blogPost query
    return queryClient
      .getQueryData(['blogPosts'])
      ?.find((d) => d.id === blogPostId)
  },
})

----------------------------------------

TITLE: Query Filtering Operations in TanStack Query
DESCRIPTION: Examples of using QueryFilters to perform various operations like canceling queries, removing inactive queries, and refetching active queries based on different filter conditions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
// Cancel all queries
await queryClient.cancelQueries()

// Remove all inactive queries that begin with `posts` in the key
queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })

// Refetch all active queries
await queryClient.refetchQueries({ type: 'active' })

// Refetch all active queries that begin with `posts` in the key
await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })

----------------------------------------

TITLE: Conditionally Enabling Query Based on Filter in Vue
DESCRIPTION: This example shows how to conditionally enable a query based on a filter value. The query is only executed when the filter is not empty, using a computed property to determine the 'enabled' state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-16_snippet_1

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const filter = ref('')
const isEnabled = computed(() => !!filter.value)
const { data } = useQuery({
  queryKey: ['todos', filter],
  queryFn: () => fetchTodos(filter),
  // ‚¨áÔ∏è disabled as long as the filter is empty
  enabled: isEnabled,
})
</script>

<template>
  <span v-if="data">Filter was set and data is here!</span>
</template>

----------------------------------------

TITLE: Persister API Function Signature
DESCRIPTION: Function signature for the experimental_createPersister utility.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
experimental_createPersister(options: StoragePersisterOptions)

----------------------------------------

TITLE: Prefetching Queries in Nuxt 2 Component
DESCRIPTION: Shows how to prefetch queries in a Nuxt 2 component, using onServerPrefetch and dehydrating the query state. It demonstrates both prefetched and non-prefetched queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-16_snippet_3

LANGUAGE: vue
CODE:
<template>
  <div>
    <button @click="refetch">Refetch</button>
    <p>{{ data }}</p>
  </div>
</template>

<script lang="ts">
import {
  defineComponent,
  onServerPrefetch,
  useContext,
} from '@nuxtjs/composition-api'
import { useQuery, useQueryClient, dehydrate } from '@tanstack/vue-query'

export default defineComponent({
  setup() {
    // Get QueryClient either from SSR context, or Vue context
    const { ssrContext } = useContext()
    // Make sure to provide `queryClient` as a second parameter to `useQuery` calls
    const queryClient =
      (ssrContext != null && ssrContext.VueQuery) || useQueryClient()

    // This will be prefetched and sent from the server
    const { data, refetch, suspense } = useQuery(
      {
        queryKey: ['todos'],
        queryFn: getTodos,
      },
      queryClient,
    )
    // This won't be prefetched, it will start fetching on client side
    const { data2 } = useQuery(
      {
        queryKey: 'todos2',
        queryFn: getTodos,
      },
      queryClient,
    )

    onServerPrefetch(async () => {
      await suspense()
      ssrContext.nuxt.vueQueryState = dehydrate(queryClient)
    })

    return {
      refetch,
      data,
    }
  },
})
</script>

----------------------------------------

TITLE: Keeping Only First Page in Infinite Query Data
DESCRIPTION: This snippet demonstrates how to manually update the infinite query data to keep only the first page, which can be useful for resetting the query to its initial state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
queryClient.setQueryData(['projects'], (data) => ({
  pages: data.pages.slice(0, 1),
  pageParams: data.pageParams.slice(0, 1),
}))

----------------------------------------

TITLE: Basic Mutation Setup with injectMutation in TanStack Query
DESCRIPTION: This snippet shows a simple setup for a mutation using the injectMutation function from TanStack Query. It defines a mutation with a postTodo mutation function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/invalidations-from-mutations.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
mutation = injectMutation(() => ({
  mutationFn: postTodo,
}))

----------------------------------------

TITLE: Subscribing to QueryCache Updates
DESCRIPTION: Demonstrates how to subscribe to cache updates using the subscribe method, which provides notifications about query state changes.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryCache.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
const callback = (event) => {
  console.log(event.type, event.query)
}

const unsubscribe = queryCache.subscribe(callback)

----------------------------------------

TITLE: Implementing Query Error Reset with ErrorBoundary in React
DESCRIPTION: Demonstrates how to use useQueryErrorResetBoundary hook with React Error Boundary to handle and reset query errors. The hook returns a reset function that can be used to clear query errors within the closest QueryErrorResetBoundary scope or globally if no boundary is defined.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useQueryErrorResetBoundary.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useQueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => {
  const { reset } = useQueryErrorResetBoundary()
  return (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ resetErrorBoundary }) => (
        <div>
          There was an error!
          <Button onClick={() => resetErrorBoundary()}>Try again</Button>
        </div>
      )}
    >
      <Page />
    </ErrorBoundary>
  )
}

----------------------------------------

TITLE: Registering Global Error Type
DESCRIPTION: Shows how to register a global error type for all queries in a Solid Query application by extending the Register interface.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/typescript.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
import '@tanstack/solid-query'

declare module '@tanstack/solid-query' {
  interface Register {
    defaultError: AxiosError
  }
}

const query = useQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.error
//    ^? (property) error: AxiosError | null

----------------------------------------

TITLE: Typing Query Options in Angular Query
DESCRIPTION: Shows how to use the queryOptions helper for better type inference when extracting query options into a separate function or service.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/typescript.md#2025-04-16_snippet_7

LANGUAGE: ts
CODE:
@Injectable({
  providedIn: 'root',
})
export class QueriesService {
  private http = inject(HttpClient)

  post(postId: number) {
    return queryOptions({
      queryKey: ['post', postId],
      queryFn: () => {
        return lastValueFrom(
          this.http.get<Post>(
            `https://jsonplaceholder.typicode.com/posts/${postId}`,
          ),
        )
      },
    })
  }
}

@Component({
  // ...
})
export class Component {
  queryClient = inject(QueryClient)

  postId = signal(1)

  queries = inject(QueriesService)
  optionsSignal = computed(() => this.queries.post(this.postId()))

  postQuery = injectQuery(() => this.queries.post(1))
  postQuery = injectQuery(() => this.queries.post(this.postId()))

  // You can also pass a signal which returns query options
  postQuery = injectQuery(this.optionsSignal)

  someMethod() {
    this.queryClient.prefetchQuery(this.queries.post(23))
  }
}

data = this.queryClient.getQueryData(groupOptions().queryKey)
// ^? data: Post | undefined

data = queryClient.getQueryData<Post>(['post', 1])

----------------------------------------

TITLE: Query Status Transitions in Dependent Queries with TanStack Query
DESCRIPTION: This snippet shows the different status transitions of a dependent query. It illustrates how the status and fetchStatus properties change as the dependent query progresses from pending to fetching to success.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/dependent-queries.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
status: 'pending'
isPending: true
fetchStatus: 'idle'

LANGUAGE: tsx
CODE:
status: 'pending'
isPending: true
fetchStatus: 'fetching'

LANGUAGE: tsx
CODE:
status: 'success'
isPending: false
fetchStatus: 'idle'

----------------------------------------

TITLE: Defining and Using Query Options in Angular with TanStack Query
DESCRIPTION: This snippet shows how to create a service with reusable query definitions using queryOptions from TanStack Query. It demonstrates defining a query for fetching a post, and how to use it in components and with the queryClient for operations like prefetching and setting query data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-options.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import { queryOptions } from '@tanstack/angular-query-experimental'

@Injectable({
  providedIn: 'root',
})
export class QueriesService {
  private http = inject(HttpClient)

  post(postId: number) {
    return queryOptions({
      queryKey: ['post', postId],
      queryFn: () => {
        return lastValueFrom(
          this.http.get<Post>(
            `https://jsonplaceholder.typicode.com/posts/${postId}`,
          ),
        )
      },
    })
  }
}

// usage:

postId = input.required({
  transform: numberAttribute,
})
queries = inject(QueriesService)

postQuery = injectQuery(() => this.queries.post(this.postId()))

queryClient.prefetchQuery(this.queries.post(23))
queryClient.setQueryData(this.queries.post(42).queryKey, newPost)

----------------------------------------

TITLE: Implementing Query Client with Persister
DESCRIPTION: Example showing how to create a QueryClient with a persister configuration using localStorage.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/plugins/createPersister.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { QueryClient } from '@tanstack/vue-query'
import { experimental_createPersister } from '@tanstack/query-persist-client-core'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: experimental_createPersister({
        storage: localStorage,
        maxAge: 1000 * 60 * 60 * 12, // 12 hours
      }),
    },
  },
})

----------------------------------------

TITLE: Updating refetchInterval Callback in TanStack Query v5
DESCRIPTION: This snippet demonstrates the change in the refetchInterval callback function. In v5, it only receives the query object as an argument, instead of both data and query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
- refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false | undefined) // [!code --]
+ refetchInterval: number | false | ((query: Query) => number | false | undefined) // [!code ++]

----------------------------------------

TITLE: Executing Basic Parallel Queries in Vue with TanStack Query
DESCRIPTION: This snippet demonstrates how to execute multiple queries in parallel using the useQuery hook from TanStack Query in a Vue.js setup script. It shows three separate queries for users, teams, and projects.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/parallel-queries.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup lang="ts">
// The following queries will execute in parallel
const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
const projectsQuery = useQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
})
</script>

----------------------------------------

TITLE: Correct Usage of TanStack Query Hook in React Dependencies
DESCRIPTION: Shows the proper way to use TanStack Query hooks with React dependency arrays by destructuring the specific methods needed, maintaining referential stability.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/no-unstable-deps.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/no-unstable-deps": "warn" */
import { useCallback } from 'React'
import { useMutation } from '@tanstack/react-query'

function Component() {
  const { mutate } = useMutation({ mutationFn: (value: string) => value })
  const callback = useCallback(() => {
    mutate('hello')
  }, [mutate])
  return null
}

----------------------------------------

TITLE: Using useQuery with Suspense in Solid Query
DESCRIPTION: This example shows how to use useQuery with Solid's Suspense and ErrorBoundary components. It demonstrates how to handle loading and error states using these built-in components.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/solid-query'

function App() {
  const todos = useQuery(() => ({
    queryKey: 'todos',
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
    throwOnError: true,
  }))

  return (
    <ErrorBoundary fallback={<div>Error: {todos.error.message}</div>}>
      <Suspense fallback={<div>Loading...</div>}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Suspense>
    </ErrorBoundary>
  )
}

----------------------------------------

TITLE: Using QueryClient Fetch Methods
DESCRIPTION: Demonstrates the new async prefetchQuery and fetchQuery methods available on QueryClient.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
// Prefetch a query:
await queryClient.prefetchQuery('posts', fetchPosts)

// Fetch a query:
try {
  const data = await queryClient.fetchQuery('posts', fetchPosts)
} catch (error) {
  // Error handling
}

----------------------------------------

TITLE: Configuring Query Client with Pending Query Support
DESCRIPTION: Creates a query client configuration that supports dehydrating pending queries and handles server/browser environments differently. Includes error handling and stale time configuration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_7

LANGUAGE: typescript
CODE:
import {
  isServer,
  QueryClient,
  defaultShouldDehydrateQuery,
} from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
      dehydrate: {
        // include pending queries in dehydration
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === 'pending',
        shouldRedactErrors: (error) => {
          return false
        },
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

export function getQueryClient() {
  if (isServer) {
    return makeQueryClient()
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

----------------------------------------

TITLE: Disabling Query Execution with Enabled Option in Vue
DESCRIPTION: This snippet demonstrates how to disable a query by setting the 'enabled' option to false. It also shows how to manually trigger the query using the 'refetch' function and handle different query states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
  enabled: false,
})
</script>

<template>
  <button @click="refetch()">Fetch Todos</button>
  <span v-if="isLoading">Loading...</span>
  <span v-else-if="isError">Error: {{ error?.message }}</span>
  <div v-else-if="data">
    <span v-if="isFetching">Fetching...</span>
    <ul>
      <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
    </ul>
  </div>
  <span v-else>Not ready...</span>
</template>

----------------------------------------

TITLE: Using skipToken for Typesafe Query Disabling in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates the use of 'skipToken' to disable a query in a type-safe manner. It's particularly useful when working with TypeScript and conditional query execution based on filter values.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { skipToken, useQuery } from '@tanstack/react-query'

function Todos() {
  const [filter, setFilter] = React.useState<string | undefined>()

  const { data } = useQuery({
    queryKey: ['todos', filter],
    // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
    queryFn: filter ? () => fetchTodos(filter) : skipToken,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}

----------------------------------------

TITLE: Subscribing to Online State Changes in TanStack Query
DESCRIPTION: Shows how to subscribe to online state changes using the OnlineManager. Returns an unsubscribe function that can be used to clean up the subscription.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/onlineManager.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { onlineManager } from '@tanstack/react-query'

const unsubscribe = onlineManager.subscribe((isOnline) => {
  console.log('isOnline', isOnline)
})

----------------------------------------

TITLE: Reactive Query Implementation
DESCRIPTION: Improved implementation that accepts a ref and properly tracks changes to the userId.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
export function useUserProjects(userId: Ref<string>) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(userId.value),
  );
}

----------------------------------------

TITLE: Basic Query Keys in TanStack Query
DESCRIPTION: Demonstrates basic query key patterns for simple queries. Shows how to structure query keys for a list of todos and a custom query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
// A list of todos
injectQuery(() => ({ queryKey: ['todos'], ... }))

// Something else, whatever!
injectQuery(() => ({ queryKey: ['something', 'special'], ... }))

----------------------------------------

TITLE: Registering Query and Mutation Key Types in React Query
DESCRIPTION: Illustrates how to register global QueryKey and MutationKey types for structured and typed keys across the library.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/typescript.md#2025-04-16_snippet_5

LANGUAGE: ts
CODE:
import '@tanstack/react-query'

type QueryKey = ['dashboard' | 'marketing', ...ReadonlyArray<unknown>]

declare module '@tanstack/react-query' {
  interface Register {
    queryKey: QueryKey
    mutationKey: QueryKey
  }
}

----------------------------------------

TITLE: Updating QueryClient Configuration for gcTime
DESCRIPTION: Shows how to migrate from cacheTime to gcTime option in QueryClient configuration. The gcTime option controls when unused query data is garbage collected.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_7

LANGUAGE: tsx
CODE:
const MINUTE = 1000 * 60;

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
-      cacheTime: 10 * MINUTE, // [!code --]
+      gcTime: 10 * MINUTE, // [!code ++]
    },
  },
})

----------------------------------------

TITLE: Incorrect Usage of Object Rest Destructuring with useQuery in React Query
DESCRIPTION: This example demonstrates incorrect code that uses object rest destructuring on useQuery results. This pattern subscribes to every field of the query result which may cause unnecessary re-renders.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/no-rest-destructuring.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/no-rest-destructuring": "warn" */

const useTodos = () => {
  const { data: todos, ...rest } = useQuery({
    queryKey: ['todos'],
    queryFn: () => api.getTodos(),
  })
  return { todos, ...rest }
}

----------------------------------------

TITLE: Internal Custom Key Implementation
DESCRIPTION: Demonstrates how custom keys are internally combined with default query keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo

----------------------------------------

TITLE: Invalidating Multiple Queries After Mutation in Vue Query
DESCRIPTION: Example showing how to invalidate multiple query keys ('todos' and 'reminders') after a successful mutation using the useMutation hook and queryClient. The invalidation ensures that the affected queries will refetch their data to maintain consistency.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/invalidations-from-mutations.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useMutation, useQueryClient } from '@tanstack/vue-query'

const queryClient = useQueryClient()

// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
const mutation = useMutation({
  mutationFn: addTodo,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    queryClient.invalidateQueries({ queryKey: ['reminders'] })
  },
})

----------------------------------------

TITLE: Using Previous Data as Placeholder in TanStack Query with Angular
DESCRIPTION: This example demonstrates how to use a function for placeholderData that returns the previous query data. This approach is useful for preserving existing data during refetching or when switching between queries with similar data structures.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
class TodosComponent {
  result = injectQuery(() => ({
    queryKey: ['todos', id()],
    queryFn: () => fetch(`/todos/${id}`),
    placeholderData: (previousData, previousQuery) => previousData,
  }))
}

----------------------------------------

TITLE: Query with Default staleTime
DESCRIPTION: Shows query configuration with default staleTime that causes immediate refetch on mount.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})

----------------------------------------

TITLE: Initializing and Subscribing to QueryObserver in TanStack Query
DESCRIPTION: Demonstrates how to create a new QueryObserver instance and subscribe to query results. The observer is initialized with a queryClient and options object containing a queryKey. The subscribe method returns an unsubscribe function that can be called to clean up the subscription.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryObserver.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const observer = new QueryObserver(queryClient, { queryKey: ['posts'] })

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})

----------------------------------------

TITLE: Persister Import Path Updates
DESCRIPTION: Updates to import paths for persistence-related functionality, moving from experimental to stable APIs.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_14

LANGUAGE: tsx
CODE:
- import { persistQueryClient } from 'react-query/persistQueryClient-experimental' // [!code --]
- import { createWebStoragePersistor } from 'react-query/createWebStoragePersistor-experimental' // [!code --]
- import { createAsyncStoragePersistor } from 'react-query/createAsyncStoragePersistor-experimental' // [!code --]

+ import { persistQueryClient } from '@tanstack/react-query-persist-client' // [!code ++]
+ import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister' // [!code ++]
+ import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'  // [!code ++]

----------------------------------------

TITLE: Async Callbacks in Mutations
DESCRIPTION: Demonstrates the execution order of async callbacks in mutations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: addTodo,
  onSuccess: async () => {
    console.log("I'm first!")
  },
  onSettled: async () => {
    console.log("I'm second!")
  },
})

----------------------------------------

TITLE: Initializing QueryClientProvider in Svelte
DESCRIPTION: This snippet demonstrates how to set up the QueryClientProvider near the root of a Svelte project. It creates a QueryClient instance and wraps a child component with the provider.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/overview.md#2025-04-16_snippet_0

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
  import Example from './lib/Example.svelte'

  const queryClient = new QueryClient()
</script>

<QueryClientProvider client={queryClient}>
  <Example />
</QueryClientProvider>

----------------------------------------

TITLE: Custom Context Provider Setup for Component Data
DESCRIPTION: Implementation of a separate custom context provider for component-level data access, demonstrating isolation of query clients.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_19

LANGUAGE: tsx
CODE:
const context = React.createContext<QueryClient | undefined>(undefined)
const queryClient = new QueryClient()

export const useItems = () => {
  return useQuery(ITEMS_KEY, ITEMS_FETCHER, {
    context,
  })
}

export const MyComponentDataProvider = ({
  children,
}: {
  children: React.ReactNode
}) => {
  return (
    <QueryClientProvider client={queryClient} context={context}>
      {children}
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Mocking QueryClient in TanStack Query Tests (JavaScript)
DESCRIPTION: This snippet demonstrates how to mock the QueryClient for testing purposes. It shows how to create a wrapper component that provides a mocked QueryClient to the components being tested.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { render } from '@testing-library/react'

const createWrapper = () => {
  const testQueryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  })
  return ({ children }) => (
    <QueryClientProvider client={testQueryClient}>
      {children}
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Using queryClient.resetQueries
DESCRIPTION: The resetQueries method resets queries to their initial state. Unlike clear, it notifies subscribers, and unlike invalidateQueries, it resets to pre-loaded state. Queries with initialData are reset to that value.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_15

LANGUAGE: tsx
CODE:
queryClient.resetQueries({ queryKey, exact: true })

----------------------------------------

TITLE: Basic Non-Reactive Query Implementation
DESCRIPTION: Initial implementation of a query composable that doesn't properly handle reactivity when the userId changes.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
export function useUserProjects(userId: string) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(userId),
  );
}

----------------------------------------

TITLE: Async Mutation with Error Handling
DESCRIPTION: Shows how to use mutations with async/await pattern and proper error handling using try/catch.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_6

LANGUAGE: typescript
CODE:
mutation = injectMutation(() => ({ mutationFn: addTodo }))

try {
  const todo = await mutation.mutateAsync(todo)
  console.log(todo)
} catch (error) {
  console.error(error)
} finally {
  console.log('done')
}

----------------------------------------

TITLE: Configuring Network Mode in TanStack Query
DESCRIPTION: This code demonstrates how to set the networkMode option when creating a Query client. The networkMode determines when queries will be fetched based on network connectivity.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/network-mode.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
import { QueryClient } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      networkMode: 'online',
    },
    mutations: {
      networkMode: 'online',
    },
  },
})

----------------------------------------

TITLE: Implementing Manual Query Cancellation in TanStack Query
DESCRIPTION: This snippet shows how to manually cancel a query using queryClient.cancelQueries(). It includes a button that, when clicked, cancels the query and reverts it to its previous state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

return (
  <button
    onClick={(e) => {
      e.preventDefault()
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }}
  >
    Cancel
  </button>
)

----------------------------------------

TITLE: Disabling Queries with enabled Option in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to disable a query using the 'enabled' option set to false. It shows the usage of useQuery hook with a disabled query and how to manually trigger the query using the refetch function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/disabling-queries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
function Todos() {
  const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
    enabled: false,
  })

  return (
    <div>
      <button onClick={() => refetch()}>Fetch Todos</button>

      {data ? (
        <>
          <ul>
            {data.map((todo) => (
              <li key={todo.id}>{todo.title}</li>
            ))}
          </ul>
        </>
      ) : isError ? (
        <span>Error: {error.message}</span>
      ) : isLoading ? (
        <span>Loading...</span>
      ) : (
        <span>Not ready ...</span>
      )}

      <div>{isFetching ? 'Fetching...' : null}</div>
    </div>
  )
}

----------------------------------------

TITLE: React Query Setup in Remix Root Route
DESCRIPTION: Configures React Query provider in Remix root route with SSR-optimized settings. Similar to Next.js setup but adapted for Remix architecture.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
// app/root.tsx
import { Outlet } from '@remix-run/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp() {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Outlet />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Global Query Retry Configuration in Angular
DESCRIPTION: Demonstrates how to configure retry behavior globally for all queries using QueryClient. Implements an exponential backoff strategy for retry delays.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-retries.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
import {
  QueryCache,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/angular-query-experimental'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
})

bootstrapApplication(AppComponent, {
  providers: [provideTanStackQuery(queryClient)],
})

----------------------------------------

TITLE: Initializing QueriesObserver in TanStack Query
DESCRIPTION: Demonstrates how to create and use a QueriesObserver instance to monitor multiple queries. The observer can watch multiple queries simultaneously and provides a subscription mechanism to react to query results.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueriesObserver.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const observer = new QueriesObserver(queryClient, [
  { queryKey: ['post', 1], queryFn: fetchPost },
  { queryKey: ['post', 2], queryFn: fetchPost },
])

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})

----------------------------------------

TITLE: Testing Infinite Query Pagination
DESCRIPTION: Example of testing infinite query pagination with fetchNextPage functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-16_snippet_8

LANGUAGE: typescript
CODE:
const { result } = renderHook(() => useInfiniteQueryCustomHook(), {
  wrapper,
})

await waitFor(() => expect(result.current.isSuccess).toBe(true))

expect(result.current.data.pages).toStrictEqual(generateMockedResponse(1))

result.current.fetchNextPage()

await waitFor(() =>
  expect(result.current.data.pages).toStrictEqual([
    ...generateMockedResponse(1),
    ...generateMockedResponse(2),
  ]),
)

expectation.done()

----------------------------------------

TITLE: Using setQueryData with Direct Value
DESCRIPTION: Setting query data by directly providing a new value to replace the existing cached data for a query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_7

LANGUAGE: tsx
CODE:
setQueryData(queryKey, newData)

----------------------------------------

TITLE: Using Static Placeholder Data in TanStack Query with React
DESCRIPTION: This snippet shows how to use static placeholder data in a useQuery hook. It fetches todos and uses placeholderTodos as temporary data while the query is loading.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/placeholder-query-data.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  placeholderData: placeholderTodos,
})

----------------------------------------

TITLE: Basic Vue Mutation Implementation with TanStack Query
DESCRIPTION: Demonstrates basic mutation usage in Vue with loading, error, and success states. Uses the useMutation hook to handle POST requests for creating todos.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/mutations.md#2025-04-16_snippet_0

LANGUAGE: vue
CODE:
<script setup>
import { useMutation } from '@tanstack/vue-query'

const { isPending, isError, error, isSuccess, mutate } = useMutation({
  mutationFn: (newTodo) => axios.post('/todos', newTodo),
})

function addTodo() {
  mutate({ id: new Date(), title: 'Do Laundry' })
}
</script>

<template>
  <span v-if="isPending">Adding todo...</span>
  <span v-else-if="isError">An error occurred: {{ error.message }}</span>
  <span v-else-if="isSuccess">Todo added!</span>
  <button @click="addTodo">Create Todo</button>
</template>

----------------------------------------

TITLE: Manually Removing First Page from Infinite Query Data
DESCRIPTION: This code snippet demonstrates how to manually remove the first page from the infinite query data using the queryClient's setQueryData method.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
queryClient.setQueryData(['projects'], (data) => ({
  pages: data.pages.slice(1),
  pageParams: data.pageParams.slice(1),
}))

----------------------------------------

TITLE: Mutation Filtering Operations in TanStack Query
DESCRIPTION: Examples of using MutationFilters to check mutation status and filter mutations based on mutation keys or predicate functions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
// Get the number of all fetching mutations
await queryClient.isMutating()

// Filter mutations by mutationKey
await queryClient.isMutating({ mutationKey: ['post'] })

// Filter mutations using a predicate function
await queryClient.isMutating({
  predicate: (mutation) => mutation.state.variables?.id === 1,
})

----------------------------------------

TITLE: Retrieving Default Options
DESCRIPTION: Shows how to get the default options that were set when creating the client or with setDefaultOptions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_18

LANGUAGE: tsx
CODE:
const defaultOptions = queryClient.getDefaultOptions()

----------------------------------------

TITLE: Incorrect Implementation of Query Function in TanStack Query (TSX)
DESCRIPTION: An example of incorrect code that violates the no-void-query-fn rule. The query function doesn't return a value from the API call, which would cause TanStack Query to cache undefined instead of the actual data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/no-void-query-fn.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/no-void-query-fn": "error" */

useQuery({
  queryKey: ['todos'],
  queryFn: async () => {
    await api.todos.fetch() // Function doesn't return the fetched data
  },
})

----------------------------------------

TITLE: Creating Suspendable Component with Vue Query
DESCRIPTION: Implementation of a suspendable component using Vue Query's useQuery hook with async setup function. Shows how to fetch data and handle suspense state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/suspense.md#2025-04-16_snippet_1

LANGUAGE: vue
CODE:
<script>
import { defineComponent } from 'vue'
import { useQuery } from '@tanstack/vue-query'

const todoFetcher = async () =>
  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
    response.json(),
  )
export default defineComponent({
  name: 'SuspendableComponent',
  async setup() {
    const { data, suspense } = useQuery(['todos'], todoFetcher)
    await suspense()

    return { data }
  },
})
</script>

----------------------------------------

TITLE: Providing TanStack Query Client in NgModule-based Angular Apps
DESCRIPTION: This snippet demonstrates how to provide the TanStack Query client in a traditional NgModule-based Angular application. It shows the configuration within an NgModule decorator to make the QueryClient available throughout the application.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/quick-start.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [provideTanStackQuery(new QueryClient())],
  bootstrap: [AppComponent],
})
export class AppModule {}

----------------------------------------

TITLE: Query Status Switch Implementation
DESCRIPTION: Shows an alternative approach to handling query states using a switch statement in the template, demonstrating status-based conditional rendering.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/queries.md#2025-04-16_snippet_3

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  standalone: true,
  template: `
    @switch (todos.status()) {
      @case ('pending') {
        <span>Loading...</span>
      }
      @case ('error') {
        <span>Error: {{ todos.error()?.message }}</span>
      }
      <!-- also status === 'success', but "else" logic works, too -->
      @default {
        <ul>
          @for (todo of todos.data(); track todo.id) {
            <li>{{ todo.title }}</li>
          } @empty {
            <li>No todos found</li>
          }
        </ul>
      }
    }
  `,
})
class TodosComponent {}

----------------------------------------

TITLE: Disabling Window Focus Refetching for a Specific Query in Angular with TanStack Query
DESCRIPTION: This example demonstrates how to disable automatic refetching on window focus for a specific query using the injectQuery function. It sets up a query for fetching todos with the refetchOnWindowFocus option set to false.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/window-focus-refetching.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false,
}))

----------------------------------------

TITLE: Using queryClient.isFetching
DESCRIPTION: The isFetching method returns an integer representing how many queries are currently fetching, including background fetching, loading new pages, or loading more infinite query results.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_16

LANGUAGE: tsx
CODE:
if (queryClient.isFetching()) {
  console.log('At least one query is fetching!')
}

----------------------------------------

TITLE: Sequential Mutation Callbacks
DESCRIPTION: Demonstrates the execution order of mutation callbacks using async/await pattern.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onSuccess: async () => {
    console.log("I'm first!")
  },
  onSettled: async () => {
    console.log("I'm second!")
  },
}))

----------------------------------------

TITLE: Predicate-based Query Invalidation
DESCRIPTION: Shows how to use a predicate function for fine-grained control over which queries to invalidate. The example filters queries based on a version number in the query key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-invalidation.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
queryClient.invalidateQueries({
  predicate: (query) =>
    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { version: 20 }],
  queryFn: fetchTodoList,
}))

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { version: 10 }],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { version: 5 }],
  queryFn: fetchTodoList,
}))

----------------------------------------

TITLE: Initializing Vue Query Plugin
DESCRIPTION: Setup code for initializing Vue Query in a Vue application using VueQueryPlugin.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/installation.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { VueQueryPlugin } from '@tanstack/vue-query'

app.use(VueQueryPlugin)

----------------------------------------

TITLE: Dynamic Devtools Loading with Keyboard Shortcut
DESCRIPTION: Advanced configuration showing how to implement on-demand devtools loading triggered by a keyboard shortcut using RxJS observables and signals.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/devtools.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
@Injectable({ providedIn: 'root' })
class DevtoolsOptionsManager {
  loadDevtools = toSignal(
    fromEvent<KeyboardEvent>(document, 'keydown').pipe(
      map(
        (event): boolean =>
          event.metaKey && event.ctrlKey && event.shiftKey && event.key === 'D',
      ),
      scan((acc, curr) => acc || curr, false),
    ),
    {
      initialValue: false,
    },
  )
}

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(),
    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({
        initialIsOpen: true,
        loadDevtools: inject(DevtoolsOptionsManager).loadDevtools(),
      })),
    ),
  ],
}

----------------------------------------

TITLE: Implementing Online Status Management with NetInfo in React Native
DESCRIPTION: Sets up online status management for React Query using @react-native-community/netinfo to handle connection state changes.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/react-native.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import NetInfo from '@react-native-community/netinfo'
import { onlineManager } from '@tanstack/react-query'

onlineManager.setEventListener((setOnline) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})

----------------------------------------

TITLE: Initial Data with Stale Time Configuration in TanStack Query
DESCRIPTION: Shows how to configure staleTime to control when a query with initial data will refetch. This example delays refetching until an interaction event occurs after 1000ms.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
// Show initialTodos immediately, but won't refetch until
// another interaction event is encountered after 1000 ms
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 1000,
}))

----------------------------------------

TITLE: Correct Usage of useQuery Without Object Rest Destructuring in React Query
DESCRIPTION: This example shows the correct approach to work with useQuery results without using object rest destructuring. It demonstrates storing the query result in a variable and then using standard object destructuring, which is fine performance-wise.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/no-rest-destructuring.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const todosQuery = useQuery({
  queryKey: ['todos'],
  queryFn: () => api.getTodos(),
})

// normal object destructuring is fine
const { data: todos } = todosQuery

----------------------------------------

TITLE: Event Handling with Mutations in React
DESCRIPTION: Shows correct implementation of form submission handling with mutations in React, addressing event pooling issues in React 16 and earlier.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
// This will not work in React 16 and earlier
const CreateTodo = () => {
  const mutation = useMutation({
    mutationFn: (event) => {
      event.preventDefault()
      return fetch('/api', new FormData(event.target))
    },
  })

  return <form onSubmit={mutation.mutate}>...</form>
}

// This will work
const CreateTodo = () => {
  const mutation = useMutation({
    mutationFn: (formData) => {
      return fetch('/api', formData)
    },
  })
  const onSubmit = (event) => {
    event.preventDefault()
    mutation.mutate(new FormData(event.target))
  }

  return <form onSubmit={onSubmit}>...</form>
}

----------------------------------------

TITLE: Hydrating Query Client State in React Query
DESCRIPTION: Example showing how to hydrate a previously dehydrated state back into a QueryClient cache. This is typically used on the client side to restore prefetched or persisted query states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { hydrate } from '@tanstack/react-query'

hydrate(queryClient, dehydratedState, options)

----------------------------------------

TITLE: Using provideAngularQuery in NgModule-based Angular Applications
DESCRIPTION: Example demonstrating how to integrate the provideAngularQuery function in a traditional NgModule-based Angular application by adding it to the providers array.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
import {
  provideAngularQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [provideAngularQuery(new QueryClient())],
  bootstrap: [AppComponent],
})
export class AppModule {}

----------------------------------------

TITLE: Configuring InfiniteQueryOptions in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to use the infiniteQueryOptions function to configure options for an infinite query. It accepts a queryKey and additional options that can be passed to useInfiniteQuery. The function is typically used for prefetching or other query operations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/infiniteQueryOptions.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
infiniteQueryOptions({
  queryKey,
  ...options,
})

----------------------------------------

TITLE: Configuring Query Options in React Query
DESCRIPTION: The queryOptions function is used to configure various options for queries in React Query. It allows setting properties such as queryKey, queryFn, enabled, and more to customize query behavior.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/queryOptions.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
import { queryOptions } from '@tanstack/react-query'

const options = queryOptions({
  queryKey: ['posts'],
  queryFn: fetchPosts,
  enabled: true,
})

----------------------------------------

TITLE: Implementing App Focus State Management
DESCRIPTION: Sets up focus state management using React Native's AppState to trigger query updates when the app becomes active.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/react-native.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
import { useEffect } from 'react'
import { AppState, Platform } from 'react-native'
import type { AppStateStatus } from 'react-native'
import { focusManager } from '@tanstack/react-query'

function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

useEffect(() => {
  const subscription = AppState.addEventListener('change', onAppStateChange)

  return () => subscription.remove()
}, [])

----------------------------------------

TITLE: Basic Initial Query Data Setup in TanStack Query
DESCRIPTION: A simple example showing how to provide initial data to a query using the initialData property. This allows the query to show data immediately while fetching updated data in the background.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/initial-query-data.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
}))

----------------------------------------

TITLE: Implementing Basic Filtering with TanStack Query in React
DESCRIPTION: This code snippet demonstrates how to implement basic filtering functionality using TanStack Query in a React component. It uses the useQuery hook to fetch data and applies a filter based on the selected status.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/filters.md#2025-04-16_snippet_0

LANGUAGE: jsx
CODE:
import { useQuery } from '@tanstack/react-query'

function App() {
  const [status, setStatus] = React.useState('all')

  const result = useQuery({
    queryKey: ['todos', { status }],
    queryFn: ({ queryKey: [_key, { status }] }) =>
      fetchTodos(status),
  })

  return (
    <div>
      <TodoCounter todos={result.data} />
      <TodoFilter status={status} setStatus={setStatus} />
      <TodoList todos={result.data} />
    </div>
  )
}

----------------------------------------

TITLE: Setting Query-Specific Defaults
DESCRIPTION: Demonstrates setting default options for specific queries, including setting a default queryFn.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_21

LANGUAGE: tsx
CODE:
queryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })

function Component() {
  const { data } = useQuery({ queryKey: ['posts'] })
}

----------------------------------------

TITLE: Query Default Configuration - Retry Settings
DESCRIPTION: Default retry configuration with 3 attempts and exponential backoff. Can be customized using retry and retryDelay options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/important-defaults.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)
    }
  }
})

----------------------------------------

TITLE: Reactive Query Options using Svelte Stores
DESCRIPTION: This snippet shows how to make TanStack Query options reactive in Svelte by using writable and derived stores. The intervalMs is converted to a writable store, and the query options are created as a derived store, ensuring that changes to intervalMs are reflected in the query's refetchInterval.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reactivity.md#2025-04-16_snippet_1

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { derived, writable } from 'svelte/store'
  import { createQuery } from '@tanstack/svelte-query'

  const endpoint = 'http://localhost:5173/api/data'

  const intervalMs = writable(1000)

  const query = createQuery(
    derived(intervalMs, ($intervalMs) => ({
      queryKey: ['refetch'],
      queryFn: async () => await fetch(endpoint).then((r) => r.json()),
      refetchInterval: $intervalMs,
    })),
  )
</script>

<input type="number" bind:value={$intervalMs} />

----------------------------------------

TITLE: Implementing Query Cancellation with graphql-request in TanStack Query
DESCRIPTION: This snippet shows how to use the AbortSignal with graphql-request in a TanStack Query queryFn. The signal is passed to the client's request method.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
const client = new GraphQLClient(endpoint)

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    client.request({ document: query, signal })
  },
})

----------------------------------------

TITLE: Query Client with Data Serialization
DESCRIPTION: Enhanced query client configuration that includes custom serialization and deserialization for non-JSON data types.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_10

LANGUAGE: typescript
CODE:
import { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'
import { deserialize, serialize } from './transformer'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      // ...
      hydrate: {
        deserializeData: deserialize,
      },
      dehydrate: {
        serializeData: serialize,
      },
    },
  })
}

----------------------------------------

TITLE: Implementing queryOptions with Undefined Initial Data in TypeScript
DESCRIPTION: Function overload for queryOptions that handles cases where initial data is undefined. Takes the same generic parameters as the defined data version but returns a different options type.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/queryoptions.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object

----------------------------------------

TITLE: Configuring Basic Query Retries in TanStack Query
DESCRIPTION: Demonstrates how to configure retry attempts for a specific query using the useQuery hook. This example shows setting a fixed number of retry attempts (10) for a failing query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/react-query'

// Make a specific query retry a certain number of times
const result = useQuery({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
})

----------------------------------------

TITLE: Configuring Global Window Focus Refetching in TanStack Query
DESCRIPTION: Demonstrates how to disable window focus refetching globally by configuring the QueryClient default options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false, // default: true
    },
  },
})

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}

----------------------------------------

TITLE: Using skipToken to Disable Query in Vue
DESCRIPTION: This snippet illustrates how to use the 'skipToken' to disable a query when a certain condition is not met. The query function is computed based on the filter value, returning skipToken when the filter is empty or undefined.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/disabling-queries.md#2025-04-16_snippet_2

LANGUAGE: vue
CODE:
<script setup>
import { useQuery, skipToken } from '@tanstack/vue-query'

const filter = ref('')
const queryFn = computed(() =>
  !!filter.value ? () => fetchTodos(filter) : skipToken,
)
const { data } = useQuery({
  queryKey: ['todos', filter],
  // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
  queryFn: queryFn,
})
</script>

<template>
  <span v-if="data">Filter was set and data is here!</span>
</template>

----------------------------------------

TITLE: Using Static Placeholder Data in TanStack Query with Angular
DESCRIPTION: This example shows how to provide static placeholder data to a query. The placeholderData option is set to a predefined variable 'placeholderTodos' which will be displayed while the actual query is loading.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/placeholder-query-data.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
class TodosComponent {
  result = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  }))
}

----------------------------------------

TITLE: Defining Query Keys for Todo Fetching in TanStack Query
DESCRIPTION: This snippet demonstrates how to create a custom hook that uses TanStack Query to fetch a todo item. It shows the structure of a query key array, combining a string identifier with a dynamic todoId.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/query-keys.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
function useTodos(todoId) {
  const queryKey = ['todos', todoId]
  return useQuery({
    queryKey,
    queryFn: () => fetchTodoById(todoId.value),
  })
}

----------------------------------------

TITLE: Creating Multiple Queries with TypeScript Type Definitions
DESCRIPTION: Function signature for createQueries that allows creating multiple queries with complex type parameters. Takes query options and an optional queryClient, returns a Readable store containing the combined query results.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/createqueries.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function createQueries<T, TCombinedResult>(
  __namedParameters,
  queryClient?,
): Readable<TCombinedResult>

----------------------------------------

TITLE: Implementing injectInfiniteQuery with Additional Overload
DESCRIPTION: This is another overload of the injectInfiniteQuery function with the same structure as the first one, providing flexibility in how the function can be called with different types of parameters and expected return values.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectinfinitequery.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
function injectInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(optionsFn, injector?): CreateInfiniteQueryResult<TData, TError>

----------------------------------------

TITLE: Integrating Vue Query Devtools Component
DESCRIPTION: Vue component setup for integrating the Vue Query Devtools component into a Vue 3 application. It imports and includes the VueQueryDevtools component in the template.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/devtools.md#2025-04-16_snippet_1

LANGUAGE: vue
CODE:
<script setup>
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
</script>

<template>
  <h1>The app!</h1>
  <VueQueryDevtools />
</template>

----------------------------------------

TITLE: Updating QueryClient Methods to Single Object Signature in TanStack Query v5
DESCRIPTION: This snippet shows the migration of various QueryClient methods to use a single object parameter instead of multiple parameters. It includes examples for methods like isFetching, ensureQueryData, getQueriesData, and others.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
queryClient.isFetching(key, filters) // [!code --]
queryClient.isFetching({ queryKey, ...filters }) // [!code ++]
queryClient.ensureQueryData(key, filters) // [!code --]
queryClient.ensureQueryData({ queryKey, ...filters }) // [!code ++]
queryClient.getQueriesData(key, filters) // [!code --]
queryClient.getQueriesData({ queryKey, ...filters }) // [!code ++]
queryClient.setQueriesData(key, updater, filters, options) // [!code --]
queryClient.setQueriesData({ queryKey, ...filters }, updater, options) // [!code ++]
queryClient.removeQueries(key, filters) // [!code --]
queryClient.removeQueries({ queryKey, ...filters }) // [!code ++]
queryClient.resetQueries(key, filters, options) // [!code --]
queryClient.resetQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.cancelQueries(key, filters, options) // [!code --]
queryClient.cancelQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.invalidateQueries(key, filters, options) // [!code --]
queryClient.invalidateQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.refetchQueries(key, filters, options) // [!code --]
queryClient.refetchQueries({ queryKey, ...filters }, options) // [!code ++]
queryClient.fetchQuery(key, fn, options) // [!code --]
queryClient.fetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
queryClient.prefetchQuery(key, fn, options) // [!code --]
queryClient.prefetchQuery({ queryKey, queryFn, ...options }) // [!code ++]
queryClient.fetchInfiniteQuery(key, fn, options) // [!code --]
queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]
queryClient.prefetchInfiniteQuery(key, fn, options) // [!code --]
queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]

----------------------------------------

TITLE: Creating Infinite Query Function Definition in TypeScript
DESCRIPTION: Function signature for createInfiniteQuery that enables infinite/continuous data fetching in TanStack Query. Takes generic type parameters for query data, error handling, pagination, and query key types. Accepts options and an optional queryClient parameter.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/createinfinitequery.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function createInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(options, queryClient?): CreateInfiniteQueryResult<TData, TError>

----------------------------------------

TITLE: Implementing Suspense Wrapper in Solid.js
DESCRIPTION: Shows how to wrap a suspendable component with Solid's Suspense component and specify a loading fallback component.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/suspense.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { Suspense } from 'solid-js'
;<Suspense fallback={<LoadingSpinner />}>
  <SuspendableComponent />
</Suspense>

----------------------------------------

TITLE: Configuring QueryClient with No Retries
DESCRIPTION: Configuration to disable query retries during testing to prevent timeouts.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ‚úÖ turns retries off
      retry: false,
    },
  },
})
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

----------------------------------------

TITLE: Prefetching Infinite Queries with TanStack Query in TypeScript
DESCRIPTION: This example shows how to prefetch an infinite query using the prefetchInfiniteQuery method. It demonstrates prefetching multiple pages of a 'projects' query, using options like initialPageParam, getNextPageParam, and pages.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/prefetching.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const prefetchProjects = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // prefetch the first 3 pages
  })
}

----------------------------------------

TITLE: Mocking Paginated API Response
DESCRIPTION: Function to generate mock responses for paginated data testing.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-16_snippet_6

LANGUAGE: typescript
CODE:
function generateMockedResponse(page) {
  return {
    page: page,
    items: [...]
  }
}

----------------------------------------

TITLE: Configuring VueQueryPlugin with Custom QueryClient Instance
DESCRIPTION: Demonstrates how to use a pre-created QueryClient instance with VueQueryPlugin.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const myClient = new QueryClient(queryClientConfig)
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClient: myClient,
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Using usePrefetchQuery Hook in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates the basic usage of the usePrefetchQuery hook. It's used to prefetch queries during render, before a suspense boundary that wraps a component using useSuspenseQuery. The hook accepts options similar to queryClient.prefetchQuery.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/usePrefetchQuery.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
usePrefetchQuery(options)

----------------------------------------

TITLE: Configuring VueQueryPlugin with QueryClientConfig
DESCRIPTION: Shows how to initialize VueQueryPlugin with custom QueryClientConfig options, setting default query configuration like staleTime.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: { queries: { staleTime: 3600 } },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Defining CreateBaseQueryResult Generic Type - TypeScript
DESCRIPTION: Defines a type alias that combines BaseQueryNarrowing with mapped signals, allowing for custom data, error and state types. It uses generics to provide flexibility in typing the query results while maintaining type safety.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/type-aliases/createbasequeryresult.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
type CreateBaseQueryResult<TData, TError, TState>: BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, "safely">>;

----------------------------------------

TITLE: Using useMutation in SolidJS
DESCRIPTION: This snippet shows how to use the useMutation hook in SolidJS. Like useInfiniteQuery, it is called with an arrow function to match SolidJS syntax.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useInfiniteQuery.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
useMutation(() => ...)

----------------------------------------

TITLE: Setting Fixed Retry Delay for Individual Queries
DESCRIPTION: Demonstrates how to set a fixed retry delay for an individual query, overriding the default exponential backoff behavior with a constant delay time.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-retries.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
})

----------------------------------------

TITLE: Accessing Running Mutations Variables with useMutationState
DESCRIPTION: Example showing how to get variables of all pending mutations using useMutationState hook with filters and select options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/useMutationState.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useMutationState } from '@tanstack/react-query'

const variables = useMutationState({
  filters: { status: 'pending' },
  select: (mutation) => mutation.state.variables,
})

----------------------------------------

TITLE: Type Inference with HTTP Client
DESCRIPTION: Demonstrates type inference when using Angular's HttpClient with injectQuery for API calls.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/typescript.md#2025-04-16_snippet_2

LANGUAGE: angular-ts
CODE:
@Component({
  template: `@let data = query.data();`,
  //               ^? data: Group[] | undefined
})
class MyComponent {
  http = inject(HttpClient)

  query = injectQuery(() => ({
    queryKey: ['groups'],
    queryFn: () => lastValueFrom(this.http.get<Group[]>('/groups')),
  }))
}

----------------------------------------

TITLE: Replacing remove Method with removeQueries in TanStack Query v5
DESCRIPTION: This snippet shows how to replace the deprecated remove method of useQuery with the removeQueries method of QueryClient in TanStack Query v5.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
const queryClient = useQueryClient()
const query = useQuery({ queryKey, queryFn })

query.remove() // [!code --]
queryClient.removeQueries({ queryKey }) // [!code ++]

----------------------------------------

TITLE: Setting Available Network Modes in TanStack Query
DESCRIPTION: This snippet shows the different networkMode options available in TanStack Query. These options control query behavior based on network status.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/network-mode.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
type NetworkMode = 'online' | 'always' | 'offlineFirst'

----------------------------------------

TITLE: Testing Network Calls with Nock
DESCRIPTION: Example of testing network requests using Nock to mock API responses.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-16_snippet_5

LANGUAGE: typescript
CODE:
const queryClient = new QueryClient()
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

const expectation = nock('http://example.com').get('/api/data').reply(200, {
  answer: 42,
})

const { result } = renderHook(() => useFetchData(), { wrapper })

await waitFor(() => expect(result.current.isSuccess).toBe(true))

expect(result.current.data).toEqual({ answer: 42 })

----------------------------------------

TITLE: Query with initialDataUpdatedAt
DESCRIPTION: Shows how to use initialDataUpdatedAt to specify when the initial data was last updated.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 1 minute
  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
})

----------------------------------------

TITLE: Updating getQueryData and getQueryState Methods in TanStack Query v5
DESCRIPTION: This snippet shows the changes to the getQueryData and getQueryState methods of the QueryClient. These methods now only accept a queryKey as an argument, removing the filters parameter.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
queryClient.getQueryData(queryKey, filters) // [!code --]
queryClient.getQueryData(queryKey) // [!code ++]

queryClient.getQueryState(queryKey, filters) // [!code --]
queryClient.getQueryState(queryKey) // [!code ++]

----------------------------------------

TITLE: Custom Hook with Network Request
DESCRIPTION: Example of a custom hook that makes an API request using React Query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/testing.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
function useFetchData() {
  return useQuery({
    queryKey: ['fetchData'],
    queryFn: () => request('/api/data'),
  })
}

----------------------------------------

TITLE: React Query with React.use() Implementation
DESCRIPTION: Example of using React Query with experimental React.use() API for data fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
import React from 'react'
import { useQuery } from '@tanstack/react-query'
import { fetchTodos, type Todo } from './api'

function TodoList({ query }: { query: UseQueryResult<Todo[]> }) {
  const data = React.use(query.promise)

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

export function App() {
  const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })

  return (
    <>
      <h1>Todos</h1>
      <React.Suspense fallback={<div>Loading...</div>}>
        <TodoList query={query} />
      </React.Suspense>
    </>
  )
}

----------------------------------------

TITLE: Initial Data Loading with SvelteKit Load Function
DESCRIPTION: Implementation of data loading using SvelteKit's load function to pass server-side data to the client through the initialData option.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
export async function load() {
  const posts = await getPosts()
  return { posts }
}

LANGUAGE: svelte
CODE:
<script>
  import { createQuery } from '@tanstack/svelte-query'
  import type { PageData } from './$types'

  export let data: PageData

  const query = createQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: data.posts,
  })
</script>

----------------------------------------

TITLE: Setting Default Query Options
DESCRIPTION: Demonstrates setting default options for all queries in the queryClient, such as configuring staleTime.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_19

LANGUAGE: tsx
CODE:
queryClient.setDefaultOptions({
  queries: {
    staleTime: Infinity,
  },
})

----------------------------------------

TITLE: Implementing Async Storage Persistence
DESCRIPTION: Example implementation of async storage persistence using React Native's AsyncStorage with TanStack Query, including QueryClient configuration and provider setup.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/createAsyncStoragePersister.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/react-query'
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
})

const Root = () => (
  <PersistQueryClientProvider
    client={queryClient}
    persistOptions={{ persister: asyncStoragePersister }}
  >
    <App />
  </PersistQueryClientProvider>
)

export default Root

----------------------------------------

TITLE: Defining DefinedCreateQueryResult Type Alias in TypeScript for Svelte Query
DESCRIPTION: This code snippet defines a type alias DefinedCreateQueryResult that extends DefinedCreateBaseQueryResult. It is used for options when creating a query with initial data in Svelte Query. The type has two generic parameters: TData (defaulting to unknown) and TError (defaulting to DefaultError).
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/type-aliases/definedcreatequeryresult.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
type DefinedCreateQueryResult<TData, TError>: DefinedCreateBaseQueryResult<TData, TError>;

----------------------------------------

TITLE: Implementing Query Cancellation with Angular HttpClient
DESCRIPTION: Example showing how to implement query cancellation using Angular's HttpClient with RxJS operators to handle abort signals.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
postQuery = injectQuery(() => ({
  enabled: this.postId() > 0,
  queryKey: ['post', this.postId()],
  queryFn: async (context): Promise<Post> => {
    const abort$ = fromEvent(context.signal, 'abort')
    return lastValueFrom(this.getPost$(this.postId()).pipe(takeUntil(abort$)))
  },
}))

----------------------------------------

TITLE: Basic Devtools Setup in Angular Query
DESCRIPTION: Shows how to enable devtools by adding withDevtools to provideTanStackQuery in the application configuration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/devtools.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
import {
  QueryClient,
  provideTanStackQuery,
  withDevtools,
} from '@tanstack/angular-query-experimental'

export const appConfig: ApplicationConfig = {
  providers: [provideTanStackQuery(new QueryClient(), withDevtools())],
}

----------------------------------------

TITLE: Defining CreateInfiniteQueryResult Type Alias in TypeScript
DESCRIPTION: Generic type alias that maps infinite query observer results to signals. Takes two type parameters: TData (defaults to unknown) for the data type and TError (defaults to DefaultError) for the error type.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/type-aliases/createinfinitequeryresult.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
type CreateInfiniteQueryResult<TData, TError>: MapToSignals<InfiniteQueryObserverResult<TData, TError>>;

----------------------------------------

TITLE: Custom Context Provider Setup for Container Data
DESCRIPTION: Implementation of a custom context provider for container-level data access using React Query, including user data fetching functionality.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_18

LANGUAGE: tsx
CODE:
const context = React.createContext<QueryClient | undefined>(undefined)
const queryClient = new QueryClient()

export const useUser = () => {
  return useQuery(USER_KEY, USER_FETCHER, {
    context,
  })
}

export const ContainerDataProvider = ({
  children,
}: {
  children: React.ReactNode
}) => {
  return (
    <QueryClientProvider client={queryClient} context={context}>
      {children}
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Implementing Bi-directional Infinite List with TanStack Query
DESCRIPTION: This example demonstrates how to set up a bi-directional infinite list using useInfiniteQuery. It includes configuration for fetching both next and previous pages.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/infinite-queries.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
})

----------------------------------------

TITLE: Using Vue Query with Script Setup
DESCRIPTION: Example of using Vue Query with Composition API and script setup syntax, demonstrating basic query implementation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/installation.md#2025-04-16_snippet_2

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isFetching, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})
</script>

<template>...</template>

----------------------------------------

TITLE: Illustrating Optimized Client-Side Navigation with Prefetching in Markdown
DESCRIPTION: This snippet demonstrates an optimized request waterfall for client-side navigation using prefetching techniques in frameworks like Next.js or Remix.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_12

LANGUAGE: markdown
CODE:
```
1. |> JS for <Feed>
1. |> getFeed() + getGraphDataById()
2.   |> JS for <GraphFeedItem>
```

----------------------------------------

TITLE: Manually Setting Focus State in TanStack Query
DESCRIPTION: Demonstrates manual focus state management using setFocused method. Shows how to set focused, unfocused states and reset to default focus check.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/focusManager.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

// Set focused
focusManager.setFocused(true)

// Set unfocused
focusManager.setFocused(false)

// Fallback to the default focus check
focusManager.setFocused(undefined)

----------------------------------------

TITLE: Defining injectQueryClient Function in TypeScript
DESCRIPTION: Shows the function signature for injectQueryClient without parameters, returning a QueryClient instance.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
function injectQueryClient(): QueryClient

----------------------------------------

TITLE: Injecting Mutation Tracking Signal in TypeScript for TanStack Query
DESCRIPTION: This function injects a signal that tracks the number of mutations an application is fetching. It takes optional filters and an Angular injector as parameters, and returns a signal with the number of fetching mutations. This can be used for implementing app-wide loading indicators.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectismutating.md#2025-04-16_snippet_0

LANGUAGE: TypeScript
CODE:
function injectIsMutating(filters?, injector?): Signal<number>

----------------------------------------

TITLE: Configuring Recommended Rules with Legacy Config in ESLint
DESCRIPTION: Legacy ESLint configuration (.eslintrc) that enables all recommended rules from the TanStack Query plugin using the extends property.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-16_snippet_6

LANGUAGE: json
CODE:
{
  "extends": ["plugin:@tanstack/query/recommended"]
}

----------------------------------------

TITLE: Optimized Request Sequence
DESCRIPTION: Example of an optimized request sequence when hoisting the getGraphDataById query to the Feed component.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/request-waterfalls.md#2025-04-16_snippet_8

LANGUAGE: text
CODE:
1. |> getFeed()
2.   |> getGraphDataById()
2.   |> JS for <GraphFeedItem>

----------------------------------------

TITLE: Component Query Example with Comments
DESCRIPTION: Shows a basic component setup with nested queries that creates a request waterfall pattern.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}

----------------------------------------

TITLE: MaybeRef Query Implementation
DESCRIPTION: Enhanced implementation that accepts both plain values and refs using MaybeRef type.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
export function useUserProjects(userId: MaybeRef<string>) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(toValue(userId)),
  );
}

----------------------------------------

TITLE: Fetching Query Data with Stale Time Configuration
DESCRIPTION: Shows how to fetch query data with a specific stale time configuration of 10000ms. Data will only be refetched if older than the stale time.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
try {
  const data = await queryClient.fetchQuery({
    queryKey,
    queryFn,
    staleTime: 10000,
  })
} catch (error) {
  console.log(error)
}

----------------------------------------

TITLE: Floating Mode Implementation
DESCRIPTION: Example of implementing React Query devtools in floating mode, which provides a toggleable overlay interface.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/devtools.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )

----------------------------------------

TITLE: Dynamic Query Keys with Signals
DESCRIPTION: Demonstrates using reactive signals with query keys and enabling/disabling queries based on conditions. Shows integration with fetch functions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-keys.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
todoId = signal(-1)

injectQuery(() => ({
  enabled: todoId() > 0,
  queryKey: ['todos', todoId()],
  queryFn: () => fetchTodoById(todoId()),
}))

----------------------------------------

TITLE: Advanced Serialization with Compression
DESCRIPTION: Example of implementing custom serialization using compression to store more data in localStorage.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/createSyncStoragePersister.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
import { QueryClient } from '@tanstack/react-query'
import { persistQueryClient } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

import { compress, decompress } from 'lz-string'

const queryClient = new QueryClient({
  defaultOptions: { queries: { staleTime: Infinity } },
})

persistQueryClient({
  queryClient: queryClient,
  persister: createSyncStoragePersister({
    storage: window.localStorage,
    serialize: (data) => compress(JSON.stringify(data)),
    deserialize: (data) => JSON.parse(decompress(data)),
  }),
  maxAge: Infinity,
})

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands to install dependencies and start the example project using npm package manager
SOURCE: https://github.com/TanStack/query/blob/main/examples/solid/default-query-function/README.md#2025-04-16_snippet_0

LANGUAGE: shell
CODE:
npm install
npm run start

----------------------------------------

TITLE: Fetching Infinite Query Data
DESCRIPTION: Demonstrates fetching and caching infinite query data that supports pagination. Returns paginated data in the pages property.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
try {
  const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })
  console.log(data.pages)
} catch (error) {
  console.log(error)
}

----------------------------------------

TITLE: Setting Mutation-Specific Defaults
DESCRIPTION: Demonstrates setting default options for specific mutations, including setting a default mutationFn.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_23

LANGUAGE: tsx
CODE:
queryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })

function Component() {
  const { data } = useMutation({ mutationKey: ['addPost'] })
}

----------------------------------------

TITLE: Defining CreateInfiniteQueryResult Type Alias in TypeScript
DESCRIPTION: Defines the CreateInfiniteQueryResult type alias as a Readable store containing an InfiniteQueryObserverResult. It has two generic type parameters: TData (defaulting to unknown) and TError (defaulting to DefaultError).
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/type-aliases/createinfinitequeryresult.md#2025-04-16_snippet_0

LANGUAGE: TypeScript
CODE:
type CreateInfiniteQueryResult<TData, TError>: Readable<InfiniteQueryObserverResult<TData, TError>>;

----------------------------------------

TITLE: Query Matching Utility in TanStack Query
DESCRIPTION: Utility function to check if a query matches the provided set of query filters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const isMatching = matchQuery(filters, query)

----------------------------------------

TITLE: Optimized Parent Component Prefetching
DESCRIPTION: Shows how to optimize the component by prefetching the comments query in the parent component to avoid waterfalls.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/prefetching.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  // Prefetch
  useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
    // Optional optimization to avoid rerenders when this query changes:
    notifyOnChangeProps: [],
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}

----------------------------------------

TITLE: Custom Error Type Usage in TypeScript Query
DESCRIPTION: Demonstrates how to specify custom error types in TypeScript when throwing non-Error values in query functions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_8

LANGUAGE: ts
CODE:
useQuery<number, string>({
  queryKey: ['some-query'],
  queryFn: async () => {
    if (Math.random() > 0.5) {
      throw 'some error'
    }
    return 42
  },
})

----------------------------------------

TITLE: Setting Custom Event Listener in TanStack Query FocusManager
DESCRIPTION: Demonstrates how to set a custom event listener using setEventListener method to handle visibility changes. The example shows setting up and cleaning up visibility change event listeners.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/focusManager.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

focusManager.setEventListener((handleFocus) => {
  // Listen to visibilitychange
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('visibilitychange', handleFocus, false)
  }

  return () => {
    // Be sure to unsubscribe if a new handler is set
    window.removeEventListener('visibilitychange', handleFocus)
  }
})

----------------------------------------

TITLE: Installing TanStack Angular Query with pnpm
DESCRIPTION: Command to install the experimental TanStack Angular Query library using pnpm package manager. This library is compatible with Angular v16 and higher.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/installation.md#2025-04-16_snippet_1

LANGUAGE: bash
CODE:
pnpm add @tanstack/angular-query-experimental

----------------------------------------

TITLE: Mutation Retry Configuration
DESCRIPTION: Demonstrates how to configure retry behavior for failed mutations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_8

LANGUAGE: tsx
CODE:
const mutation = useMutation({
  mutationFn: addTodo,
  retry: 3,
})

----------------------------------------

TITLE: Installing and Running TanStack Query Expo Example
DESCRIPTION: Command line instructions for installing Expo CLI globally and running the example project using pnpm package manager.
SOURCE: https://github.com/TanStack/query/blob/main/examples/react/react-native/README.md#2025-04-16_snippet_0

LANGUAGE: bash
CODE:
npm install --global expo-cli

LANGUAGE: bash
CODE:
pnpm install

LANGUAGE: bash
CODE:
pnpm start

----------------------------------------

TITLE: Updating Query Data with Mutation Response in Solid Query
DESCRIPTION: This snippet demonstrates how to use the onSuccess callback in a mutation to update the query cache with the response data. It shows updating a todo item's title in a list of todos.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/updates-from-mutation-responses.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
const mutation = useMutation(() => updateTodo, {
  onSuccess: (data, variables) => {
    queryClient.setQueryData(['todos'], (oldTodos) => {
      return oldTodos.map((todo) => {
        if (todo.id === variables.id) {
          return { ...todo, ...data }
        }
        return todo
      })
    })
  },
})

----------------------------------------

TITLE: Advanced Query Invalidation with Predicate Function in TanStack Query (TSX)
DESCRIPTION: This snippet shows how to use a predicate function with invalidateQueries for more granular control over which queries to invalidate, based on their query key and other properties.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-invalidation.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
queryClient.invalidateQueries({
  predicate: (query) =>
    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 20 }],
  queryFn: fetchTodoList,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 10 }],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 5 }],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Illustrating Client-Side Request Waterfall in Markdown
DESCRIPTION: This snippet demonstrates the request waterfall that occurs during client-side rendering, showing the sequential nature of resource loading and data fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_8

LANGUAGE: markdown
CODE:
```
1. |> Markup (without content)
2.   |> JS for <Feed>
3.     |> getFeed()
4.       |> JS for <GraphFeedItem>
5.         |> getGraphDataById()
```

----------------------------------------

TITLE: React Query with Next.js Server Components Setup
DESCRIPTION: Configuration for using React Query with Next.js server components and streaming hydration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/suspense.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import * as React from 'react'
import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    return makeQueryClient()
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export function Providers(props: { children: React.ReactNode }) {
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>
        {props.children}
      </ReactQueryStreamedHydration>
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Setting Global Retry Delay in Vue Query Plugin
DESCRIPTION: Demonstrates how to configure global retry delay settings using exponential backoff through Vue Query plugin options. The retry delay increases exponentially with each attempt, capped at 30 seconds.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/query-retries.md#2025-04-16_snippet_1

LANGUAGE: ts
CODE:
import { VueQueryPlugin } from '@tanstack/vue-query'

const vueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Using queryClient.getQueryState
DESCRIPTION: The getQueryState method retrieves an existing query's state. It returns undefined if the query doesn't exist.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_9

LANGUAGE: tsx
CODE:
const state = queryClient.getQueryState(queryKey)
console.log(state.dataUpdatedAt)

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands for setting up and running the TanStack Query example project. First install dependencies with npm install, then start the application with npm run start.
SOURCE: https://github.com/TanStack/query/blob/main/examples/solid/basic/README.md#2025-04-16_snippet_0

LANGUAGE: bash
CODE:
npm install

LANGUAGE: bash
CODE:
npm run start

----------------------------------------

TITLE: Correct Infinite Query Property Order
DESCRIPTION: Example of correct property order in useInfiniteQuery that follows the ESLint rule. The queryFn, getPreviousPageParam, and getNextPageParam properties are arranged in the proper order for correct type inference.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/infinite-query-property-order.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/infinite-query-property-order": "warn" */
import { useInfiniteQuery } from '@tanstack/react-query'

const query = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: async ({ pageParam }) => {
    const response = await fetch(`/api/projects?cursor=${pageParam}`)
    return await response.json()
  },
  initialPageParam: 0,
  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
  maxPages: 3,
})

----------------------------------------

TITLE: Mocking Server Responses in TanStack Query Tests (JavaScript)
DESCRIPTION: This snippet illustrates how to mock server responses for testing queries. It uses the MSW (Mock Service Worker) library to intercept and mock API calls, allowing for controlled testing of query behavior.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
import { rest } from 'msw'
import { setupServer } from 'msw/node'

const server = setupServer(
  rest.get('/api/data', (req, res, ctx) => {
    return res(ctx.json({ name: 'Mocked Name' }))
  })
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

----------------------------------------

TITLE: Basic Query Disabling in Angular Component
DESCRIPTION: Demonstrates a basic implementation of a disabled query using injectQuery with enabled: false option. The query will not automatically execute and requires manual triggering through refetch.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/disabling-queries.md#2025-04-16_snippet_0

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  template: `<div>
    <button (click)="query.refetch()">Fetch Todos</button>

    @if (query.data()) {
      <ul>
        @for (todo of query.data(); track todo.id) {
          <li>{{ todo.title }}</li>
        }
      </ul>
    } @else {
      @if (query.isError()) {
        <span>Error: {{ query.error().message }}</span>
      } @else if (query.isLoading()) {
        <span>Loading...</span>
      } @else if (!query.isLoading() && !query.isError()) {
        <span>Not ready ...</span>
      }
    }

    <div>{{ query.isLoading() ? 'Fetching...' : '' }}</div>
  </div>`,
})
export class TodosComponent {
  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
    enabled: false,
  }))
}

----------------------------------------

TITLE: Data Ownership Example with Server Components
DESCRIPTION: Illustrates potential issues with data ownership when mixing Server and Client Components, specifically showing how data can get out of sync during client-side revalidation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
// app/posts/page.tsx
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from '@tanstack/react-query'
import Posts from './posts'

export default async function PostsPage() {
  const queryClient = new QueryClient()

  // Note we are now using fetchQuery()
  const posts = await queryClient.fetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      {/* This is the new part */}
      <div>Nr of posts: {posts.length}</div>
      <Posts />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Signal Integration with TanStack Query
DESCRIPTION: Shows how to integrate SolidJS signals with TanStack Query, demonstrating reactive query parameters and automatic updates based on signal changes.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/quick-start.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
function Example() {
  const [enabled, setEnabled] = createSignal(false)
  const [todo, setTodo] = createSignal(0)

  const todosQuery = useQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    enabled: enabled(),
  }))

  const todoDetailsQuery = useQuery(() => ({
    queryKey: ['todo', todo()],
    queryFn: fetchTodo,
    enabled: todo() > 0,
  }))

  return (
    <div>
      <Switch>
        <Match when={todosQuery.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={todosQuery.isError}>
          <p>Error: {todosQuery.error.message}</p>
        </Match>
        <Match when={todosQuery.isSuccess}>
          <For each={todosQuery.data}>
            {(todo) => (
              <button onClick={() => setTodo(todo.id)}>{todo.title}</button>
            )}
          </For>
        </Match>
      </Switch>
      <button onClick={() => setEnabled(!enabled())}>Toggle enabled</button>
    </div>
  )
}

----------------------------------------

TITLE: Type Inference with Data Transformation
DESCRIPTION: Shows type inference when using a select function to transform query results in Angular Query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/typescript.md#2025-04-16_snippet_1

LANGUAGE: angular-ts
CODE:
@Component({
  // ...
  template: `@let data = query.data();`,
  //               ^? data: string | undefined
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
    select: (data) => data.toString(),
  }))
}

----------------------------------------

TITLE: Basic Type Inference in Solid Query
DESCRIPTION: Demonstrates how Solid Query automatically infers types from the queryFn return value, providing type safety for the query result.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/typescript.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/solid-query'

const query = useQuery(() => ({
  queryKey: ['number'],
  queryFn: () => Promise.resolve(5),
}))

query.data
//    ^? (property) data: number | undefined

----------------------------------------

TITLE: Using queryOptions for Type-Safe Query Configuration
DESCRIPTION: Demonstrates how to use the queryOptions helper to create type-safe query configurations that can be shared between different query-related functions.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/typescript.md#2025-04-16_snippet_7

LANGUAGE: ts
CODE:
import { queryOptions } from '@tanstack/solid-query'

function groupOptions() {
  return queryOptions({
    queryKey: ['groups'],
    queryFn: fetchGroups,
    staleTime: 5 * 1000,
  })
}

useQuery(groupOptions)
queryClient.prefetchQuery(groupOptions())

const data = queryClient.getQueryData(groupOptions().queryKey)
//    ^? const data: Group[] | undefined

----------------------------------------

TITLE: Manual Focus State Management
DESCRIPTION: Demonstrates how to manually control the focus state using focusManager.setFocused.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

// Override the default focus state
focusManager.setFocused(true)

// Fallback to the default focus check
focusManager.setFocused(undefined)

----------------------------------------

TITLE: Implementing injectInfiniteQuery with Defined Result Type
DESCRIPTION: This overload of the injectInfiniteQuery function returns a DefinedCreateInfiniteQueryResult, which is used when the query options include a non-undefined initialData. It has the same parameters but a more specific return type.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectinfinitequery.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
function injectInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(optionsFn, injector?): DefinedCreateInfiniteQueryResult<TData, TError>

----------------------------------------

TITLE: Defining infiniteQueryOptions Function in TypeScript
DESCRIPTION: This function creates options for infinite queries in TanStack Query. It takes a generic set of type parameters for query data, error, data structure, query key, and page parameter. The function returns a CreateInfiniteQueryOptions object.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/infinitequeryoptions.md#2025-04-16_snippet_0

LANGUAGE: TypeScript
CODE:
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): CreateInfiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryFnData,
  TQueryKey,
  TPageParam
>

----------------------------------------

TITLE: Multiple Provider Integration Example
DESCRIPTION: Demonstrates how to compose multiple React Query providers with different contexts and access their data using custom hooks.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_20

LANGUAGE: tsx
CODE:
import { ContainerDataProvider, useUser } from "@my-scope/container-data";
import { AppDataProvider } from "@my-scope/app-data";
import { MyComponentDataProvider, useItems } from "@my-scope/my-component-data";

<ContainerDataProvider> // <-- Provides container data (like "user") using its own React Query provider
  ...
  <AppDataProvider> // <-- Provides app data using its own React Query provider (unused in this example)
    ...
      <MyComponentDataProvider> // <-- Provides component data (like "items") using its own React Query provider
        <MyComponent />
      </MyComponentDataProvider>
    ...
  </AppDataProvider>
  ...
</ContainerDataProvider>

// Example of hooks provided by the "DataProvider" components above:
const MyComponent = () => {
  const user = useUser() // <-- Uses the context specified in ContainerDataProvider.
  const items = useItems() // <-- Uses the context specified in MyComponentDataProvider
  ...
}

----------------------------------------

TITLE: Using InitialData with Next.js getServerSideProps
DESCRIPTION: Example demonstrating how to pass initial data to React Query using Next.js getServerSideProps for server-side data fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
export async function getServerSideProps() {
  const posts = await getPosts()
  return { props: { posts } }
}

function Posts(props) {
  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: props.posts,
  })

  // ...
}

----------------------------------------

TITLE: Basic Usage of injectQuery in Angular
DESCRIPTION: Demonstrates the basic usage of injectQuery function in an Angular service or component to fetch data from a GitHub API endpoint.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
class ServiceOrComponent {
  query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
  }))
}

----------------------------------------

TITLE: Configuring BroadcastQueryClient - Function Call
DESCRIPTION: Example showing the basic function call structure for broadcastQueryClient with its parameters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
broadcastQueryClient({ queryClient, broadcastChannel })

----------------------------------------

TITLE: Stale-While-Revalidate Prefetching in SolidJS Query
DESCRIPTION: Demonstrates the stale-while-revalidate prefetching strategy using SolidJS Query. This approach allows serving stale data immediately while fetching fresh data in the background.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/prefetching.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
queryClient.prefetchQuery(() => ['todos'], () => fetchTodos(), {
  staleTime: 5 * 1000, // 5 seconds
  cacheTime: 10 * 1000 // 10 seconds
})

----------------------------------------

TITLE: Implementing Online Status Management with Expo Network
DESCRIPTION: Alternative implementation of online status management using expo-network package for Expo-based React Native applications.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/react-native.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
import { onlineManager } from '@tanstack/react-query'
import * as Network from 'expo-network'

onlineManager.setEventListener((setOnline) => {
  const eventSubscription = Network.addNetworkStateListener((state) => {
    setOnline(!!state.isConnected)
  })
  return eventSubscription.remove
})

----------------------------------------

TITLE: Initializing TanStack Query in NgModule-based Angular App
DESCRIPTION: Configuration for providing TanStack Query in a traditional NgModule-based Angular application.
SOURCE: https://github.com/TanStack/query/blob/main/packages/angular-query-experimental/README.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [provideTanStackQuery(new QueryClient())],
  bootstrap: [AppComponent],
})

----------------------------------------

TITLE: Getting Mutation Default Options
DESCRIPTION: Shows how to retrieve default options for specific mutations using their mutation keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_22

LANGUAGE: tsx
CODE:
const defaultOptions = queryClient.getMutationDefaults(['addPost'])

----------------------------------------

TITLE: Embedded Mode Implementation
DESCRIPTION: Example of implementing React Query devtools in embedded mode as a fixed panel within the application.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/devtools.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'

function App() {
  const [isOpen, setIsOpen] = React.useState(false)

  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <button
        onClick={() => setIsOpen(!isOpen)}
      >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
      {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
    </QueryClientProvider>
  )

----------------------------------------

TITLE: Prefetch Query Setup with SvelteKit Layout
DESCRIPTION: Advanced setup for prefetching queries using QueryClient in the layout file, enabling server-side data fetching with proper hydration on the client.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/ssr.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
import { browser } from '$app/environment'
import { QueryClient } from '@tanstack/svelte-query'

export async function load() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })

  return { queryClient }
}

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { QueryClientProvider } from '@tanstack/svelte-query'
  import type { LayoutData } from './$types'

  export let data: LayoutData
</script>

<QueryClientProvider client={data.queryClient}>
  <slot />
</QueryClientProvider>

----------------------------------------

TITLE: Multiple Mutations Handling
DESCRIPTION: Example of handling multiple mutations with callbacks, showing how callbacks behave with multiple mutation calls.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/mutations.md#2025-04-16_snippet_5

LANGUAGE: typescript
CODE:
export class Example {
  mutation = injectMutation(() => ({
    mutationFn: addTodo,
    onSuccess: (data, variables, context) => {
      // Will be called 3 times
    },
  }))

  doMutations() {
    ;['Todo 1', 'Todo 2', 'Todo 3'].forEach((todo) => {
      this.mutation.mutate(todo, {
        onSuccess: (data, variables, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
  }
}

----------------------------------------

TITLE: Implementing Custom Window Focus Event Listener
DESCRIPTION: Demonstrates how to set up a custom window focus event listener using the focusManager.setEventListener function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/window-focus-refetching.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
focusManager.setEventListener((handleFocus) => {
  // Listen to visibilitychange
  if (typeof window !== 'undefined' && window.addEventListener) {
    const visibilitychangeHandler = () => {
      handleFocus(document.visibilityState === 'visible')
    }
    window.addEventListener('visibilitychange', visibilitychangeHandler, false)
    return () => {
      // Be sure to unsubscribe if a new handler is set
      window.removeEventListener('visibilitychange', visibilitychangeHandler)
    }
  }
})

----------------------------------------

TITLE: infiniteQueryOptions Function with Undefined Initial Data in TypeScript
DESCRIPTION: This function overload allows sharing and reusing infinite query options in a type-safe way where initial data is undefined. It tags the queryKey with the type from queryFn and returns the tagged infinite query options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/infinitequeryoptions.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): UndefinedInitialDataInfiniteOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam
> &
  object

----------------------------------------

TITLE: queryOptions Implementation for Undefined Initial Data
DESCRIPTION: Function signature for queryOptions with undefined initial data. Takes options with TQueryFnData, TError, TData, and TQueryKey type parameters and returns tagged query options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/queryoptions.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object

----------------------------------------

TITLE: Singleton QueryClient Implementation
DESCRIPTION: Shows how to implement a singleton QueryClient that can be reused across Server Components using React's cache function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
// app/getQueryClient.tsx
import { QueryClient } from '@tanstack/react-query'
import { cache } from 'react'

// cache() is scoped per request, so we don't leak data between requests
const getQueryClient = cache(() => new QueryClient())
export default getQueryClient

----------------------------------------

TITLE: Defining QueriesResults Type Alias in TypeScript
DESCRIPTION: This type alias recursively maps query options to their results. It handles various cases including empty arrays, single elements, multiple elements, and reaches a maximum depth to prevent infinite recursion. It's designed to work with QueryObserverOptions and returns QueryObserverResult types.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/type-aliases/queriesresults.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
type QueriesResults<T, TResults, TDepth>: TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryResult<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesResults<[...Tails], [...TResults, GetCreateQueryResult<Head>], [...TDepth, 1]> : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>[] ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>[] : QueryObserverResult[];

----------------------------------------

TITLE: Client-Side Posts Component with Suspense Query
DESCRIPTION: Client component that uses suspense query to fetch and display posts data, leveraging server-side prefetched data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_9

LANGUAGE: typescript
CODE:
'use client'

export default function Posts() {
  const { data } = useSuspenseQuery({ queryKey: ['posts'], queryFn: getPosts })

  // ...
}

----------------------------------------

TITLE: Setting Network Mode for Individual Queries in TanStack Query
DESCRIPTION: This code snippet shows how to set the network mode for individual queries in TanStack Query. It demonstrates setting the mode to 'offlineFirst' for a specific query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/network-mode.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
import { useQuery } from '@tanstack/react-query'

function Component() {
  const result = useQuery({
    queryKey: ['key'],
    queryFn: () => fetch('/api/data'),
    networkMode: 'offlineFirst',
  })
}

----------------------------------------

TITLE: Getting All Mutations - TSX
DESCRIPTION: Demonstrates how to retrieve all mutations stored in the cache using the getAll method.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/MutationCache.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const mutations = mutationCache.getAll()

----------------------------------------

TITLE: Configuring Window Focus Refetching in Vue Query
DESCRIPTION: This snippet shows how to disable automatic refetching on window focus for all queries in a Vue application using Vue Query. It sets the 'refetchOnWindowFocus' option to false in the default query options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/window-focus-refetching.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false,
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Manual Query Cancellation in Angular Component
DESCRIPTION: Example of implementing manual query cancellation in an Angular component with a cancel button that triggers query cancellation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-cancellation.md#2025-04-16_snippet_3

LANGUAGE: angular-ts
CODE:
@Component({
  standalone: true,
  template: `<button (click)="onCancel()">Cancel</button>`,
})
export class TodosComponent {
  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: async ({ signal }) => {
      const resp = await fetch('/todos', { signal })
      return resp.json()
    },
  }))

  queryClient = inject(QueryClient)

  onCancel() {
    this.queryClient.cancelQueries(['todos'])
  }
}

----------------------------------------

TITLE: Defining QueriesResults Recursive Type in TypeScript
DESCRIPTION: A recursive type alias that maps query parameters to their results. It handles depth checking, empty arrays, single elements, and multiple elements through recursive evaluation. The type supports generic query function data, error types, and custom data types.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/type-aliases/queriesresults.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
type QueriesResults<T, TResult, TDepth>: TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetResults<Head>] : T extends [infer Head, ...(infer Tail)] ? QueriesResults<[...Tail], [...TResult, GetResults<Head>], [...TDepth, 1]> : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>[] ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>[] : QueryObserverResult[];

----------------------------------------

TITLE: Transforming Infinite Query Data with Select Option
DESCRIPTION: Using the select option to transform infinite query data. This example shows how to reverse the order of pages and page parameters, which is useful for displaying data in reverse chronological order.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/infinite-queries.md#2025-04-16_snippet_4

LANGUAGE: ts
CODE:
query = injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  select: (data) => ({
    pages: [...data.pages].reverse(),
    pageParams: [...data.pageParams].reverse(),
  }),
}))

----------------------------------------

TITLE: Error Handling in React Query Dehydration
DESCRIPTION: Example demonstrating how to handle non-serializable data during dehydration and hydration, particularly for Error objects and custom serialization needs.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/reference/hydration.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
// server
const state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors
const serializedState = mySerialize(state) // transform Error instances to objects

// client
const state = myDeserialize(serializedState) // transform objects back to Error instances
hydrate(client, state)

----------------------------------------

TITLE: Using QueryCache findAll Method
DESCRIPTION: Shows how to use findAll to get multiple query instances that match a partial query key. Returns an empty array if no matches found.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryCache.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const queries = queryCache.findAll(queryKey)

----------------------------------------

TITLE: Initializing createQuery with Defined Initial Data in TypeScript
DESCRIPTION: This overload of createQuery is used when initial data is defined. It takes options and an optional queryClient as parameters, and returns a DefinedCreateQueryResult.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/createquery.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function createQuery<TQueryFnData, TError, TData, TQueryKey>(
  options,
  queryClient?,
): DefinedCreateQueryResult<TData, TError>

----------------------------------------

TITLE: Setting Up Mutation with Key and Accessing State in Angular Query
DESCRIPTION: This snippet shows how to set up a mutation with a specific key and how to access mutation state using injectMutationState in a different part of the application.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-16_snippet_3

LANGUAGE: typescript
CODE:
// somewhere in your app
addTodo = injectMutation(() => ({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
  mutationKey: ['addTodo'],
}))

// access variables somewhere else

mutationState = injectMutationState<string>(() => ({
  filters: { mutationKey: ['addTodo'], status: 'pending' },
  select: (mutation) => mutation.state.variables,
}))

----------------------------------------

TITLE: infiniteQueryOptions Function with Defined Initial Data in TypeScript
DESCRIPTION: This function overload allows sharing and reusing infinite query options in a type-safe way where initial data is defined. It tags the queryKey with the type from queryFn and returns the tagged infinite query options.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/infinitequeryoptions.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): DefinedInitialDataInfiniteOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam
> &
  object

----------------------------------------

TITLE: Defining CreateBaseQueryOptions Type Alias in TypeScript
DESCRIPTION: This code snippet defines the CreateBaseQueryOptions type alias. It extends QueryObserverOptions with five type parameters: TQueryFnData, TError, TData, TQueryData, and TQueryKey. These parameters allow for customization of query function data, error types, and key types.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/type-aliases/createbasequeryoptions.md#2025-04-16_snippet_0

LANGUAGE: TypeScript
CODE:
type CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>: QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>;

----------------------------------------

TITLE: Defining createMutation Function in TypeScript
DESCRIPTION: This code snippet defines the createMutation function, which is used to create a mutation in Svelte Query. It takes options and an optional queryClient as parameters, and returns a CreateMutationResult. The function is generic, allowing for customization of data, error, variables, and context types.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/createmutation.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function createMutation<TData, TError, TVariables, TContext>(
  options,
  queryClient?,
): CreateMutationResult<TData, TError, TVariables, TContext>

----------------------------------------

TITLE: Using Mocked QueryClient in React Component Test (JavaScript)
DESCRIPTION: This code snippet shows how to use the mocked QueryClient wrapper in a test for a React component. It demonstrates rendering the component within the wrapper and making assertions on the rendered output.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/testing.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
test('my test', async () => {
  const wrapper = createWrapper()
  const { result } = renderHook(() => useCustomHook(), { wrapper })

  expect(result.current).toBe('foo')
})

----------------------------------------

TITLE: Using useInfiniteQuery in SolidJS
DESCRIPTION: This snippet demonstrates the basic usage of useInfiniteQuery in SolidJS. The hook is called with an arrow function to align with SolidJS syntax.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useInfiniteQuery.md#2025-04-16_snippet_1

LANGUAGE: javascript
CODE:
useInfiniteQuery(() => ...)

----------------------------------------

TITLE: Subscribing to Focus State Changes in TanStack Query
DESCRIPTION: Shows how to subscribe to focus state changes using the subscribe method. Returns an unsubscribe function for cleanup.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/focusManager.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

const unsubscribe = focusManager.subscribe((isVisible) => {
  console.log('isVisible', isVisible)
})

----------------------------------------

TITLE: Registering Global Meta Type in React Query
DESCRIPTION: Shows how to register a global Meta type for consistent and type-safe meta fields in queries and mutations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/typescript.md#2025-04-16_snippet_4

LANGUAGE: ts
CODE:
import '@tanstack/react-query'

interface MyMeta extends Record<string, unknown> {
  // Your meta type definition.
}

declare module '@tanstack/react-query' {
  interface Register {
    queryMeta: MyMeta
    mutationMeta: MyMeta
  }
}

----------------------------------------

TITLE: Replacing isDataEqual with structuralSharing in TanStack Query v5
DESCRIPTION: This snippet demonstrates how to replace the removed isDataEqual option with a custom structuralSharing function to achieve the same functionality in TanStack Query v5.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
 import { replaceEqualDeep } from '@tanstack/react-query'

- isDataEqual: (oldData, newData) => customCheck(oldData, newData) // [!code --]
+ structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData) // [!code ++]

----------------------------------------

TITLE: Incorrect QueryClient Instantiation in React Component (TSX)
DESCRIPTION: This example shows an incorrect implementation where QueryClient is created directly in the component body, causing a new instance on every render which can lead to performance issues and unexpected behavior.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/stable-query-client": "error" */

function App() {
  const queryClient = new QueryClient()
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Implementing Floating Mode Devtools
DESCRIPTION: Example of implementing the SolidQueryDevtools component in floating mode within a Solid application.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/devtools.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <SolidQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Custom Error Type Specification
DESCRIPTION: Shows how to specify a custom error type for a query, which overrides the default Error type.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/typescript.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
const query = useQuery<Group[], string>(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.error
//    ^? (property) error: string | null

----------------------------------------

TITLE: Defining initialData Property in TypeScript
DESCRIPTION: Specifies the initialData property type within the DefinedInitialDataOptions, which can be either a direct value or a function returning a value, both with NonUndefinedGuard applied.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/type-aliases/definedinitialdataoptions.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
initialData: NonUndefinedGuard<TQueryFnData> | () => NonUndefinedGuard<TQueryFnData>;

----------------------------------------

TITLE: BroadcastQueryClient Default Options
DESCRIPTION: Default configuration options for the broadcastQueryClient utility.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/broadcastQueryClient.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
{
  broadcastChannel = 'tanstack-query',
}

----------------------------------------

TITLE: Getting Query Default Options
DESCRIPTION: Shows how to retrieve default options for specific queries using their query keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_20

LANGUAGE: tsx
CODE:
const defaultOptions = queryClient.getQueryDefaults(['posts'])

----------------------------------------

TITLE: Using setQueryData with Updater Function
DESCRIPTION: Setting query data using a function that receives the current data value and returns the new one, allowing for transformations based on existing data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_8

LANGUAGE: tsx
CODE:
setQueryData(queryKey, (oldData) => newData)

----------------------------------------

TITLE: Handling Settled State in Angular Query Mutation
DESCRIPTION: This snippet demonstrates how to handle the settled state of a mutation, including both success and error cases. It provides a template for custom logic after the mutation is completed.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/optimistic-updates.md#2025-04-16_snippet_6

LANGUAGE: typescript
CODE:
injectMutation({
  mutationFn: updateTodo,
  // ...
  onSettled: (newTodo, error, variables, context) => {
    if (error) {
      // do something
    }
  },
})

----------------------------------------

TITLE: Replacing React Query with Solid Query in JavaScript
DESCRIPTION: This code snippet shows the replacement patterns for converting React Query syntax to Solid Query. It includes changes for imports and function calls.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/queries.md#2025-04-16_snippet_0

LANGUAGE: JavaScript
CODE:
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
}

----------------------------------------

TITLE: Retrieving QueryClient from Svelte Context in TypeScript
DESCRIPTION: This function retrieves a QueryClient instance from Svelte's context. It returns a QueryClient object and is defined in the svelte-query package of the TanStack Query project.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/getqueryclientcontext.md#2025-04-16_snippet_0

LANGUAGE: TypeScript
CODE:
function getQueryClientContext(): QueryClient

----------------------------------------

TITLE: injectQuery Function Signature (Defined Query Result)
DESCRIPTION: TypeScript function signature for injectQuery that returns a DefinedCreateQueryResult. It accepts a function that returns query options and an optional Angular injector.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
function injectQuery<TQueryFnData, TError, TData, TQueryKey>(
  optionsFn,
  injector?,
): DefinedCreateQueryResult<TData, TError>

----------------------------------------

TITLE: Cache Data with initialDataUpdatedAt
DESCRIPTION: Demonstrates using cached data with initialDataUpdatedAt for optimal refetch behavior.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () =>
    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
  initialDataUpdatedAt: () =>
    queryClient.getQueryState(['todos'])?.dataUpdatedAt,
})

----------------------------------------

TITLE: Initializing QueryCache with Event Handlers
DESCRIPTION: Shows how to create a new QueryCache instance with error, success, and settled event handlers. Also demonstrates finding a query by key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryCache.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
import { QueryCache } from '@tanstack/react-query'

const queryCache = new QueryCache({
  onError: (error) => {
    console.log(error)
  },
  onSuccess: (data) => {
    console.log(data)
  },
  onSettled: (data, error) => {
    console.log(data, error)
  },
})

const query = queryCache.find(['posts'])

----------------------------------------

TITLE: Defining PersistedClient Interface in TypeScript
DESCRIPTION: Specifies the structure of persisted client entries in TanStack Query. It includes a timestamp, buster string, and cache state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/plugins/persistQueryClient.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
export interface PersistedClient {
  timestamp: number
  buster: string
  cacheState: any
}

----------------------------------------

TITLE: Incorrect Usage of TanStack Query Hook in React Dependencies
DESCRIPTION: Demonstrates incorrect usage where the entire mutation object is placed in a useCallback dependency array, which can lead to infinite re-renders due to referential instability.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/no-unstable-deps.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/no-unstable-deps": "warn" */
import { useCallback } from 'React'
import { useMutation } from '@tanstack/react-query'

function Component() {
  const mutation = useMutation({ mutationFn: (value: string) => value })
  const callback = useCallback(() => {
    mutation.mutate('hello')
  }, [mutation])
  return null
}

----------------------------------------

TITLE: Prefetching Dependent Queries in Server-Side Props
DESCRIPTION: Demonstrates how to handle dependent query prefetching in server-side props/loaders for both Next.js and Remix frameworks.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_7

LANGUAGE: tsx
CODE:
// For Remix, rename this to loader instead
export async function getServerSideProps() {
  const queryClient = new QueryClient()

  const user = await queryClient.fetchQuery({
    queryKey: ['user', email],
    queryFn: getUserByEmail,
  })

  if (user?.userId) {
    await queryClient.prefetchQuery({
      queryKey: ['projects', userId],
      queryFn: getProjectsByUser,
    })
  }

  return { props: { dehydratedState: dehydrate(queryClient) } }
}

----------------------------------------

TITLE: Initializing QueryClient in Remix Root
DESCRIPTION: Example showing how to initialize QueryClient in a Remix root.tsx file with proper cache management and staleTime configuration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
// app/root.tsx
import { Outlet } from '@remix-run/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp() {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // With SSR, we usually want to set some default staleTime
            // above 0 to avoid refetching immediately on the client
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Outlet />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Updating Query Defaults Order in TanStack Query
DESCRIPTION: Demonstrates the new order for setting query defaults, from most generic to least generic key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-v5.md#2025-04-16_snippet_14

LANGUAGE: typescript
CODE:
+ queryClient.setQueryDefaults(['todo'], {
+   retry: false,
+   staleTime: 60_000,
+ })
queryClient.setQueryDefaults(['todo', 'detail'], {
+   retry: true,
  retryDelay: 1_000,
  staleTime: 10_000,
})
- queryClient.setQueryDefaults(['todo'], {
-   retry: false,
-   staleTime: 60_000,
- })

----------------------------------------

TITLE: Retrieving Restoration Context in Svelte Query
DESCRIPTION: A TypeScript function that retrieves the isRestoring boolean value from Svelte's context system. Returns a Readable store containing a boolean value indicating the restoration state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/getisrestoringcontext.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function getIsRestoringContext(): Readable<boolean>

----------------------------------------

TITLE: Using Placeholder Data as a Value in TanStack Query
DESCRIPTION: This snippet demonstrates how to use placeholder data as a value in a TanStack Query hook. It sets the placeholderData option to a predefined value, allowing the query to start in a success state with placeholder data.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/placeholder-query-data.md#2025-04-16_snippet_0

LANGUAGE: tsx
CODE:
function Todos() {
  const result = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  })
}

----------------------------------------

TITLE: Flexible Query Usage Examples
DESCRIPTION: Examples showing how to use the query with both plain values and refs.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
// Fetches the user 1's projects, userId is not expected to change.
const { data: projects } = useUserProjects('1')

// Fetches the user 1's projects, queries will react to changes on userId.
const userId = ref('1')

// Make some changes to userId...

// Query re-fetches based on any changes to userId.
const { data: projects } = useUserProjects(userId)

----------------------------------------

TITLE: Using Query Options with Type Inference and Data Selection in Angular
DESCRIPTION: This snippet demonstrates how to use query options with type inference and data selection in TanStack Query for Angular. It shows how to combine custom query options with a select function, maintaining proper type inference for the query result.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/query-options.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
// Type inference still works, so query.data will be the return type of select instead of queryFn
queries = inject(QueriesService)

query = injectQuery(() => ({
  ...groupOptions(1),
  select: (data) => data.title,
}))

----------------------------------------

TITLE: Using provideAngularQuery in Standalone Angular Applications
DESCRIPTION: Example showing how to use the provideAngularQuery function in a standalone Angular application by importing the necessary components and providing the QueryClient during bootstrap.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
import {
  provideAngularQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideAngularQuery(new QueryClient())],
})

----------------------------------------

TITLE: Custom Scheduler Configuration Examples
DESCRIPTION: Shows different ways to configure custom schedulers for batch execution timing.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/notifyManager.md#2025-04-16_snippet_5

LANGUAGE: typescript
CODE:
import { notifyManager } from '@tanstack/react-query'

// Schedule batches in the next microtask
notifyManager.setScheduler(queueMicrotask)

// Schedule batches before the next frame is rendered
notifyManager.setScheduler(requestAnimationFrame)

// Schedule batches some time in the future
notifyManager.setScheduler((cb) => setTimeout(cb, 10))

----------------------------------------

TITLE: Syntax Replacements for Solid.js in TanStack Query
DESCRIPTION: This snippet outlines the necessary syntax replacements to convert React-specific TanStack Query code to Solid.js compatible code. It includes changes for imports, mutations, queries, and infinite queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/parallel-queries.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',
}

----------------------------------------

TITLE: Using useIsFetching Hook in React Query
DESCRIPTION: Demonstrates how to import and use the useIsFetching hook from React Query. This hook returns the number of queries that are currently fetching.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useIsFetching.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
import { useIsFetching } from '@tanstack/react-query'

----------------------------------------

TITLE: Defining Query Function Type
DESCRIPTION: Type definition for the query function that fetches data. Must return a Promise and cannot return undefined.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
(context: QueryFunctionContext) => Promise<TData>

----------------------------------------

TITLE: Conditional Initial Data from Cache
DESCRIPTION: Shows how to conditionally use cached data based on its freshness.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-16_snippet_7

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () => {
    const state = queryClient.getQueryState(['todos'])
    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
      return state.data.find((d) => d.id === todoId)
    }
  },
})

----------------------------------------

TITLE: Browser Compatibility Configuration for React Query
DESCRIPTION: Defines the minimum browser versions supported by React Query. This configuration ensures optimal performance and compatibility.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/installation.md#2025-04-16_snippet_2

LANGUAGE: bash
CODE:
Chrome >= 91
Firefox >= 90
Edge >= 91
Safari >= 15
iOS >= 15
Opera >= 77

----------------------------------------

TITLE: Using QueryCache find Method
DESCRIPTION: Demonstrates using the find method to retrieve an existing query instance from the cache. Returns undefined if query doesn't exist.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryCache.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const query = queryCache.find(queryKey)

----------------------------------------

TITLE: Correct QueryClient Instantiation Outside Component (TSX)
DESCRIPTION: This example shows another correct approach where the QueryClient is created outside the component at module level, ensuring a single instance is shared across the entire application.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/stable-query-client.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient()
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Alternative onSettled Handler
DESCRIPTION: Shows how to use onSettled as an alternative to separate onError and onSuccess handlers.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/optimistic-updates.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: updateTodo,
  // ...
  onSettled: async (newTodo, error, variables, context) => {
    if (error) {
      // do something
    }
  },
})

----------------------------------------

TITLE: Reactive Usage of injectQuery with Angular Signals
DESCRIPTION: Shows how to use injectQuery with Angular signals to create a reactive query that responds to changes in a filter value, enabling or disabling based on the filter state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectquery.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
class ServiceOrComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: () => fetchTodos(this.filter()),
    // Signals can be combined with expressions
    enabled: !!this.filter(),
  }))
}

----------------------------------------

TITLE: Initializing QueryClient Hook in TypeScript
DESCRIPTION: Function signature for the useQueryClient hook that returns a QueryClient instance. It optionally accepts a QueryClient parameter and returns a QueryClient object. This function is defined in the Svelte Query package of TanStack Query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/usequeryclient.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function useQueryClient(queryClient?): QueryClient

----------------------------------------

TITLE: Auto-Loading Devtools Configuration
DESCRIPTION: Demonstrates default and explicit auto-loading configuration for devtools in development mode.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/devtools.md#2025-04-16_snippet_1

LANGUAGE: typescript
CODE:
provideTanStackQuery(new QueryClient(), withDevtools())

// which is equivalent to
provideTanStackQuery(
  new QueryClient(),
  withDevtools(() => ({ loadDevtools: 'auto' })),
)

----------------------------------------

TITLE: Defining CreateQueryOptions Interface in TypeScript for TanStack Query
DESCRIPTION: This code snippet defines the CreateQueryOptions interface, which extends OmitKeyof<CreateBaseQueryOptions> with specific type parameters. It includes four generic type parameters: TQueryFnData, TError, TData, and TQueryKey.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/interfaces/createqueryoptions.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
interface CreateQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends OmitKeyof<CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>, "suspense">

----------------------------------------

TITLE: provideAngularQuery Function Signature in TypeScript
DESCRIPTION: The function signature for provideAngularQuery which takes a QueryClient instance and returns EnvironmentProviders for Angular applications.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/provideangularquery.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function provideAngularQuery(queryClient): EnvironmentProviders

----------------------------------------

TITLE: Type Inference with Custom API Response
DESCRIPTION: Demonstrates type inference when using a custom fetch function that returns a typed Promise. The data type is automatically inferred from the return type of fetchGroups.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/typescript.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const fetchGroups = (): Promise<Group[]> =>
  axios.get('/groups').then((response) => response.data)

const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const data: Ref<Group[]> | Ref<undefined>

----------------------------------------

TITLE: Defining injectIsFetching Function in TypeScript for Angular Query
DESCRIPTION: This function injects a signal that tracks the number of queries loading or fetching in the background. It can be used for app-wide loading indicators. It takes optional QueryFilters and an Angular Injector as parameters, and returns a Signal of type number.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectisfetching.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function injectIsFetching(filters?, injector?): Signal<number>

----------------------------------------

TITLE: Using Custom QueryClient Key in Queries
DESCRIPTION: Shows how to reference a custom QueryClient key when making queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-16_snippet_4

LANGUAGE: js
CODE:
useQuery({
  queryKey: ['query1'],
  queryFn: fetcher,
  queryClientKey: 'foo',
})

----------------------------------------

TITLE: Replace Patterns for Query Functions
DESCRIPTION: Regular expression replacement patterns for converting React Query syntax to Solid Query syntax. Maps React Query function calls to their Solid Query equivalents with added arrow function syntax.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/default-query-function.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => '
}

----------------------------------------

TITLE: Manually Setting Online State in TanStack Query
DESCRIPTION: Demonstrates how to manually control the online state using setOnline method. Accepts a boolean parameter to set the connection state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/onlineManager.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { onlineManager } from '@tanstack/react-query'

// Set to online
onlineManager.setOnline(true)

// Set to offline
onlineManager.setOnline(false)

----------------------------------------

TITLE: TanStack Query Function Replacements
DESCRIPTION: Mapping of React Query function names to their Solid Query equivalents, including mutations, queries, and infinite queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/infinite-queries.md#2025-04-16_snippet_0

LANGUAGE: json
CODE:
{
  "@tanstack/react-query": "@tanstack/solid-query",
  "useMutationState[(]": "useMutationState(() => ",
  "useMutation[(]": "useMutation(() => ",
  "useQuery[(]": "useQuery(() => ",
  "useQueries[(]": "useQueries(() => ",
  "useInfiniteQuery[(]": "useInfiniteQuery(() => "
}

----------------------------------------

TITLE: Setting Custom QueryClient Key
DESCRIPTION: Shows how to set a custom key for QueryClient access in Vue context to avoid name clashing between multiple apps.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/custom-client.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Configuring Recommended Rules with Flat Config in ESLint
DESCRIPTION: ESLint flat configuration (eslint.config.js) that enables all recommended rules from the TanStack Query plugin. This is the preferred approach for modern ESLint configurations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/eslint/eslint-plugin-query.md#2025-04-16_snippet_4

LANGUAGE: js
CODE:
import pluginQuery from '@tanstack/eslint-plugin-query'

export default [
  ...pluginQuery.configs['flat/recommended'],
  // Any other config...
]

----------------------------------------

TITLE: Mutation Matching Utility in TanStack Query
DESCRIPTION: Utility function to check if a mutation matches the provided set of mutation filters.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/filters.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
const isMatching = matchMutation(filters, mutation)

----------------------------------------

TITLE: Updating Query Keys to Arrays
DESCRIPTION: Example of changing a string query key to an array query key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
-useQuery('todos', fetchTodos)
+useQuery(['todos'], fetchTodos)

----------------------------------------

TITLE: Root Layout Setup with React Query Provider
DESCRIPTION: Configures the root layout component to wrap the application with the React Query provider.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/advanced-ssr.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
import Providers from './providers'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head />
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}

----------------------------------------

TITLE: Linear Backoff Implementation
DESCRIPTION: Example of a retry delay function implementing linear backoff for failed queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useQuery.md#2025-04-16_snippet_6

LANGUAGE: typescript
CODE:
attempt => attempt * 1000

----------------------------------------

TITLE: Solid.js Batch Configuration
DESCRIPTION: Demonstrates setting up batch notification function for Solid.js integration.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/notifyManager.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
import { notifyManager } from '@tanstack/query-core'
import { batch } from 'solid-js'

notifyManager.setBatchNotifyFunction(batch)

----------------------------------------

TITLE: Query Subscription Control with Screen Focus
DESCRIPTION: Example of controlling query subscription based on screen focus state using React Navigation's useIsFocused hook.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/react-native.md#2025-04-16_snippet_4

LANGUAGE: typescript
CODE:
import React from 'react'
import { useIsFocused } from '@react-navigation/native'
import { useQuery } from '@tanstack/react-query'
import { Text } from 'react-native'

function MyComponent() {
  const isFocused = useIsFocused()

  const { dataUpdatedAt } = useQuery({
    queryKey: ['key'],
    queryFn: () => fetch(...),
    subscribed: isFocused,
  })

  return <Text>DataUpdatedAt: {dataUpdatedAt}</Text>
}

----------------------------------------

TITLE: Registering Global Error Type in React Query
DESCRIPTION: Demonstrates how to register a global error type for React Query without specifying generics on each call.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/typescript.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
import '@tanstack/react-query'

declare module '@tanstack/react-query' {
  interface Register {
    defaultError: AxiosError
  }
}

const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const error: AxiosError | null

----------------------------------------

TITLE: Markdown Feature Comparison Table
DESCRIPTION: Detailed markdown table comparing features and capabilities across React Query, SWR, Apollo Client, RTK Query, and React Router. Includes bundle sizes, platform requirements, caching strategies, and specific functionality support.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/comparison.md#2025-04-16_snippet_0

LANGUAGE: markdown
CODE:
|                                                    | React Query                              | SWR [_(Website)_][swr]                   | Apollo Client [_(Website)_][apollo]        | RTK-Query [_(Website)_][rtk-query]   | React Router [_(Website)_][react-router]                                  |
| -------------------------------------------------- | ---------------------------------------- | ---------------------------------------- | ------------------------------------------ | ------------------------------------ | ------------------------------------------------------------------------- |
| Github Repo / Stars                                | [![][stars-react-query]][gh-react-query] | [![][stars-swr]][gh-swr]                 | [![][stars-apollo]][gh-apollo]             | [![][stars-rtk-query]][gh-rtk-query] | [![][stars-react-router]][gh-react-router]                                |

----------------------------------------

TITLE: Configuring Vue Query for Vite SSR
DESCRIPTION: Sets up Vue Query for use with Vite SSR, handling both server-side and client-side initialization. It creates a QueryClient and manages dehydration and hydration of query state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/ssr.md#2025-04-16_snippet_4

LANGUAGE: javascript
CODE:
import App from './App.vue'
import viteSSR from 'vite-ssr/vue'
import {
  QueryClient,
  VueQueryPlugin,
  hydrate,
  dehydrate,
} from '@tanstack/vue-query'

export default viteSSR(App, { routes: [] }, ({ app, initialState }) => {
  // -- This is Vite SSR main hook, which is called once per request

  // Create a fresh VueQuery client
  const queryClient = new QueryClient()

  // Sync initialState with the client state
  if (import.meta.env.SSR) {
    // Indicate how to access and serialize VueQuery state during SSR
    initialState.vueQueryState = { toJSON: () => dehydrate(queryClient) }
  } else {
    // Reuse the existing state in the browser
    hydrate(queryClient, initialState.vueQueryState)
  }

  // Mount and provide the client to the app components
  app.use(VueQueryPlugin, { queryClient })
})

----------------------------------------

TITLE: Basic Query Instance Initialization in TanStack Query
DESCRIPTION: Example of initializing a query instance with a query key and fetch function. This pattern is used to fetch and cache data under a specific key.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/caching.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodos }))

----------------------------------------

TITLE: Framework Hook Mapping Configuration in TanStack Query
DESCRIPTION: Configuration object that defines string replacement patterns to convert React Query hooks to their Solid Query equivalents. This includes mappings for mutation state, mutations, queries, and infinite queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/query-invalidation.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => '
}

----------------------------------------

TITLE: Using queryClient.removeQueries
DESCRIPTION: The removeQueries method removes queries from the cache based on their query keys or other properties.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_14

LANGUAGE: tsx
CODE:
queryClient.removeQueries({ queryKey, exact: true })

----------------------------------------

TITLE: Function Call Replacements for TanStack Query
DESCRIPTION: Configuration object showing the mapping of React Query function calls to their Solid Query equivalents. Includes mutations, queries, and infinite queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/query-retries.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => '
}

----------------------------------------

TITLE: Accessing Query Cache
DESCRIPTION: Shows how to get the query cache instance associated with the queryClient.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryClient.md#2025-04-16_snippet_24

LANGUAGE: tsx
CODE:
const queryCache = queryClient.getQueryCache()

----------------------------------------

TITLE: Defining injectMutationState Function in TypeScript for TanStack Query Angular
DESCRIPTION: A TypeScript function that injects a signal to track the state of all mutations in an Angular application using TanStack Query. It accepts a mutation state options function and optional Angular injector, returning a signal that tracks mutation states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectmutationstate.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function injectMutationState<TResult>(
  mutationStateOptionsFn,
  options?,
): Signal<TResult[]>

----------------------------------------

TITLE: Basic Type Inference in Angular Query
DESCRIPTION: Demonstrates basic type inference for query results in an Angular component using injectQuery.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/typescript.md#2025-04-16_snippet_0

LANGUAGE: angular-ts
CODE:
@Component({
  // ...
  template: `@let data = query.data();`,
  //               ^? data: number | undefined
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }))
}

----------------------------------------

TITLE: Defining injectMutation Function in TypeScript
DESCRIPTION: This function injects a mutation, which is an imperative function that can be invoked to perform server-side effects. It takes an options function and an optional injector, and returns a CreateMutationResult. Unlike queries, mutations are not run automatically.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectmutation.md#2025-04-16_snippet_0

LANGUAGE: TypeScript
CODE:
function injectMutation<TData, TError, TVariables, TContext>(
  optionsFn,
  injector?,
): CreateMutationResult<TData, TError, TVariables, TContext>

----------------------------------------

TITLE: Clearing the QueryCache
DESCRIPTION: Shows how to clear the entire query cache using the clear method, removing all stored queries and their states.
SOURCE: https://github.com/TanStack/query/blob/main/docs/reference/QueryCache.md#2025-04-16_snippet_4

LANGUAGE: tsx
CODE:
queryCache.clear()

----------------------------------------

TITLE: Initial Data from Cache
DESCRIPTION: Shows how to populate initial data from cached results of another query.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/initial-query-data.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => fetch('/todos'),
  initialData: () => {
    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
  },
})

----------------------------------------

TITLE: Data Change Effect Handler Example
DESCRIPTION: Shows how to handle data changes using useEffect instead of onSuccess callback.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-4.md#2025-04-16_snippet_13

LANGUAGE: typescript
CODE:
const { data } = useQuery({ queryKey, queryFn })
React.useEffect(() => mySideEffectHere(data), [data])

----------------------------------------

TITLE: Vue Component Props Example
DESCRIPTION: Example showing prop definition in a Vue component setup script.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/reactivity.md#2025-04-16_snippet_5

LANGUAGE: vue
CODE:
<script setup lang="ts">
const props = defineProps<{
  userId: string
}>()
</script>

----------------------------------------

TITLE: Creating a Global Background Fetching Indicator in Angular with TanStack Query
DESCRIPTION: This snippet demonstrates how to implement a global loading indicator that shows when any query in the application is fetching data in the background. It uses the injectIsFetching hook from TanStack Angular Query to track the global fetching state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/guides/background-fetching-indicators.md#2025-04-16_snippet_1

LANGUAGE: angular-ts
CODE:
import { injectIsFetching } from '@tanstack/angular-query-experimental'

@Component({
  selector: 'global-loading-indicator',
  template: `
    @if (isFetching()) {
      <div>Queries are fetching in the background...</div>
    }
  `,
})
export class GlobalLoadingIndicatorComponent {
  isFetching = injectIsFetching()
}

----------------------------------------

TITLE: Using InitialData with Remix Loader
DESCRIPTION: Example showing how to implement initial data loading with React Query in a Remix loader function.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_3

LANGUAGE: tsx
CODE:
export async function loader() {
  const posts = await getPosts()
  return json({ posts })
}

function Posts() {
  const { posts } = useLoaderData<typeof loader>()

  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: posts,
  })

  // ...
}

----------------------------------------

TITLE: Defining CreateBaseMutationResult Type Alias in TypeScript
DESCRIPTION: This snippet defines the CreateBaseMutationResult type alias, which extends MutationObserverResult with additional object properties. It includes generic type parameters for data, error, variables, and context.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/type-aliases/createbasemutationresult.md#2025-04-16_snippet_0

LANGUAGE: TypeScript
CODE:
type CreateBaseMutationResult<TData, TError, TVariables, TContext>: Override<MutationObserverResult<TData, TError, TVariables, TContext>, object> & object;

----------------------------------------

TITLE: Implementing Query Cancellation with graphql-request (Pre-v4.0.0) in TanStack Query
DESCRIPTION: This example demonstrates how to use the AbortSignal with graphql-request versions lower than v4.0.0 in a TanStack Query queryFn. The signal is passed to the GraphQLClient constructor.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/query-cancellation.md#2025-04-16_snippet_5

LANGUAGE: tsx
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    const client = new GraphQLClient(endpoint, {
      signal,
    })
    return client.request(query, variables)
  },
})

----------------------------------------

TITLE: Replacing React Query function calls with SolidQuery equivalents
DESCRIPTION: This snippet shows the replacements needed to convert React Query function calls to their SolidQuery counterparts. It includes modifications for useMutationState, useMutation, useQuery, useQueries, and useInfiniteQuery.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/guides/query-options.md#2025-04-16_snippet_0

LANGUAGE: javascript
CODE:
{
  '@tanstack/react-query': '@tanstack/solid-query',
  'useMutationState[(]': 'useMutationState(() => ',
  'useMutation[(]': 'useMutation(() => ',
  'useQuery[(]': 'useQuery(() => ',
  'useQueries[(]': 'useQueries(() => ',
  'useInfiniteQuery[(]': 'useInfiniteQuery(() => ',
}

----------------------------------------

TITLE: Setting Up QueryClientProvider
DESCRIPTION: Shows how to implement the new QueryClientProvider component which replaces ReactQueryConfigProvider and ReactQueryCacheProvider.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/migrating-to-react-query-3.md#2025-04-16_snippet_2

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from 'react-query'

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}

----------------------------------------

TITLE: Illustrating Client-Side Navigation Request Waterfall in Markdown
DESCRIPTION: This snippet shows the request waterfall that occurs during client-side navigation in a single-page application, highlighting the limitations of server-side rendering benefits.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_11

LANGUAGE: markdown
CODE:
```
1. |> JS for <Feed>
2.   |> getFeed()
3.     |> JS for <GraphFeedItem>
4.       |> getGraphDataById()
```

----------------------------------------

TITLE: Filtering Fetching Queries with useIsFetching
DESCRIPTION: Demonstrates using useIsFetching with filters to check fetching state for specific queries.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/solid/reference/useIsFetching.md#2025-04-16_snippet_2

LANGUAGE: javascript
CODE:
const isFetchingTodos = useIsFetching({ queryKey: ['todos'] })

----------------------------------------

TITLE: Defining useHydrate Function in TypeScript
DESCRIPTION: This snippet defines the useHydrate function, which takes optional parameters for state, options, and queryClient. It returns void and is used for hydrating query state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/svelte/reference/functions/usehydrate.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
function useHydrate(state?, options?, queryClient?): void

----------------------------------------

TITLE: Registering Custom Error Type
DESCRIPTION: Demonstrates how to register a custom default error type for Angular Query using module augmentation.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/typescript.md#2025-04-16_snippet_6

LANGUAGE: ts
CODE:
import '@tanstack/angular-query-experimental'

declare module '@tanstack/angular-query-experimental' {
  interface Register {
    defaultError: AxiosError
  }
}

const query = injectQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

computed(() => {
  const error = query.error()
  //      ^? error: AxiosError | null
})

----------------------------------------

TITLE: Defining injectQueryClient Function with InjectOptions in TypeScript
DESCRIPTION: Shows the function signature for injectQueryClient with InjectOptions parameter, returning a QueryClient instance.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/functions/injectqueryclient.md#2025-04-16_snippet_2

LANGUAGE: typescript
CODE:
function injectQueryClient(injectOptions): QueryClient

----------------------------------------

TITLE: Global State After TanStack Query in TypeScript
DESCRIPTION: Example of reduced global state after moving server-state to TanStack Query. This snippet demonstrates how the global state object is simplified to contain only client-specific state.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/does-this-replace-client-state.md#2025-04-16_snippet_1

LANGUAGE: tsx
CODE:
const globalState = {
  themeMode,
  sidebarStatus,
}

----------------------------------------

TITLE: Declaring CreateBaseQueryOptions Interface with Generic Types in TypeScript
DESCRIPTION: Defines a generic interface for query options that extends QueryObserverOptions. Includes type parameters for query function data, error handling, transformed data, and query keys.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/angular/reference/interfaces/createbasequeryoptions.md#2025-04-16_snippet_0

LANGUAGE: typescript
CODE:
interface CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> extends QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> {
  TQueryFnData = unknown
  TError = DefaultError
  TData = TQueryFnData
  TQueryData = TQueryFnData
  TQueryKey extends QueryKey = QueryKey
}

----------------------------------------

TITLE: Illustrating Server-Side Rendering Request Optimization in Markdown
DESCRIPTION: This snippet shows how server-side rendering can optimize the request waterfall by including content and initial data in the markup, reducing client-side requests.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/ssr.md#2025-04-16_snippet_9

LANGUAGE: markdown
CODE:
```
1. |> Markup (with content AND initial data)
2.   |> JS for <Feed>
2.   |> JS for <GraphFeedItem>
```

----------------------------------------

TITLE: Consecutive Mutations Example
DESCRIPTION: Illustrates the behavior of callbacks in consecutive mutations.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/react/guides/mutations.md#2025-04-16_snippet_6

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: addTodo,
  onSuccess: (data, variables, context) => {
    // Will be called 3 times
  },
})

const todos = ['Todo 1', 'Todo 2', 'Todo 3']
todos.forEach((todo) => {
  mutate(todo, {
    onSuccess: (data, variables, context) => {
      // Will execute only once, for the last mutation (Todo 3),
      // regardless which mutation resolves first
    },
  })
})

----------------------------------------

TITLE: Vue Query Implementation with Status Enum
DESCRIPTION: Demonstrates an alternative approach to handling query states using the status enum property instead of boolean flags. Shows how to handle pending, error, and success states explicitly.
SOURCE: https://github.com/TanStack/query/blob/main/docs/framework/vue/guides/queries.md#2025-04-16_snippet_2

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { status, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
</script>

<template>
  <span v-if="status === 'pending'">Loading...</span>
  <span v-else-if="status === 'error'">Error: {{ error.message }}</span>
  <!-- also status === 'success', but "else" logic works, too -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>