This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: advanced/dapps/react-dapp-v2
- Files matching these patterns are excluded: **/*.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
advanced/
  dapps/
    react-dapp-v2/
      src/
        chains/
          bip122.ts
          cosmos.ts
          eip155.ts
          index.ts
          kadena.ts
          multiversx.ts
          near.ts
          polkadot.ts
          solana.ts
          tezos.ts
          tron.ts
        components/
          app/
            index.tsx
          shared/
            index.ts
          Asset.tsx
          Banner.tsx
          Blockchain.tsx
          Button.tsx
          Column.tsx
          Header.tsx
          Icon.tsx
          Loader.tsx
          Metadata.tsx
          Modal.tsx
          OriginSimulationDropdown.tsx
          Pairing.tsx
          Peer.tsx
          RelayRegionDropdown.tsx
          Toggle.tsx
          Wrapper.tsx
        constants/
          default.ts
          index.ts
        contexts/
          ChainDataContext.tsx
          ClientContext.tsx
          JsonRpcContext.tsx
        helpers/
          api.ts
          bip122.ts
          eip1271.ts
          eip712.ts
          index.ts
          kadena.ts
          namespaces.ts
          solana.ts
          tx.ts
          types.ts
          utilities.ts
        modals/
          shared/
            index.ts
          LoaderModal.tsx
          PairingModal.tsx
          PingModal.tsx
          RequestLoaderModal.tsx
          RequestModal.tsx
        pages/
          _app.tsx
          _error.tsx
          404.tsx
          index.tsx
        styles/
          globals.css
          Home.module.css
        styles.ts
      .env.local.example
      .eslintrc.json
      .gitignore
      .prettierignore
      next.config.js
      package.json
      README.md
      tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="advanced/dapps/react-dapp-v2/src/chains/bip122.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const BIP122_MAINNET = "000000000019d6689c085ae165831e93";
export const BIP122_TESTNET = "000000000933ea01ad0ee984209779ba";
export const BIP122_DUST_LIMIT = "1001";

export const BtcChainData: ChainsMap = {
  [BIP122_MAINNET]: {
    id: `bip122:${BIP122_MAINNET}`,
    name: "BTC Mainnet",
    rpc: [],
    slip44: 0,
    testnet: false,
  },
  [BIP122_TESTNET]: {
    id: `bip122:${BIP122_TESTNET}`,
    name: "BTC Testnet",
    rpc: [],
    slip44: 501,
    testnet: true,
  },
};

export const BtcMetadata: NamespaceMetadata = {
  [BIP122_MAINNET]: {
    logo: "/assets/btc-testnet.png",
    rgb: "247, 147, 25",
  },
  [BIP122_TESTNET]: {
    logo: "/assets/btc-testnet.png",
    rgb: "247, 147, 25",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = BtcMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/cosmos.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const CosmosChainData: ChainsMap = {
  "cosmoshub-4": {
    name: "Cosmos Hub",
    id: "cosmos:cosmoshub-4",
    rpc: ["https://rpc.cosmos.network"],
    slip44: 118,
    testnet: false,
  },
  "irishub-1": {
    name: "Irisnet",
    id: "cosmos:irishub-1",
    rpc: ["https://rpc.irisnet.org"],
    slip44: 566,
    testnet: false,
  },
  "kava-4": {
    name: "Kava",
    id: "cosmos:kava-4",
    rpc: ["https://kava4.data.kava.io"],
    slip44: 459,
    testnet: false,
  },
  "columbus-4": {
    name: "Terra",
    id: "cosmos:columbus-4",
    rpc: [],
    slip44: 330,
    testnet: false,
  },
};

export const CosmosMetadata: NamespaceMetadata = {
  "cosmoshub-4": {
    logo: "/assets/" + "cosmos-cosmoshub-4.png",
    rgb: "27, 31, 53",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = CosmosMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/eip155.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  convertHexToNumber,
  convertHexToUtf8,
  ChainsMap,
} from "../helpers";

export const EIP155Colors = {
  ethereum: "99, 125, 234",
  optimism: "233, 1, 1",
  goerli: "189, 174, 155",
  xdai: "73, 169, 166",
  polygon: "130, 71, 229",
  zksync: "90, 90, 90",
  celo: "60, 203, 132",
  arbitrum: "44, 55, 75",
};

export const EIP155ChainData: ChainsMap = {
  "1": {
    name: "Ethereum Mainnet",
    id: "eip155:1",
    rpc: ["https://api.mycryptoapi.com/eth"],
    slip44: 60,
    testnet: false,
  },
  "5": {
    name: "Ethereum Goerli",
    id: "eip155:5",
    rpc: ["https://rpc.goerli.mudit.blog"],
    slip44: 60,
    testnet: true,
  },
  "11155111": {
    name: "Ethereum Sepolia",
    id: "eip155:11155111",
    rpc: ["https://gateway.tenderly.co/public/sepolia	"],
    slip44: 60,
    testnet: true,
  },
  "10": {
    name: "Optimism Mainnet",
    id: "eip155:10",
    rpc: ["https://mainnet.optimism.io"],
    slip44: 60,
    testnet: false,
  },
  "42": {
    name: "Ethereum Kovan",
    id: "eip155:42",
    rpc: ["https://kovan.poa.network"],
    slip44: 60,
    testnet: true,
  },
  "69": {
    name: "Optimism Kovan",
    id: "eip155:69",
    rpc: ["https://kovan.optimism.io"],
    slip44: 60,
    testnet: true,
  },
  "100": {
    name: "xDAI",
    id: "eip155:100",
    rpc: ["https://dai.poa.network"],
    slip44: 60,
    testnet: false,
  },
  "280": {
    name: "zkSync Era Testnet",
    id: "eip155:280",
    rpc: ["https://testnet.era.zksync.dev"],
    slip44: 60,
    testnet: true,
  },
  "324": {
    name: "zkSync Era",
    id: "eip155:324",
    rpc: ["https://mainnet.era.zksync.io"],
    slip44: 60,
    testnet: false,
  },
  "137": {
    name: "Polygon Mainnet",
    id: "eip155:137",
    rpc: ["https://rpc-mainnet.matic.network"],
    slip44: 60,
    testnet: false,
  },
  "420": {
    name: "Optimism Goerli",
    id: "eip155:420",
    rpc: ["https://goerli.optimism.io"],
    slip44: 60,
    testnet: true,
  },
  "42161": {
    name: "Arbitrum One",
    id: "eip155:42161",
    rpc: ["https://arb1.arbitrum.io/rpc"],
    slip44: 60,
    testnet: false,
  },
  "42220": {
    name: "Celo Mainnet",
    id: "eip155:42220",
    rpc: ["https://forno.celo.org"],
    slip44: 52752,
    testnet: false,
  },
  "44787": {
    name: "Celo Alfajores",
    id: "eip155:44787",
    rpc: ["https://alfajores-forno.celo-testnet.org"],
    slip44: 52752,
    testnet: true,
  },
  "80001": {
    name: "Polygon Mumbai",
    id: "eip155:80001",
    rpc: ["https://rpc-mumbai.matic.today"],
    slip44: 60,
    testnet: true,
  },
  "421611": {
    name: "Arbitrum Rinkeby",
    id: "eip155:421611",
    rpc: ["https://rinkeby.arbitrum.io/rpc"],
    slip44: 60,
    testnet: true,
  },
};

export const EIP155Metadata: NamespaceMetadata = {
  "1": {
    name: "Ethereum",
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "5": {
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "11155111": {
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "10": {
    name: "Optimism",
    logo: "/assets/" + "eip155-10.png",
    rgb: EIP155Colors.optimism,
  },
  "42": {
    logo: "/assets/" + "eip155-42.png",
    rgb: EIP155Colors.ethereum,
  },
  "420": {
    logo: "/assets/" + "eip155-420.png",
    rgb: EIP155Colors.optimism,
  },
  "100": {
    logo: "/assets/" + "eip155-100.png",
    rgb: EIP155Colors.xdai,
  },
  "280": {
    name: "zkSync Era Testnet",
    logo: "/assets/" + "eip155-324.svg",
    rgb: EIP155Colors.zksync,
  },
  "324": {
    name: "zkSync Era",
    logo: "/assets/" + "eip155-324.svg",
    rgb: EIP155Colors.zksync,
  },
  "137": {
    name: "Polygon",
    logo: "/assets/" + "eip155-137.png",
    rgb: EIP155Colors.polygon,
  },
  "80001": {
    logo: "/assets/" + "eip155-80001.png",
    rgb: EIP155Colors.polygon,
  },
  "42161": {
    name: "Arbitrum",
    logo: "/assets/" + "eip155-42161.png",
    rgb: EIP155Colors.arbitrum,
  },
  "42220": {
    name: "Celo",
    logo: "/assets/" + "eip155-42220.png",
    rgb: EIP155Colors.celo,
  },
  "44787": {
    logo: "/assets/" + "eip155-44787.png",
    rgb: EIP155Colors.celo,
  },
  "421611": {
    logo: "/assets/" + "eip155-421611.png",
    rgb: EIP155Colors.arbitrum,
  },
};
export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = EIP155Metadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  let params = [{ label: "Method", value: request.method }];

  switch (request.method) {
    case "eth_sendTransaction":
    case "eth_signTransaction":
      params = [
        ...params,
        { label: "From", value: request.params[0].from },
        { label: "To", value: request.params[0].to },
        {
          label: "Gas Limit",
          value: request.params[0].gas
            ? convertHexToNumber(request.params[0].gas)
            : request.params[0].gasLimit
            ? convertHexToNumber(request.params[0].gasLimit)
            : "",
        },
        {
          label: "Gas Price",
          value: convertHexToNumber(request.params[0].gasPrice),
        },
        {
          label: "Nonce",
          value: convertHexToNumber(request.params[0].nonce),
        },
        {
          label: "Value",
          value: request.params[0].value
            ? convertHexToNumber(request.params[0].value)
            : "",
        },
        { label: "Data", value: request.params[0].data },
      ];
      break;

    case "eth_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[0] },
        { label: "Message", value: request.params[1] },
      ];
      break;
    case "personal_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[1] },
        {
          label: "Message",
          value: convertHexToUtf8(request.params[0]),
        },
      ];
      break;
    default:
      params = [
        ...params,
        {
          label: "params",
          value: JSON.stringify(request.params, null, "\t"),
        },
      ];
      break;
  }
  return params;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/index.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import * as eip155 from "./eip155";
import * as cosmos from "./cosmos";
import * as polkadot from "./polkadot";
import * as solana from "./solana";
import * as near from "./near";
import * as multiversx from "./multiversx";
import * as tron from "./tron";
import * as tezos from "./tezos";
import * as kadena from "./kadena";
import * as bip122 from "./bip122";

import { ChainMetadata, ChainRequestRender } from "../helpers";

export function getChainMetadata(chainId: string): ChainMetadata {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainMetadata(chainId);
    case "cosmos":
      return cosmos.getChainMetadata(chainId);
    case "polkadot":
      return polkadot.getChainMetadata(chainId);
    case "solana":
      return solana.getChainMetadata(chainId);
    case "near":
      return near.getChainMetadata(chainId);
    case "kadena":
      return kadena.getChainMetadata(chainId);
    case "mvx":
      return multiversx.getChainMetadata(chainId);
    case "tron":
      return tron.getChainMetadata(chainId);
    case "tezos":
      return tezos.getChainMetadata(chainId);
    case "bip122":
      return bip122.getChainMetadata(chainId);
    default:
      throw new Error(`No metadata handler for namespace ${namespace}`);
  }
}

export function getChainRequestRender(
  request: JsonRpcRequest,
  chainId: string
): ChainRequestRender[] {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainRequestRender(request);
    case "cosmos":
      return cosmos.getChainRequestRender(request);
    case "polkadot":
      return polkadot.getChainRequestRender(request);
    case "near":
      return near.getChainRequestRender(request);
    case "tezos":
      return tezos.getChainRequestRender(request);
    case "kadena":
      return kadena.getChainRequestRender(request);
    default:
      throw new Error(`No render handler for namespace ${namespace}`);
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/kadena.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const KadenaMetadata: NamespaceMetadata = {
  mainnet01: {
    logo: "/assets/kadena.png",
    rgb: "237, 9, 143",
  },
  testnet04: {
    logo: "/assets/kadena.png",
    rgb: "237, 9, 143",
  },
};

// TODO: add `kadena` namespace to `caip-api` package to avoid manual specification here.
export const KadenaChainData: ChainsMap = {
  mainnet01: {
    name: "Kadena",
    id: "kadena:mainnet01",
    rpc: ["https://api.chainweb.com"],
    slip44: 626,
    testnet: false,
  },
  testnet04: {
    name: "Kadena Testnet",
    id: "kadena:testnet04",
    rpc: ["https://api.chainweb.com"],
    slip44: 626,
    testnet: true,
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = KadenaMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/multiversx.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const MultiversxChainData: ChainsMap = {
  "1": {
    id: "mvx:1",
    name: "MultiversX Mainnet",
    rpc: ["https://api.multiversx.com"],
    slip44: 508,
    testnet: false,
  },
  D: {
    id: "mvx:D",
    name: "MultiversX Devnet",
    rpc: ["https://devnet-api.multiversx.com"],
    slip44: 508,
    testnet: true,
  },
  // Keep only one Test Chain visible
  // T: {
  //   id: "mvx:T",
  //   name: "MultiversX Testnet",
  //   rpc: ["https://testnet-api.multiversx.com"],
  //   slip44: 508,
  //   testnet: true,
  // },
};

export const MultiversxMetadata: NamespaceMetadata = {
  // MultiversX Mainnet
  "1": {
    logo: "/assets/multiversx_logo.svg",
    rgb: "0, 0, 0",
  },
  // MultiversX Testnet
  T: {
    logo: "/assets/multiversx_logo.svg",
    rgb: "0, 0, 0",
  },
  // MultiversX Devnet
  D: {
    logo: "/assets/multiversx_logo.svg",
    rgb: "0, 0, 0",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = MultiversxMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/near.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const NearMetadata: NamespaceMetadata = {
  testnet: {
    logo: "https://avatars.githubusercontent.com/u/7613128?s=200&v=4",
    rgb: "27, 31, 53",
  },
};

export const NearChainData: ChainsMap = {
  testnet: {
    name: "NEAR Testnet",
    id: "near:testnet",
    rpc: ["https://rpc.testnet.near.org"],
    slip44: 397,
    testnet: true,
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = NearMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/polkadot.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";
import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const PolkadotChainData: ChainsMap = {
  ["91b171bb158e2d3848fa23a9f1c25182"]: {
    id: "polkadot:91b171bb158e2d3848fa23a9f1c25182",
    name: "Polkadot Mainnet",
    rpc: ["wss://rpc.polkadot.io"],
    slip44: 0,
    testnet: false,
  },
  ["e143f23803ac50e8f6f8e62695d1ce9e"]: {
    id: "polkadot:e143f23803ac50e8f6f8e62695d1ce9e",
    name: "Polkadot Testnet (Westend)",
    rpc: ["wss://westend-rpc.polkadot.io"],
    slip44: 0,
    testnet: false,
  },
};

export const PolkadotMetadata: NamespaceMetadata = {
  // eslint-disable-next-line no-useless-computed-key
  ["91b171bb158e2d3848fa23a9f1c25182"]: {
    logo: "/assets/polkadot.svg",
    rgb: "230, 1, 122",
  },
  ["e143f23803ac50e8f6f8e62695d1ce9e"]: {
    logo: "/assets/westend-logo.svg",
    rgb: "218, 104, 167",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = PolkadotMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/solana.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const SolanaChainData: ChainsMap = {
  "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
    id: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    name: "Solana Mainnet",
    rpc: [
      "https://api.mainnet-beta.solana.com",
      "https://solana-api.projectserum.com",
    ],
    slip44: 501,
    testnet: false,
  },
  EtWTRABZaYq6iMfeYKouRu166VU2xqa1: {
    id: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    name: "Solana Devnet",
    rpc: ["https://api.devnet.solana.com"],
    slip44: 501,
    testnet: true,
  },
  "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": {
    id: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
    name: "Solana Testnet",
    rpc: ["https://api.testnet.solana.com"],
    slip44: 501,
    testnet: true,
  },
};

export const SolanaMetadata: NamespaceMetadata = {
  // Solana Mainnet
  "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
    logo: "/assets/solana_logo.png",
    rgb: "0, 0, 0",
  },
  // Solana Devnet
  EtWTRABZaYq6iMfeYKouRu166VU2xqa1: {
    logo: "/assets/solana_logo.png",
    rgb: "0, 0, 0",
  },
  // Solana Testnet
  "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": {
    logo: "/assets/solana_logo.png",
    rgb: "0, 0, 0",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = SolanaMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/tezos.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const TezosMetadata: NamespaceMetadata = {
  mainnet: {
    logo: "/assets/tezos.svg",
    rgb: "44, 125, 247",
  },
  testnet: {
    logo: "/assets/tezos.svg",
    rgb: "44, 125, 247",
  },
};

export const TezosChainData: ChainsMap = {
  mainnet: {
    name: "Tezos",
    id: "tezos:mainnet",
    rpc: ["https://mainnet.api.tez.ie"],
    slip44: 1729,
    testnet: false,
  },
  testnet: {
    name: "Tezos Testnet",
    id: "tezos:testnet",
    rpc: ["https://ghostnet.ecadinfra.com"],
    slip44: 1729,
    testnet: true,
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = TezosMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/tron.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const TronChainData: ChainsMap = {
  "0x2b6653dc": {
    id: "tron:0x2b6653dc",
    name: "Tron Mainnet",
    rpc: [],
    slip44: 195,
    testnet: false,
  },
  "0xcd8690dc": {
    id: "tron:0xcd8690dc",
    name: "Tron Testnet",
    rpc: [],
    slip44: 195,
    testnet: true,
  },
};

export const TronMetadata: NamespaceMetadata = {
  // Tron Mainnet
  "0x2b6653dc": {
    logo: "https://tronscan.io/static/media/TRON.4a760cebd163969b2ee874abf2415e9a.svg",
    rgb: "183, 62, 49",
  },
  // Tron TestNet
  "0xcd8690dc": {
    logo: "https://tronscan.io/static/media/TRON.4a760cebd163969b2ee874abf2415e9a.svg",
    rgb: "183, 62, 49",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = TronMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/app/index.tsx">
import styled from "styled-components";
import { fonts } from "../../styles";
import Button from "../Button";
import Column from "../Column";
import Wrapper from "../Wrapper";

export const SLayout = styled.div`
  position: relative;
  width: 100%;
  min-height: 100vh;
  text-align: center;
`;

export const SContent = styled(Wrapper as any)`
  width: 100%;
  height: 100%;
  padding: 0 16px;
`;

export const SLanding = styled(Column as any)`
  /* height: 600px; */
`;

export const SButtonContainer = styled(Column as any)`
  width: 250px;
  margin: 50px 0;
`;

export const SConnectButton = styled(Button as any)`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
`;

export const SAccountsContainer = styled(SLanding as any)`
  height: 100%;
  padding-bottom: 30px;
  & h3 {
    padding-top: 30px;
  }
`;

export const SToggleContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 10px auto;
  & > p {
    margin-right: 10px;
  }
`;

export const SDropDownContainer = styled.div`
  padding-top: 20px;
  display: flex;
  justify-content: center;
  align-items: flex-end;
`;

export const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

export const SAccounts = styled(SFullWidthContainer)`
  justify-content: space-between;
  align-items: start;
  & > div {
    margin: 12px 0;
    flex: 1 0 100%;
    @media (min-width: 648px) {
      flex: 0 1 48%;
    }
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/shared/index.ts">
import styled from "styled-components";

export const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

export const STable = styled(SContainer)`
  flex-direction: column;
  text-align: left;
`;

export const SRow = styled.div`
  width: 100%;
  display: flex;
  margin: 6px 0;
`;

export const SKey = styled.div`
  width: 30%;
  font-weight: 700;
`;

export const SValue = styled.div`
  width: 70%;
  font-family: monospace;
`;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Asset.tsx">
import * as React from "react";
import styled from "styled-components";

import Icon from "./Icon";

import { AssetData, fromWad } from "../helpers";

import { getChainMetadata } from "../chains";

const xdaiLogo = getChainMetadata("eip155:100").logo;
const maticLogo = getChainMetadata("eip155:137").logo;
const kadenaLogo = getChainMetadata("kadena:testnet04").logo;
const btcLogo = getChainMetadata(
  "bip122:000000000933ea01ad0ee984209779ba"
).logo;

const SAsset = styled.div`
  width: 100%;
  padding: 20px;
  display: flex;
  justify-content: space-between;
`;
const SAssetLeft = styled.div`
  display: flex;
`;

const SAssetName = styled.div`
  display: flex;
  margin-left: 10px;
`;

const SAssetRight = styled.div`
  display: flex;
`;

const SAssetBalance = styled.div`
  display: flex;
`;

function getAssetIcon(asset: AssetData): JSX.Element {
  if (!!asset.contractAddress) {
    const src = `https://raw.githubusercontent.com/TrustWallet/tokens/master/tokens/${asset.contractAddress.toLowerCase()}.png`;
    return <Icon src={src} fallback={"/assets/erc20.svg"} />;
  }
  switch (asset.symbol.toLowerCase()) {
    case "eth":
      return <Icon src={"/assets/eth.svg"} />;
    case "xdai":
      return <Icon src={xdaiLogo} />;
    case "matic":
      return <Icon src={maticLogo} />;
    case "kda":
      return <Icon src={kadenaLogo} />;
    case "btc":
      return <Icon src={btcLogo} />;
    default:
      return <Icon src={"/assets/eth20.svg"} />;
  }
}

interface AssetProps {
  asset: AssetData;
}

const Asset = (props: AssetProps) => {
  const { asset } = props;
  return (
    <SAsset {...props}>
      <SAssetLeft>
        {getAssetIcon(asset)}
        <SAssetName>{asset.name}</SAssetName>
      </SAssetLeft>
      <SAssetRight>
        <SAssetBalance>
          {fromWad(asset.balance || "0")} {asset.symbol}
        </SAssetBalance>
      </SAssetRight>
    </SAsset>
  );
};

export default Asset;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Banner.tsx">
import * as React from "react";
import styled from "styled-components";

const SBannerWrapper = styled.div`
  display: flex;
  align-items: center;
  position: relative;
`;

const SBanner = styled.div`
  width: 275px;
  height: 45px;
  background: url(/assets/walletconnect.png) no-repeat;
  background-size: cover;
  background-position: center;
`;

const Banner = () => (
  <SBannerWrapper>
    <SBanner />
  </SBannerWrapper>
);

export default Banner;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Blockchain.tsx">
import React, { PropsWithChildren, FC } from "react";
import { styled } from "styled-components";

import Asset from "./Asset";
import Button from "./Button";
import Column from "./Column";
import Loader from "./Loader";

import { getChainMetadata } from "../chains";
import {
  AccountAction,
  ellipseAddress,
  AccountBalances,
  ChainMetadata,
  ChainNamespaces,
  ChainData,
} from "../helpers";
import { fonts } from "../styles";

interface AccountStyleProps {
  rgb: string;
  children?: React.ReactNode;
  onClick?: () => void;
  className?: string;
}

const SAccount = styled.div<AccountStyleProps>`
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  border-radius: 8px;
  padding: 8px;
  margin: 5px 0;
  border: ${({ rgb }) => `2px solid rgb(${rgb})`};
  &.active {
    box-shadow: ${({ rgb }) => `0 0 8px rgb(${rgb})`};
  }
`;

const SChain = styled.div`
  width: 100%;
  display: flex;
  align-items: center;
  & p {
    font-weight: 600;
  }
  & img {
    border-radius: 50%;
    width: 35px;
    height: 35px;
    margin-right: 10px;
  }
`;

const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

interface ActionProps {
  rgb: string;
}

const SAction = styled(Button)<ActionProps>`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
  background-color: ${({ rgb }) => `rgb(${rgb})`};
`;

const SBlockchainChildrenContainer = styled(SFullWidthContainer)`
  flex-direction: column;
`;

interface BlockchainProps {
  chainData: ChainNamespaces;
  fetching?: boolean;
  active?: boolean;
  chainId: string;
  address?: string;
  onClick?: (chain: string) => void;
  balances?: AccountBalances;
  actions?: AccountAction[];
}

interface BlockchainDisplayData {
  data: ChainData;
  meta: ChainMetadata;
}

function getBlockchainDisplayData(
  chainId: string,
  chainData: ChainNamespaces
): BlockchainDisplayData | undefined {
  const [namespace, reference] = chainId.split(":");
  let meta: ChainMetadata;
  try {
    meta = getChainMetadata(chainId);
  } catch (e) {
    return undefined;
  }
  const data: ChainData = chainData[namespace][reference];
  if (typeof data === "undefined") return undefined;
  return { data, meta };
}

const Blockchain: FC<PropsWithChildren<BlockchainProps>> = (
  props: PropsWithChildren<BlockchainProps>
) => {
  const {
    chainData,
    fetching,
    chainId,
    address,
    onClick,
    active,
    balances,
    actions,
  } = props;
  if (!Object.keys(chainData).length) return null;

  const chain = getBlockchainDisplayData(chainId, chainData);

  if (typeof chain === "undefined") return null;

  const name = chain.meta.name || chain.data.name;
  const account =
    typeof address !== "undefined" ? `${chainId}:${address}` : undefined;
  const assets =
    typeof account !== "undefined" && typeof balances !== "undefined"
      ? balances[account]
      : [];
  return (
    <React.Fragment>
      <SAccount
        rgb={chain.meta.rgb}
        onClick={() => onClick && onClick(props.chainId)}
        className={active ? "active" : ""}
      >
        <SChain>
          <img src={chain.meta.logo} alt={name} />
          <p>{name}</p>
        </SChain>
        {!!address && <p>{ellipseAddress(address)}</p>}
        <SBlockchainChildrenContainer>
          {fetching ? (
            <Column center>
              <SContainer>
                <Loader rgb={`rgb(${chain.meta.rgb})`} />
              </SContainer>
            </Column>
          ) : (
            <>
              {!!assets && assets.length ? (
                <SFullWidthContainer>
                  <h6>Balances</h6>
                  <Column center>
                    {assets.map((asset) =>
                      asset.symbol ? (
                        <Asset key={asset.symbol} asset={asset} />
                      ) : null
                    )}
                  </Column>
                </SFullWidthContainer>
              ) : null}
              {address && !!actions && actions.length ? (
                <SFullWidthContainer>
                  <h6>Methods</h6>
                  {actions.map((action) => (
                    <SAction
                      key={action.method}
                      left
                      rgb={chain.meta.rgb}
                      onClick={() => action.callback(chainId, address)}
                    >
                      {action.method}
                    </SAction>
                  ))}
                </SFullWidthContainer>
              ) : null}
            </>
          )}
        </SBlockchainChildrenContainer>
      </SAccount>
    </React.Fragment>
  );
};
export default Blockchain;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Button.tsx">
import * as React from "react";
import { styled, keyframes } from "styled-components";
import Loader from "./Loader";
import { colors, fonts, shadows, transitions } from "../styles";

interface ButtonStyleProps {
  fetching: boolean;
  outline: boolean;
  type: "button" | "submit" | "reset";
  color: string;
  disabled: boolean;
  icon: any;
  left: boolean;
}

interface ButtonProps extends ButtonStyleProps {
  children: React.ReactNode;
  onClick?: any;
}

const SIcon = styled.div`
  position: absolute;
  height: 15px;
  width: 15px;
  margin: 0 8px;
  top: calc((100% - 15px) / 2);
`;

const SHoverLayer = styled.div`
  transition: ${transitions.button};
  position: absolute;
  height: 100%;
  width: 100%;
  background-color: rgb(${colors.white}, 0.1);
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  pointer-events: none;
  opacity: 0;
  visibility: hidden;
`;

const SButton = styled.button<ButtonStyleProps>`
  transition: ${transitions.button};
  position: relative;
  border: none;
  border-style: none;
  box-sizing: border-box;
  background-color: ${({ outline, color }) =>
    outline ? "transparent" : `rgb(${colors[color]})`};
  border: ${({ outline, color }) =>
    outline ? `1px solid rgb(${colors[color]})` : "none"};
  color: ${({ outline, color }) =>
    outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`};
  box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  font-weight: ${fonts.weight.semibold};
  padding: ${({ icon, left }) =>
    icon ? (left ? "7px 12px 8px 28px" : "7px 28px 8px 12px") : "8px 12px"};
  cursor: ${({ disabled }) => (disabled ? "auto" : "pointer")};
  will-change: transform;

  &:disabled {
    opacity: 0.6;
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  }

  @media (hover: hover) {
    &:hover {
      transform: ${({ disabled }) => (!disabled ? "translateY(-1px)" : "none")};
      box-shadow: ${({ disabled, outline }) =>
        !disabled
          ? outline
            ? "none"
            : `${shadows.hover}`
          : `${shadows.soft}`};
    }

    &:hover ${SHoverLayer} {
      opacity: 1;
      visibility: visible;
    }
  }

  &:active {
    transform: ${({ disabled }) => (!disabled ? "translateY(1px)" : "none")};
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
    color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgba(${colors.white}, 0.24)`};

    & ${SIcon} {
      opacity: 0.8;
    }
  }

  & ${SIcon} {
    right: ${({ left }) => (left ? "auto" : "0")};
    left: ${({ left }) => (left ? "0" : "auto")};
    display: ${({ icon }) => (icon ? "block" : "none")};
    mask: ${({ icon }) => (icon ? `url(${icon}) center no-repeat` : "none")};
    background-color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`};
    transition: 0.15s ease;
  }
`;

const Button = (props: ButtonProps) => (
  <SButton
    {...props}
    type={props.type}
    outline={props.outline}
    color={props.color}
    disabled={props.disabled}
    icon={props.icon}
    left={props.left}
  >
    <SHoverLayer />
    <SIcon />
    {props.fetching ? <Loader size={20} color="white" /> : props.children}
  </SButton>
);

Button.defaultProps = {
  fetching: false,
  outline: false,
  type: "button",
  color: "lightBlue",
  disabled: false,
  icon: null,
  left: false,
};

export default Button;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Column.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled } from "styled-components";

interface ColumnStyleProps {
  spanHeight: boolean;
  maxWidth: number;
  center: boolean;
  children?: React.ReactNode;
}

interface ColumnProps extends ColumnStyleProps {
  children: React.ReactNode;
}

const SColumn = styled.div<ColumnStyleProps>`
  position: relative;
  width: 100%;
  height: ${({ spanHeight }) => (spanHeight ? "100%" : "auto")};
  max-width: ${({ maxWidth }) => `${maxWidth}px`};
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: ${({ center }) => (center ? "center" : "flex-start")};
`;

const Column = (props: ColumnProps) => {
  const { children, spanHeight, maxWidth, center } = props;
  return (
    <SColumn
      {...props}
      spanHeight={spanHeight}
      maxWidth={maxWidth}
      center={center}
    >
      {children}
    </SColumn>
  );
};

Column.propTypes = {
  children: PropTypes.node.isRequired,
  spanHeight: PropTypes.bool,
  maxWidth: PropTypes.number,
  center: PropTypes.bool,
};

Column.defaultProps = {
  spanHeight: false,
  maxWidth: 600,
  center: false,
};

export default Column;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Header.tsx">
import * as React from "react";
import styled from "styled-components";
import { SessionTypes } from "@walletconnect/types";

import { fonts, responsive } from "../styles";
import Button from "./Button";
import Icon from "./Icon";
import { DEFAULT_GITHUB_REPO_URL } from "../constants";

const SHeader = styled.div`
  margin-top: -1px;
  margin-bottom: 1px;
  width: 100%;
  height: 100px;
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 16px;
  @media screen and (${responsive.sm.max}) {
    font-size: ${fonts.size.small};
  }
`;

const SHeaderActions = styled.div`
  display: flex;
  & button {
    margin-left: 10px;
  }
`;

const SActiveAccount = styled.div`
  display: flex;
  align-items: center;
  position: relative;
  font-weight: 500;
`;

const GithubLogoContainer = styled.div`
  padding-top: 8px;
`;

const SActiveSession = styled(SActiveAccount as any)`
  flex-direction: column;
  text-align: left;
  align-items: flex-start;
  & p {
    font-size: 0.8em;
    margin: 0;
    padding: 0;
  }
  & p:nth-child(n + 2) {
    font-weight: bold;
  }
`;

interface HeaderProps {
  ping: () => Promise<void>;
  emit: () => Promise<void>;
  disconnect: () => Promise<void>;
  session: SessionTypes.Struct | undefined;
}

const Header = (props: HeaderProps) => {
  const { ping, disconnect, session, emit } = props;
  return (
    <SHeader {...props}>
      {session ? (
        <>
          <SActiveSession>
            <p>{`Connected to`}</p>
            <p>{session.peer.metadata.name}</p>
          </SActiveSession>
          <SHeaderActions>
            <GithubLogoContainer>
              <a
                href={DEFAULT_GITHUB_REPO_URL}
                target="_blank"
                rel="noreferrer"
              >
                <Icon size={24} src={"/assets/githubLogo.svg"} />
              </a>
            </GithubLogoContainer>
            <Button outline color="black" onClick={ping}>
              {"Ping"}
            </Button>
            <Button outline color="black" onClick={emit}>
              {"Emit"}
            </Button>
            <Button outline color="red" onClick={disconnect}>
              {"Disconnect"}
            </Button>
          </SHeaderActions>
        </>
      ) : null}
    </SHeader>
  );
};

export default Header;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Icon.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

interface IconStyleProps {
  size: number;
}

const SIcon = styled.img<IconStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
`;

const Icon = (props: any) => {
  const { src, fallback, size } = props;
  return (
    <SIcon
      {...props}
      src={src}
      size={size}
      onError={(event: any) => {
        if (fallback) {
          event.target.src = fallback;
        }
      }}
    />
  );
};

Icon.propTypes = {
  src: PropTypes.string,
  fallback: PropTypes.string,
  size: PropTypes.number,
};

Icon.defaultProps = {
  src: null,
  fallback: "",
  size: 20,
};

export default Icon;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Loader.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled, keyframes } from "styled-components";
import { colors } from "../styles";

const load = keyframes`
  0% {
    transform: scale(1.0);
  }
  5% {
    transform: scale(1.0);
  }
  50% {
    transform: scale(0.8);
  }
  95% {
    transform: scale(1.0);
  }
  100% {
    transform: scale(1.0);
  }
`;

interface LoaderStyleProps {
  size: number;
  children?: React.ReactNode;
  viewBox?: string;
}

interface LoaderProps extends LoaderStyleProps {
  color: string;
  rgb?: string;
}

const SLoader = styled.svg<LoaderStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  animation: ${load} 1s infinite cubic-bezier(0.25, 0, 0.75, 1);
  transform: translateZ(0);
`;

const Loader = (props: LoaderProps) => {
  const { size, color } = props;
  const rgb = props.rgb || `rgb(${colors[color]})`;
  return (
    <SLoader viewBox="0 0 186 187" size={size}>
      <g stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
        <path
          d="M60,10.34375 C32.3857625,10.34375 10,32.7295125 10,60.34375 L10,126.34375 C10,153.957987 32.3857625,176.34375 60,176.34375 L126,176.34375 C153.614237,176.34375 176,153.957987 176,126.34375 L176,60.34375 C176,32.7295125 153.614237,10.34375 126,10.34375 L60,10.34375 Z M60,0.34375 L126,0.34375 C159.137085,0.34375 186,27.206665 186,60.34375 L186,126.34375 C186,159.480835 159.137085,186.34375 126,186.34375 L60,186.34375 C26.862915,186.34375 0,159.480835 0,126.34375 L0,60.34375 C0,27.206665 26.862915,0.34375 60,0.34375 Z"
          id="Rectangle-Copy"
          fill={rgb}
          fillRule="nonzero"
        />
        <rect
          id="Rectangle"
          fill={rgb}
          x="44"
          y="44.34375"
          width="98"
          height="98"
          rx="35"
        />
      </g>
    </SLoader>
  );
};

Loader.propTypes = {
  size: PropTypes.number,
  color: PropTypes.string,
};

Loader.defaultProps = {
  size: 40,
  color: "lightBlue",
};

export default Loader;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Metadata.tsx">
import Head from "next/head";
import * as React from "react";
import { DEFAULT_APP_METADATA } from "../constants";

const Metadata = () => (
  <Head>
    <title>{DEFAULT_APP_METADATA.name}</title>
    <meta name="description" content={DEFAULT_APP_METADATA.description} />
    <meta name="url" content={DEFAULT_APP_METADATA.url} />

    {DEFAULT_APP_METADATA.icons.map((icon, index) => (
      <link key={index} rel="icon" href={icon} />
    ))}
  </Head>
);

export default Metadata;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Modal.tsx">
import React, { useEffect, useRef, useState } from "react";
import { styled } from "styled-components";
import { colors, transitions } from "../styles";

interface LightboxProps {
  show: boolean;
  offset: number;
  opacity?: number;
  children?: React.ReactNode;
  ref?: React.RefObject<HTMLDivElement>;
}

const SLightbox = styled.div<LightboxProps>`
  transition: opacity 0.1s ease-in-out;
  text-align: center;
  position: absolute;
  width: 100vw;
  height: 100%;
  margin-left: -50vw;
  top: ${({ offset }) => (offset ? `-${offset}px` : 0)};
  left: 50%;
  z-index: 2;
  will-change: opacity;
  background-color: ${({ opacity }) => {
    let alpha = 0.4;
    if (typeof opacity === "number") {
      alpha = opacity;
    }
    return `rgba(0, 0, 0, ${alpha})`;
  }};
  opacity: ${({ show }) => (show ? 1 : 0)};
  visibility: ${({ show }) => (show ? "visible" : "hidden")};
  pointer-events: ${({ show }) => (show ? "auto" : "none")};
  display: flex;
  justify-content: center;
  align-items: center;
`;

const SModalContainer = styled.div`
  position: relative;
  width: 100%;
  height: 100%;
  padding: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

interface HitboxProps {
  onClick?: () => void;
}

const SHitbox = styled.div<HitboxProps>`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
`;

interface CloseButtonStyleProps {
  size: number;
  color: string;
  onClick?: any;
}

const SCloseButton = styled.div<CloseButtonStyleProps>`
  transition: ${transitions.short};
  position: absolute;
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  right: ${({ size }) => `${size / 1.6667}px`};
  top: ${({ size }) => `${size / 1.6667}px`};
  opacity: 0.5;
  cursor: pointer;

  &:hover {
    opacity: 1;
  }
  &:before,
  &:after {
    position: absolute;
    content: " ";
    height: ${({ size }) => `${size}px`};
    width: 2px;
    background: ${({ color }) => `rgb(${colors[color]})`};
  }
  &:before {
    transform: rotate(45deg);
  }
  &:after {
    transform: rotate(-45deg);
  }
`;

const SCard = styled.div`
  position: relative;
  width: 100%;
  max-width: 500px;
  padding: 25px;
  background-color: rgb(${colors.white});
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;

const SModalContent = styled.div`
  position: relative;
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

interface IProps {
  children: React.ReactNode;
  show: boolean;
  closeModal: () => void;
  opacity?: number;
}

export default function Modal({ children, show, opacity, closeModal }: IProps) {
  const [offset, setOffset] = useState(0);
  const lightboxRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (lightboxRef.current) {
      const lightboxRect = lightboxRef.current.getBoundingClientRect();
      const nextOffset = lightboxRect.top > 0 ? lightboxRect.top : 0;

      if (nextOffset !== 0 && nextOffset !== offset) {
        setOffset(nextOffset);
      }
    }
  }, [offset]);

  return (
    <SLightbox show={show} offset={offset} opacity={opacity} ref={lightboxRef}>
      <SModalContainer>
        <SHitbox onClick={closeModal} />
        <SCard>
          <SCloseButton size={25} color="dark" onClick={closeModal} />
          <SModalContent>{children}</SModalContent>
        </SCard>
      </SModalContainer>
    </SLightbox>
  );
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/OriginSimulationDropdown.tsx">
import * as React from "react";
import { ORIGIN_OPTIONS } from "../constants/default";
import { styled } from "styled-components";

interface OriginSimulationProps {
  origin: string;
  show: boolean;
}

interface SelectContainerProps {
  value?: string;
  onChange?: (e: any) => void;
  children?: React.ReactNode;
}

const SelectContainer = styled.select<SelectContainerProps>`
  width: 150px;
  background: transparent;
  color: black;
  height: 30px;
  border-radius: 4px;
  padding: 2px;
  font-size: "1.25em";
  bottom: 40px;
  left: 50px;
  direction: ltr;
  unicode-bidi: embed;
  margin: 5px;
`;

interface SelectOptionProps {
  value?: string;
  selected?: boolean;
  children?: React.ReactNode;
}

const SelectOption = styled.option<SelectOptionProps>`
  font-size: "1.25em";
`;

const OriginSimulationDropdown = (props: OriginSimulationProps) => {
  const { show } = props;
  const [selectedOrigin, setSelectedOrigin] = React.useState(props.origin);
  React.useEffect(() => {
    if (!show) {
      return;
    }

    setSelectedOrigin(
      localStorage.getItem("wallet_connect_dapp_origin") || props.origin
    );
  }, [show, props.origin]);

  const setOrigin = React.useCallback((origin: string) => {
    localStorage.setItem("wallet_connect_dapp_origin", origin);
    location.reload();
  }, []);
  return (
    <div>
      {show && (
        <SelectContainer
          value={selectedOrigin}
          onChange={(e) => setOrigin(e?.target?.value)}
        >
          <option disabled>Origin Url:</option>
          {ORIGIN_OPTIONS.map((e, i) => {
            const seleted = e.value === selectedOrigin;
            console.log("selected", seleted, e.value);
            return (
              <SelectOption key={i} value={e.value} selected={seleted}>
                {e.label}
              </SelectOption>
            );
          })}
        </SelectContainer>
      )}
    </div>
  );
};

export default OriginSimulationDropdown;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Pairing.tsx">
import * as React from "react";
import styled from "styled-components";

import { PairingTypes } from "@walletconnect/types";

import Peer from "./Peer";

interface PairingProps {
  pairing: PairingTypes.Struct;
  onClick?: any;
}

const SPairingContainer = styled.div`
  width: 100%;
  cursor: pointer;
`;

const Pairing = (props: PairingProps) => {
  const { peerMetadata } = props.pairing;
  return (
    <SPairingContainer onClick={props.onClick}>
      <div>
        {typeof peerMetadata !== "undefined" ? (
          <Peer oneLiner metadata={peerMetadata} />
        ) : (
          <div>{`Unknown Wallet`}</div>
        )}
      </div>
    </SPairingContainer>
  );
};

export default Pairing;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Peer.tsx">
import { SignClientTypes } from "@walletconnect/types";
import * as React from "react";
import styled from "styled-components";
import { colors, fonts } from "../styles";

const SPeerOneLiner = styled.div`
  display: flex;
  align-items: center;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;

  & img {
    width: 40px;
    height: 40px;
  }
  & > div {
    margin-left: 10px;
  }
`;

const SPeerCard = styled.div`
  align-items: center;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-direction: column;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;
  & > div {
    margin: 4px auto;
  }
`;

const SIcon = styled.img`
  width: 100px;
  margin: 0 auto;
`;

const SCenter = styled.div`
  text-align: center;
`;

const SUrl = styled(SCenter as any)`
  font-size: ${fonts.size.small};
  opacity: 0.8;
`;

const SName = styled(SCenter as any)`
  font-weight: bold;
`;

interface PeerProps {
  oneLiner?: boolean;
  metadata: SignClientTypes.Metadata;
}

const Peer = (props: PeerProps) =>
  props.oneLiner ? (
    <SPeerOneLiner>
      <img src={props.metadata.icons[0]} alt={props.metadata.name} />
      <div>{props.metadata.name}</div>
    </SPeerOneLiner>
  ) : (
    <SPeerCard>
      <SIcon src={props.metadata.icons[0]} alt={props.metadata.name} />
      <SName>{props.metadata.name}</SName>
      <SCenter>{props.metadata.description}</SCenter>
      <SUrl>{props.metadata.url}</SUrl>
    </SPeerCard>
  );

export default Peer;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/RelayRegionDropdown.tsx">
import * as React from "react";
import { REGIONALIZED_RELAYER_ENDPOINTS } from "../constants/default";
import styled from "styled-components";
import Icon from "./Icon";
import { useState } from "react";

interface RelayRegionDropdownProps {
  relayerRegion: string;
  setRelayerRegion?: (relayer: string) => void;
  show: boolean;
}

const SelectContainer = styled.select`
  width: 150px;
  background: transparent;
  color: black;
  height: 30px;
  border-radius: 4px;
  padding: 2px;
  font-size: "1.25em";
  bottom: 40px;
  left: 50px;
  direction: ltr;
  unicode-bidi: embed;
  margin: 5px;
`;

const SelectOption = styled.option`
  font-size: "1.25em";
`;

const RelayRegionDropdown = (props: RelayRegionDropdownProps) => {
  const { relayerRegion, setRelayerRegion, show } = props;
  return (
    <div>
      {show && (
        <SelectContainer
          value={relayerRegion}
          onChange={(e) => setRelayerRegion?.(e?.target?.value)}
        >
          <option disabled>Relayer Region:</option>
          {REGIONALIZED_RELAYER_ENDPOINTS.map((e, i) => {
            return (
              <SelectOption key={i} value={e.value}>
                {e.label}
              </SelectOption>
            );
          })}
        </SelectContainer>
      )}
    </div>
  );
};

export default RelayRegionDropdown;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Toggle.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

import { colors, transitions } from "../styles";

interface IToggleStyleProps {
  color: string;
  active: boolean;
}

const SToggle = styled.div<IToggleStyleProps>`
  position: relative;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  transition: ${transitions.base};
  & div {
    transition: ${transitions.base};
    appearance: none;
    transition: all 0.3s ease;
    box-shadow: ${({ active, color }) =>
      active
        ? `inset 0px 0px 0px 20px rgb(${colors[color]})`
        : `inset 0px 0px 0px 1px rgb(${colors.grey})`};
    border-radius: 1rem;
    background-color: rgb(${colors.white});
    padding: 1px;
    display: inline-block;
    width: 46px;
    height: 26px;
    position: relative;
    cursor: pointer;
    margin: 0px;
    vertical-align: bottom;
    outline: none;
    border: none;
  }
  & div:after {
    transition: ${transitions.base};
    box-shadow: inset 0 1px 0 rgb(${colors.grey}),
      0px 2px 2px 1px rgba(${colors.black}, 0.2);
    border-radius: 1rem;
    left: ${({ active }) => (active ? `20px` : `0`)};
    content: "";
    position: absolute;
    width: 24px;
    height: 24px;
    cursor: pointer;
    background-color: rgb(${colors.white});
  }
`;

interface IToggleProps extends IToggleStyleProps {
  onClick?: any;
}

const Toggle = (props: IToggleProps) => (
  <SToggle color={props.color} active={props.active} onClick={props.onClick}>
    <div />
  </SToggle>
);

Toggle.propTypes = {
  active: PropTypes.bool,
  color: PropTypes.string,
  onClick: PropTypes.func,
};

Toggle.defaultProps = {
  active: false,
  color: "green",
};

export default Toggle;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Wrapper.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled, { keyframes } from "styled-components";

const fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

interface WrapperStyleProps {
  center: boolean;
}

const SWrapper = styled.div<WrapperStyleProps>`
  will-change: transform, opacity;
  animation: ${fadeIn} 0.7s ease 0s normal 1;
  min-height: 200px;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: ${({ center }) => (center ? `center` : `flex-start`)};
`;

interface WrapperProps extends WrapperStyleProps {
  children: React.ReactNode;
}

const Wrapper = (props: WrapperProps) => {
  const { children, center } = props;
  return (
    <SWrapper {...props} center={center}>
      {children}
    </SWrapper>
  );
};

Wrapper.propTypes = {
  children: PropTypes.node.isRequired,
  center: PropTypes.bool,
};

Wrapper.defaultProps = {
  center: false,
};

export default Wrapper;
</file>

<file path="advanced/dapps/react-dapp-v2/src/constants/default.ts">
import { getAppMetadata } from "@walletconnect/utils";

if (!process.env.NEXT_PUBLIC_PROJECT_ID)
  throw new Error("`NEXT_PUBLIC_PROJECT_ID` env variable is missing.");

export const DEFAULT_MAIN_CHAINS = [
  // mainnets
  "eip155:1",
  "eip155:10",
  "eip155:100",
  "eip155:137",
  "eip155:324",
  "eip155:42161",
  "eip155:42220",
  "cosmos:cosmoshub-4",
  "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  "polkadot:91b171bb158e2d3848fa23a9f1c25182",
  "mvx:1",
  "tron:0x2b6653dc",
  "tezos:mainnet",
  "kadena:mainnet01",
  "bip122:000000000019d6689c085ae165831e93",
];

export const DEFAULT_TEST_CHAINS = [
  // testnets
  "eip155:5",
  "eip155:11155111",
  "eip155:280",
  "eip155:420",
  "eip155:80001",
  "eip155:421611",
  "eip155:44787",
  "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  "polkadot:e143f23803ac50e8f6f8e62695d1ce9e",
  "near:testnet",
  "mvx:D",
  "tron:0xcd8690dc",
  "tezos:testnet",
  "kadena:testnet04",
  "bip122:000000000933ea01ad0ee984209779ba",
];

export const DEFAULT_CHAINS = [...DEFAULT_MAIN_CHAINS, ...DEFAULT_TEST_CHAINS];

export const DEFAULT_PROJECT_ID = process.env.NEXT_PUBLIC_PROJECT_ID;
export const DEFAULT_RELAY_URL = process.env.NEXT_PUBLIC_RELAY_URL;

export const DEFAULT_LOGGER = "debug";

export const DEFAULT_APP_METADATA = {
  name: "React App",
  description: "React App for WalletConnect",
  url: "https://walletconnect.com/",
  icons: ["https://avatars.githubusercontent.com/u/37784886"],
  verifyUrl: "https://verify.walletconnect.com",
};

/**
 * EIP5792
 */
export const DEFAULT_EIP5792_METHODS = {
  WALLET_GET_CAPABILITIES: "wallet_getCapabilities",
  WALLET_SEND_CALLS: "wallet_sendCalls",
  WALLET_GET_CALLS_STATUS: "wallet_getCallsStatus",
} as const;

export type SendCallsParams = {
  version: string;
  chainId: `0x${string}`; // Hex chain id
  from: `0x${string}`;
  calls: {
    to?: `0x${string}` | undefined;
    data?: `0x${string}` | undefined;
    value?: `0x${string}` | undefined; // Hex value
  }[];
  capabilities?: Record<string, any> | undefined;
};

// capability names as string literals
export type CapabilityName = "atomicBatch" | "paymasterService" | "sessionKey";
// Capability type where each key is a capability name and value has `supported` field
export type Capabilities = {
  [K in CapabilityName]: {
    supported: boolean;
  };
};
// GetCapabilitiesResult type using mapped types
export type GetCapabilitiesResult = Record<string, Capabilities>;

export type GetCallsResult = {
  status: "PENDING" | "CONFIRMED";
  receipts?: {
    logs: {
      address: `0x${string}`;
      data: `0x${string}`;
      topics: `0x${string}`[];
    }[];
    status: `0x${string}`; // Hex 1 or 0 for success or failure, respectively
    blockHash: `0x${string}`;
    blockNumber: `0x${string}`;
    gasUsed: `0x${string}`;
    transactionHash: `0x${string}`;
  }[];
};
/**
 * EIP7715
 */
export const DEFAULT_EIP7715_METHODS = {
  WALLET_GRANT_PERMISSIONS: "wallet_grantPermissions",
} as const;
export type WalletGrantPermissionsParameters = {
  signer?:
    | {
        type: string;
        data?: unknown | undefined;
      }
    | undefined;
  permissions: readonly {
    data: unknown;
    policies: readonly {
      data: unknown;
      type: string;
    }[];
    required?: boolean | undefined;
    type: string;
  }[];
  expiry: number;
};

export type WalletGrantPermissionsReturnType = {
  expiry: number;
  factory?: `0x${string}` | undefined;
  factoryData?: string | undefined;
  grantedPermissions: readonly {
    data: unknown;
    policies: readonly {
      data: unknown;
      type: string;
    }[];
    required?: boolean | undefined;
    type: string;
  }[];
  permissionsContext: string;
  signerData?:
    | {
        userOpBuilder?: `0x${string}` | undefined;
        submitToAddress?: `0x${string}` | undefined;
      }
    | undefined;
};
/**
 * EIP155
 */
export const DEFAULT_EIP155_METHODS = {
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  PERSONAL_SIGN: "personal_sign",
};

export const DEFAULT_EIP155_OPTIONAL_METHODS = {
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
} as const;

export const DEFAULT_OPTIONAL_METHODS = {
  ...DEFAULT_EIP155_OPTIONAL_METHODS,
  ...DEFAULT_EIP5792_METHODS,
  ...DEFAULT_EIP7715_METHODS,
};

export enum DEFAULT_EIP_155_EVENTS {
  ETH_CHAIN_CHANGED = "chainChanged",
  ETH_ACCOUNTS_CHANGED = "accountsChanged",
}

/**
 * COSMOS
 */
export enum DEFAULT_COSMOS_METHODS {
  COSMOS_SIGN_DIRECT = "cosmos_signDirect",
  COSMOS_SIGN_AMINO = "cosmos_signAmino",
}

export enum DEFAULT_COSMOS_EVENTS {}

/**
 * SOLANA
 */
export enum DEFAULT_SOLANA_METHODS {
  SOL_SIGN_TRANSACTION = "solana_signTransaction",
  SOL_SIGN_MESSAGE = "solana_signMessage",
  SOL_SIGN_AND_SEND_TRANSACTION = "solana_signAndSendTransaction",
  SOL_SIGN_ALL_TRANSACTIONS = "solana_signAllTransactions",
}

export enum DEFAULT_SOLANA_EVENTS {}

/**
 * POLKADOT
 */
export enum DEFAULT_POLKADOT_METHODS {
  POLKADOT_SIGN_TRANSACTION = "polkadot_signTransaction",
  POLKADOT_SIGN_MESSAGE = "polkadot_signMessage",
}

export enum DEFAULT_POLKADOT_EVENTS {}

/**
 * NEAR
 */
export enum DEFAULT_NEAR_METHODS {
  NEAR_SIGN_IN = "near_signIn",
  NEAR_SIGN_OUT = "near_signOut",
  NEAR_GET_ACCOUNTS = "near_getAccounts",
  NEAR_SIGN_AND_SEND_TRANSACTION = "near_signAndSendTransaction",
  NEAR_SIGN_AND_SEND_TRANSACTIONS = "near_signAndSendTransactions",
}

export enum DEFAULT_NEAR_EVENTS {}

/**
 * MULTIVERSX
 */
export enum DEFAULT_MULTIVERSX_METHODS {
  MULTIVERSX_SIGN_TRANSACTION = "mvx_signTransaction",
  MULTIVERSX_SIGN_TRANSACTIONS = "mvx_signTransactions",
  MULTIVERSX_SIGN_MESSAGE = "mvx_signMessage",
  MULTIVERSX_SIGN_LOGIN_TOKEN = "mvx_signLoginToken",
  MULTIVERSX_SIGN_NATIVE_AUTH_TOKEN = "mvx_signNativeAuthToken",
  MULTIVERSX_CANCEL_ACTION = "mvx_cancelAction",
}

export enum DEFAULT_MULTIVERSX_EVENTS {}

/**
 * TRON
 */
export enum DEFAULT_TRON_METHODS {
  TRON_SIGN_TRANSACTION = "tron_signTransaction",
  TRON_SIGN_MESSAGE = "tron_signMessage",
}

export enum DEFAULT_TRON_EVENTS {}

/**
 * TEZOS
 */
export enum DEFAULT_TEZOS_METHODS {
  TEZOS_GET_ACCOUNTS = "tezos_getAccounts",
  TEZOS_SEND = "tezos_send",
  TEZOS_SIGN = "tezos_sign",
}

export enum DEFAULT_TEZOS_EVENTS {}

export const DEFAULT_GITHUB_REPO_URL =
  "https://github.com/WalletConnect/web-examples/tree/main/dapps/react-dapp-v2";

type RelayerType = {
  value: string | undefined;
  label: string;
};

/**
 * KADENA
 */
export enum DEFAULT_KADENA_METHODS {
  KADENA_GET_ACCOUNTS = "kadena_getAccounts_v1",
  KADENA_SIGN = "kadena_sign_v1",
  KADENA_QUICKSIGN = "kadena_quicksign_v1",
}

export enum DEFAULT_KADENA_EVENTS {}
/**
 * BITCOIN
 */
export enum DEFAULT_BIP122_METHODS {
  BIP122_SEND_TRANSACTION = "sendTransfer",
  BIP122_GET_ACCOUNT_ADDRESSES = "getAccountAddresses",
  BIP122_SIGN_MESSAGE = "signMessage",
  BIP122_SIGN_PSBT = "signPsbt",
}
export enum DEFAULT_BIP122_EVENTS {
  BIP122_ADDRESS_CHANGED = "bip122_addressesChanged",
}

export const REGIONALIZED_RELAYER_ENDPOINTS: RelayerType[] = [
  {
    value: DEFAULT_RELAY_URL,
    label: "Default",
  },

  {
    value: "wss://us-east-1.relay.walletconnect.com",
    label: "US",
  },
  {
    value: "wss://eu-central-1.relay.walletconnect.com",
    label: "EU",
  },
  {
    value: "wss://ap-southeast-1.relay.walletconnect.com",
    label: "Asia Pacific",
  },
];

export const ORIGIN_OPTIONS = [
  {
    value: getAppMetadata().url,
    label: "VALID",
  },
  {
    value: "https://invalid.origin",
    label: "INVALID",
  },
  {
    value: "unknown",
    label: "UNKNOWN",
  },
];
</file>

<file path="advanced/dapps/react-dapp-v2/src/constants/index.ts">
export * from "./default";
</file>

<file path="advanced/dapps/react-dapp-v2/src/contexts/ChainDataContext.tsx">
import {
  createContext,
  ReactNode,
  useContext,
  useEffect,
  useState,
} from "react";
import { SolanaChainData } from "../chains/solana";
import { PolkadotChainData } from "../chains/polkadot";
import { MultiversxChainData } from "../chains/multiversx";
import { TronChainData } from "../chains/tron";

import { ChainNamespaces, ChainsMap, getAllChainNamespaces } from "../helpers";
import { NearChainData } from "../chains/near";
import { CosmosChainData } from "../chains/cosmos";
import { EIP155ChainData } from "../chains/eip155";
import { TezosChainData } from "../chains/tezos";
import { KadenaChainData } from "../chains/kadena";
import { BtcChainData } from "../chains/bip122";

/**
 * Types
 */
interface IContext {
  chainData: ChainNamespaces;
}

/**
 * Context
 */
export const ChainDataContext = createContext<IContext>({} as IContext);

/**
 * Provider
 */
export function ChainDataContextProvider({
  children,
}: {
  children: ReactNode | ReactNode[];
}) {
  const [chainData, setChainData] = useState<ChainNamespaces>({});

  const loadChainData = async () => {
    const namespaces = getAllChainNamespaces();
    const chainData: ChainNamespaces = {};
    await Promise.all(
      namespaces.map(async (namespace) => {
        let chains: ChainsMap | undefined;
        switch (namespace) {
          case "solana":
            chains = SolanaChainData;
            break;
          case "polkadot":
            chains = PolkadotChainData;
            break;
          case "near":
            chains = NearChainData;
            break;
          case "mvx":
            chains = MultiversxChainData;
            break;
          case "tron":
            chains = TronChainData;
            break;
          case "cosmos":
            chains = CosmosChainData;
            break;
          case "eip155":
            chains = EIP155ChainData;
            break;
          case "tezos":
            chains = TezosChainData;
            break;
          case "kadena":
            chains = KadenaChainData;
            break;
          case "bip122":
            chains = BtcChainData;
            break;
          default:
            console.error("Unknown chain namespace: ", namespace);
        }

        if (typeof chains !== "undefined") {
          chainData[namespace] = chains;
        }
      })
    );

    setChainData(chainData);
  };

  useEffect(() => {
    loadChainData();
  }, []);

  return (
    <ChainDataContext.Provider
      value={{
        chainData,
      }}
    >
      {children}
    </ChainDataContext.Provider>
  );
}

export function useChainData() {
  const context = useContext(ChainDataContext);
  if (context === undefined) {
    throw new Error(
      "useChainData must be used within a ChainDataContextProvider"
    );
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/contexts/ClientContext.tsx">
import Client from "@walletconnect/sign-client";
import { PairingTypes, SessionTypes } from "@walletconnect/types";
import { Web3Modal } from "@web3modal/standalone";
import { RELAYER_EVENTS } from "@walletconnect/core";
import toast from "react-hot-toast";

import { PublicKey } from "@solana/web3.js";
import {
  createContext,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { getAppMetadata, getSdkError } from "@walletconnect/utils";
import {
  DEFAULT_APP_METADATA,
  DEFAULT_LOGGER,
  DEFAULT_PROJECT_ID,
  DEFAULT_RELAY_URL,
} from "../constants";
import { AccountBalances, apiGetAccountBalance } from "../helpers";
import {
  getOptionalNamespaces,
  getRequiredNamespaces,
} from "../helpers/namespaces";
import { getPublicKeysFromAccounts } from "../helpers/solana";

/**
 * Types
 */
interface IContext {
  client: Client | undefined;
  session: SessionTypes.Struct | undefined;
  connect: (pairing?: { topic: string }) => Promise<void>;
  disconnect: () => Promise<void>;
  isInitializing: boolean;
  chains: string[];
  relayerRegion: string;
  pairings: PairingTypes.Struct[];
  accounts: string[];
  solanaPublicKeys?: Record<string, PublicKey>;
  balances: AccountBalances;
  isFetchingBalances: boolean;
  setChains: any;
  setRelayerRegion: any;
  origin: string;
  setAccounts: any;
}

/**
 * Context
 */
export const ClientContext = createContext<IContext>({} as IContext);

/**
 * Web3Modal Config
 */
const web3Modal = new Web3Modal({
  projectId: DEFAULT_PROJECT_ID,
  themeMode: "light",
  walletConnectVersion: 2,
  mobileWallets: [
    {
      id: "bifrost",
      name: "Bifrost Wallet",
      links: {
        native: "bifrostwallet://",
        universal: "https://bifrostwallet.com",
      },
    },
  ],
});

/**
 * Provider
 */
export function ClientContextProvider({
  children,
}: {
  children: ReactNode | ReactNode[];
}) {
  const [client, setClient] = useState<Client>();
  const [pairings, setPairings] = useState<PairingTypes.Struct[]>([]);
  const [session, setSession] = useState<SessionTypes.Struct>();

  const [isFetchingBalances, setIsFetchingBalances] = useState(false);
  const [isInitializing, setIsInitializing] = useState(false);
  const prevRelayerValue = useRef<string>("");

  const [balances, setBalances] = useState<AccountBalances>({});
  const [accounts, setAccounts] = useState<string[]>([]);
  const [solanaPublicKeys, setSolanaPublicKeys] =
    useState<Record<string, PublicKey>>();
  const [chains, setChains] = useState<string[]>([]);
  const [relayerRegion, setRelayerRegion] = useState<string>(
    DEFAULT_RELAY_URL!
  );
  const [origin, setOrigin] = useState<string>(getAppMetadata().url);
  const reset = () => {
    setSession(undefined);
    setBalances({});
    setAccounts([]);
    setChains([]);
    setRelayerRegion(DEFAULT_RELAY_URL!);
  };

  const getAccountBalances = async (_accounts: string[]) => {
    setIsFetchingBalances(true);
    try {
      const arr = await Promise.all(
        _accounts.map(async (account) => {
          const [namespace, reference, address] = account.split(":");
          const chainId = `${namespace}:${reference}`;
          const assets = await apiGetAccountBalance(address, chainId);
          return { account, assets: [assets] };
        })
      );

      const balances: AccountBalances = {};
      arr.forEach(({ account, assets }) => {
        balances[account] = assets;
      });
      setBalances(balances);
    } catch (e) {
      console.error(e);
    } finally {
      setIsFetchingBalances(false);
    }
  };

  useMemo(() => {
    if (!accounts.length) return;
    getAccountBalances(accounts);
  }, [accounts]);

  const onSessionConnected = useCallback(
    async (_session: SessionTypes.Struct) => {
      const allNamespaceAccounts = Object.values(_session.namespaces)
        .map((namespace) => namespace.accounts)
        .flat();
      const allNamespaceChains = Object.keys(_session.namespaces);

      setSession(_session);
      setChains(allNamespaceChains);
      setAccounts(allNamespaceAccounts);
      setSolanaPublicKeys(getPublicKeysFromAccounts(allNamespaceAccounts));

      await getAccountBalances(allNamespaceAccounts);
    },
    []
  );

  const connect = useCallback(
    async (pairing: any) => {
      if (typeof client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }
      console.log("connect, pairing topic is:", pairing?.topic);
      try {
        const namespacesToRequest = getRequiredNamespaces(chains);
        const { uri, approval } = await client.connect({
          pairingTopic: pairing?.topic,
          requiredNamespaces: {},
          optionalNamespaces: namespacesToRequest,
        });

        // Open QRCode modal if a URI was returned (i.e. we're not connecting an existing pairing).
        if (uri) {
          // Create a flat array of all requested chains across namespaces.
          const standaloneChains = Object.values(namespacesToRequest)
            .map((namespace) => namespace.chains)
            .flat() as string[];

          web3Modal.openModal({ uri, standaloneChains });
        }

        const session = await approval();
        console.log("Established session:", session);
        await onSessionConnected(session);
        // Update known pairings after session is connected.
        setPairings(client.pairing.getAll({ active: true }));
      } catch (e) {
        console.error(e);
        toast.error((e as Error).message, {
          position: "bottom-left",
        });
        throw e;
      } finally {
        // close modal in case it was open
        web3Modal.closeModal();
      }
    },
    [chains, client, onSessionConnected]
  );

  const disconnect = useCallback(async () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    if (typeof session === "undefined") {
      throw new Error("Session is not connected");
    }

    await client.disconnect({
      topic: session.topic,
      reason: getSdkError("USER_DISCONNECTED"),
    });

    // Reset app state after disconnect.
    reset();
  }, [client, session]);

  const _subscribeToEvents = useCallback(
    async (_client: Client) => {
      if (typeof _client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }

      _client.on("session_ping", (args) => {
        console.log("EVENT", "session_ping", args);
      });

      _client.on("session_event", (args) => {
        console.log("EVENT", "session_event", args);
      });

      _client.on("session_update", ({ topic, params }) => {
        console.log("EVENT", "session_update", { topic, params });
        const { namespaces } = params;
        const _session = _client.session.get(topic);
        const updatedSession = { ..._session, namespaces };
        onSessionConnected(updatedSession);
      });

      _client.on("session_delete", () => {
        console.log("EVENT", "session_delete");
        reset();
      });
    },
    [onSessionConnected]
  );

  const _checkPersistedState = useCallback(
    async (_client: Client) => {
      if (typeof _client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }
      // populates existing pairings to state
      setPairings(_client.pairing.getAll({ active: true }));
      console.log(
        "RESTORED PAIRINGS: ",
        _client.pairing.getAll({ active: true })
      );

      if (typeof session !== "undefined") return;
      // populates (the last) existing session to state
      if (_client.session.length) {
        const lastKeyIndex = _client.session.keys.length - 1;
        const _session = _client.session.get(
          _client.session.keys[lastKeyIndex]
        );
        console.log("RESTORED SESSION:", _session);
        await onSessionConnected(_session);
        return _session;
      }
    },
    [session, onSessionConnected]
  );

  const _logClientId = useCallback(async (_client: Client) => {
    if (typeof _client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    try {
      const clientId = await _client.core.crypto.getClientId();
      console.log("WalletConnect ClientID: ", clientId);
      localStorage.setItem("WALLETCONNECT_CLIENT_ID", clientId);
    } catch (error) {
      console.error(
        "Failed to set WalletConnect clientId in localStorage: ",
        error
      );
    }
  }, []);

  const createClient = useCallback(async () => {
    try {
      setIsInitializing(true);
      const claimedOrigin =
        localStorage.getItem("wallet_connect_dapp_origin") || origin;
      const _client = await Client.init({
        logger: DEFAULT_LOGGER,
        relayUrl: relayerRegion,
        projectId: DEFAULT_PROJECT_ID,
        metadata: {
          name: "React App",
          description: "App to test WalletConnect network",
          url: claimedOrigin,
          icons: [],
        },
      });
      if (claimedOrigin === "unknown") {
        //@ts-expect-error - private property
        _client.core.verify.verifyUrlV3 = "0xdeafbeef";
        console.log("verify", _client.core.verify);
      }
      setClient(_client);
      setOrigin(_client.metadata.url);
      console.log("metadata url:", _client.metadata);

      prevRelayerValue.current = relayerRegion;
      await _subscribeToEvents(_client);
      await _checkPersistedState(_client);
      await _logClientId(_client);
    } catch (err) {
      throw err;
    } finally {
      setIsInitializing(false);
    }
  }, [
    _checkPersistedState,
    _subscribeToEvents,
    _logClientId,
    relayerRegion,
    origin,
  ]);

  useEffect(() => {
    const claimedOrigin =
      localStorage.getItem("wallet_connect_dapp_origin") || origin;
    console.log("claimedOrigin:", claimedOrigin);
    let interval: NodeJS.Timer;
    // simulates `UNKNOWN` validation by removing the verify iframe thus preventing POST message
    if (claimedOrigin === "unknown") {
      //The interval is needed as Verify tries to init new iframe(with different urls) multiple times
      interval = setInterval(
        () => document.getElementById("verify-api")?.remove(),
        500
      );
    }
    return () => {
      clearInterval(interval);
    };
  }, [origin]);

  useEffect(() => {
    if (!client) {
      createClient();
    } else if (
      prevRelayerValue.current &&
      prevRelayerValue.current !== relayerRegion
    ) {
      client.core.relayer.restartTransport(relayerRegion);
      prevRelayerValue.current = relayerRegion;
    }
  }, [createClient, relayerRegion, client]);

  useEffect(() => {
    if (!client) return;
    client.core.relayer.on(RELAYER_EVENTS.connect, () => {
      toast.success("Network connection is restored!", {
        position: "bottom-left",
      });
    });

    client.core.relayer.on(RELAYER_EVENTS.disconnect, () => {
      toast.error("Network connection lost.", {
        position: "bottom-left",
      });
    });
  }, [client]);

  const value = useMemo(
    () => ({
      pairings,
      isInitializing,
      balances,
      isFetchingBalances,
      accounts,
      solanaPublicKeys,
      chains,
      relayerRegion,
      client,
      session,
      connect,
      disconnect,
      setChains,
      setRelayerRegion,
      origin,
      setAccounts,
    }),
    [
      pairings,
      isInitializing,
      balances,
      isFetchingBalances,
      accounts,
      solanaPublicKeys,
      chains,
      relayerRegion,
      client,
      session,
      connect,
      disconnect,
      setChains,
      setRelayerRegion,
      origin,
      setAccounts,
    ]
  );

  return (
    <ClientContext.Provider
      value={{
        ...value,
      }}
    >
      {children}
    </ClientContext.Provider>
  );
}

export function useWalletConnectClient() {
  const context = useContext(ClientContext);
  if (context === undefined) {
    throw new Error(
      "useWalletConnectClient must be used within a ClientContextProvider"
    );
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/contexts/JsonRpcContext.tsx">
import { BigNumber, utils } from "ethers";
import { createContext, ReactNode, useContext, useState } from "react";
import * as encoding from "@walletconnect/encoding";
import { Transaction as EthTransaction } from "@ethereumjs/tx";
import { recoverTransaction } from "@celo/wallet-base";
import * as bitcoin from "bitcoinjs-lib";

import {
  formatDirectSignDoc,
  stringifySignDocValues,
  verifyAminoSignature,
  verifyDirectSignature,
} from "cosmos-wallet";
import bs58 from "bs58";
import { verifyMessageSignature } from "solana-wallet";
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction as SolanaTransaction,
  clusterApiUrl,
} from "@solana/web3.js";
// @ts-expect-error
import TronWeb from "tronweb";
import {
  IPactCommand,
  PactCommand,
  createWalletConnectQuicksign,
  createWalletConnectSign,
} from "@kadena/client";
import { PactNumber } from "@kadena/pactjs";
import {
  IUTXO,
  KadenaAccount,
  eip712,
  formatTestBatchCall,
  formatTestTransaction,
  getLocalStorageTestnetFlag,
  getProviderUrl,
  hashPersonalMessage,
  hashTypedDataMessage,
  verifySignature,
} from "../helpers";
import { useWalletConnectClient } from "./ClientContext";
import {
  DEFAULT_COSMOS_METHODS,
  DEFAULT_EIP155_METHODS,
  DEFAULT_SOLANA_METHODS,
  DEFAULT_POLKADOT_METHODS,
  DEFAULT_NEAR_METHODS,
  DEFAULT_MULTIVERSX_METHODS,
  DEFAULT_TRON_METHODS,
  DEFAULT_TEZOS_METHODS,
  DEFAULT_KADENA_METHODS,
  DEFAULT_EIP155_OPTIONAL_METHODS,
  DEFAULT_EIP5792_METHODS,
  SendCallsParams,
  GetCapabilitiesResult,
  GetCallsResult,
  DEFAULT_BIP122_METHODS,
  DEFAULT_EIP7715_METHODS,
  WalletGrantPermissionsParameters,
  WalletGrantPermissionsReturnType,
} from "../constants";
import { useChainData } from "./ChainDataContext";
import { rpcProvidersByChainId } from "../../src/helpers/api";
import { signatureVerify, cryptoWaitReady } from "@polkadot/util-crypto";

import {
  Transaction as MultiversxTransaction,
  TransactionPayload,
  Address,
  SignableMessage,
} from "@multiversx/sdk-core";
import { UserVerifier } from "@multiversx/sdk-wallet/out/userVerifier";
import { parseEther } from "ethers/lib/utils";
import {
  apiGetAddressUtxos,
  calculateChange,
  getAvailableBalanceFromUtxos,
  isBip122Testnet,
  isOrdinalAddress,
  isValidBip122Signature,
} from "../helpers/bip122";
import { getAddressFromAccount } from "@walletconnect/utils";
import { BIP122_DUST_LIMIT } from "../chains/bip122";

/**
 * Types
 */
interface IFormattedRpcResponse {
  method?: string;
  address?: string;
  valid: boolean;
  result: string;
}

type TRpcRequestCallback = (
  chainId: string,
  address: string,
  message?: string
) => Promise<void>;

interface IContext {
  ping: () => Promise<void>;
  ethereumRpc: {
    testSendTransaction: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
    testEthSign: TRpcRequestCallback;
    testSignPersonalMessage: TRpcRequestCallback;
    testSignTypedData: TRpcRequestCallback;
    testSignTypedDatav4: TRpcRequestCallback;
    testWalletGetCapabilities: TRpcRequestCallback;
    testWalletSendCalls: TRpcRequestCallback;
    testWalletGrantPermissions: TRpcRequestCallback;
    testWalletGetCallsStatus: TRpcRequestCallback;
  };
  cosmosRpc: {
    testSignDirect: TRpcRequestCallback;
    testSignAmino: TRpcRequestCallback;
  };
  solanaRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  polkadotRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  nearRpc: {
    testSignAndSendTransaction: TRpcRequestCallback;
    testSignAndSendTransactions: TRpcRequestCallback;
  };
  multiversxRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
    testSignTransactions: TRpcRequestCallback;
  };
  tronRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  tezosRpc: {
    testGetAccounts: TRpcRequestCallback;
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  kadenaRpc: {
    testGetAccounts: TRpcRequestCallback;
    testSign: TRpcRequestCallback;
    testQuicksign: TRpcRequestCallback;
  };
  bip122Rpc: {
    testGetAccountAddresses: TRpcRequestCallback;
    testSignMessage: TRpcRequestCallback;
    testSendTransaction: TRpcRequestCallback;
    testSignPsbt: TRpcRequestCallback;
  };
  rpcResult?: IFormattedRpcResponse | null;
  isRpcRequestPending: boolean;
  isTestnet: boolean;
  setIsTestnet: (isTestnet: boolean) => void;
}

/**
 * Context
 */
export const JsonRpcContext = createContext<IContext>({} as IContext);

/**
 * Provider
 */
export function JsonRpcContextProvider({
  children,
}: {
  children: ReactNode | ReactNode[];
}) {
  const [pending, setPending] = useState(false);
  const [result, setResult] = useState<IFormattedRpcResponse | null>();
  const [isTestnet, setIsTestnet] = useState(getLocalStorageTestnetFlag());
  const [lastTxId, setLastTxId] = useState<`0x${string}`>();
  const [kadenaAccount, setKadenaAccount] = useState<KadenaAccount | null>(
    null
  );

  const { client, session, accounts, balances, solanaPublicKeys, setAccounts } =
    useWalletConnectClient();

  const { chainData } = useChainData();

  const _createJsonRpcRequestHandler =
    (
      rpcRequest: (
        chainId: string,
        address: string
      ) => Promise<IFormattedRpcResponse>
    ) =>
    async (chainId: string, address: string) => {
      if (typeof client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }
      if (typeof session === "undefined") {
        throw new Error("Session is not connected");
      }

      try {
        setPending(true);
        const result = await rpcRequest(chainId, address);
        setResult(result);
      } catch (err: any) {
        console.error("RPC request failed: ", err);
        setResult({
          address,
          valid: false,
          result: err?.message ?? err,
        });
      } finally {
        setPending(false);
      }
    };

  const _verifyEip155MessageSignature = (
    message: string,
    signature: string,
    address: string
  ) =>
    utils.verifyMessage(message, signature).toLowerCase() ===
    address.toLowerCase();

  const ping = async () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    if (typeof session === "undefined") {
      throw new Error("Session is not connected");
    }

    try {
      setPending(true);

      let valid = false;

      try {
        await client.ping({ topic: session.topic });
        valid = true;
      } catch (e) {
        valid = false;
      }

      // display result
      setResult({
        method: "ping",
        valid,
        result: valid ? "Ping succeeded" : "Ping failed",
      });
    } catch (e) {
      console.error(e);
      setResult(null);
    } finally {
      setPending(false);
    }
  };

  // -------- ETHEREUM/EIP155 RPC METHODS --------

  const ethereumRpc = {
    testSendTransaction: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);

        const tx = await formatTestTransaction(account);

        const balance = BigNumber.from(balances[account][0].balance || "0");
        if (balance.lt(BigNumber.from(tx.gasPrice).mul(tx.gasLimit))) {
          return {
            method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
            address,
            valid: false,
            result: "Insufficient funds for intrinsic transaction cost",
          };
        }

        const result = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
            params: [tx],
          },
        });

        // format displayed result
        return {
          method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
          address,
          valid: true,
          result,
        };
      }
    ),
    testSignTransaction: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);

        const tx = await formatTestTransaction(account);

        const signedTx = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION,
            params: [tx],
          },
        });

        const CELO_ALFAJORES_CHAIN_ID = 44787;
        const CELO_MAINNET_CHAIN_ID = 42220;

        let valid = false;
        const [, reference] = chainId.split(":");
        if (
          reference === CELO_ALFAJORES_CHAIN_ID.toString() ||
          reference === CELO_MAINNET_CHAIN_ID.toString()
        ) {
          const [, signer] = recoverTransaction(signedTx);
          valid = signer.toLowerCase() === address.toLowerCase();
        } else {
          valid = EthTransaction.fromSerializedTx(
            signedTx as any
          ).verifySignature();
        }

        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION,
          address,
          valid,
          result: signedTx,
        };
      }
    ),
    testSignPersonalMessage: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // test message
        const message = `My email is john@doe.com - ${Date.now()}`;

        // encode message (hex)
        const hexMsg = encoding.utf8ToHex(message, true);
        // personal_sign params
        const params = [hexMsg, address];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_METHODS.PERSONAL_SIGN,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashMsg = hashPersonalMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashMsg,
          rpc.baseURL
        );

        // format displayed result
        return {
          method: DEFAULT_EIP155_METHODS.PERSONAL_SIGN,
          address,
          valid,
          result: signature,
        };
      }
    ),
    testEthSign: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // test message
        const message = `My email is john@doe.com - ${Date.now()}`;
        // encode message (hex)
        const hexMsg = encoding.utf8ToHex(message, true);
        // eth_sign params
        const params = [address, hexMsg];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashMsg = hashPersonalMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashMsg,
          rpc.baseURL
        );

        // format displayed result
        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN + " (standard)",
          address,
          valid,
          result: signature,
        };
      }
    ),
    testSignTypedData: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const message = JSON.stringify(eip712.example);

        // eth_signTypedData params
        const params = [address, message];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashedTypedData = hashTypedDataMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashedTypedData,
          rpc.baseURL
        );

        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
          address,
          valid,
          result: signature,
        };
      }
    ),
    testSignTypedDatav4: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const message = JSON.stringify(eip712.example);
        console.log("eth_signTypedData_v4");

        // eth_signTypedData_v4 params
        const params = [address, message];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA_V4,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashedTypedData = hashTypedDataMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashedTypedData,
          rpc.baseURL
        );

        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
          address,
          valid,
          result: signature,
        };
      }
    ),
    testWalletGetCapabilities: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        // The wallet_getCapabilities "caching" should ultimately move into the provider.
        // check the session.sessionProperties first for capabilities
        const capabilitiesJson = session?.sessionProperties?.["capabilities"];
        const walletCapabilities =
          capabilitiesJson && JSON.parse(capabilitiesJson);
        let capabilities = walletCapabilities[address] as
          | GetCapabilitiesResult
          | undefined;
        // send request for wallet_getCapabilities
        if (!capabilities)
          capabilities = await client!.request<GetCapabilitiesResult>({
            topic: session!.topic,
            chainId,
            request: {
              method: DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES,
              params: [address],
            },
          });

        // format displayed result
        return {
          method: DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES,
          address,
          valid: true,
          result: JSON.stringify(capabilities),
        };
      }
    ),
    testWalletGetCallsStatus: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }
        if (lastTxId === undefined)
          throw new Error(
            `Last transaction ID is undefined, make sure previous call to sendCalls returns successfully. `
          );
        const params = [lastTxId];
        // send request for wallet_getCallsStatus
        const getCallsStatusResult = await client!.request<GetCallsResult>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS,
            params: params,
          },
        });

        // format displayed result
        return {
          method: DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS,
          address,
          valid: true,
          result: JSON.stringify(getCallsStatusResult),
        };
      }
    ),
    testWalletSendCalls: _createJsonRpcRequestHandler(
      //Sample test call - batch multiple native send tx

      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);

        const balance = BigNumber.from(balances[account][0].balance || "0");
        if (balance.lt(parseEther("0.0002"))) {
          return {
            method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
            address,
            valid: false,
            result:
              "Insufficient funds for batch call [minimum 0.0002ETH required excluding gas].",
          };
        }
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];
        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }
        const sendCallsRequestParams: SendCallsParams =
          await formatTestBatchCall(account);
        // send batch Tx
        const txId = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
            params: [sendCallsRequestParams],
          },
        });
        // store the last transactionId to use it for wallet_getCallsReceipt
        setLastTxId(
          txId && txId.startsWith("0x") ? (txId as `0x${string}`) : undefined
        );
        // format displayed result
        return {
          method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
          address,
          valid: true,
          result: txId,
        };
      }
    ),
    testWalletGrantPermissions: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];
        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }
        const walletGrantPermissionsParameters: WalletGrantPermissionsParameters =
          {
            signer: {
              type: "key",
              data: {
                id: "0xc3cE257B5e2A2ad92747dd486B38d7b4B36Ac7C9",
              },
            },
            permissions: [
              {
                type: "native-token-limit",
                data: {
                  amount: parseEther("0.5"),
                },
                policies: [],
                required: true,
              },
            ],

            expiry: 1716846083638,
          } as WalletGrantPermissionsParameters;
        // send wallet_grantPermissions rpc request
        const issuePermissionResponse =
          await client!.request<WalletGrantPermissionsReturnType>({
            topic: session!.topic,
            chainId,
            request: {
              method: DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS,
              params: [walletGrantPermissionsParameters],
            },
          });

        // format displayed result
        return {
          method: DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS,
          address,
          valid: true,
          result: JSON.stringify(issuePermissionResponse),
        };
      }
    ),
  };

  // -------- COSMOS RPC METHODS --------

  const cosmosRpc = {
    testSignDirect: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // test direct sign doc inputs
        const inputs = {
          fee: [{ amount: "2000", denom: "ucosm" }],
          pubkey: "AgSEjOuOr991QlHCORRmdE5ahVKeyBrmtgoYepCpQGOW",
          gasLimit: 200000,
          accountNumber: 1,
          sequence: 1,
          bodyBytes:
            "0a90010a1c2f636f736d6f732e62616e6b2e763162657461312e4d736753656e6412700a2d636f736d6f7331706b707472653766646b6c366766727a6c65736a6a766878686c63337234676d6d6b38727336122d636f736d6f7331717970717870713971637273737a673270767871367273307a716733797963356c7a763778751a100a0575636f736d120731323334353637",
          authInfoBytes:
            "0a500a460a1f2f636f736d6f732e63727970746f2e736563703235366b312e5075624b657912230a21034f04181eeba35391b858633a765c4a0c189697b40d216354d50890d350c7029012040a020801180112130a0d0a0575636f736d12043230303010c09a0c",
        };

        // split chainId
        const [namespace, reference] = chainId.split(":");

        // format sign doc
        const signDoc = formatDirectSignDoc(
          inputs.fee,
          inputs.pubkey,
          inputs.gasLimit,
          inputs.accountNumber,
          inputs.sequence,
          inputs.bodyBytes,
          reference
        );

        // cosmos_signDirect params
        const params = {
          signerAddress: address,
          signDoc: stringifySignDocValues(signDoc),
        };

        // send message
        const result = await client!.request<{ signature: string }>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_DIRECT,
            params,
          },
        });

        const targetChainData = chainData[namespace][reference];

        if (typeof targetChainData === "undefined") {
          throw new Error(`Missing chain data for chainId: ${chainId}`);
        }

        const valid = await verifyDirectSignature(
          address,
          result.signature,
          signDoc
        );

        // format displayed result
        return {
          method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_DIRECT,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
    testSignAmino: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // split chainId
        const [namespace, reference] = chainId.split(":");

        // test amino sign doc
        const signDoc = {
          msgs: [],
          fee: { amount: [], gas: "23" },
          chain_id: "foochain",
          memo: "hello, world",
          account_number: "7",
          sequence: "54",
        };

        // cosmos_signAmino params
        const params = { signerAddress: address, signDoc };

        // send message
        const result = await client!.request<{ signature: string }>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
            params,
          },
        });

        const targetChainData = chainData[namespace][reference];

        if (typeof targetChainData === "undefined") {
          throw new Error(`Missing chain data for chainId: ${chainId}`);
        }

        const valid = await verifyAminoSignature(
          address,
          result.signature,
          signDoc
        );

        // format displayed result
        return {
          method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
  };

  // -------- SOLANA RPC METHODS --------

  const solanaRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        if (!solanaPublicKeys) {
          throw new Error("Could not find Solana PublicKeys.");
        }

        const senderPublicKey = solanaPublicKeys[address];

        // rpc.walletconnect.com doesn't support solana testnet yet
        const connection = new Connection(
          isTestnet ? clusterApiUrl("testnet") : getProviderUrl(chainId)
        );

        // Using deprecated `getRecentBlockhash` over `getLatestBlockhash` here, since `mainnet-beta`
        // cluster only seems to support `connection.getRecentBlockhash` currently.
        const { blockhash } = await connection.getRecentBlockhash();

        const transaction = new SolanaTransaction({
          feePayer: senderPublicKey,
          recentBlockhash: blockhash,
        }).add(
          SystemProgram.transfer({
            fromPubkey: senderPublicKey,
            toPubkey: Keypair.generate().publicKey,
            lamports: 1,
          })
        );

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_SOLANA_METHODS.SOL_SIGN_TRANSACTION,
            params: {
              feePayer: transaction.feePayer!.toBase58(),
              recentBlockhash: transaction.recentBlockhash!,
              instructions: transaction.instructions.map((instruction) => ({
                programId: instruction.programId.toBase58(),
                keys: instruction.keys.map((key) => ({
                  ...key,
                  pubkey: key.pubkey.toBase58(),
                })),
                data: bs58.encode(instruction.data),
              })),
              partialSignatures: transaction.signatures.map((sign) => ({
                pubkey: sign.publicKey.toBase58(),
                signature: bs58.encode(sign.signature!),
              })),
              transaction: transaction
                .serialize({ verifySignatures: false })
                .toString("base64"),
            },
          },
        });

        // We only need `Buffer.from` here to satisfy the `Buffer` param type for `addSignature`.
        // The resulting `UInt8Array` is equivalent to just `bs58.decode(...)`.
        transaction.addSignature(
          senderPublicKey,
          Buffer.from(bs58.decode(result.signature))
        );

        const valid = transaction.verifySignatures();

        return {
          method: DEFAULT_SOLANA_METHODS.SOL_SIGN_TRANSACTION,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        if (!solanaPublicKeys) {
          throw new Error("Could not find Solana PublicKeys.");
        }

        const senderPublicKey = solanaPublicKeys[address];

        // Encode message to `UInt8Array` first via `TextEncoder` so we can pass it to `bs58.encode`.
        const message = bs58.encode(
          new TextEncoder().encode(
            `This is an example message to be signed - ${Date.now()}`
          )
        );

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_SOLANA_METHODS.SOL_SIGN_MESSAGE,
            params: {
              pubkey: senderPublicKey.toBase58(),
              message,
            },
          },
        });

        const valid = verifyMessageSignature(
          senderPublicKey.toBase58(),
          result.signature,
          message
        );

        return {
          method: DEFAULT_SOLANA_METHODS.SOL_SIGN_MESSAGE,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
  };

  // -------- POLKADOT RPC METHODS --------
  const polkadotRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const transactionPayload = {
          specVersion: "0x00002468",
          transactionVersion: "0x0000000e",
          address: `${address}`,
          blockHash:
            "0x554d682a74099d05e8b7852d19c93b527b5fae1e9e1969f6e1b82a2f09a14cc9",
          blockNumber: "0x00cb539c",
          era: "0xc501",
          genesisHash:
            "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e",
          method:
            "0x0001784920616d207369676e696e672074686973207472616e73616374696f6e21",
          nonce: "0x00000000",
          signedExtensions: [
            "CheckNonZeroSender",
            "CheckSpecVersion",
            "CheckTxVersion",
            "CheckGenesis",
            "CheckMortality",
            "CheckNonce",
            "CheckWeight",
            "ChargeTransactionPayment",
          ],
          tip: "0x00000000000000000000000000000000",
          version: 4,
        };

        const result = await client!.request<{
          payload: string;
          signature: string;
        }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_TRANSACTION,
            params: {
              address,
              transactionPayload,
            },
          },
        });

        return {
          method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_TRANSACTION,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const message = `This is an example message to be signed - ${Date.now()}`;

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_MESSAGE,
            params: {
              address,
              message,
            },
          },
        });

        // sr25519 signatures need to wait for WASM to load
        await cryptoWaitReady();
        const { isValid: valid } = signatureVerify(
          message,
          result.signature,
          address
        );

        return {
          method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_MESSAGE,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
  };

  // -------- NEAR RPC METHODS --------

  const nearRpc = {
    testSignAndSendTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTION;
        const result = await client!.request({
          topic: session!.topic,
          chainId,
          request: {
            method,
            params: {
              transaction: {
                signerId: address,
                receiverId: "guest-book.testnet",
                actions: [
                  {
                    type: "FunctionCall",
                    params: {
                      methodName: "addMessage",
                      args: { text: "Hello from Wallet Connect!" },
                      gas: "30000000000000",
                      deposit: "0",
                    },
                  },
                ],
              },
            },
          },
        });

        return {
          method,
          address,
          valid: true,
          result: JSON.stringify((result as any).transaction),
        };
      }
    ),
    testSignAndSendTransactions: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTIONS;
        const result = await client!.request({
          topic: session!.topic,
          chainId,
          request: {
            method,
            params: {
              transactions: [
                {
                  signerId: address,
                  receiverId: "guest-book.testnet",
                  actions: [
                    {
                      type: "FunctionCall",
                      params: {
                        methodName: "addMessage",
                        args: { text: "Hello from Wallet Connect! (1/2)" },
                        gas: "30000000000000",
                        deposit: "0",
                      },
                    },
                  ],
                },
                {
                  signerId: address,
                  receiverId: "guest-book.testnet",
                  actions: [
                    {
                      type: "FunctionCall",
                      params: {
                        methodName: "addMessage",
                        args: { text: "Hello from Wallet Connect! (2/2)" },
                        gas: "30000000000000",
                        deposit: "0",
                      },
                    },
                  ],
                },
              ],
            },
          },
        });

        return {
          method,
          address,
          valid: true,
          result: JSON.stringify(
            (result as any).map((r: any) => r.transaction)
          ),
        };
      }
    ),
  };

  // -------- MULTIVERSX RPC METHODS --------

  const multiversxRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const reference = chainId.split(":")[1];

        const userAddress = new Address(address);
        const verifier = UserVerifier.fromAddress(userAddress);
        const transactionPayload = new TransactionPayload("testdata");

        const testTransaction = new MultiversxTransaction({
          nonce: 1,
          value: "10000000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
          data: transactionPayload,
        });
        const transaction = testTransaction.toPlainObject();

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTION,
            params: {
              transaction,
            },
          },
        });

        const valid = verifier.verify(
          testTransaction.serializeForSigning(),
          Buffer.from(result.signature, "hex")
        );

        return {
          method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTION,
          address,
          valid,
          result: result.signature.toString(),
        };
      }
    ),
    testSignTransactions: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const reference = chainId.split(":")[1];

        const userAddress = new Address(address);
        const verifier = UserVerifier.fromAddress(userAddress);
        const testTransactionPayload = new TransactionPayload("testdata");

        const testTransaction = new MultiversxTransaction({
          nonce: 1,
          value: "10000000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
          data: testTransactionPayload,
        });

        // no data for this Transaction
        const testTransaction2 = new MultiversxTransaction({
          nonce: 2,
          value: "20000000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
        });

        const testTransaction3Payload = new TransactionPayload("third");
        const testTransaction3 = new MultiversxTransaction({
          nonce: 3,
          value: "300000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
          data: testTransaction3Payload,
        });

        const transactions = [
          testTransaction,
          testTransaction2,
          testTransaction3,
        ].map((transaction) => transaction.toPlainObject());

        const result = await client!.request<{
          signatures: { signature: string }[];
        }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTIONS,
            params: {
              transactions,
            },
          },
        });

        const valid = [
          testTransaction,
          testTransaction2,
          testTransaction3,
        ].reduce((acc, current, index) => {
          return (
            acc &&
            verifier.verify(
              current.serializeForSigning(),
              Buffer.from(result.signatures[index].signature, "hex")
            )
          );
        }, true);

        const resultSignatures = result.signatures.map(
          (signature: any) => signature.signature
        );

        return {
          method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTIONS,
          address,
          valid,
          result: resultSignatures.join(", "),
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const userAddress = new Address(address);
        const verifier = UserVerifier.fromAddress(userAddress);

        const testMessage = new SignableMessage({
          address: userAddress,
          message: Buffer.from(`Sign this message - ${Date.now()}`, "ascii"),
        });

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_MESSAGE,
            params: {
              address,
              message: testMessage.message.toString(),
            },
          },
        });

        const valid = verifier.verify(
          testMessage.serializeForSigning(),
          Buffer.from(result.signature, "hex")
        );

        return {
          method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_MESSAGE,
          address,
          valid,
          result: result.signature.toString(),
        };
      }
    ),
  };

  // -------- TRON RPC METHODS --------

  const tronRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        // Nile TestNet, if you want to use in MainNet, change the fullHost to 'https://api.trongrid.io'
        const fullHost = isTestnet
          ? "https://nile.trongrid.io/"
          : "https://api.trongrid.io/";

        const tronWeb = new TronWeb({
          fullHost,
        });

        // Take USDT as an example:
        // Nile TestNet: https://nile.tronscan.org/#/token20/TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf
        // MainNet: https://tronscan.org/#/token20/TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t

        const testContract = isTestnet
          ? "TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf"
          : "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
        const testTransaction =
          await tronWeb.transactionBuilder.triggerSmartContract(
            testContract,
            "approve(address,uint256)",
            { feeLimit: 200000000 },
            [
              { type: "address", value: address },
              { type: "uint256", value: 0 },
            ],
            address
          );

        const { result } = await client!.request<{ result: any }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TRON_METHODS.TRON_SIGN_TRANSACTION,
            params: {
              address,
              transaction: {
                ...testTransaction,
              },
            },
          },
        });

        return {
          method: DEFAULT_TRON_METHODS.TRON_SIGN_TRANSACTION,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const message = "This is a message to be signed for Tron";

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TRON_METHODS.TRON_SIGN_MESSAGE,
            params: {
              address,
              message,
            },
          },
        });

        return {
          method: DEFAULT_TRON_METHODS.TRON_SIGN_MESSAGE,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
  };

  // -------- TEZOS RPC METHODS --------

  const tezosRpc = {
    testGetAccounts: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TEZOS_METHODS.TEZOS_GET_ACCOUNTS,
            params: {},
          },
        });

        return {
          method: DEFAULT_TEZOS_METHODS.TEZOS_GET_ACCOUNTS,
          address,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const result = await client!.request<{ hash: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TEZOS_METHODS.TEZOS_SEND,
            params: {
              account: address,
              operations: [
                {
                  kind: "transaction",
                  amount: "1", // 1 mutez, smallest unit
                  destination: address, // send to ourselves
                },
              ],
            },
          },
        });

        return {
          method: DEFAULT_TEZOS_METHODS.TEZOS_SEND,
          address,
          valid: true,
          result: result.hash,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const payload = "05010000004254";

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TEZOS_METHODS.TEZOS_SIGN,
            params: {
              account: address,
              payload,
            },
          },
        });

        return {
          method: DEFAULT_TEZOS_METHODS.TEZOS_SIGN,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
  };

  // -------- KADENA RPC METHODS --------

  const kadenaRpc = {
    testGetAccounts: _createJsonRpcRequestHandler(
      async (
        WCNetworkId: string,
        publicKey: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_KADENA_METHODS.KADENA_GET_ACCOUNTS;

        const result = await client!.request<any>({
          topic: session!.topic,
          chainId: WCNetworkId,
          request: {
            method,
            params: {
              account: `${WCNetworkId}:${publicKey}`,
              contracts: ["coin"],
            },
          },
        });

        // In a real app you would let the user pick which account they want to use. For this example we'll just set it to the first one.
        const [firstAccount] = result.accounts;

        // The information below will later be used to create a transaction
        setKadenaAccount({
          publicKey: firstAccount.publicKey, // Kadena public key
          account: firstAccount.kadenaAccounts[0].name, // Kadena account
          chainId: firstAccount.kadenaAccounts[0].chains[0], // Kadena ChainId
        });

        return {
          method,
          address: publicKey,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
    testSign: _createJsonRpcRequestHandler(
      async (
        WCNetworkId: string,
        publicKey: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_KADENA_METHODS.KADENA_SIGN;
        const [_, networkId] = WCNetworkId.split(":");

        if (!kadenaAccount) {
          throw new Error("No Kadena account selected. Call getAccounts first");
        }

        if (!client) {
          throw new Error("No client found");
        }

        const pactCommand = new PactCommand();
        pactCommand.code = `(coin.transfer "${
          kadenaAccount.account
        }" "k:abcabcabcabc" ${new PactNumber(1).toDecimal()})`;

        pactCommand
          .setMeta(
            {
              chainId: kadenaAccount.chainId,
              gasLimit: 1000,
              gasPrice: 1.0e-6,
              ttl: 10 * 60,
              sender: kadenaAccount.account,
            },
            networkId as IPactCommand["networkId"]
          )
          .addCap("coin.GAS", kadenaAccount.publicKey)
          .addCap(
            "coin.TRANSFER",
            kadenaAccount.publicKey, // public key of sender
            kadenaAccount.account, // account of sender
            "k:abcabcabcabc", // account of receiver
            { decimal: `1` } // amount
          );

        const signWithWalletConnect = createWalletConnectSign(
          client as any,
          session as any,
          WCNetworkId as any
        );

        const result = await signWithWalletConnect(pactCommand);

        return {
          method,
          address: kadenaAccount.publicKey,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
    testQuicksign: _createJsonRpcRequestHandler(
      async (
        WCNetworkId: string,
        publicKey: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_KADENA_METHODS.KADENA_QUICKSIGN;
        const [_, networkId] = WCNetworkId.split(":");

        if (!kadenaAccount) {
          throw new Error("No Kadena account selected. Call getAccounts first");
        }

        const pactCommand = new PactCommand();
        pactCommand.code = `(coin.transfer "${
          kadenaAccount.account
        }" "k:abcabcabcabc" ${new PactNumber(1).toDecimal()})`;

        pactCommand
          .setMeta(
            {
              chainId: kadenaAccount.chainId,
              gasLimit: 1000,
              gasPrice: 1.0e-6,
              ttl: 10 * 60,
              sender: kadenaAccount.account,
            },
            networkId as IPactCommand["networkId"]
          )
          .addCap("coin.GAS", publicKey)
          .addCap(
            "coin.TRANSFER",
            publicKey, // pubKey of sender
            kadenaAccount.account, // account of sender
            "k:abcabcabcabc", // account of receiver
            { decimal: `1` } // amount
          );

        const quicksignWithWalletConnect = createWalletConnectQuicksign(
          client as any,
          session as any,
          WCNetworkId as any
        );

        const result = await quicksignWithWalletConnect(pactCommand);

        return {
          method,
          address: publicKey,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
  };

  const bip122Rpc = {
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        console.log("testSignMessage", chainId, address);
        const method = DEFAULT_BIP122_METHODS.BIP122_SIGN_MESSAGE;
        const message = "This is a message to be signed for BIP122";
        const shouldAddAddress = address !== getAddressFromAccount(accounts[0]);
        const result = await client!.request<{
          signature: string;
          address: string;
        }>({
          topic: session!.topic,
          chainId: chainId,
          request: {
            method,
            params: {
              message,
              account: getAddressFromAccount(accounts[0]),
              address: shouldAddAddress ? address : undefined,
            },
          },
        });

        return {
          method,
          address: address,
          valid: await isValidBip122Signature(
            address,
            result.signature,
            message
          ),
          result: result.signature,
        };
      }
    ),
    testSendTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_BIP122_METHODS.BIP122_SEND_TRANSACTION;

        const utxos = await apiGetAddressUtxos(address, chainId);
        console.log("utxos", utxos);
        const availableBalance = getAvailableBalanceFromUtxos(utxos); // in satoshis
        console.log("availableBalance", availableBalance);
        const req = {
          account: address,
          recipientAddress: address,
          amount: BIP122_DUST_LIMIT,
        };
        console.log("request", {
          method,
          params: req,
          chainId,
        });

        const result = await client!.request<{ txid: string }>({
          topic: session!.topic,
          chainId: chainId,
          request: {
            method,
            params: req,
          },
        });
        console.log("result", result);
        return {
          method,
          address: address,
          valid: true,
          result: result?.txid,
        };
      }
    ),
    testSignPsbt: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_BIP122_METHODS.BIP122_SIGN_PSBT;

        const network = isBip122Testnet(chainId)
          ? bitcoin.networks.testnet
          : bitcoin.networks.bitcoin;

        console.log("network", isBip122Testnet(chainId), network);
        const utxos = (await apiGetAddressUtxos(address, chainId)) as IUTXO[];
        if (!utxos || utxos.length === 0) {
          throw new Error("No UTXOs found for address: " + address);
        }

        const availableBalance = getAvailableBalanceFromUtxos(utxos); // in satoshis
        const satoshisToTransfer = parseInt(BIP122_DUST_LIMIT, 10);
        if (availableBalance < satoshisToTransfer) {
          throw new Error(
            "Insufficient balance: " + availableBalance + " satoshis"
          );
        }

        const psbt = new bitcoin.Psbt({ network });

        const utxosToSpend: any[] = [];
        let utxosValue = 0;
        utxos.forEach((utxo) => {
          utxosValue += utxo.value;
          utxosToSpend.push(utxo);
          if (utxosValue >= satoshisToTransfer) {
            return;
          }
        });
        const signInputs: unknown[] = [];

        utxosToSpend.forEach((utxo, index) => {
          psbt.addInput({
            hash: utxo.txid,
            index: utxo.vout,
            witnessUtxo: {
              script: bitcoin.address.toOutputScript(address, network),
              value: utxo.value,
            },
          });
          signInputs.push({
            address,
            index,
            sighashTypes: [bitcoin.Transaction.SIGHASH_ALL],
          });
        });

        const change = calculateChange(utxosToSpend, satoshisToTransfer, 5);
        if (change > 0) {
          psbt.addOutput({
            address: address,
            value: change,
          });
        }

        psbt.addOutput({
          address: address,
          value: satoshisToTransfer,
        });

        const transaction = psbt.toBase64();

        console.log("availableBalance", availableBalance);
        const req = {
          account: address,
          psbt: transaction,
          signInputs,
          broadcast: false,
        };
        console.log("signPsbt", {
          method,
          params: req,
          chainId,
        });

        const result = await client!.request<{ psbt: string }>({
          topic: session!.topic,
          chainId: chainId,
          request: {
            method,
            params: req,
          },
        });
        console.log("result", result);
        const reconstructed = bitcoin.Psbt.fromBase64(result.psbt, { network });
        return {
          method,
          address: address,
          valid: true,
          result: reconstructed.extractTransaction().toHex(),
        };
      }
    ),
    testGetAccountAddresses: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_BIP122_METHODS.BIP122_GET_ACCOUNT_ADDRESSES;
        const isOrdinal = isOrdinalAddress(address);
        const req = {
          account: address,
          intentions: isOrdinal ? ["ordinal"] : ["payment"],
        };
        const addresses =
          session?.sessionProperties?.[
            `bip122_${DEFAULT_BIP122_METHODS.BIP122_GET_ACCOUNT_ADDRESSES}`
          ];
        let result;
        if (addresses) {
          console.log("cached addresses", addresses);
          const parsed = JSON.parse(addresses);
          result = isOrdinal ? parsed.ordinal : parsed.payment;
          console.log("parsed", result);
        } else {
          console.log("request", {
            method,
            params: req,
            chainId,
          });

          result = await client!.request<any>({
            topic: session!.topic,
            chainId: chainId,
            request: {
              method,
              params: req,
            },
          });

          console.log("result", result);
        }

        const accounts = result.map((r: any) => `${chainId}:${r.address}`);
        setAccounts((prev: string[]) => [...new Set([...prev, ...accounts])]);

        return {
          method,
          address: address,
          valid: true,
          result: result.map((r: any) => r.address).join(", "),
        };
      }
    ),
  };

  return (
    <JsonRpcContext.Provider
      value={{
        ping,
        ethereumRpc,
        cosmosRpc,
        solanaRpc,
        polkadotRpc,
        nearRpc,
        multiversxRpc,
        tronRpc,
        tezosRpc,
        kadenaRpc,
        rpcResult: result,
        isRpcRequestPending: pending,
        isTestnet,
        setIsTestnet,
        bip122Rpc,
      }}
    >
      {children}
    </JsonRpcContext.Provider>
  );
}

export function useJsonRpc() {
  const context = useContext(JsonRpcContext);
  if (context === undefined) {
    throw new Error("useJsonRpc must be used within a JsonRpcContextProvider");
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/api.ts">
import axios, { AxiosInstance } from "axios";
import { apiGetKadenaAccountBalance } from "./kadena";

import { AssetData } from "./types";
import { PactCommand } from "@kadena/client";
import { apiGetBip122AccountBalance } from "./bip122";

export type RpcProvidersByChainId = Record<
  number,
  {
    name: string;
    baseURL: string;
    token: {
      name: string;
      symbol: string;
    };
  }
>;

const WALLETCONNECT_RPC_BASE_URL = `https://rpc.walletconnect.com/v1?projectId=${process.env.NEXT_PUBLIC_PROJECT_ID}`;

export const rpcProvidersByChainId: RpcProvidersByChainId = {
  1: {
    name: "Ethereum Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:1",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  5: {
    name: "Ethereum Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:5",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  11155111: {
    name: "Ethereum Sepolia",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:11155111",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  137: {
    name: "Polygon Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:137",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  280: {
    name: "zkSync Era Testnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:280",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  324: {
    name: "zkSync Era",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:324",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  80001: {
    name: "Polygon Mumbai",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:80001",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  10: {
    name: "Optimism",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:10",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  420: {
    name: "Optimism Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:420",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  42161: {
    name: "Arbitrum",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:42161",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  421611: {
    name: "Arbitrum Rinkeby",
    baseURL: "https://rinkeby.arbitrum.io/rpc",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  100: {
    name: "xDAI",
    baseURL: "https://xdai-archive.blockscout.com",
    token: {
      name: "xDAI",
      symbol: "xDAI",
    },
  },
  42220: {
    name: "Celo",
    baseURL: "https://rpc.walletconnect.com/v1",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
  44787: {
    name: "Celo Alfajores",
    baseURL: "https://alfajores-forno.celo-testnet.org",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
};

const api: AxiosInstance = axios.create({
  baseURL: "https://rpc.walletconnect.com/v1",
  timeout: 10000, // 10 secs
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json",
  },
});

export async function apiGetAccountBalance(
  address: string,
  chainId: string
): Promise<AssetData> {
  const [namespace, networkId] = chainId.split(":");

  if (namespace === "kadena") {
    return apiGetKadenaAccountBalance(
      address,
      networkId as PactCommand["networkId"]
    );
  }

  if (namespace === "bip122") {
    return apiGetBip122AccountBalance(address, networkId as string);
  }

  if (namespace !== "eip155") {
    return { balance: "", symbol: "", name: "" };
  }

  const ethChainId = chainId.split(":")[1];
  const rpc = rpcProvidersByChainId[Number(ethChainId)];
  if (!rpc) {
    return { balance: "", symbol: "", name: "" };
  }
  const { baseURL, token } = rpc;
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_getBalance",
    params: [address, "latest"],
    id: 1,
  });
  const { result } = response.data;
  const balance = parseInt(result, 16).toString();
  return { balance, ...token };
}

export const apiGetAccountNonce = async (
  address: string,
  chainId: string
): Promise<number> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_getTransactionCount",
    params: [address, "latest"],
    id: 1,
  });
  const { result } = response.data;
  const nonce = parseInt(result, 16);
  return nonce;
};

export const apiGetGasPrice = async (chainId: string): Promise<string> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_gasPrice",
    params: [],
    id: 1,
  });
  const { result } = response.data;
  return result;
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/bip122.ts">
import { schnorr } from "@noble/curves/secp256k1";
import * as bitcoin from "bitcoinjs-lib";
import BitcoinMessage from "bitcoinjs-message";
import { convertHexToBase64 } from "./utilities";
import { IUTXO } from "./types";
import { BIP122_TESTNET } from "../chains/bip122";

export async function apiGetBip122AccountBalance(
  address: string,
  chainId: string
) {
  const utxo = await apiGetAddressUtxos(address, chainId);
  const balanceInSatoshis = getAvailableBalanceFromUtxos(utxo);
  const balanceInBtc = balanceInSatoshis * 0.00000001;
  return { balance: balanceInBtc.toString(), symbol: "BTC", name: "BTC" };
}

export async function apiGetAddressUtxos(address: string, chainId: string) {
  const isTestnet = chainId.includes(BIP122_TESTNET);
  return await (
    await fetch(
      `https://mempool.space${
        isTestnet ? "/testnet" : ""
      }/api/address/${address}/utxo`
    )
  ).json();
}

export function getAvailableBalanceFromUtxos(utxos: IUTXO[]) {
  if (!utxos || !utxos.length) {
    return 0;
  }
  return utxos.reduce((acc, { value }) => acc + value, 0);
}

export function calculateChange(
  utxos: IUTXO[],
  amount: number,
  feeRate: number
): number {
  const inputSum = utxos.reduce((sum, utxo) => sum + utxo.value, 0); // Sum of all UTXO values
  const estimatedSize = 10 + 148 * utxos.length + 34 * 2; // Rough estimate of transaction size
  const fee = estimatedSize * feeRate; // Transaction fee
  const change = inputSum - amount - fee; // Calculate change
  return change;
}

export async function isValidBip122Signature(
  address: string,
  signature: string,
  message: string
) {
  // if taproot address
  if (address.startsWith("bc1p") || address.startsWith("tb1p")) {
    // Convert the Ordinals address (Taproot) to the internal public key
    const decoded = bitcoin.address.fromBech32(address);
    if (decoded.version !== 1 || decoded.data.length !== 32) {
      throw new Error("Invalid Taproot address");
    }

    const publicKey = decoded.data; // The 32-byte internal public key (X coordinate of pubkey)

    // Hash the message using SHA256 (standard Bitcoin message hashing)
    const messageHash = bitcoin.crypto.sha256(Buffer.from(message));

    // Verify the Schnorr signature using tiny-secp256k1
    return schnorr.verify(
      new Uint8Array(Buffer.from(signature, "hex")),
      new Uint8Array(messageHash),
      new Uint8Array(publicKey)
    );
  }

  return BitcoinMessage.verify(
    message,
    address,
    convertHexToBase64(signature),
    undefined,
    true
  );
}

export function isOrdinalAddress(address: string) {
  return address.startsWith("tb1p");
}

export function isBip122Testnet(chainId: string) {
  return chainId.includes(BIP122_TESTNET);
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/eip1271.ts">
import { Contract, providers, utils } from "ethers";

const spec = {
  magicValue: "0x1626ba7e",
  abi: [
    {
      constant: true,
      inputs: [
        {
          name: "_hash",
          type: "bytes32",
        },
        {
          name: "_sig",
          type: "bytes",
        },
      ],
      name: "isValidSignature",
      outputs: [
        {
          name: "magicValue",
          type: "bytes4",
        },
      ],
      payable: false,
      stateMutability: "view",
      type: "function",
    },
  ],
};

async function isValidSignature(
  address: string,
  sig: string,
  data: string,
  provider: providers.Provider,
  abi = eip1271.spec.abi,
  magicValue = eip1271.spec.magicValue
): Promise<boolean> {
  let returnValue;
  try {
    returnValue = await new Contract(address, abi, provider).isValidSignature(
      utils.arrayify(data),
      sig
    );
  } catch (e) {
    return false;
  }
  return returnValue.toLowerCase() === magicValue.toLowerCase();
}

export const eip1271 = {
  spec,
  isValidSignature,
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/eip712.ts">
// From spec: https://eips.ethereum.org/EIPS/eip-712
const example = {
  types: {
    EIP712Domain: [
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
    ],
    Person: [
      { name: "name", type: "string" },
      { name: "wallet", type: "address" },
    ],
    Mail: [
      { name: "from", type: "Person" },
      { name: "to", type: "Person" },
      { name: "contents", type: "string" },
    ],
  },
  primaryType: "Mail",
  domain: {
    name: "Ether Mail",
    version: "1",
    chainId: 1,
    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
  },
  message: {
    from: { name: "Cow", wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826" },
    to: { name: "Bob", wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB" },
    contents: "Hello, Bob!",
  },
};

export const eip712 = {
  example,
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/index.ts">
export * from "./api";
export * from "./eip712";
export * from "./eip1271";
export * from "./tx";
export * from "./types";
export * from "./utilities";
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/kadena.ts">
import { IPactCommand, PactCommand } from "@kadena/client";

export async function getKadenaChainAmount(
  WCNetworkId: string
): Promise<number> {
  const ENDPOINT = WCNetworkId === "testnet04" ? "testnet." : "";

  try {
    const response = await fetch(`https://api.${ENDPOINT}chainweb.com/info`, {
      mode: "cors",
    });

    const json = await response.json();
    return json.nodeNumberOfChains;
  } catch (e) {
    console.error("Error fetching Kadena chain info", e);
    return 0;
  }
}

async function getKadenaBalanceForChain(
  publicKey: string,
  WCNetworkId: IPactCommand["networkId"],
  kadenaChainID: IPactCommand["publicMeta"]["chainId"]
): Promise<number> {
  const ENDPOINT = WCNetworkId === "testnet04" ? "testnet." : "";
  const API_HOST = `https://api.${ENDPOINT}chainweb.com/chainweb/0.0/${WCNetworkId}/chain/${kadenaChainID}/pact`;

  // This request will fail if there is no on-chain activity for the given account yet
  try {
    const command = new PactCommand();
    command.code = `(coin.get-balance "k:${publicKey}")`;
    command.setMeta(
      { sender: `k:${publicKey}`, chainId: kadenaChainID },
      WCNetworkId
    );
    const { result } = await command.local(API_HOST, {
      preflight: false,
      signatureVerification: false,
    });

    if (result.status !== "success") return 0;

    return result.data * 10e17;
  } catch (e) {
    return 0;
  }
}

const kadenaNumberOfChains: Record<string, number> = {
  mainnet01: 0,
  testnet04: 0,
};

export async function apiGetKadenaAccountBalance(
  publicKey: string,
  WCNetworkId: IPactCommand["networkId"]
) {
  if (!kadenaNumberOfChains[WCNetworkId]) {
    kadenaNumberOfChains[WCNetworkId] = await getKadenaChainAmount(WCNetworkId);
  }

  const chainBalances = await Promise.all(
    Array.from(Array(kadenaNumberOfChains[WCNetworkId])).map(
      async (_val, chainNumber) =>
        getKadenaBalanceForChain(
          publicKey,
          WCNetworkId,
          chainNumber.toString() as IPactCommand["publicMeta"]["chainId"]
        )
    )
  );

  const totalBalance = chainBalances.reduce((acc, item) => acc + item, 0);

  return {
    balance: totalBalance.toString(),
    symbol: "KDA",
    name: "KDA",
  };
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/namespaces.ts">
import { ProposalTypes } from "@walletconnect/types";
import {
  DEFAULT_COSMOS_EVENTS,
  DEFAULT_COSMOS_METHODS,
  DEFAULT_EIP155_METHODS,
  DEFAULT_EIP_155_EVENTS,
  DEFAULT_SOLANA_EVENTS,
  DEFAULT_SOLANA_METHODS,
  DEFAULT_POLKADOT_EVENTS,
  DEFAULT_POLKADOT_METHODS,
  DEFAULT_NEAR_METHODS,
  DEFAULT_NEAR_EVENTS,
  DEFAULT_KADENA_METHODS,
  DEFAULT_KADENA_EVENTS,
  DEFAULT_MULTIVERSX_EVENTS,
  DEFAULT_MULTIVERSX_METHODS,
  DEFAULT_TRON_METHODS,
  DEFAULT_TRON_EVENTS,
  DEFAULT_TEZOS_METHODS,
  DEFAULT_TEZOS_EVENTS,
  DEFAULT_OPTIONAL_METHODS,
  DEFAULT_BIP122_METHODS,
  DEFAULT_BIP122_EVENTS,
} from "../constants";

export const getNamespacesFromChains = (chains: string[]) => {
  const supportedNamespaces: string[] = [];
  chains.forEach((chainId) => {
    const [namespace] = chainId.split(":");
    if (!supportedNamespaces.includes(namespace)) {
      supportedNamespaces.push(namespace);
    }
  });

  return supportedNamespaces;
};

export const getSupportedRequiredMethodsByNamespace = (namespace: string) => {
  switch (namespace) {
    case "eip155":
      return Object.values(DEFAULT_EIP155_METHODS);
    case "cosmos":
      return Object.values(DEFAULT_COSMOS_METHODS);
    case "solana":
      return Object.values(DEFAULT_SOLANA_METHODS);
    case "polkadot":
      return Object.values(DEFAULT_POLKADOT_METHODS);
    case "near":
      return Object.values(DEFAULT_NEAR_METHODS);
    case "mvx":
      return Object.values(DEFAULT_MULTIVERSX_METHODS);
    case "tron":
      return Object.values(DEFAULT_TRON_METHODS);
    case "tezos":
      return Object.values(DEFAULT_TEZOS_METHODS);
    case "kadena":
      return Object.values(DEFAULT_KADENA_METHODS);
    case "bip122":
      return Object.values(DEFAULT_BIP122_METHODS);
    default:
      throw new Error(
        `No default required methods for namespace: ${namespace}`
      );
  }
};

export const getSupportedOptionalMethodsByNamespace = (namespace: string) => {
  switch (namespace) {
    case "eip155":
      return Object.values(DEFAULT_OPTIONAL_METHODS);
    case "cosmos":
    case "solana":
    case "polkadot":
    case "near":
    case "mvx":
    case "tron":
    case "tezos":
    case "kadena":
    case "bip122":
      return [];
    default:
      throw new Error(
        `No default optional methods for namespace: ${namespace}`
      );
  }
};

export const getSupportedEventsByNamespace = (namespace: string) => {
  switch (namespace) {
    case "eip155":
      return Object.values(DEFAULT_EIP_155_EVENTS);
    case "cosmos":
      return Object.values(DEFAULT_COSMOS_EVENTS);
    case "solana":
      return Object.values(DEFAULT_SOLANA_EVENTS);
    case "polkadot":
      return Object.values(DEFAULT_POLKADOT_EVENTS);
    case "near":
      return Object.values(DEFAULT_NEAR_EVENTS);
    case "mvx":
      return Object.values(DEFAULT_MULTIVERSX_EVENTS);
    case "tron":
      return Object.values(DEFAULT_TRON_EVENTS);
    case "tezos":
      return Object.values(DEFAULT_TEZOS_EVENTS);
    case "kadena":
      return Object.values(DEFAULT_KADENA_EVENTS);
    case "bip122":
      return Object.values(DEFAULT_BIP122_EVENTS);
    default:
      throw new Error(`No default events for namespace: ${namespace}`);
  }
};

export const getRequiredNamespaces = (
  chains: string[]
): ProposalTypes.RequiredNamespaces => {
  const selectedNamespaces = getNamespacesFromChains(chains);
  console.log("selected required namespaces:", selectedNamespaces);

  return Object.fromEntries(
    selectedNamespaces.map((namespace) => [
      namespace,
      {
        methods: getSupportedRequiredMethodsByNamespace(namespace),
        chains: chains.filter((chain) => chain.startsWith(namespace)),
        events: getSupportedEventsByNamespace(namespace) as any[],
      },
    ])
  );
};

export const getOptionalNamespaces = (
  chains: string[]
): ProposalTypes.OptionalNamespaces => {
  const selectedNamespaces = getNamespacesFromChains(chains);
  console.log("selected optional namespaces:", selectedNamespaces);

  return Object.fromEntries(
    selectedNamespaces.map((namespace) => [
      namespace,
      {
        methods: getSupportedOptionalMethodsByNamespace(namespace),
        chains: chains.filter((chain) => chain.startsWith(namespace)),
        events: [],
      },
    ])
  );
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/solana.ts">
import { PublicKey } from "@solana/web3.js";

export function getPublicKeysFromAccounts(accounts: string[]) {
  return (
    accounts
      // Filter out any non-solana accounts.
      .filter((account) => account.startsWith("solana:"))
      // Create a map of Solana address -> publicKey.
      .reduce((map: Record<string, PublicKey>, account) => {
        const address = account.split(":").pop();
        if (!address) {
          throw new Error(
            `Could not derive Solana address from CAIP account: ${account}`
          );
        }
        map[address] = new PublicKey(address);
        return map;
      }, {})
  );
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/tx.ts">
import * as encoding from "@walletconnect/encoding";

import { apiGetAccountNonce, apiGetGasPrice } from "./api";
import { parseEther } from "ethers/lib/utils";
import { SendCallsParams } from "../constants";

export async function formatTestTransaction(account: string) {
  const [namespace, reference, address] = account.split(":");
  const chainId = `${namespace}:${reference}`;

  let _nonce;
  try {
    _nonce = await apiGetAccountNonce(address, chainId);
  } catch (error) {
    throw new Error(
      `Failed to fetch nonce for address ${address} on chain ${chainId}`
    );
  }

  const nonce = encoding.sanitizeHex(encoding.numberToHex(_nonce));

  // gasPrice
  const _gasPrice = await apiGetGasPrice(chainId);
  const gasPrice = encoding.sanitizeHex(_gasPrice);

  // gasLimit
  const _gasLimit = 21000;
  const gasLimit = encoding.sanitizeHex(encoding.numberToHex(_gasLimit));

  // value
  const _value = 0;
  const value = encoding.sanitizeHex(encoding.numberToHex(_value));

  const tx = {
    from: address,
    to: address,
    data: "0x",
    nonce,
    gasPrice,
    gasLimit,
    value,
  };

  return tx;
}

export async function formatTestBatchCall(account: string) {
  const [namespace, reference, address] = account.split(":");
  // preparing calldata for batch send
  //sepolia pow faucet address
  const receiverAddress = "0x6Cc9397c3B38739daCbfaA68EaD5F5D77Ba5F455";
  const amountToSend = parseEther("0.0001").toHexString();
  const calls = [
    {
      to: receiverAddress as `0x${string}`,
      data: "0x" as `0x${string}`,
      value: amountToSend as `0x${string}`,
    },
    {
      to: receiverAddress as `0x${string}`,
      data: "0x" as `0x${string}`,
      value: amountToSend as `0x${string}`,
    },
  ];
  const sendCallsRequestParams: SendCallsParams = {
    version: "1.0",
    chainId: `0x${BigInt(reference).toString(16)}`,
    from: address as `0x${string}`,
    calls: calls,
  };

  return sendCallsRequestParams;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/types.ts">
import { IPactCommand } from "@kadena/client";
import { ChainId } from "@kadena/types";

export interface AssetData {
  symbol: string;
  name: string;
  contractAddress?: string;
  balance?: string;
}

export interface ChainData {
  name: string;
  id: string;
  rpc: string[];
  slip44: number;
  testnet: boolean;
}
export interface ChainsMap {
  [reference: string]: ChainData;
}
export interface TxData {
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasLimit: string;
  value: string;
  data: string;
}

export interface BlockScoutTx {
  value: string;
  txreceipt_status: string;
  transactionIndex: string;
  to: string;
  timeStamp: string;
  nonce: string;
  isError: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface BlockScoutTokenTx {
  value: string;
  transactionIndex: string;
  tokenSymbol: string;
  tokenName: string;
  tokenDecimal: string;
  to: string;
  timeStamp: string;
  nonce: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface ParsedTx {
  timestamp: string;
  hash: string;
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasUsed: string;
  fee: string;
  value: string;
  input: string;
  error: boolean;
  asset: AssetData;
  operations: TxOperation[];
}

export interface TxOperation {
  asset: AssetData;
  value: string;
  from: string;
  to: string;
  functionName: string;
}

export interface GasPricesResponse {
  fastWait: number;
  avgWait: number;
  blockNum: number;
  fast: number;
  fastest: number;
  fastestWait: number;
  safeLow: number;
  safeLowWait: number;
  speed: number;
  block_time: number;
  average: number;
}

export interface GasPrice {
  time: number;
  price: number;
}

export interface GasPrices {
  timestamp: number;
  slow: GasPrice;
  average: GasPrice;
  fast: GasPrice;
}

export interface MethodArgument {
  type: string;
}

export interface Method {
  signature: string;
  name: string;
  args: MethodArgument[];
}

export interface ChainRequestRender {
  label: string;
  value: string;
}

export interface ChainMetadata {
  name?: string;
  logo: string;
  rgb: string;
}

export interface NamespaceMetadata {
  [reference: string]: ChainMetadata;
}
export interface ChainNamespaces {
  [namespace: string]: ChainsMap;
}

export interface AccountAction {
  method: string;
  callback: (chainId: string, address: string) => Promise<void>;
}

export interface AccountBalances {
  [account: string]: AssetData[];
}

export interface KadenaAccount {
  publicKey: string; // Kadena public key
  account: string; // Kadena account
  chainId: ChainId; // Kadena ChainId
}

export interface IUTXO {
  txid: string;
  vout: number;
  value: number;
  status: {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
  };
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/utilities.ts">
import { BigNumber, BigNumberish, providers, utils } from "ethers";
import * as encoding from "@walletconnect/encoding";
import { TypedDataUtils } from "eth-sig-util";
import * as ethUtil from "ethereumjs-util";

import { eip1271 } from "./eip1271";
import { DEFAULT_CHAINS } from "../constants";

export function capitalize(string: string): string {
  return string
    .split(" ")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(" ");
}

export function ellipseText(text = "", maxLength = 9999): string {
  if (text.length <= maxLength) {
    return text;
  }
  const _maxLength = maxLength - 3;
  let ellipse = false;
  let currentLength = 0;
  const result =
    text
      .split(" ")
      .filter((word) => {
        currentLength += word.length;
        if (ellipse || currentLength >= _maxLength) {
          ellipse = true;
          return false;
        } else {
          return true;
        }
      })
      .join(" ") + "...";
  return result;
}

export function ellipseAddress(address = "", width = 10): string {
  return `${address.slice(0, width)}...${address.slice(-width)}`;
}

export function getDataString(func: string, arrVals: any[]): string {
  let val = "";
  for (let i = 0; i < arrVals.length; i++) {
    val += encoding.padLeft(arrVals[i], 64);
  }
  const data = func + val;
  return data;
}

export function isMobile(): boolean {
  let mobile = false;

  function hasTouchEvent(): boolean {
    try {
      document.createEvent("TouchEvent");
      return true;
    } catch (e) {
      return false;
    }
  }

  function hasMobileUserAgent(): boolean {
    if (
      /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
        navigator.userAgent
      ) ||
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
        navigator.userAgent.substr(0, 4)
      )
    ) {
      return true;
    } else if (hasTouchEvent()) {
      return true;
    }
    return false;
  }

  mobile = hasMobileUserAgent();

  return mobile;
}

export function encodePersonalMessage(msg: string): string {
  const data = encoding.utf8ToBuffer(msg);
  const buf = Buffer.concat([
    Buffer.from(
      "\u0019Ethereum Signed Message:\n" + data.length.toString(),
      "utf8"
    ),
    data,
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashPersonalMessage(msg: string): string {
  const data = encodePersonalMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function encodeTypedDataMessage(msg: string): string {
  const data = TypedDataUtils.sanitizeData(JSON.parse(msg));
  const buf = Buffer.concat([
    Buffer.from("1901", "hex"),
    TypedDataUtils.hashStruct("EIP712Domain", data.domain, data.types),
    TypedDataUtils.hashStruct(
      data.primaryType as string,
      data.message,
      data.types
    ),
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashTypedDataMessage(msg: string): string {
  const data = encodeTypedDataMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function recoverAddress(sig: string, hash: string): string {
  const params = ethUtil.fromRpcSig(sig);
  const result = ethUtil.ecrecover(
    ethUtil.toBuffer(hash),
    params.v,
    params.r,
    params.s
  );
  const signer = ethUtil.bufferToHex(ethUtil.publicToAddress(result));
  return signer;
}

export function recoverPersonalSignature(sig: string, msg: string): string {
  const hash = hashPersonalMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export function recoverTypedMessage(sig: string, msg: string): string {
  const hash = hashTypedDataMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export async function verifySignature(
  address: string,
  sig: string,
  hash: string,
  rpcUrl: string
): Promise<boolean> {
  const provider = new providers.JsonRpcProvider(rpcUrl);
  const bytecode = await provider.getCode(address);
  if (
    !bytecode ||
    bytecode === "0x" ||
    bytecode === "0x0" ||
    bytecode === "0x00"
  ) {
    const signer = recoverAddress(sig, hash);
    return signer.toLowerCase() === address.toLowerCase();
  } else {
    return eip1271.isValidSignature(address, sig, hash, provider);
  }
}

export function convertHexToNumber(hex: string) {
  try {
    return encoding.hexToNumber(hex);
  } catch (e) {
    return hex;
  }
}

export function convertHexToUtf8(hex: string) {
  try {
    return encoding.hexToUtf8(hex);
  } catch (e) {
    return hex;
  }
}
export function convertHexToBase64(hex: string) {
  try {
    return encoding.hexToBuffer(hex).toString("base64");
  } catch (e) {
    return hex;
  }
}

export const sanitizeDecimals = (value: string, decimals = 18): string => {
  const [integer, fractional] = value.split(".");
  const _fractional = fractional
    ? fractional.substring(0, decimals).replace(/0+$/gi, "")
    : undefined;
  return _fractional ? [integer, _fractional].join(".") : integer;
};

export const toWad = (amount: string, decimals = 18): BigNumber => {
  return utils.parseUnits(sanitizeDecimals(amount, decimals), decimals);
};

export const fromWad = (wad: BigNumberish, decimals = 18): string => {
  try {
    return sanitizeDecimals(utils.formatUnits(wad, decimals), decimals);
  } catch (e) {
    return wad?.toString();
  }
};

export const LOCALSTORAGE_KEY_TESTNET = "TESTNET";
export const INITIAL_STATE_TESTNET_DEFAULT = true;

export function setLocaleStorageTestnetFlag(value: boolean): void {
  if (typeof window !== "undefined") {
    window.localStorage.setItem(LOCALSTORAGE_KEY_TESTNET, `${value}`);
  }
}

export function getLocalStorageTestnetFlag(): boolean {
  if (typeof window === "undefined") return false;
  let value = INITIAL_STATE_TESTNET_DEFAULT;
  const persisted = window.localStorage.getItem(LOCALSTORAGE_KEY_TESTNET);
  if (!persisted) {
    setLocaleStorageTestnetFlag(value);
  } else {
    value = persisted === "true" ? true : false;
  }
  return value;
}

export const getAllChainNamespaces = () => {
  const namespaces: string[] = [];
  DEFAULT_CHAINS.forEach((chainId) => {
    const [namespace] = chainId.split(":");
    if (!namespaces.includes(namespace)) {
      namespaces.push(namespace);
    }
  });
  return namespaces;
};

export const getProviderUrl = (chainId: string) => {
  return `https://rpc.walletconnect.com/v1/?chainId=${chainId}&projectId=${process.env.NEXT_PUBLIC_PROJECT_ID}`;
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/shared/index.ts">
import styled from "styled-components";

export const SModalContainer = styled.div`
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

export const SModalTitle = styled.div`
  margin: 1em 0;
  font-size: 20px;
  font-weight: 700;
`;

export const SModalParagraph = styled.p`
  margin-top: 30px;
`;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/LoaderModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer } from "../components/shared";

import { SModalContainer, SModalParagraph, SModalTitle } from "./shared";

interface LoaderModal {
  title: string;
  text?: string;
}

const LoaderModal = (props: LoaderModal) => {
  const { title, text } = props;
  return (
    <>
      <SModalContainer>
        <SModalTitle>{title}</SModalTitle>
        <SContainer>
          <Loader />
          <br />
          <SModalParagraph>{text}</SModalParagraph>
        </SContainer>
      </SModalContainer>
    </>
  );
};

export default LoaderModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/PairingModal.tsx">
import * as React from "react";

import { PairingTypes } from "@walletconnect/types";

import Button from "../components/Button";
import Pairing from "../components/Pairing";
import { STable } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";
import LoaderModal from "./LoaderModal";
import toast from "react-hot-toast";

interface PairingModalProps {
  pairings: PairingTypes.Struct[];
  connect: (pairing?: { topic: string }) => Promise<void>;
}

const PairingModal = (props: PairingModalProps) => {
  const { pairings, connect } = props;
  const [pairing, setPairing] = React.useState<PairingTypes.Struct>();

  const onConnect = React.useCallback(
    async (pairing: PairingTypes.Struct) => {
      try {
        setPairing(pairing);
        await connect({ topic: pairing.topic });
      } catch (error) {
        toast.error((error as Error).message, {
          position: "bottom-left",
        });
        setPairing(undefined);
      }
    },
    [connect]
  );
  return pairing ? (
    <LoaderModal
      title={`Connecting to ${pairing?.peerMetadata?.name}`}
      text="Open your wallet to approve the connection request"
    />
  ) : (
    <SModalContainer>
      <SModalTitle>{"Select available pairing or create new one"}</SModalTitle>
      <STable>
        {pairings.map((pairing) => (
          <Pairing
            key={pairing.topic}
            pairing={pairing}
            onClick={() => onConnect(pairing)}
          />
        ))}
      </STable>
      <Button onClick={() => connect()}>{`New Pairing`}</Button>
    </SModalContainer>
  );
};

export default PairingModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/PingModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";

interface PingModalProps {
  pending: boolean;
  result: any;
}

const PingModal = (props: PingModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending Session Ping"}</SModalTitle>
          <SContainer>
            <Loader />
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid ? "Successful Session Ping" : "Failed Session Ping"}
          </SModalTitle>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"Unknown Error with Session Ping"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default PingModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/RequestLoaderModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer, STable, SRow, SKey, SValue } from "../components/shared";

import { SModalContainer, SModalTitle, SModalParagraph } from "./shared";

interface RequestModalProps {
  pending: boolean;
  result: any;
}

const RequestLoaderModal = (props: RequestModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending JSON-RPC Request"}</SModalTitle>
          <SContainer>
            <Loader />
            <SModalParagraph>
              {"Waiting response from your wallet"}
            </SModalParagraph>
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid
              ? "JSON-RPC Request Success"
              : "JSON-RPC Request Failed"}
          </SModalTitle>
          <STable>
            {Object.keys(result).map((key) => (
              <SRow key={key}>
                <SKey>{key}</SKey>
                <SValue>{result[key].toString()}</SValue>
              </SRow>
            ))}
          </STable>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"JSON-RPC Request Failed"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default RequestLoaderModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/RequestModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer, STable, SRow, SKey, SValue } from "../components/shared";

import { SModalContainer, SModalTitle, SModalParagraph } from "./shared";

interface RequestModalProps {
  pending: boolean;
  result: any;
}

const RequestModal = (props: RequestModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending JSON-RPC Request"}</SModalTitle>
          <SContainer>
            <Loader />
            <SModalParagraph>
              {"Approve or reject request using your wallet"}
            </SModalParagraph>
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid
              ? "JSON-RPC Request Approved"
              : "JSON-RPC Request Failed"}
          </SModalTitle>
          <STable>
            {Object.keys(result).map((key) => (
              <SRow key={key}>
                <SKey>{key}</SKey>
                <SValue>{result[key].toString()}</SValue>
              </SRow>
            ))}
          </STable>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"JSON-RPC Request Rejected"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default RequestModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/_app.tsx">
import "../styles/globals.css";
import type { AppProps } from "next/app";
import { createGlobalStyle } from "styled-components";
import { Toaster } from "react-hot-toast";

import { ClientContextProvider } from "../contexts/ClientContext";
import { JsonRpcContextProvider } from "../contexts/JsonRpcContext";
import { ChainDataContextProvider } from "../contexts/ChainDataContext";
import Metadata from "../components/Metadata";

import { globalStyle } from "../styles";
const GlobalStyle = createGlobalStyle`
  ${globalStyle}
`;

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Toaster />
      <Metadata />
      <GlobalStyle />
      <ChainDataContextProvider>
        <ClientContextProvider>
          <JsonRpcContextProvider>
            <Component {...pageProps} />
          </JsonRpcContextProvider>
        </ClientContextProvider>
      </ChainDataContextProvider>
    </>
  );
}

export default MyApp;
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/_error.tsx">
export default function Error() {
  return <div>An error as occured</div>;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/404.tsx">
export default function FourOhFour() {
  return <h1>404 Page Not Found</h1>;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/index.tsx">
import type { NextPage } from "next";
import React, { useCallback, useEffect, useRef, useState } from "react";
import toast from "react-hot-toast";

import Banner from "../components/Banner";
import Blockchain from "../components/Blockchain";
import Column from "../components/Column";
import RelayRegionDropdown from "../components/RelayRegionDropdown";
import Header from "../components/Header";
import Modal from "../components/Modal";
import {
  DEFAULT_COSMOS_METHODS,
  DEFAULT_EIP155_METHODS,
  DEFAULT_MAIN_CHAINS,
  DEFAULT_SOLANA_METHODS,
  DEFAULT_POLKADOT_METHODS,
  DEFAULT_MULTIVERSX_METHODS,
  DEFAULT_TEST_CHAINS,
  DEFAULT_NEAR_METHODS,
  DEFAULT_KADENA_METHODS,
  DEFAULT_TRON_METHODS,
  DEFAULT_TEZOS_METHODS,
  DEFAULT_EIP155_OPTIONAL_METHODS,
  DEFAULT_EIP5792_METHODS,
  GetCapabilitiesResult,
  DEFAULT_BIP122_METHODS,
  DEFAULT_EIP7715_METHODS,
} from "../constants";
import { AccountAction, setLocaleStorageTestnetFlag } from "../helpers";
import Toggle from "../components/Toggle";
import RequestModal from "../modals/RequestModal";
import PairingModal from "../modals/PairingModal";
import PingModal from "../modals/PingModal";
import {
  SAccounts,
  SAccountsContainer,
  SButtonContainer,
  SConnectButton,
  SContent,
  SDropDownContainer,
  SLanding,
  SLayout,
  SToggleContainer,
} from "../components/app";
import { useWalletConnectClient } from "../contexts/ClientContext";
import { useJsonRpc } from "../contexts/JsonRpcContext";
import { useChainData } from "../contexts/ChainDataContext";
import Icon from "../components/Icon";
import OriginSimulationDropdown from "../components/OriginSimulationDropdown";
import LoaderModal from "../modals/LoaderModal";
import { numberToHex } from "@walletconnect/encoding";
import RequestLoaderModal from "../modals/RequestLoaderModal";

// Normal import does not work here
const { version } = require("@walletconnect/sign-client/package.json");

const Home: NextPage = () => {
  const [modal, setModal] = useState("");

  const closeModal = () => setModal("");
  const openPairingModal = () => setModal("pairing");
  const openPingModal = () => setModal("ping");
  const openRequestModal = () => setModal("request");
  const openRequestLoaderModal = () => setModal("requestLoader");
  const openDisconnectModal = () => setModal("disconnect");

  // Initialize the WalletConnect client.
  const {
    client,
    pairings,
    session,
    connect,
    disconnect,
    chains,
    relayerRegion,
    accounts,
    balances,
    isFetchingBalances,
    isInitializing,
    setChains,
    setRelayerRegion,
    origin,
    setAccounts,
  } = useWalletConnectClient();

  // Use `JsonRpcContext` to provide us with relevant RPC methods and states.
  const {
    ping,
    ethereumRpc,
    cosmosRpc,
    solanaRpc,
    polkadotRpc,
    nearRpc,
    multiversxRpc,
    tronRpc,
    tezosRpc,
    kadenaRpc,
    bip122Rpc,
    isRpcRequestPending,
    rpcResult,
    isTestnet,
    setIsTestnet,
  } = useJsonRpc();

  const { chainData } = useChainData();

  // Close the pairing modal after a session is established.
  useEffect(() => {
    if (session && modal === "pairing") {
      closeModal();
    }
  }, [session, modal]);

  const onConnect = () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    // Suggest existing pairings (if any).
    if (pairings.length) {
      openPairingModal();
    } else {
      // If no existing pairings are available, trigger `WalletConnectClient.connect`.
      connect();
    }
  };

  const onPing = async () => {
    openPingModal();
    await ping();
  };

  const onDisconnect = useCallback(async () => {
    openDisconnectModal();
    try {
      await disconnect();
    } catch (error) {
      toast.error((error as Error).message, {
        position: "bottom-left",
      });
    }
    closeModal();
  }, [disconnect]);

  async function emit() {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }

    await client.emit({
      topic: session?.topic || "",
      event: { name: "chainChanged", data: {} },
      chainId: "eip155:5",
    });
  }

  const getEthereumActions = (
    chainId: string,
    address: string
  ): AccountAction[] => {
    const actions = {
      [DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION]: {
        method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSendTransaction(chainId, address);
        },
      },
      [DEFAULT_EIP155_METHODS.PERSONAL_SIGN]: {
        method: DEFAULT_EIP155_METHODS.PERSONAL_SIGN,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignPersonalMessage(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignTransaction(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN + " (standard)",
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testEthSign(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignTypedData(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA_V4]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA_V4,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignTypedDatav4(chainId, address);
        },
      },
      [DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES]: {
        method: DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES,
        callback: async (chainId: string, address: string) => {
          openRequestLoaderModal();
          await ethereumRpc.testWalletGetCapabilities(chainId, address);
        },
      },
      [DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS]: {
        method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testWalletSendCalls(chainId, address);
        },
      },
      [DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS]: {
        method: DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testWalletGetCallsStatus(chainId, address);
        },
      },
      [DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS]: {
        method: DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testWalletGrantPermissions(chainId, address);
        },
      },
    };

    let availableActions: AccountAction[] = [];
    const chainIdAsHex = `0x${numberToHex(parseInt(chainId))}`;
    const capabilitiesJson = session?.sessionProperties?.["capabilities"];
    const walletCapabilities = capabilitiesJson && JSON.parse(capabilitiesJson);
    session?.namespaces?.["eip155"].methods.forEach((methodName) => {
      const action: AccountAction | undefined =
        actions[methodName as keyof typeof actions];
      // Determine if the method requires additional capability checks
      const requiresCapabilityCheck = [
        "wallet_sendCalls",
        "wallet_getCallsStatus",
        "wallet_grantPermissions",
      ].includes(methodName);
      // Check capabilities only if the method requires it
      if (
        !requiresCapabilityCheck ||
        hasEIP7592RequiredCapabilities(
          address,
          chainIdAsHex,
          walletCapabilities
        )
      ) {
        availableActions.push(action);
      }
    });

    // if a method is approved in the session thats not supported by the app, it will result in an undefined item in the array
    return availableActions.filter((action) => action !== undefined);
  };

  const hasEIP7592RequiredCapabilities = (
    address: string,
    chainId: string,
    walletCapabilities: any
  ): boolean => {
    if (!walletCapabilities) return false;
    const addressCapabilities: GetCapabilitiesResult | undefined =
      walletCapabilities[address];
    if (
      addressCapabilities &&
      addressCapabilities[chainId] &&
      (addressCapabilities[chainId]["atomicBatch"]?.supported ||
        addressCapabilities[chainId]["paymasterService"]?.supported ||
        addressCapabilities[chainId]["sessionKey"]?.supported)
    )
      return true; // Capabilities are supported
    return false; // Capabilities are not supported or not defined
  };

  const getCosmosActions = (): AccountAction[] => {
    const onSignDirect = async (chainId: string, address: string) => {
      openRequestModal();
      await cosmosRpc.testSignDirect(chainId, address);
    };
    const onSignAmino = async (chainId: string, address: string) => {
      openRequestModal();
      await cosmosRpc.testSignAmino(chainId, address);
    };
    return [
      {
        method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_DIRECT,
        callback: onSignDirect,
      },
      {
        method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
        callback: onSignAmino,
      },
    ];
  };

  const getSolanaActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await solanaRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await solanaRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_SOLANA_METHODS.SOL_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_SOLANA_METHODS.SOL_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getPolkadotActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await polkadotRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await polkadotRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getNearActions = (): AccountAction[] => {
    const onSignAndSendTransaction = async (
      chainId: string,
      address: string
    ) => {
      openRequestModal();
      await nearRpc.testSignAndSendTransaction(chainId, address);
    };
    const onSignAndSendTransactions = async (
      chainId: string,
      address: string
    ) => {
      openRequestModal();
      await nearRpc.testSignAndSendTransactions(chainId, address);
    };
    return [
      {
        method: DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTION,
        callback: onSignAndSendTransaction,
      },
      {
        method: DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTIONS,
        callback: onSignAndSendTransactions,
      },
    ];
  };

  const getMultiversxActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await multiversxRpc.testSignTransaction(chainId, address);
    };
    const onSignTransactions = async (chainId: string, address: string) => {
      openRequestModal();
      await multiversxRpc.testSignTransactions(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await multiversxRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTIONS,
        callback: onSignTransactions,
      },
      {
        method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getTronActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await tronRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await tronRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_TRON_METHODS.TRON_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_TRON_METHODS.TRON_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getTezosActions = (): AccountAction[] => {
    const onGetAccounts = async (chainId: string, address: string) => {
      openRequestModal();
      await tezosRpc.testGetAccounts(chainId, address);
    };
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await tezosRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await tezosRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_TEZOS_METHODS.TEZOS_GET_ACCOUNTS,
        callback: onGetAccounts,
      },
      {
        method: DEFAULT_TEZOS_METHODS.TEZOS_SEND,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_TEZOS_METHODS.TEZOS_SIGN,
        callback: onSignMessage,
      },
    ];
  };

  const getKadenaActions = (): AccountAction[] => {
    const testGetAccounts = async (chainId: string, address: string) => {
      openRequestModal();
      await kadenaRpc.testGetAccounts(chainId, address);
    };
    const testSign = async (chainId: string, address: string) => {
      openRequestModal();
      await kadenaRpc.testSign(chainId, address);
    };

    const testSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await kadenaRpc.testQuicksign(chainId, address);
    };

    return [
      {
        method: DEFAULT_KADENA_METHODS.KADENA_GET_ACCOUNTS,
        callback: testGetAccounts,
      },
      {
        method: DEFAULT_KADENA_METHODS.KADENA_SIGN,
        callback: testSign,
      },
      {
        method: DEFAULT_KADENA_METHODS.KADENA_QUICKSIGN,
        callback: testSignMessage,
      },
    ];
  };

  const getBip122Actions = (): AccountAction[] => {
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testSignMessage(chainId, address);
    };
    const onGetAccountAddresses = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testGetAccountAddresses(chainId, address);
    };
    const onSendTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testSendTransaction(chainId, address);
    };
    const onSignPsbt = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testSignPsbt(chainId, address);
    };
    return [
      {
        method: DEFAULT_BIP122_METHODS.BIP122_SEND_TRANSACTION,
        callback: onSendTransaction,
      },
      {
        method: DEFAULT_BIP122_METHODS.BIP122_GET_ACCOUNT_ADDRESSES,
        callback: onGetAccountAddresses,
      },
      {
        method: DEFAULT_BIP122_METHODS.BIP122_SIGN_MESSAGE,
        callback: onSignMessage,
      },
      {
        method: DEFAULT_BIP122_METHODS.BIP122_SIGN_PSBT,
        callback: onSignPsbt,
      },
    ];
  };

  const getBlockchainActions = (account: string) => {
    const [namespace, chainId, address] = account.split(":");
    switch (namespace) {
      case "eip155":
        return getEthereumActions(chainId, address);
      case "cosmos":
        return getCosmosActions();
      case "solana":
        return getSolanaActions();
      case "polkadot":
        return getPolkadotActions();
      case "near":
        return getNearActions();
      case "mvx":
        return getMultiversxActions();
      case "tron":
        return getTronActions();
      case "tezos":
        return getTezosActions();
      case "kadena":
        return getKadenaActions();
      case "bip122":
        return getBip122Actions();
      default:
        break;
    }
  };

  // Toggle between displaying testnet or mainnet chains as selection options.
  const toggleTestnets = () => {
    const nextIsTestnetState = !isTestnet;
    setIsTestnet(nextIsTestnetState);
    setLocaleStorageTestnetFlag(nextIsTestnetState);
  };

  const handleChainSelectionClick = (chainId: string) => {
    if (chains.includes(chainId)) {
      setChains(chains.filter((chain) => chain !== chainId));
    } else {
      setChains([...chains, chainId]);
    }
  };

  // Renders the appropriate model for the given request that is currently in-flight.
  const renderModal = () => {
    switch (modal) {
      case "pairing":
        if (typeof client === "undefined") {
          throw new Error("WalletConnect is not initialized");
        }
        return <PairingModal pairings={pairings} connect={connect} />;
      case "request":
        return (
          <RequestModal pending={isRpcRequestPending} result={rpcResult} />
        );
      case "ping":
        return <PingModal pending={isRpcRequestPending} result={rpcResult} />;
      case "requestLoader":
        return (
          <RequestLoaderModal
            pending={isRpcRequestPending}
            result={rpcResult}
          />
        );
      case "disconnect":
        return <LoaderModal title={"Disconnecting..."} />;
      default:
        return null;
    }
  };

  const [openSelect, setOpenSelect] = useState(false);

  const openDropdown = () => {
    setOpenSelect(!openSelect);
  };

  const renderContent = () => {
    const chainOptions = isTestnet ? DEFAULT_TEST_CHAINS : DEFAULT_MAIN_CHAINS;

    return !accounts.length && !Object.keys(balances).length ? (
      <SLanding center>
        <Banner />
        <h6>{`Using v${version || "2.0.0-beta"}`}</h6>
        <SButtonContainer>
          <h6>Select chains:</h6>
          <SToggleContainer>
            <p>Testnets Only?</p>
            <Toggle active={isTestnet} onClick={toggleTestnets} />
          </SToggleContainer>
          {chainOptions.map((chainId) => (
            <Blockchain
              key={chainId}
              chainId={chainId}
              chainData={chainData}
              onClick={handleChainSelectionClick}
              active={chains.includes(chainId)}
            />
          ))}
          <SConnectButton left onClick={onConnect} disabled={!chains.length}>
            Connect
          </SConnectButton>
          <SDropDownContainer>
            <RelayRegionDropdown
              relayerRegion={relayerRegion}
              setRelayerRegion={setRelayerRegion}
              show={openSelect}
            />
            <OriginSimulationDropdown origin={origin} show={openSelect} />
          </SDropDownContainer>
          <button onClick={openDropdown} style={{ background: "transparent" }}>
            <Icon size={30} src={"/assets/settings.svg"} />
          </button>
        </SButtonContainer>
      </SLanding>
    ) : (
      <SAccountsContainer>
        <h3>Accounts</h3>
        <SAccounts>
          {accounts.map((account) => {
            const [namespace, reference, address] = account.split(":");
            const chainId = `${namespace}:${reference}`;
            return (
              <Blockchain
                key={account}
                active
                chainData={chainData}
                fetching={isFetchingBalances}
                address={address}
                chainId={chainId}
                balances={balances}
                actions={getBlockchainActions(account)}
              />
            );
          })}
        </SAccounts>
      </SAccountsContainer>
    );
  };

  return (
    <SLayout>
      <Column maxWidth={1000} spanHeight>
        <Header
          ping={onPing}
          disconnect={onDisconnect}
          session={session}
          emit={emit}
        />
        <SContent>{isInitializing ? "Loading..." : renderContent()}</SContent>
      </Column>
      <Modal show={!!modal} closeModal={closeModal}>
        {renderModal()}
      </Modal>
    </SLayout>
  );
};

export default Home;
</file>

<file path="advanced/dapps/react-dapp-v2/src/styles/globals.css">
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
  body {
    color: white;
    background: black;
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/styles/Home.module.css">
.container {
  padding: 0 2rem;
}

.main {
  min-height: 100vh;
  padding: 4rem 0;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.footer {
  display: flex;
  flex: 1;
  padding: 2rem 0;
  border-top: 1px solid #eaeaea;
  justify-content: center;
  align-items: center;
}

.footer a {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-grow: 1;
}

.title a {
  color: #0070f3;
  text-decoration: none;
}

.title a:hover,
.title a:focus,
.title a:active {
  text-decoration: underline;
}

.title {
  margin: 0;
  line-height: 1.15;
  font-size: 4rem;
}

.title,
.description {
  text-align: center;
}

.description {
  margin: 4rem 0;
  line-height: 1.5;
  font-size: 1.5rem;
}

.code {
  background: #fafafa;
  border-radius: 5px;
  padding: 0.75rem;
  font-size: 1.1rem;
  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,
    Bitstream Vera Sans Mono, Courier New, monospace;
}

.grid {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  max-width: 800px;
}

.card {
  margin: 1rem;
  padding: 1.5rem;
  text-align: left;
  color: inherit;
  text-decoration: none;
  border: 1px solid #eaeaea;
  border-radius: 10px;
  transition: color 0.15s ease, border-color 0.15s ease;
  max-width: 300px;
}

.card:hover,
.card:focus,
.card:active {
  color: #0070f3;
  border-color: #0070f3;
}

.card h2 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.card p {
  margin: 0;
  font-size: 1.25rem;
  line-height: 1.5;
}

.logo {
  height: 1em;
  margin-left: 0.5rem;
}

@media (max-width: 600px) {
  .grid {
    width: 100%;
    flex-direction: column;
  }
}

@media (prefers-color-scheme: dark) {
  .card,
  .footer {
    border-color: #222;
  }
  .code {
    background: #111;
  }
  .logo img {
    filter: invert(1);
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/styles.ts">
export const colors: Record<string, string> = {
  white: "255, 255, 255",
  black: "0, 0, 0",
  dark: "12, 12, 13",
  grey: "169, 169, 188",
  darkGrey: "113, 119, 138",
  lightGrey: "212, 212, 212",
  blue: "101, 127, 230",
  lightBlue: "64, 153, 255",
  yellow: "250, 188, 45",
  orange: "246, 133, 27",
  green: "84, 209, 146",
  pink: "255, 51, 102",
  red: "214, 75, 71",
  purple: "110, 107, 233",
};

export const fonts = {
  size: {
    tiny: "10px",
    small: "14px",
    medium: "16px",
    large: "18px",
    h1: "60px",
    h2: "50px",
    h3: "40px",
    h4: "32px",
    h5: "24px",
    h6: "20px",
  },
  weight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
  },
  family: {
    OpenSans: `"Open Sans", sans-serif`,
  },
};

export const transitions = {
  short: "all 0.1s ease-in-out",
  base: "all 0.2s ease-in-out",
  long: "all 0.3s ease-in-out",
  button: "all 0.15s ease-in-out",
};

export const shadows = {
  soft: "0 4px 6px 0 rgba(50, 50, 93, 0.11), 0 1px 3px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
  medium:
    "0 3px 6px 0 rgba(0, 0, 0, 0.06), 0 0 1px 0 rgba(50, 50, 93, 0.02), 0 5px 10px 0 rgba(59, 59, 92, 0.08)",
  big: "0 15px 35px 0 rgba(50, 50, 93, 0.06), 0 5px 15px 0 rgba(50, 50, 93, 0.15)",
  hover:
    "0 7px 14px 0 rgba(50, 50, 93, 0.1), 0 3px 6px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
};

export const responsive = {
  xs: {
    min: "min-width: 467px",
    max: "max-width: 468px",
  },
  sm: {
    min: "min-width: 639px",
    max: "max-width: 640px",
  },
  md: {
    min: "min-width: 959px",
    max: "max-width: 960px",
  },
  lg: {
    min: "min-width: 1023px",
    max: "max-width: 1024px",
  },
  xl: {
    min: "min-width: 1399px",
    max: "max-width: 1400px",
  },
};

export const globalStyle = `

  html, body, #root {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: ${fonts.family.OpenSans};
    font-style: normal;
    font-stretch: normal;
    font-weight: ${fonts.weight.normal};
    font-size: ${fonts.size.medium};
    background-color: rgb(${colors.white});
    color: rgb(${colors.dark});
    overflow-y:auto;
    text-rendering: optimizeLegibility;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  	-webkit-text-size-adjust: 100%;
    -webkit-overflow-scrolling: touch;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;  
  }

  button {
    border-style: none;
    line-height: 1em;
    background-image: none;
    outline: 0;
    -webkit-box-shadow: none;
            box-shadow: none;
  }

  [tabindex] {
    outline: none;
    width: 100%;
    height: 100%;
  }

  a, p, h1, h2, h3, h4, h5, h6 {
  	text-decoration: none;
  	margin: 0;
    padding: 0;
    margin: 0.7em 0;
  }

  h1 {
    font-size: ${fonts.size.h1}
  }
  h2 {
    font-size: ${fonts.size.h2}
  }
  h3 {
    font-size: ${fonts.size.h3}
  }
  h4 {
    font-size: ${fonts.size.h4}
  }
  h5 {
    font-size: ${fonts.size.h5}
  }
  h6 {
    font-size: ${fonts.size.h6}
  }

  a {
    background-color: transparent;
    -webkit-text-decoration-skip: objects;  
    text-decoration: none;
    color: inherit;
    outline: none;
  }

  b,
  strong {
    font-weight: inherit;
    font-weight: bolder;
  }

  ul, li {
  	list-style: none;
  	margin: 0;
  	padding: 0;
  }

  * {
    box-sizing: border-box !important;
  }


  input {
    -webkit-appearance: none;
  }

  article,
  aside,
  details,
  figcaption,
  figure,
  footer,
  header,
  main,
  menu,
  nav,
  section,
  summary {
    display: block;
  }
  audio,
  canvas,
  progress,
  video {
    display: inline-block;
  }

  input[type="color"],
  input[type="date"],
  input[type="datetime"],
  input[type="datetime-local"],
  input[type="email"],
  input[type="month"],
  input[type="number"],
  input[type="password"],
  input[type="search"],
  input[type="tel"],
  input[type="text"],
  input[type="time"],
  input[type="url"],
  input[type="week"],
  select:focus,
  textarea {
    font-size: 16px;
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2/.env.local.example">
NEXT_PUBLIC_PROJECT_ID=39bc...
NEXT_PUBLIC_RELAY_URL=wss://relay.walletconnect.com
</file>

<file path="advanced/dapps/react-dapp-v2/.eslintrc.json">
{
  "extends": "next/core-web-vitals",
  "rules": {
    "no-trailing-spaces": 1,
    "@next/next/no-img-element": "off"
  },
  "overrides": [
		{
			"extends": ["plugin:package-json/recommended"],
			"files": ["package.json"],
			"parser": "jsonc-eslint-parser",
			"plugins": ["package-json"]
		}
	]
}
</file>

<file path="advanced/dapps/react-dapp-v2/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="advanced/dapps/react-dapp-v2/.prettierignore">
.changeset
coverage
.idea
.next
node_modules
</file>

<file path="advanced/dapps/react-dapp-v2/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  distDir: "build",
  webpack(config) {
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
    };

    return config;
  },
};

module.exports = nextConfig;
</file>

<file path="advanced/dapps/react-dapp-v2/package.json">
{
  "name": "react-dapp-v2-next",
  "version": "2.3.3",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prettier": "prettier --check '**/*.{js,ts,jsx,tsx}'",
    "prettier:write": "prettier --write '**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@celo/wallet-base": "^5.1.1",
    "@ethereumjs/tx": "^3.5.0",
    "@kadena/client": "^0.5.0",
    "@kadena/cryptography-utils": "^0.4.0",
    "@kadena/pactjs": "^0.4.3",
    "@kadena/types": "^0.6.0",
    "@multiversx/sdk-core": "12.18.0",
    "@multiversx/sdk-wallet": "4.2.0",
    "@noble/curves": "^1.8.1",
    "@noble/secp256k1": "^2.2.3",
    "@polkadot/util-crypto": "^10.1.2",
    "@solana/web3.js": "^1.36.0",
    "@walletconnect/core": "^2.19.1",
    "@walletconnect/encoding": "^1.0.1",
    "@walletconnect/jsonrpc-utils": "^1.0.8",
    "@walletconnect/sign-client": "2.19.2",
    "@walletconnect/types": "2.19.2",
    "@walletconnect/utils": "2.19.2",
    "@web3modal/standalone": "2.4.3",
    "axios": "^1.0.0",
    "bitcoinjs-lib": "^6.1.5",
    "bitcoinjs-message": "^2.2.0",
    "blockies-ts": "^1.0.0",
    "bs58": "^5.0.0",
    "cosmos-wallet": "^1.2.0",
    "eth-sig-util": "^2.5.3",
    "ethereumjs-util": "^7.0.6",
    "ethers": "^5.3.0",
    "fp-ts": "^2.13.1",
    "next": "14.2.25",
    "prop-types": "^15.7.2",
    "qr-image": "^3.2.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hot-toast": "^2.4.1",
    "react-scripts": "^4.0.3",
    "solana-wallet": "^1.0.1",
    "styled-components": "^6.1.15",
    "tronweb": "^4.4.0",
    "web-vitals": "^0.2.4"
  },
  "devDependencies": {
    "@types/eth-sig-util": "^2.1.1",
    "@types/jest": "^27.4.0",
    "@types/node": "^17.0.14",
    "@types/pino": "^7.0.5",
    "@types/prop-types": "^15.7.4",
    "@types/qr-image": "^3.2.5",
    "@types/react": "18.0.15",
    "@types/react-dom": "18.0.6",
    "@types/styled-components": "^5.1.34",
    "eslint": "8.21.0",
    "eslint-config-next": "14.2.25",
    "eslint-plugin-package-json": "^0.13.1",
    "jsonc-eslint-parser": "^2.4.0",
    "pino-pretty": "^13.0.0",
    "prettier": "^2.8.8",
    "typescript": "^4.7.4"
  },
  "pnpm": {
    "overrides": {
      "node-forge@<1.0.0": ">=1.0.0",
      "node-forge@<1.3.0": ">=1.3.0",
      "ejs@<3.1.7": ">=3.1.7",
      "browserslist@>=4.0.0 <4.16.5": ">=4.16.5",
      "loader-utils@>=2.0.0 <2.0.3": ">=2.0.3",
      "postcss@<8.4.31": ">=8.4.31",
      "next@>=0.9.9 <13.4.20-canary.13": ">=13.4.20-canary.13",
      "yaml@>=2.0.0-5 <2.2.2": ">=2.2.2",
      "loader-utils@>=2.0.0 <2.0.4": ">=2.0.4",
      "nth-check@<2.0.1": ">=2.0.1",
      "shell-quote@<=1.7.2": ">=1.7.3",
      "minimist@<0.2.1": ">=0.2.1",
      "minimatch@<3.0.5": ">=3.0.5",
      "webpack-dev-middleware@<=5.3.3": ">=5.3.4",
      "immer@>=7.0.0 <9.0.6": ">=9.0.6",
      "tar@<6.2.1": ">=6.2.1",
      "minimist@<0.2.4": ">=0.2.4",
      "axios@>=0.8.1 <0.28.0": ">=0.28.0",
      "tough-cookie@<4.1.3": ">=4.1.3",
      "protobufjs@>=7.0.0 <7.2.5": ">=7.2.5",
      "protobufjs@>=6.10.0 <6.11.4": ">=6.11.4",
      "braces@<3.0.3": ">=3.0.3",
      "ejs@<3.1.10": ">=3.1.10",
      "ws@>=2.1.0 <5.2.4": ">=5.2.4",
      "micromatch@<4.0.8": ">=4.0.8",
      "rollup@<2.79.2": ">=2.79.2",
      "http-proxy-middleware@<2.0.7": ">=2.0.7",
      "next@>=10.0.0 <14.2.7": ">=14.2.7",
      "cross-spawn@>=7.0.0 <7.0.5": ">=7.0.5",
      "semver@>=7.0.0 <7.5.2": ">=7.5.2",
      "next@>=9.5.5 <14.2.15": ">=14.2.15",
      "ansi-html@<0.0.8": ">=0.0.8",
      "axios@<1.8.2": ">=1.8.2"
    }
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/README.md">
# React dApp (with standalone v2 client)

🔗 Live dapp demo - https://react-app.walletconnect.com/ <br />
🔗 Live wallet demo - https://react-wallet.walletconnect.com/ <br />
📚 WalletConnect v2 Docs - https://docs.walletconnect.com/2.0

## Overview

This is an example implementation of a React dApp (generated via `create-react-app`) using the standalone
client for WalletConnect v2 to:

- handle pairings
- manage sessions
- send JSON-RPC requests to a paired wallet

## Running locally

Install the app's dependencies:

```bash
yarn
```

Set up your local environment variables by copying the example into your own `.env.local` file:

```bash
cp .env.local.example .env.local
```

Your `.env.local` now contains the following environment variables:

- `NEXT_PUBLIC_PROJECT_ID` (placeholder) - You can generate your own ProjectId at https://cloud.walletconnect.com
- `NEXT_PUBLIC_RELAY_URL` (already set)

## Develop

```bash
yarn dev
```

## Test

```bash
yarn test
```

## Build

```bash
yarn build
```
</file>

<file path="advanced/dapps/react-dapp-v2/tsconfig.json">
{
  "compilerOptions": {
    "target": "es2015",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
</file>

</files>
