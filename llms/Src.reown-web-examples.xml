This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    pr_checks.yml
    ui_tests.yml
advanced/
  dapps/
    chain-abstraction-demo/
      app/
        hooks/
          useGiftDonut.tsx
        globals.css
        layout.tsx
        page.tsx
      components/
        assets/
          CoinSVG.tsx
          GiftSVG.tsx
          NetworkSVG.tsx
        gift-donut-modal-views/
          CheckoutReceipentAddressView.tsx
          CheckoutView.tsx
          ChooseNetworkView.tsx
          index.tsx
          PayWithView.tsx
        purchase-donut-modal-views/
          CheckoutView.tsx
          ErrorView.tsx
          PaymentOptions.tsx
          PaymentOptionsView.tsx
          RecieptView.tsx
        ui/
          badge.tsx
          button.tsx
          card.tsx
          dialog.tsx
          drawer.tsx
          input.tsx
          label.tsx
          separator.tsx
          sonner.tsx
          tooltip.tsx
        BalanceDisplay.tsx
        CheckWalletToast.tsx
        ConnectWalletButton.tsx
        DonutImage.tsx
        DonutInfo.tsx
        GiftDonutButton.tsx
        GiftDonutModal.tsx
        GiftDonutModalTrigger.tsx
        Navbar.tsx
        PurchaseDonutButton.tsx
        theme-provider.tsx
        TransactionToast.tsx
        WalletCheckoutModal.tsx
      config/
        checkoutViews.ts
        index.tsx
      consts/
        tokens.ts
      context/
        index.tsx
      controllers/
        GiftDonutModalManager.ts
        WalletCheckoutModalManager.ts
      data/
        CheckoutPaymentAssets.ts
        EIP155Data.ts
      hooks/
        use-media-query.ts
        useWalletCheckout.ts
        useWalletGetAssets.ts
      lib/
        utils.ts
      public/
        .well-known/
          walletconnect.txt
      types/
        ERC5792.ts
        ERC7811.ts
        wallet_checkout.ts
      utils/
        BalanceFetcherUtil.ts
        FormatterUtil.ts
        NetworksUtil.ts
        WalletCheckoutUtil.ts
      .env.example
      .eslintrc.json
      .gitignore
      components.json
      next.config.mjs
      package.json
      postcss.config.mjs
      README.md
      tailwind.config.ts
      tsconfig.json
    chat-demo-agent/
      public/
        .well-known/
          walletconnect.txt
      src/
        app/
          api/
            send-message/
              request-validation.ts
              route.ts
            signer/
              route.ts
          globals.css
          layout.tsx
          page.tsx
          provider.tsx
          theme-provider.tsx
        components/
          chat-components/
            ChatHeader.tsx
            ChatInterface.tsx
            ChatMessage.tsx
            ConnectionScreen.tsx
            Header.tsx
            MessageArea.tsx
            MessageInput.tsx
          ui/
            alert.tsx
            button.tsx
            dropdown-menu.tsx
            scroll-area.tsx
            toast.tsx
            toaster.tsx
          ConnectWalletButton.tsx
        config/
          constants.ts
        context/
          ChatContext.tsx
        errors/
          api-errors.ts
        hooks/
          use-chat.ts
          use-toast.ts
        lib/
          services/
            1inch.ts
            blockchainapi.ts
            openai.ts
            swap.ts
          chatApi.ts
          utils.ts
        reducers/
          chatReducer.ts
        types/
          chat/
            types.ts
          1inch.ts
          api.ts
        utils/
          ChainUtil.ts
          ChatContants.ts
          ChatSmartSessionsPermissionsUtil.ts
          CommonUtils.ts
          ConstantsUtil.ts
          ERC7715PermissionsAsyncUtils.ts
          messageUtils.ts
          UserOpBuilderServiceUtils.ts
      .env.example
      .gitignore
      .node-version
      components.json
      eslint.config.mjs
      next.config.ts
      package.json
      postcss.config.mjs
      tailwind.config.ts
      tsconfig.json
      wrangler.json
    react-dapp-v2/
      src/
        chains/
          bip122.ts
          cosmos.ts
          eip155.ts
          index.ts
          kadena.ts
          multiversx.ts
          near.ts
          polkadot.ts
          solana.ts
          tezos.ts
          tron.ts
        components/
          app/
            index.tsx
          shared/
            index.ts
          Asset.tsx
          Banner.tsx
          Blockchain.tsx
          Button.tsx
          Column.tsx
          Header.tsx
          Icon.tsx
          Loader.tsx
          Metadata.tsx
          Modal.tsx
          OriginSimulationDropdown.tsx
          Pairing.tsx
          Peer.tsx
          RelayRegionDropdown.tsx
          Toggle.tsx
          Wrapper.tsx
        constants/
          default.ts
          index.ts
        contexts/
          ChainDataContext.tsx
          ClientContext.tsx
          JsonRpcContext.tsx
        helpers/
          api.ts
          bip122.ts
          eip1271.ts
          eip712.ts
          index.ts
          kadena.ts
          namespaces.ts
          solana.ts
          tx.ts
          types.ts
          utilities.ts
        modals/
          shared/
            index.ts
          LoaderModal.tsx
          PairingModal.tsx
          PingModal.tsx
          RequestLoaderModal.tsx
          RequestModal.tsx
        pages/
          _app.tsx
          _error.tsx
          404.tsx
          index.tsx
        styles/
          globals.css
          Home.module.css
        styles.ts
      .env.local.example
      .eslintrc.json
      .gitignore
      .prettierignore
      next.config.js
      package.json
      README.md
      tsconfig.json
    react-dapp-v2-cosmos-provider/
      public/
        index.html
        manifest.json
      src/
        chains/
          cosmos.ts
          eip155.ts
          index.ts
          polkadot.ts
        components/
          app/
            index.tsx
          shared/
            index.ts
          Asset.tsx
          Banner.tsx
          Blockchain.tsx
          Button.tsx
          Column.tsx
          Header.tsx
          Icon.tsx
          Loader.tsx
          Metadata.tsx
          Modal.tsx
          Pairing.tsx
          Peer.tsx
          Toggle.tsx
          Wrapper.tsx
        constants/
          default.ts
          index.ts
        contexts/
          ClientContext.tsx
        helpers/
          api.ts
          eip1271.ts
          eip712.ts
          index.ts
          tx.ts
          types.ts
          utilities.ts
        modals/
          shared/
            index.ts
          PairingModal.tsx
          PingModal.tsx
          RequestModal.tsx
        pages/
          _app.tsx
          _error.tsx
          404.tsx
          index.tsx
        styles/
          globals.css
          Home.module.css
        react-app-env.d.ts
        styles.ts
      .env.local.example
      .gitignore
      .prettierrc
      images.d.ts
      LICENSE
      next-env.d.ts
      next.config.js
      package.json
      README.md
      tsconfig.json
    react-dapp-v2-with-ethers/
      public/
        index.html
        manifest.json
      src/
        chains/
          cosmos.ts
          eip155.ts
          index.ts
          polkadot.ts
        components/
          app/
            index.tsx
          shared/
            index.ts
          Asset.tsx
          Banner.tsx
          Blockchain.tsx
          Button.tsx
          Column.tsx
          Header.tsx
          Icon.tsx
          Loader.tsx
          Metadata.tsx
          Modal.tsx
          Pairing.tsx
          Peer.tsx
          Toggle.tsx
          Wrapper.tsx
        constants/
          default.ts
          index.ts
        contexts/
          ClientContext.tsx
        helpers/
          api.ts
          eip1271.ts
          eip712.ts
          index.ts
          tx.ts
          types.ts
          utilities.ts
        modals/
          shared/
            index.ts
          PairingModal.tsx
          PingModal.tsx
          RequestModal.tsx
        pages/
          _app.tsx
          _error.tsx
          404.tsx
          index.tsx
        react-app-env.d.ts
        styles.ts
      .env.local.example
      .gitignore
      .prettierrc
      images.d.ts
      LICENSE
      next-env.d.ts
      next.config.js
      package.json
      README.md
      tsconfig.json
    smart-sessions-demo/
      public/
        .well-known/
          walletconnect.txt
      src/
        app/
          api/
            dca/
              execute/
                route.ts
            signer/
              route.ts
            tictactoe/
              create/
                route.ts
              make-move/
                system/
                  route.ts
                user/
                  route.ts
          demo/
            dca/
              page.tsx
            tictactoe/
              page.tsx
          globals.css
          HomePage.tsx
          layout.tsx
          page.tsx
        components/
          DcaComponents/
            AddressDisplay.tsx
            AssetAllocationField.tsx
            AssetBalance.tsx
            AssetToBuyField.tsx
            Dashboard.tsx
            DCA.tsx
            DCAExecutionProgress.tsx
            DCAForm.tsx
            InvestmentIntervalField.tsx
            NotConnectedScreen.tsx
            NumberOfOrdersField.tsx
          TicTacToeComponents/
            DisplayPlayerScore.tsx
            PositionSquare.tsx
            StartGameButton.tsx
            TicTacToe.tsx
            TicTacToeBoard.tsx
          ui/
            button.tsx
            card.tsx
            form.tsx
            input.tsx
            label.tsx
            progress.tsx
            select.tsx
            separator.tsx
            sonner.tsx
            tabs.tsx
            tooltip.tsx
          ConnectWalletButton.tsx
          DemoApplicationList.tsx
        context/
          DcaApplicationContextProvider.tsx
          TicTacToeContextProvider.tsx
        hooks/
          useDCA.ts
          useLocalStorageState.ts
          useTicTacToeActions.ts
        lib/
          utils.ts
        schema/
          DCAFormSchema.ts
        utils/
          ChainsUtil.ts
          CommonUtils.ts
          ConstantsUtil.ts
          DataUtil.ts
          DCAUtils.ts
          DonutContract.ts
          EncodingUtils.ts
          ERC7715PermissionsAsyncUtils.ts
          LocalStorage.ts
          TicTacToeAbi.ts
          TicTacToeUtils.ts
          UserOpBuilderServiceUtils.ts
      .env.example
      .gitignore
      components.json
      eslint.config.mjs
      next.config.mjs
      package.json
      postcss.config.mjs
      README.md
      tailwind.config.ts
      tsconfig.json
  wallets/
    react-wallet-v2/
      public/
        main.css
      src/
        components/
          PaymentCheckout/
            visual/
              BadgeAlertIcon.tsx
              BadgeCheckIcon.tsx
              GiftIcon.tsx
              OrderDetailIcon.tsx
              WalletIcon.tsx
            GenericDropdown.tsx
            NetworkDropdown.tsx
            SelectedPaymentDetails.tsx
            TokenDropdown.tsx
          AccountCard.tsx
          AccountPicker.tsx
          AccountSelectCard.tsx
          ChainAbstractionBalanceCard.tsx
          ChainAddressMini.tsx
          ChainCard.tsx
          ChainDataMini.tsx
          ChainSmartAddressMini.tsx
          Layout.tsx
          Modal.tsx
          ModalFooter.tsx
          ModuleActions.tsx
          MultibridgeRequestModal.tsx
          Navigation.tsx
          OrderInfoCard.tsx
          PageHeader.tsx
          PairingCard.tsx
          PaymentOptions.tsx
          PermissionDetailsCard.tsx
          Products.tsx
          ProjectInfoCard.tsx
          ProposalSelectSection.tsx
          QrReader.tsx
          RelayRegionPicker.tsx
          RequestDataCard.tsx
          RequestDetalilsCard.tsx
          RequestMethodCard.tsx
          RequestModal.tsx
          RequestModalContainer.tsx
          RouteTransition.tsx
          SessionCard.tsx
          SessionChainCard.tsx
          SessionProposalChainCard.tsx
          VerifyInfobox.tsx
        consts/
          smartAccounts.ts
        data/
          Bip122Data.ts
          chainsUtil.ts
          COSMOSData.ts
          EIP155Data.ts
          EIP5792Data.ts
          EIP7715Data.ts
          EIP7811Data.ts
          ERC7579ModuleData.ts
          KadenaData.ts
          MultiversxData.ts
          NEARData.ts
          PolkadotData.ts
          RelayerRegions.ts
          SolanaData.ts
          TezosData.ts
          tokenUtil.ts
          TronData.ts
        hooks/
          useInitialization.ts
          usePriorityAccounts.ts
          useSmartAccounts.ts
          useWalletConnectEventsManager.ts
        lib/
          smart-accounts/
            builders/
              ContextBuilderUtil.ts
              CosignerService.ts
              SafeUserOpBuilder.ts
              SmartSessionUtil.ts
              UserOpBuilder.ts
              UserOpBuilderUtil.ts
            BiconomySmartAccountLib.ts
            KernelSmartAccountLib.ts
            SafeSmartAccountLib.ts
            SmartAccountLib.ts
          Bip122Lib.ts
          CosmosLib.ts
          EIP155Lib.ts
          KadenaLib.ts
          MultiversxLib.ts
          NearLib.ts
          PolkadotLib.ts
          SolanaLib.ts
          TezosLib.ts
          TronLib.ts
        pages/
          accounts/
            [eip155Address]/
              modules/
                [module]/
                  index.tsx
              index.tsx
          api/
            wallet.ts
          _app.tsx
          account.tsx
          index.tsx
          pairings.tsx
          session.tsx
          sessions.tsx
          settings.tsx
          walletconnect.tsx
          wc.tsx
        schema/
          WalletCheckoutSchema.ts
        store/
          ModalStore.ts
          SettingsStore.ts
          WalletCheckoutCtrl.ts
        types/
          wallet_checkout.ts
        utils/
          Bip122RequestHandlerUtil.ts
          Bip122WalletUtil.ts
          ChainAbstractionService.ts
          ChainUtil.ts
          ConstantsUtil.ts
          CosmosRequestHandler.ts
          CosmosWalletUtil.ts
          EIP155RequestHandlerUtil.ts
          EIP155WalletUtil.ts
          EIP5792RequestHandlerUtils.ts
          EIP5792WalletUtil.ts
          EIP7715RequestHandlerUtils.ts
          ERC7579AccountUtils.ts
          HelperUtil.ts
          KadenaRequestHandlerUtil.ts
          KadenaWalletUtil.ts
          MultibridgeUtil.ts
          MultiversxRequestHandlerUtil.ts
          MultiversxWalletUtil.ts
          NearRequestHandlerUtil.ts
          NearWalletUtil.ts
          PaymentValidatorUtil.ts
          PolkadotRequestHandlerUtil.ts
          PolkadotWalletUtil.ts
          SmartAccountUtil.ts
          SolanaRequestHandlerUtil.ts
          SolanaWalletUtil.ts
          TezosRequestHandlerUtil.ts
          TezosWalletUtil.ts
          TransactionSimulatorUtil.ts
          TronRequestHandlerUtil.ts
          TronWalletUtil.ts
          UserOpBuilderUtil.ts
          WalletCheckoutPaymentHandler.ts
          WalletCheckoutUtil.ts
          WalletConnectUtil.ts
        views/
          LoadingModal.tsx
          ModulesManagement.tsx
          OwnableValidatorActions.tsx
          OwnableValidatorAddOwnerAction.tsx
          OwnableValidatorInstallAction.tsx
          OwnableValidatorSetThresholdAction.tsx
          OwnableValidatorUninstallAction.tsx
          SessionAuthenticateModal.tsx
          SessionCheckoutModal.tsx
          SessionGetBip122AddressesModal.tsx
          SessionGrantPermissionsModal.tsx
          SessionProposalModal.tsx
          SessionSendCallsModal.tsx
          SessionSendTransactionBip122Modal.tsx
          SessionSendTransactionModal.tsx
          SessionSignBip122Modal.tsx
          SessionSignCosmosModal.tsx
          SessionSignKadenaModal.tsx
          SessionSignModal.tsx
          SessionSignMultiversxModal.tsx
          SessionSignNearModal.tsx
          SessionSignPolkadotModal.tsx
          SessionSignSolanaModal.tsx
          SessionSignTezosModal.tsx
          SessionSignTronModal.tsx
          SessionSignTypedDataModal.tsx
          SessionUnsuportedMethodModal.tsx
          TheatPrompt.tsx
      .env.local.example
      .eslintrc.json
      .gitignore
      .prettierignore
      .prettierrc.json
      docker-compose.yaml
      next-env.d.ts
      next.config.js
      package.json
      README.md
      tsconfig.json
dapps/
  README.md
.gitignore
LICENSE
README.md
renovate.json
roadmap.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/pr_checks.yml">
name: PR Checks

concurrency:
  # Support push/pr as event types with different behaviors each:
  # 1. push: queue up builds
  # 2. pr: only allow one run per PR
  group: ${{ github.workflow }}-${{ github.event.type }}${{ github.event.pull_request.number }}
  # If there is already a workflow running for the same pull request, cancel it
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_TEAM_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.UI_TEST_WALLET_V2_VERCEL_PROJECT_ID }}

on:
  pull_request:
    paths:
      - "advanced/wallets/react-wallet-v2/**"
      - "advanced/dapps/react-dapp-v2/**"

jobs:
  code_style:
    name: "Code Style"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        style-command:
          - lint
          - prettier
        project:
          - dapps/react-dapp-v2
          - wallets/react-wallet-v2
    steps:
      - name: checkout
        uses: actions/checkout@v3
      - name: setup-node
        uses: actions/setup-node@v3
        with:
          node-version: 18.x
      - name: install
        working-directory: advanced/${{ matrix.project }}
        run: yarn install --immutable --immutable-cache --check-cache
      - name: check
        working-directory: advanced/${{ matrix.project }}
        run: yarn ${{ matrix.style-command }}

  ui-test:
    name: "UI Tests"
    uses: ./.github/workflows/ui_tests.yml
    secrets: inherit
</file>

<file path=".github/workflows/ui_tests.yml">
name: UI Tests

on: workflow_call

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_TEAM_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.UI_TEST_WALLET_V2_VERCEL_PROJECT_ID }}

jobs:
  preview:
    name: "Preview deployment"
    runs-on: ubuntu-latest
    outputs:
      preview-url: ${{ steps.preview.outputs.PREVIEW_URL }}
    steps:
      - uses: actions/checkout@v4
      - name: Install Vercel CLI
        run: npm install --global vercel@latest
      - name: Pull Vercel Environment Information
        run: vercel pull --yes --environment=preview --token=${{ secrets.UI_TEST_VERCEL_TOKEN }}
      - name: Build Project Artifacts
        run: vercel build --token=${{ secrets.UI_TEST_VERCEL_TOKEN }}
      - name: Deploy Project Artifacts to Vercel
        run: vercel deploy --prebuilt --token=${{ secrets.UI_TEST_VERCEL_TOKEN }} > preview.txt
      - name: preview
        id: preview
        run: echo "PREVIEW_URL=$(cat preview.txt | tail -n 1)" >> "$GITHUB_OUTPUT"

  ui-test:
    needs: preview
    with:
      base-url: http://localhost:3000/
      wallet-url: ${{ needs.preview.outputs.preview-url }}/
      skip-playwright-webserver: false
      branch: main
      command: playwright:test:wallet
    uses: WalletConnect/web3modal/.github/workflows/ui_tests.yml@main
    secrets:
      NEXT_PUBLIC_PROJECT_ID: ${{ secrets.UI_TEST_PROJECT_ID }}
      TESTS_NEXTAUTH_SECRET: ${{ secrets.TESTS_NEXTAUTH_SECRET }}
      TESTS_MAILSEC_API_KEY: ${{ secrets.MAILSAC_API_KEY }}
</file>

<file path="advanced/dapps/chain-abstraction-demo/app/hooks/useGiftDonut.tsx">
import { config } from "@/config";
import { tokenAddresses } from "@/consts/tokens";
import { Network, Token } from "@/data/EIP155Data";
import { toast } from "sonner";
import { erc20Abi, Hex, PublicClient } from "viem";
import { getAccount, getWalletClient, getPublicClient } from "wagmi/actions";
import { useState } from "react";
import { TransactionToast } from "@/components/TransactionToast";

type TransactionStatus = "waiting-approval" | "pending" | "success" | "error";

export default function useGiftDonut() {
  const [isPending, setIsPending] = useState(false);

  const updateToast = (
    toastId: ReturnType<typeof toast>,
    status: TransactionStatus,
    {
      elapsedTime,
      hash,
      networkName,
    }: {
      elapsedTime?: number;
      hash?: string;
      networkName?: string;
    } = {},
  ) => {
    toast(
      <TransactionToast
        status={status}
        elapsedTime={elapsedTime}
        hash={hash}
        networkName={networkName}
      />,
      { id: toastId },
    );
  };

  const validateTransaction = async (network: Network) => {
    const client = await getWalletClient(config, { chainId: network.chainId });
    const publicClient = getPublicClient(config);
    if (!publicClient) throw new Error("Failed to get public client");

    const account = getAccount(config);
    const connectedChainId = account.chain?.id;

    if (!connectedChainId) throw new Error("Chain undefined");
    if (connectedChainId !== network.chainId) {
      throw new Error(
        "Please switch chain, connected chain does not match network",
      );
    }

    return { client, publicClient };
  };

  const getTokenContract = (token: Token, chainId: number) => {
    const tokenChainMapping = tokenAddresses[token.name];
    if (!tokenChainMapping) throw new Error("Token not supported");

    const contract = tokenChainMapping[chainId];
    if (!contract) throw new Error("Can't send on specified chain");

    return contract;
  };

  const giftDonutAsync = async (
    to: Hex,
    donutCount: number,
    token: Token,
    network: Network,
  ) => {
    setIsPending(true);
    const startTime = Date.now();
    const toastId = toast(<TransactionToast status="waiting-approval" />);
    let updateInterval: ReturnType<typeof setInterval>;

    try {
      // Validate chain and get clients
      const { client, publicClient } = await validateTransaction(network);
      const chainId = getAccount(config).chain?.id!;

      // Get token contract
      const contract = getTokenContract(token, chainId);
      
      // Calculate token amount using token's decimals
      const tokenAmount = donutCount * 10 ** token.decimals;
      // Start tracking elapsed time
      updateInterval = setInterval(() => {
        updateToast(toastId, "waiting-approval", {
          elapsedTime: Math.floor((Date.now() - startTime) / 1000),
        });
      }, 1000);

      // Send transaction
      const tx = await client.writeContract({
        abi: erc20Abi,
        address: contract,
        functionName: "transfer",
        args: [to, BigInt(tokenAmount)],
      });

      // Update to pending status
      updateToast(toastId, "pending", { hash: tx, networkName: network.name });

      // Wait for transaction
      const receipt = await publicClient.waitForTransactionReceipt({
        hash: tx,
      });
      clearInterval(updateInterval);

      // Update final status
      const finalElapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      const finalStatus = receipt.status === "success" ? "success" : "error";

      updateToast(toastId, finalStatus, {
        elapsedTime: finalElapsedSeconds,
        hash: tx,
        networkName: network.name,
      });

      return tx;
    } catch (e) {
      clearInterval(updateInterval!);
      const finalElapsedSeconds = Math.floor((Date.now() - startTime) / 1000);

      if (e instanceof Error) {
        updateToast(toastId, "error", { elapsedTime: finalElapsedSeconds });
      }
      console.error(e);
    } finally {
      setIsPending(false);
    }
  };

  return { giftDonutAsync, isPending };
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --tertiary-foreground: rgba(244, 244, 244, 1);
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 10% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
    
    /* Custom variables from component */
    --foreground-foreground-secondary: rgba(230, 230, 230, 1);
    --foreground-foreground-accent-primary-010: rgba(9, 136, 240, 0.1);
    --text-text-accent-primary: rgba(9, 136, 240, 1);
    --border-border-secondary: rgba(200, 200, 200, 1);
  }
  
  .dark {
    --background: 0 0% 13%;
    --foreground: 0 0% 15%;
    --invert: 0 0% 13%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 100%;
    --primary-foreground: 0 0% 15%;
    --secondary: 0 0% 60%;
    --secondary-foreground: 0 0% 98%;
    --tertiary-foreground: rgba(54, 54, 54, 1);
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 207, 93%, 49%, 0.2;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    
    /* Custom variables from component */
    --foreground-foreground-secondary: rgba(42, 42, 42, 1);
    --foreground-foreground-accent-primary-010: rgba(9, 136, 240, 0.1);
    --text-text-accent-primary: rgba(9, 136, 240, 1);
    --border-border-secondary: rgba(79, 79, 79, 1);
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Additional utility classes for common patterns in the component */
@layer components {
  .rounded-button {
    @apply h-8 w-8 rounded-full p-0;
    background-color: var(--tertiary-foreground);
  }
  
  .payment-option-badge {
    @apply flex gap-1 p-1 rounded-full text-sm items-center;
    background-color: var(--tertiary-foreground);
  }
  
  .icon-container {
    @apply w-10 h-10 rounded-full flex items-center justify-center;
    background-color: var(--foreground-foreground-secondary);
  }
  
  .accent-button {
    background: var(--foreground-foreground-accent-primary-010);
  }
  
  .accent-text {
    color: var(--text-text-accent-primary);
  }
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import AppKitProvider from "@/context";
import { cn } from "@/lib/utils";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "@/components/ui/sonner";

const inter = Inter({
  subsets: ["latin"],
  display: "swap",
});

export const metadata: Metadata = {
  title: "Chain Abstraction Demo",
  description: "Demo dapp for chain abstraction UX demonstration",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head />
      <body
        className={cn(
          "min-h-screen bg-background font-sans antialiased overflow-y-auto",
          inter.className,
        )}
      >
        <AppKitProvider>
          <ThemeProvider
            attribute="class"
            defaultTheme="dark"
            disableTransitionOnChange
          >
            <div className="flex justify-center min-h-screen">{children}</div>
          </ThemeProvider>
        </AppKitProvider>
        <Toaster expand={true} />
      </body>
    </html>
  );
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/app/page.tsx">
"use client";

import * as React from "react";
import Image from "next/image";
import { ConnectWalletButton } from "@/components/ConnectWalletButton";
import { useAppKitAccount } from "@reown/appkit/react";
import Navbar from "@/components/Navbar";
import { GiftDonutModalTrigger } from "@/components/GiftDonutModalTrigger";
import PurchaseDonutButton from "@/components/PurchaseDonutButton";
import { useWalletCheckout } from "@/hooks/useWalletCheckout";

export default function Home() {
  const { status, address } = useAppKitAccount();
  const { isWalletCheckoutSupported, } = useWalletCheckout()

  return (
    <div className="sm:w-1/2 flex flex-col sm:mx-10">
      <Navbar />
      <div className="flex flex-col justify-center gap-4 mt-8">
        <div className="flex items-center justify-center h-64 relative ">
          <Image
            src="/donut-cover.png"
            alt="Gift Donut"
            className="object-cover"
            fill={true}
          />
        </div>
        <div className="flex flex-col gap-5">
          <div className="flex flex-col text-left">
            <p className=" font-bold text-primary">Donut #1</p>
            <p className=" text-secondary">Gift Donut lets you send virtual donuts to friends using stable coins for a fun.</p>
          </div>
          <div className="flex justify-between items-center w-full">
            <div className="flex flex-col text-left">
              <p className=" text-secondary">Price</p>
              <p className=" font-bold text-primary">$1.00</p>
            </div>
            {status === "connected" || address ? (
              <div className="flex gap-2">
                <GiftDonutModalTrigger
                  triggerText="Gift Donut"
                  initialView="Checkout"
                  className="bg-blue-500 hover:bg-blue-700 text-invert"
                />
                {isWalletCheckoutSupported && <PurchaseDonutButton />}
              </div>
            ) : (
              <div>
                <ConnectWalletButton />
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/assets/CoinSVG.tsx">
export default function CoinSVG() {
  return (
    <svg
      width="16"
      height="11"
      viewBox="0 0 16 11"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M11.5 3.09812V2.75C11.5 1.1825 9.13562 0 6 0C2.86438 0 0.5 1.1825 0.5 2.75V5.25C0.5 6.55562 2.14062 7.59313 4.5 7.90375V8.25C4.5 9.8175 6.86438 11 10 11C13.1356 11 15.5 9.8175 15.5 8.25V5.75C15.5 4.45625 13.9113 3.4175 11.5 3.09812ZM3.5 6.67937C2.27562 6.3375 1.5 5.77437 1.5 5.25V4.37063C2.01 4.73187 2.69313 5.02313 3.5 5.21875V6.67937ZM8.5 5.21875C9.30688 5.02313 9.99 4.73187 10.5 4.37063V5.25C10.5 5.77437 9.72437 6.3375 8.5 6.67937V5.21875ZM7.5 9.67937C6.27563 9.3375 5.5 8.77437 5.5 8.25V7.98938C5.66437 7.99563 5.83063 8 6 8C6.2425 8 6.47937 7.99187 6.71187 7.97812C6.97016 8.07059 7.23325 8.14904 7.5 8.21313V9.67937ZM7.5 6.89062C7.00338 6.96399 6.50201 7.00055 6 7C5.49799 7.00055 4.99662 6.96399 4.5 6.89062V5.40375C4.99736 5.46856 5.49843 5.50071 6 5.5C6.50157 5.50071 7.00264 5.46856 7.5 5.40375V6.89062ZM11.5 9.89062C10.5053 10.0365 9.49468 10.0365 8.5 9.89062V8.4C8.9972 8.46684 9.49833 8.50025 10 8.5C10.5016 8.50071 11.0026 8.46856 11.5 8.40375V9.89062ZM14.5 8.25C14.5 8.77437 13.7244 9.3375 12.5 9.67937V8.21875C13.3069 8.02312 13.99 7.73187 14.5 7.37062V8.25Z"
        fill="white"
      />
    </svg>
  );
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/assets/GiftSVG.tsx">
export default function GiftSvg() {
  return (
    <svg
      width="21"
      height="20"
      viewBox="0 0 21 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M18.75 5.75H15.4613C15.4978 5.71906 15.5353 5.68906 15.5709 5.65625C15.8557 5.40329 16.0851 5.0943 16.245 4.74861C16.4049 4.40292 16.4917 4.02796 16.5 3.64718C16.5123 3.23063 16.4394 2.81595 16.2856 2.42861C16.1319 2.04127 15.9006 1.68944 15.606 1.39471C15.3113 1.09999 14.9596 0.868599 14.5723 0.714741C14.185 0.560882 13.7703 0.487806 13.3538 0.499997C12.9728 0.508201 12.5977 0.594951 12.2518 0.754816C11.906 0.91468 11.5968 1.14422 11.3438 1.42906C10.9936 1.8349 10.7089 2.29291 10.5 2.78656C10.2911 2.29291 10.0064 1.8349 9.65625 1.42906C9.40318 1.14422 9.09405 0.91468 8.74818 0.754816C8.40232 0.594951 8.02718 0.508201 7.64625 0.499997C7.22969 0.487806 6.81503 0.560882 6.42774 0.714741C6.04044 0.868599 5.68868 1.09999 5.39405 1.39471C5.09941 1.68944 4.86812 2.04127 4.71438 2.42861C4.56064 2.81595 4.48768 3.23063 4.5 3.64718C4.50833 4.02796 4.59514 4.40292 4.755 4.74861C4.91486 5.0943 5.14434 5.40329 5.42906 5.65625C5.46469 5.68718 5.50219 5.71718 5.53875 5.75H2.25C1.85218 5.75 1.47064 5.90803 1.18934 6.18934C0.908035 6.47064 0.75 6.85217 0.75 7.25V10.25C0.75 10.6478 0.908035 11.0294 1.18934 11.3107C1.47064 11.592 1.85218 11.75 2.25 11.75V17.75C2.25 18.1478 2.40804 18.5294 2.68934 18.8107C2.97064 19.092 3.35218 19.25 3.75 19.25H17.25C17.6478 19.25 18.0294 19.092 18.3107 18.8107C18.592 18.5294 18.75 18.1478 18.75 17.75V11.75C19.1478 11.75 19.5294 11.592 19.8107 11.3107C20.092 11.0294 20.25 10.6478 20.25 10.25V7.25C20.25 6.85217 20.092 6.47064 19.8107 6.18934C19.5294 5.90803 19.1478 5.75 18.75 5.75ZM12.4688 2.42281C12.5875 2.29167 12.7321 2.1865 12.8934 2.1139C13.0547 2.0413 13.2293 2.00284 13.4062 2.00093H13.4522C13.6595 2.00223 13.8645 2.0449 14.0552 2.12644C14.2458 2.20798 14.4183 2.32675 14.5624 2.47579C14.7066 2.62483 14.8195 2.80115 14.8947 2.99441C14.9698 3.18766 15.0056 3.39397 15 3.60125C14.9981 3.77815 14.9596 3.95275 14.887 4.11408C14.8144 4.27541 14.7093 4.42 14.5781 4.53875C13.6884 5.32625 12.2119 5.60375 11.2969 5.70125C11.4094 4.70843 11.7188 3.26562 12.4688 2.42281ZM6.46031 2.45656C6.75088 2.16602 7.14441 2.00194 7.55531 2H7.60125C7.77815 2.0019 7.95275 2.04037 8.11409 2.11297C8.27542 2.18556 8.42 2.29073 8.53875 2.42187C9.32531 3.31062 9.60281 4.78437 9.70031 5.69562C8.78906 5.60187 7.31531 5.32062 6.42656 4.53406C6.29543 4.41531 6.19026 4.27073 6.11766 4.1094C6.04506 3.94806 6.0066 3.77346 6.00469 3.59656C5.99887 3.38584 6.03593 3.17614 6.11361 2.98018C6.19128 2.78421 6.30796 2.60607 6.45656 2.45656H6.46031ZM2.25 7.25H9.75V10.25H2.25V7.25ZM3.75 11.75H9.75V17.75H3.75V11.75ZM17.25 17.75H11.25V11.75H17.25V17.75ZM18.75 10.25H11.25V7.25H18.75V10.25Z"
        fill="#9A9A9A"
      />
    </svg>
  );
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/assets/NetworkSVG.tsx">
export default function NetworkSVG() {
  return (
    <svg
      width="14"
      height="13"
      viewBox="0 0 14 13"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M14 6C14 6.13261 13.9473 6.25979 13.8536 6.35355C13.7598 6.44732 13.6326 6.5 13.5 6.5H11.5V8.5H12C12.2652 8.5 12.5196 8.60536 12.7071 8.79289C12.8946 8.98043 13 9.23478 13 9.5V11.5C13 11.7652 12.8946 12.0196 12.7071 12.2071C12.5196 12.3946 12.2652 12.5 12 12.5H10C9.73478 12.5 9.48043 12.3946 9.29289 12.2071C9.10536 12.0196 9 11.7652 9 11.5V9.5C9 9.23478 9.10536 8.98043 9.29289 8.79289C9.48043 8.60536 9.73478 8.5 10 8.5H10.5V6.5H3.5V8.5H4C4.26522 8.5 4.51957 8.60536 4.70711 8.79289C4.89464 8.98043 5 9.23478 5 9.5V11.5C5 11.7652 4.89464 12.0196 4.70711 12.2071C4.51957 12.3946 4.26522 12.5 4 12.5H2C1.73478 12.5 1.48043 12.3946 1.29289 12.2071C1.10536 12.0196 1 11.7652 1 11.5V9.5C1 9.23478 1.10536 8.98043 1.29289 8.79289C1.48043 8.60536 1.73478 8.5 2 8.5H2.5V6.5H0.5C0.367392 6.5 0.240215 6.44732 0.146447 6.35355C0.0526784 6.25979 0 6.13261 0 6C0 5.86739 0.0526784 5.74021 0.146447 5.64645C0.240215 5.55268 0.367392 5.5 0.5 5.5H6.5V4H6C5.73478 4 5.48043 3.89464 5.29289 3.70711C5.10536 3.51957 5 3.26522 5 3V1C5 0.734784 5.10536 0.48043 5.29289 0.292893C5.48043 0.105357 5.73478 0 6 0H8C8.26522 0 8.51957 0.105357 8.70711 0.292893C8.89464 0.48043 9 0.734784 9 1V3C9 3.26522 8.89464 3.51957 8.70711 3.70711C8.51957 3.89464 8.26522 4 8 4H7.5V5.5H13.5C13.6326 5.5 13.7598 5.55268 13.8536 5.64645C13.9473 5.74021 14 5.86739 14 6Z"
        fill="white"
      />
    </svg>
  );
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/gift-donut-modal-views/CheckoutReceipentAddressView.tsx">
import {
  giftDonutModalManager,
  GiftDonutModalViewProps,
} from "@/controllers/GiftDonutModalManager";
import { Button } from "../ui/button";
import Image from "next/image";
import React from "react";
import { cn } from "@/lib/utils";
import { ArrowLeft, ChevronLeft, Copy, UserRound, X } from "lucide-react";
import { Input } from "../ui/input";
import GiftSvg from "../assets/GiftSVG";
import useGiftDonut from "@/app/hooks/useGiftDonut";
import { toast } from "sonner";

function CheckoutReceipentAddressView({
  onViewChange,
  onClose,
}: GiftDonutModalViewProps) {
  return (
    <div>
      <GiftDonutForm onClose={onClose} onViewChange={onViewChange} />
    </div>
  );
}

interface GiftDonutFormProps extends React.ComponentProps<"form"> {
  onViewChange: (viewKey: string) => void;
  onClose: () => void;
}

function GiftDonutForm({
  className,
  onViewChange,
  onClose,
}: GiftDonutFormProps) {
  const donutCount = giftDonutModalManager.getDonutCount();
  const recipient = giftDonutModalManager.getRecipient();
  const [recipientAddress, setRecipientAddress] = React.useState(
    recipient || "",
  );
  const { giftDonutAsync, isPending } = useGiftDonut();

  const setRecipient = (address: string) => {
    setRecipientAddress(address);
    giftDonutModalManager.setRecipient(address);
  };

  const handleCheckout = async () => {
    try {
      const to = recipientAddress as `0x${string}`;
      const token = giftDonutModalManager.getToken();
      const network = giftDonutModalManager.getNetwork();
      if (!network) {
        throw new Error("Network not selected");
      }

      // Start the transaction before closing the modal
      const giftPromise = giftDonutAsync(to, donutCount, token, network);
      onClose(); // Close modal after initiating transaction
      await giftPromise; // Wait for transaction to complete
    } catch (e) {
      console.error(e);
      if (e instanceof Error) {
        toast.error(e.message);
      }
    }
  };

  return (
    <div
      className={cn("flex flex-col items-start gap-4 text-primary", className)}
    >
      <div className="grid grid-cols-3 items-center w-full">
        <div className="flex justify-start">
          <Button variant="ghost" onClick={() => onViewChange("Checkout")}>
            <ChevronLeft className="h-4 w-4" />
          </Button>
        </div>
        <div className="col-start-2 col-end-3 text-center">
          <h1>Gift Donut</h1>
        </div>
        <div className="col-start-3 flex justify-end">
          <Button variant="ghost" onClick={onClose}>
            <X className="h-4 w-4" />
          </Button>
        </div>
      </div>
      <div className="flex flex-col items-center gap-2 w-full bg-primary-foreground p-4 rounded-3xl">
        <div className="flex items-center gap-2 w-full">
          <Image
            src="/donut-cover.png"
            alt="Gift Donut"
            width={80}
            height={80}
            className="rounded-lg"
          />
          <div className="flex flex-col gap-2 w-full h-full">
            <p className="text-xl font-bold">Donut #1</p>
            <div className="grid grid-cols-2">
              <div className="flex flex-col">
                <p className="text-xs text-secondary">Price</p>
                <span className="text-lg font-bold">$1.00</span>
              </div>
              <div className="flex flex-col">
                <p className="text-xs text-secondary">Qty</p>
                <span className="text-lg font-bold">{donutCount}</span>
              </div>
            </div>
          </div>
        </div>
        <hr
          style={{
            background: "var(--border-border-primary, rgba(42, 42, 42, 1))",
          }}
          className="w-full border-t"
        />
        <div className="flex justify-between w-full ">
          <p className="text-xl text-secondary">Total</p>
          <div className="flex flex-col">
            <p className="text-xl font-bold">
              ${(donutCount * 1.0).toFixed(2)}
            </p>
            <p className="flex justify-end text-xs text-secondary">(+fee)</p>
          </div>
        </div>
      </div>

      <div className="flex flex-col w-full gap-4 bg-primary-foreground p-4 rounded-3xl">
        <div className="flex w-10 h-10 items-center justify-center">
          <GiftSvg />
        </div>
        <p className="text-secondary text-base">Send to </p>
        <div className="relative w-full">
          <UserRound className="w-4 h-4 absolute top-1/2 left-3 transform -translate-y-1/2 text-gray-500" />
          <Input
            type="text"
            placeholder="Type address"
            value={recipientAddress}
            onChange={(e) => setRecipient(e.target.value)}
            className="px-10 py-2 w-full rounded-s border h-16 bg-background"
          />
          <Copy className="w-4 h-4 absolute top-1/2 right-3 transform -translate-y-1/2 text-gray-500" />
        </div>
      </div>
      <div className="flex gap-2 w-full">
        <button
          onClick={() => onViewChange("Checkout")}
          type="button"
          style={{
            border:
              "1px solid var(--border-border-secondary, rgba(79, 79, 79, 1))",
          }}
          className="flex flex-1 text-primary items-center justify-center border-secondary rounded-lg"
        >
          <p className="flex items-center">
            <ArrowLeft className="w-4 h-4" />
            Back
          </p>
        </button>
        <Button
          style={{
            background:
              "var(--foreground-foreground-accent-primary-010, rgba(9, 136, 240, 0.1))",
          }}
          disabled={!recipientAddress}
          onClick={handleCheckout}
          type="button"
          variant="secondary"
          className="flex flex-1 gap-1"
        >
          <p
            className="flex items-center"
            style={{
              color: "var(--text-text-accent-primary, rgba(9, 136, 240, 1))",
            }}
          >
            Checkout
          </p>
        </Button>
      </div>
    </div>
  );
}

export default CheckoutReceipentAddressView;
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/gift-donut-modal-views/CheckoutView.tsx">
import {
  giftDonutModalManager,
  GiftDonutModalViewProps,
} from "@/controllers/GiftDonutModalManager";
import { Button } from "../ui/button";
import Image from "next/image";
import React from "react";
import { cn } from "@/lib/utils";
import { AlertTriangle, ArrowRight, ChevronRight, X } from "lucide-react";
import CoinSVG from "../assets/CoinSVG";
import NetworkSVG from "../assets/NetworkSVG";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "../ui/tooltip";

function CheckoutView({ onViewChange, onClose }: GiftDonutModalViewProps) {
  return (
    <div>
      <GiftDonutForm onClose={onClose} onViewChange={onViewChange} />
    </div>
  );
}

interface GiftDonutFormProps extends React.ComponentProps<"form"> {
  onViewChange: (viewKey: string) => void;
  onClose: () => void;
}

function GiftDonutForm({
  className,
  onViewChange,
  onClose,
}: GiftDonutFormProps) {
  const donutCount = giftDonutModalManager.getDonutCount();
  const [count, setCount] = React.useState(donutCount);

  const selectedToken = giftDonutModalManager.getToken();
  const selectedNetwork = giftDonutModalManager.getNetwork();
  const tokenBalance = giftDonutModalManager.getBalanceBySymbol(selectedToken.name);
  const maxDonutPurchasable = Math.trunc(parseFloat(tokenBalance) / 1.0);
  
  // If there's a selected network but the token is not compatible, automatically redirect
  React.useEffect(() => {
    if (selectedNetwork && !giftDonutModalManager.isTokenNetworkCompatible()) {
      // We need to change the network since this token isn't supported here
      onViewChange("ChooseNetwork");
    }
  }, [selectedToken, selectedNetwork, onViewChange]);

  // Allow any count >= 0.
  const setDonutCount = (newCount: number) => {
    if (newCount < 0) return;
    setCount(newCount);
    giftDonutModalManager.setDonutCount(newCount);
  };

  // Check whether the selected count exceeds the available balance.
  const isExceeded = count > maxDonutPurchasable;

  return (
    <div className={cn("flex flex-col items-start gap-4", className)}>
      <div className="grid grid-cols-3 items-center w-full">
        <div className="col-start-2 col-end-3 text-center">
          <h1 className="text-primary">Gift Donut</h1>
        </div>
        <div className="col-start-3 flex justify-end">
          <Button variant="ghost" onClick={onClose}>
            <X className="text-primary h-4 w-4" />
          </Button>
        </div>
      </div>
      <div className="flex items-center gap-2 w-full bg-primary-foreground p-4 rounded-3xl">
        <Image src="/donut-cover.png" alt="Gift Donut" width={80} height={80} />
        <div className="flex flex-col gap-2 w-full h-full">
          <p className="text-primary font-bold">Donut #1</p>
          <div className="flex flex-col">
            <div className="flex items-center justify-between mb-1">
              <p className="text-secondary">Price</p>
              <Button
                variant="link"
                size="sm"
                onClick={() => setDonutCount(maxDonutPurchasable)}
                className="text-xs h-auto p-0 text-secondary hover:text-primary"
              >
                Max: {maxDonutPurchasable}
              </Button>
            </div>
            <div className="flex items-center justify-between">
              <p className="text-primary font-bold">$1.00</p>
              <div className="flex items-center text-primary">
                <Button
                  variant="outline"
                  onClick={() => setDonutCount(count - 1)}
                  className="rounded-button"
                  disabled={count <= 0}
                >
                  -
                </Button>
                <div className="w-8 text-center">{count}</div>
                <Button
                  variant="outline"
                  onClick={() => setDonutCount(count + 1)}
                  className="rounded-button"
                >
                  +
                </Button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div className="flex items-center flex-col gap-2 w-full text-primary">
        <div className="flex w-full items-center gap-2">
          <div className="icon-container">
            <CoinSVG />
          </div>
          <div className="flex flex-1 items-center justify-between">
            <p>Pay with</p>
            <div className="flex gap-4 items-center justify-between cursor-pointer">
              <div
                className="payment-option-badge"
                onClick={() => onViewChange("PayWith")}
              >
                {selectedToken && (
                  <div className="rounded-full">
                    <Image
                      src={selectedToken.icon}
                      alt="Token"
                      width={14}
                      height={14}
                      className="object-contain rounded-full"
                    />
                  </div>
                )}
                <p>{selectedToken ? selectedToken.name : "Pay with"}</p>
              </div>
              <ChevronRight className="w-4 h-4" />
            </div>
          </div>
        </div>
        <div className="flex w-full items-center gap-2">
          <div className="icon-container">
            <NetworkSVG />
          </div>
          <div className="flex flex-1 items-center justify-between">
            <p>Choose Network</p>
            <div className="flex gap-4 items-center justify-between cursor-pointer">
              <div
                className="payment-option-badge"
                onClick={() => onViewChange("ChooseNetwork")}
              >
                {selectedNetwork && (
                  <div className="rounded-full">
                    <Image
                      src={selectedNetwork.icon}
                      alt="Network"
                      width={14}
                      height={14}
                      className="object-contain rounded-full"
                    />
                  </div>
                )}
                {selectedNetwork ? selectedNetwork.name : "Choose network"}
              </div>
              <ChevronRight className="w-4 h-4" />
            </div>
          </div>
        </div>
      </div>
      {/* Total Section Updated with Tooltip and Warning Icon */}
      <div className="flex justify-between w-full items-center">
        <p className="text-secondary">Total</p>
        {isExceeded ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <div className="flex items-center gap-2">
                  <AlertTriangle className="h-4 w-4 text-yellow-500" />
                  <p className="text-md font-bold text-yellow-500">
                    ${(count * 1.0).toFixed(2)}
                  </p>
                </div>
              </TooltipTrigger>
              <TooltipContent className="bg-primary-foreground">
                <p className="text-xs text-primary">
                  Warning: Your selected count exceeds your token balance
                </p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : (
          <p className="text-md font-bold text-primary">
            ${(count * 1.0).toFixed(2)}
          </p>
        )}
      </div>
      <div className="flex gap-2 w-full">
        <button
          onClick={onClose}
          type="button"
          className="flex flex-1 text-primary items-center justify-center border border-border-secondary rounded-lg"
        >
          Cancel
        </button>
        <Button
         style={{
          background: "var(--foreground-foreground-accent-primary-010, rgba(9, 136, 240, 0.1))",
        }}
          onClick={() => {
            // If token and network are incompatible, redirect to network selection
            if (!giftDonutModalManager.isTokenNetworkCompatible()) {
              onViewChange("ChooseNetwork");
            } else {
              onViewChange("CheckoutReceipentAddress");
            }
          }}
          type="button"
          variant="secondary"
          className="flex flex-1 gap-1"
          disabled={!giftDonutModalManager.isTokenNetworkCompatible()}
        >
          <p
            className="flex items-center"
            style={{ color: "var(--text-text-accent-primary, rgba(9, 136, 240, 1))" }}
          >
            {!giftDonutModalManager.isTokenNetworkCompatible() ? "Choose Network" : "Next"} <ArrowRight className="w-4 h-4" />
          </p>
        </Button>
      </div>
    </div>
  );
}

export default CheckoutView;
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/gift-donut-modal-views/ChooseNetworkView.tsx">
import { Network, supportedNetworks } from "@/data/EIP155Data";
import { Separator } from "../ui/separator";
import React from "react";
import Image from "next/image";
import { Label } from "../ui/label";
import { CheckIcon, ChevronLeft, X } from "lucide-react";
import { cn } from "@/lib/utils";
import {
  giftDonutModalManager,
  GiftDonutModalViewProps,
} from "@/controllers/GiftDonutModalManager";
import { Button } from "../ui/button";
import { useAppKitNetwork } from "@reown/appkit/react";
import { toast } from "sonner";
import { getSupportedNetworks } from "@/consts/tokens";

function ChooseNetworkView({ onViewChange, onClose }: GiftDonutModalViewProps) {
  return (
    <div className={cn("flex flex-col items-start gap-4 text-primary")}>
      <div className="grid grid-cols-3 items-center w-full">
        <div className="flex justify-start">
          <Button variant="ghost" onClick={() => onViewChange("Checkout")}>
            <ChevronLeft className="h-4 w-4" />
          </Button>
        </div>
        <div className="col-end-3 text-center">
          <h1>Choose network</h1>
        </div>
        <div className="flex justify-end">
          <Button variant="ghost" onClick={onClose}>
            <X className="h-4 w-4" />
          </Button>
        </div>
      </div>
      <NetworkList className="w-full" />
    </div>
  );
}

function NetworkList({ className }: React.ComponentProps<"form">) {
  const selectedToken = giftDonutModalManager.getToken();
  const tokenSupportedNetworks = getSupportedNetworks(selectedToken.name);
  const { switchNetwork, caipNetwork } = useAppKitNetwork();

  // Initialize network state based on caipNetwork
  const [network, setNetwork] = React.useState<Network | undefined>(() => {
    const currentChainId = caipNetwork?.id;
    if (!currentChainId) return undefined;

    // Find the matching network from supported networks
    const matchingNetwork = supportedNetworks.find(
      (net) =>
        net.chainId === currentChainId &&
        tokenSupportedNetworks.includes(net.chainId),
    );

    // If found, set it in the modal manager
    if (matchingNetwork) {
      giftDonutModalManager.setNetwork(matchingNetwork);
    }

    return matchingNetwork;
  });

  const setSelectedNetwork = (network: Network) => {
    setNetwork(network);
    giftDonutModalManager.setNetwork(network);
    if (caipNetwork?.id !== network.chainId) {
      switchNetwork(network.chain);
      toast.info(
        `Switching Network from ${caipNetwork?.name || "current network"} to ${network.name}`,
      );
    }
  };

  // Filter supported networks
  const filteredNetworks = supportedNetworks.filter((network) =>
    tokenSupportedNetworks.includes(network.chainId),
  );

  return (
    <div className={cn("flex flex-col items-start gap-4", className)}>
      {filteredNetworks.map((networkItem, index) => (
        <div key={networkItem.chainId} className="w-full">
          <NetworkItem
            network={networkItem}
            selected={network?.chainId === networkItem.chainId}
            onClick={() => setSelectedNetwork(networkItem)}
            isCurrentNetwork={caipNetwork?.id === networkItem.chainId}
          />
          {index < filteredNetworks.length - 1 && <Separator />}
        </div>
      ))}
    </div>
  );
}

function NetworkItem({
  network,
  selected,
  onClick,
  isCurrentNetwork,
}: {
  network: Network;
  selected: boolean;
  onClick: () => void;
  isCurrentNetwork: boolean;
}) {
  return (
    <button
      className={cn(
        "w-full p-3 rounded-lg transition-colors",
        "hover:bg-primary-foreground/50",
        "flex items-center gap-3",
      )}
      onClick={onClick}
    >
      <div className="w-10 h-10 rounded-full flex items-center justify-center">
        <Image
          src={network.icon}
          alt={network.name}
          width={40}
          height={40}
          className="rounded-full"
        />
      </div>
      <div className="flex flex-1 items-center justify-between">
        <div className="flex flex-col items-start">
          <Label className="font-medium">{network.name}</Label>
          {isCurrentNetwork && (
            <span className="text-xs text-muted-foreground">
              Current Network
            </span>
          )}
        </div>
        {selected && <CheckIcon className="h-5 w-5 text-green-500" />}
      </div>
    </button>
  );
}

export default ChooseNetworkView;
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/gift-donut-modal-views/index.tsx">
import CheckoutView from "./CheckoutView";
import CheckoutReceipentAddressView from "./CheckoutReceipentAddressView";
import ChooseNetworkView from "./ChooseNetworkView";
import PayWithkView from "./PayWithView";

// Default Views with clear type annotations
export const GiftDonutModalViews = {
  Checkout: CheckoutView,
  ChooseNetwork: ChooseNetworkView,
  PayWith: PayWithkView,
  CheckoutReceipentAddress: CheckoutReceipentAddressView,
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/gift-donut-modal-views/PayWithView.tsx">
import { supportedTokens, Token, isTokenSupportedOnNetwork } from "@/data/EIP155Data";
import { Separator } from "../ui/separator";
import React from "react";
import Image from "next/image";
import { Label } from "../ui/label";
import { CheckIcon, ChevronLeft, X } from "lucide-react";
import { cn } from "@/lib/utils";
import {
  giftDonutModalManager,
  GiftDonutModalViewProps,
} from "@/controllers/GiftDonutModalManager";
import { Button } from "../ui/button";

function PayWithView({ onViewChange, onClose }: GiftDonutModalViewProps) {
  return (
    <div className={cn("flex flex-col items-start gap-4 text-primary")}>
      <div className="grid grid-cols-3 items-center w-full">
        <div className="flex justify-start">
          <Button variant="ghost" onClick={() => onViewChange("Checkout")}>
            <ChevronLeft className="h-4 w-4" />
          </Button>
        </div>
        <div className="col-end-3 text-center">
          <h1>Pay with</h1>
        </div>
        <div className="flex justify-end">
          <Button variant="ghost" onClick={onClose}>
            <X className="h-4 w-4" />
          </Button>
        </div>
      </div>
      
      <TokenList className="w-full" onViewChange={onViewChange} />
    </div>
  );
}

function TokenList({ 
  className, 
  onViewChange 
}: React.ComponentProps<"form"> & { onViewChange: (viewKey: string) => void }) {
  const selectedToken = giftDonutModalManager.getToken();
  const selectedNetwork = giftDonutModalManager.getNetwork();
  const [token, setToken] = React.useState<Token | undefined>(selectedToken);
  
  // Filter tokens based on network compatibility
  const availableTokens = React.useMemo(() => {
    if (!selectedNetwork) {
      return supportedTokens; // If no network selected, show all tokens
    }
    
    // Filter tokens to only those supported on the selected network
    return supportedTokens.filter(token => 
      isTokenSupportedOnNetwork(token, selectedNetwork.chainId)
    );
  }, [selectedNetwork]);

  const setSelectedToken = (token: Token) => {
    setToken(token);
    giftDonutModalManager.setToken(token);
  };

  // If no tokens are available for the selected network, show a message
  if (availableTokens.length === 0 && selectedNetwork) {
    return (
      <div className={cn("flex flex-col items-center text-center gap-4 p-4", className)}>
        <p className="text-primary">No supported tokens found for {selectedNetwork.name}.</p>
        <Button onClick={() => onViewChange("ChooseNetwork")}>
          Choose Another Network
        </Button>
      </div>
    );
  }

  return (
    <div className={cn("flex flex-col items-start gap-4", className)}>
      {availableTokens.map((tokenItem, index) => (
        <div key={index} className="w-full">
          <TokenItem
            token={tokenItem}
            selected={token?.address === tokenItem.address}
            onClick={() => setSelectedToken(tokenItem)}
          />
          {availableTokens.length - 1 !== index && <Separator />}
        </div>
      ))}
    </div>
  );
}

function TokenItem({
  token,
  selected,
  onClick,
}: {
  token: Token;
  selected: boolean;
  onClick: () => void;
}) {
  const balance = giftDonutModalManager.getBalanceBySymbol(token.name);
  const formattedBalance = parseFloat(balance).toFixed(4);

  return (
    <button
      className={cn(
        "w-full p-3 rounded-lg transition-colors",
        "hover:bg-primary-foreground/50",
        "flex items-center gap-3",
      )}
      onClick={onClick}
    >
      <div className="w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center">
        <Image
          src={token.icon}
          alt={token.name}
          width={40}
          height={40}
          className="rounded-full"
        />
      </div>
      <div className="flex flex-1 items-center justify-between">
        <div className="flex flex-col items-start gap-0.5">
          <Label className="font-medium">{token.name}</Label>
          <span className="text-xs text-muted-foreground">
            Balance: ${formattedBalance}
          </span>
        </div>
        {selected && <CheckIcon className="h-5 w-5 text-green-500" />}
      </div>
    </button>
  );
}

export default PayWithView;
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/purchase-donut-modal-views/CheckoutView.tsx">
"use client";

import React from "react";
import { useSnapshot } from "valtio";
import { Button } from "@/components/ui/button";
import { Loader2, X, ArrowRight, Wallet2 } from "lucide-react";
import { useWalletCheckout } from "@/hooks/useWalletCheckout";
import { WalletCheckoutModalViewProps } from "@/controllers/WalletCheckoutModalManager";
import { walletCheckoutManager } from "@/controllers/WalletCheckoutModalManager";
import Image from "next/image";
import { PaymentOptions } from "@/components/purchase-donut-modal-views/PaymentOptions";

export const CheckoutView: React.FC<WalletCheckoutModalViewProps> = ({ onClose, onViewChange }) => {
  const { isWalletCheckoutSupported } = useWalletCheckout();
  const snap = useSnapshot(walletCheckoutManager.getState());
  
  const handleCheckout = async () => {
    await walletCheckoutManager.executeCheckout();
  };
  
  const { product, itemCount, isLoading, paymentOptions } = snap.state;
  const priceValue = parseFloat(product.price.replace('$', ''));
  const totalPrice = (priceValue * itemCount).toFixed(2);
  
  const hasSelectedPaymentOptions = paymentOptions.length > 0;
  
  return (
    <div className="flex flex-col items-start gap-4">
      {/* Header */}
      <div className="grid grid-cols-3 items-center w-full">
        <div className="col-start-2 col-end-3 text-center">
          <h1 className="text-primary">Checkout</h1>
        </div>
        <div className="col-start-3 flex justify-end">
          <Button variant="ghost" onClick={onClose}>
            <X className="text-primary h-4 w-4" />
          </Button>
        </div>
      </div>
      
      {/* Product Card */}
      <div className="flex items-center gap-2 w-full bg-primary-foreground p-4 rounded-3xl">
        <Image 
          src="/donut.png" 
          alt={product.name} 
          width={80} 
          height={80}
          className="object-cover rounded-md"
        />
        <div className="flex flex-col gap-2 w-full h-full">
          <p className="text-primary font-bold">{product.name}</p>
          <div className="flex flex-col">
            <div className="flex items-center justify-between mb-1">
              <p className="text-secondary">Price</p>
              <Button
                variant="link"
                size="sm"
                className="text-xs h-auto p-0 text-secondary hover:text-primary"
              >
                {product.price} each
              </Button>
            </div>
            <div className="flex items-center justify-between">
              <p className="text-primary font-bold">Quantity</p>
              <div className="flex items-center text-primary">
                <div className="w-8 text-center">{itemCount}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Payment Details Section with PaymentOptions component */}
      <div className="flex items-center flex-col gap-2 w-full text-primary">
        <div className="flex w-full items-center gap-2">
          <div className="icon-container">
            <Wallet2 className="w-4 h-4" />
          </div>
          <div className="flex flex-1 items-center justify-between">
            <p>Payment Options</p>
            <div className="flex gap-4 items-center justify-between">
              <PaymentOptions />
            </div>
          </div>
        </div>
      </div>
      
      {/* Total Section */}
      <div className="flex justify-between w-full items-center mt-2">
        <p className="text-secondary">Total</p>
        <p className="text-md font-bold text-primary">
          ${totalPrice}
        </p>
      </div>
      
      {/* Buttons */}
      <div className="flex gap-2 w-full">
        <button
          onClick={onClose}
          type="button"
          className="flex flex-1 text-primary items-center justify-center border border-border-secondary rounded-lg p-2"
        >
          Cancel
        </button>
        <Button
          onClick={handleCheckout}
          type="button"
          className="flex flex-1 gap-1 accent-button"
          disabled={isLoading || !isWalletCheckoutSupported || !hasSelectedPaymentOptions}
        >
          <p className="flex items-center accent-text">
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" /> 
                Processing...
              </>
            ) : (
              <>
                Complete Payment <ArrowRight className="w-4 h-4 ml-1" />
              </>
            )}
          </p>
        </Button>
      </div>
    </div>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/purchase-donut-modal-views/ErrorView.tsx">
"use client";

import React, { useEffect } from "react";
import { useSnapshot } from "valtio";
import { Button } from "@/components/ui/button";
import { AlertTriangle, X, ArrowRight } from "lucide-react";
import { walletCheckoutManager, WalletCheckoutModalViewProps } from "@/controllers/WalletCheckoutModalManager";
import { CheckoutErrorCode } from "@/types/wallet_checkout";

// Error View
export const ErrorView: React.FC<WalletCheckoutModalViewProps> = ({ onClose, onViewChange }) => {
  const snap = useSnapshot(walletCheckoutManager.getState());
  const { error } = snap.state;
  
  // Determine the error message to display
  const getErrorMessage = () => {
    // If there's an error object with code and message properties (CheckoutError)
    if (error && typeof error === 'object' && 'code' in error && 'message' in error) {
      const typedError = error as { code: number; message: string };
      
      // Handle known error codes with user-friendly messages
      switch (typedError.code) {
        case CheckoutErrorCode.USER_REJECTED:
          return "You cancelled the transaction.";
        case CheckoutErrorCode.NO_MATCHING_ASSETS:
          return "You don't have any of the required assets for this payment.";
        case CheckoutErrorCode.CHECKOUT_EXPIRED:
          return "This payment request has expired. Please try again.";
        case CheckoutErrorCode.INSUFFICIENT_FUNDS:
          return "You don't have enough funds to complete this payment.";
        case CheckoutErrorCode.METHOD_NOT_FOUND:
          return "Your wallet doesn't support this payment method.";
        case CheckoutErrorCode.UNSUPPORTED_CONTRACT_INTERACTION:
          return "This payment method is not supported for this contract.";
        case CheckoutErrorCode.INVALID_CONTRACT_INTERACTION_DATA:
          return "The contract interaction data is invalid.";
        case CheckoutErrorCode.CONTRACT_INTERACTION_FAILED:
          return "The contract interaction failed.";
        default:
          return typedError.message || "Transaction failed.";
      }
    }
    
    // If there's an error object with a message property
    if (error && typeof error === 'object' && 'message' in error) {
      return (error as { message: string }).message;
    }
    
    // If error is a string, return it directly
    if (typeof error === 'string') {
      return error;
    }
    
    // Default error message
    return "The transaction could not be completed. Please try again.";
  };

  const errorMessage = getErrorMessage();
  
  return (
    <div className="flex flex-col items-start gap-4">
      {/* Header */}
      <div className="grid grid-cols-3 items-center w-full">
        <div className="col-start-2 col-end-3 text-center">
          <h1 className="text-primary">Checkout Error</h1>
        </div>
        <div className="col-start-3 flex justify-end">
          <Button variant="ghost" onClick={onClose}>
            <X className="text-primary h-4 w-4" />
          </Button>
        </div>
      </div>
      
      {/* Error Message Card */}
      <div className="w-full bg-primary-foreground p-4 rounded-3xl">
        <div className="flex flex-col text-center gap-3">
          <div className="flex flex-col items-center gap-2">
            <div className="icon-container bg-red-100">
              <AlertTriangle className="h-6 w-6 text-red-600" />
            </div>
            <h3 className="text-lg font-medium text-red-600">Transaction Failed</h3>
          </div>
          
          <div className="mt-2 text-primary">
            <p>{errorMessage}</p>
          </div>
        </div>
      </div>
      
      {/* Buttons */}
      <div className="flex gap-2 w-full">
        <button
          onClick={onClose}
          type="button"
          className="flex flex-1 text-primary items-center justify-center border border-border-secondary rounded-lg p-2"
        >
          Cancel
        </button>
        <Button
          onClick={() => onViewChange('checkout')}
          type="button"
          className="flex flex-1 gap-1 accent-button"
        >
          <p className="flex items-center accent-text">
            Try Again <ArrowRight className="w-4 h-4 ml-1" />
          </p>
        </Button>
      </div>
    </div>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/purchase-donut-modal-views/PaymentOptions.tsx">
"use client";

import React, { useEffect } from "react";
import Image from "next/image";
import { useWalletCheckout } from "@/hooks/useWalletCheckout";
import { Plus } from "lucide-react";
import { walletCheckoutManager } from "@/controllers/WalletCheckoutModalManager";
import { useSnapshot } from "valtio";
import { supportedPaymentsAsset, getChainLogoUrl } from "@/data/CheckoutPaymentAssets";

export const PaymentOptions: React.FC = () => {
  const { getPreConfiguredPaymentsOptions } = useWalletCheckout();
  const snap = useSnapshot(walletCheckoutManager.getState());
  
  const availableAssets = snap.state.availableAssets || [];
  const selectedAssetIds = snap.state.paymentOptions.map(option => option.asset);
  const selectedAssets = availableAssets.filter(asset => 
    selectedAssetIds.includes(asset.id)
  );

  useEffect(() => {
    const fetchPaymentOptions = async () => {
      try {
        const options = await getPreConfiguredPaymentsOptions();
        
        // Filter available assets based on payment options
        const availableAssetIds = options.map(option => option.asset);
        const filteredAssets = supportedPaymentsAsset.filter(
          asset => availableAssetIds.includes(asset.id)
        );
        
        walletCheckoutManager.setAvailableAssets(filteredAssets);
        
        // If there are no payment options set yet, initialize with the first available option
        if (walletCheckoutManager.getPaymentOptions().length === 0 && options.length > 0) {
          // Select the first payment option by default
          const defaultOption = [options[0]];
          walletCheckoutManager.setPaymentOptions(defaultOption);
        }
        
        walletCheckoutManager.setAllPaymentOptions(options);
      } catch (error) {
        console.error("Error fetching payment options:", error);
      }
    };
    
    fetchPaymentOptions();
  }, [getPreConfiguredPaymentsOptions]);

  const openPaymentOptionsModal = () => {
    walletCheckoutManager.switchView('paymentOptions');
  };

  return (
    <div className="flex gap-2 items-center flex-wrap">
      {selectedAssets.slice(0, 2).map(asset => (
        <button
          key={asset.id}
          onClick={openPaymentOptionsModal}
          className="payment-option-badge transition-all hover:ring-2 hover:ring-text-text-accent-primary"
        >
          <div className="relative">
            <Image 
              src={asset.logoUrl || '/token-images/token-placeholder.png'} 
              alt={asset.name} 
              width={24} 
              height={24}
              className="rounded-full"
            />
            <div className="absolute -bottom-1 -right-1">
              <Image 
                src={getChainLogoUrl(asset.chainId)} 
                alt={asset.chainName} 
                width={14} 
                height={14}
                className="rounded-full border border-background"
              />
            </div>
          </div>
          {""}
        </button>
      ))}
      
      {/* Show a badge indicating more options if we have more than 2 */}
      {selectedAssets.length > 2 && (
        <button
          onClick={openPaymentOptionsModal}
          className="payment-option-badge transition-all hover:ring-2 hover:ring-text-text-accent-primary"
        >
          <div className="flex items-center justify-center w-6 h-6 rounded-full bg-foreground-foreground-secondary text-primary text-xs font-medium">
            +{selectedAssets.length - 2}
          </div>
        </button>
      )}
      
      {/* Plus button to open modal for adding more payment options */}
      <button
        onClick={openPaymentOptionsModal}
        className="payment-option-badge h-8 w-8 flex items-center justify-center transition-all hover:ring-2 hover:ring-text-text-accent-primary"
      >
        <Plus className="w-4 h-4" />
      </button>
    </div>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/purchase-donut-modal-views/PaymentOptionsView.tsx">
"use client";

import React, { useState, useEffect } from "react";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { X, Check, ChevronLeft } from "lucide-react";
import { getChainLogoUrl, SupportedAsset } from "@/data/CheckoutPaymentAssets";
import { walletCheckoutManager, WalletCheckoutModalViewProps } from "@/controllers/WalletCheckoutModalManager";
import { PaymentOption } from "@/types/wallet_checkout";
import { useSnapshot } from "valtio";
import { cn } from "@/lib/utils";
import { formatUnits } from "viem";

export const PaymentOptionsView: React.FC<WalletCheckoutModalViewProps> = ({ 
  onClose, 
  onViewChange 
}) => {
  const snap = useSnapshot(walletCheckoutManager.getState());
  const availableAssets = snap.state.availableAssets || [];
  const allPaymentOptions = snap.state.allPaymentOptions || [];
  
  const getPaymentOptionId = (option: PaymentOption): string => {
    const baseId = `${option.asset}`;
    
    const typeId = option.contractInteraction ? '-contract' : '-direct';
    
    const recipientId = option.recipient ? `-${option.recipient.slice(-8)}` : '';
    
    const amountId = option.amount ? `-${option.amount.slice(-6)}` : '';
    
    return `${baseId}${typeId}${recipientId}${amountId}`;
  };
  
  const [localSelectedOptionIds, setLocalSelectedOptionIds] = useState<string[]>([]);
  
  useEffect(() => {
    const selectedPaymentOptions = snap.state.paymentOptions || [];
    const selectedIds = selectedPaymentOptions.map(option => getPaymentOptionId(option));
    setLocalSelectedOptionIds(selectedIds);
  }, [snap.state.paymentOptions]);
  
  const getPaymentOptionById = (optionId: string): PaymentOption | undefined => {
    return allPaymentOptions.find(option => getPaymentOptionId(option) === optionId);
  };
  
  const handlePaymentOptionToggle = (option: PaymentOption) => {
    const optionId = getPaymentOptionId(option);
    const isSelected = localSelectedOptionIds.includes(optionId);
    
    if (isSelected) {
      if (localSelectedOptionIds.length === 1) {
        return;
      }
      setLocalSelectedOptionIds(localSelectedOptionIds.filter(id => id !== optionId));
    } else {
      setLocalSelectedOptionIds([...localSelectedOptionIds, optionId]);
    }
  };
  
  // Apply selections when user clicks Apply
  const handleApply = () => {
    // Convert selected option IDs back to payment options
    const selectedOptions = localSelectedOptionIds
      .map(optionId => getPaymentOptionById(optionId))
      .filter((option): option is PaymentOption => !!option);
    
    walletCheckoutManager.setPaymentOptions(selectedOptions);
    onViewChange('checkout');
  };

  const handleBack = () => {
    onViewChange('checkout');
  };

  // Group assets by chain
  const groupedAssets: Record<string, SupportedAsset[]> = {};
  availableAssets.forEach(asset => {
    if (!groupedAssets[asset.chainName]) {
      groupedAssets[asset.chainName] = [];
    }
    groupedAssets[asset.chainName].push(asset);
  });

  // Get all payment options for an asset (could be multiple - direct and contract)
  const getAllPaymentOptionsForAsset = (assetId: string): PaymentOption[] => {
    return allPaymentOptions.filter(option => option.asset === assetId);
  };

  // Format amount for display
  const formatAmount = (paymentOption?: PaymentOption, asset?: SupportedAsset): string => {
    if (!paymentOption?.amount || !asset) return "N/A";
    
    try {
      // Remove '0x' prefix and parse the hex amount
      const amountHex = paymentOption.amount.startsWith('0x') 
        ? paymentOption.amount.substring(2) 
        : paymentOption.amount;
      
      const amountBigInt = BigInt(`0x${amountHex}`);
      const formattedAmount = formatUnits(amountBigInt, asset.decimals);
      
      // Format to max 6 decimal places
      const parts = formattedAmount.split('.');
      if (parts.length === 2 && parts[1].length > 6) {
        return `${parts[0]}.${parts[1].substring(0, 6)}`;
      }
      
      return formattedAmount;
    } catch (e) {
      console.error("Error formatting amount:", e);
      return "Error";
    }
  };

  // Format recipient address for display
  const formatRecipient = (paymentOption?: PaymentOption): string => {
    if (!paymentOption?.recipient) return "Smart Contract";
    
    const parts = paymentOption.recipient.split(':');
    const address = parts[parts.length - 1];
    
    if (!address) return "Unknown";
    
    return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
  };

  // Get payment option type (direct payment or contract interaction)
  const getPaymentType = (paymentOption?: PaymentOption): string => {
    if (!paymentOption) return "Unknown";
    
    if (paymentOption.contractInteraction) {
      return "Contract Interaction";
    }
    
    return "Direct Payment";
  };

  return (
    <div className={cn("flex flex-col items-start gap-4 text-primary")}>
      <div className="grid grid-cols-3 items-center w-full">
        <div className="flex justify-start">
          <Button variant="ghost" onClick={handleBack}>
            <ChevronLeft className="h-4 w-4" />
          </Button>
        </div>
        <div className="col-end-3 text-center">
          <h1>Choose payment</h1>
        </div>
        <div className="flex justify-end">
          <Button variant="ghost" onClick={handleBack}>
            <X className="h-4 w-4" />
          </Button>
        </div>
      </div>
      
      {/* Payment options list with basic scrolling */}
      <div className="flex flex-col gap-4 w-full max-h-[70vh] overflow-y-auto">
        {Object.entries(groupedAssets).map(([chainName, assets]) => (
          <div key={chainName} className="space-y-2 mb-4">
            <h3 className="text-sm font-semibold text-secondary">{chainName}</h3>
            <div className="grid grid-cols-1 gap-2">
              {assets.map((asset) => {
                const assetPaymentOptions = getAllPaymentOptionsForAsset(asset.id);
                
                return assetPaymentOptions.map((option) => {
                  const optionId = getPaymentOptionId(option);
                  const isSelected = localSelectedOptionIds.includes(optionId);
                  const amount = formatAmount(option, asset);
                  const recipient = formatRecipient(option);
                  const paymentType = getPaymentType(option);
                  
                  return (
                    <button
                      key={optionId}
                      onClick={() => handlePaymentOptionToggle(option)}
                      className={`flex items-center gap-2 p-3 rounded-lg border transition-colors ${
                        isSelected 
                          ? 'border-text-text-accent-primary bg-foreground-foreground-accent-primary-010' 
                          : 'border-border-secondary hover:bg-secondary/50'
                      }`}
                    >
                      <div className="relative">
                        <Image 
                          src={asset.logoUrl} 
                          alt={asset.name} 
                          width={28} 
                          height={28}
                          className="rounded-full"
                        />
                        <div className="absolute -bottom-1 -right-1">
                          <Image 
                            src={getChainLogoUrl(asset.chainId)} 
                            alt={asset.chainName} 
                            width={16} 
                            height={16}
                            className="rounded-full border border-background"
                          />
                        </div>
                      </div>
                      
                      {/* Payment option details */}
                      <div className="flex flex-col items-start flex-1">
                        <div className="flex justify-between w-full">
                          <span className="text-sm font-medium">{asset.symbol}</span>
                          <span className="text-sm font-medium">{amount} {asset.symbol}</span>
                        </div>
                        <div className="flex justify-between w-full">
                          <span className="text-xs text-secondary">{paymentType}</span>
                          <span className="text-xs text-secondary">To: {recipient}</span>
                        </div>
                      </div>
                      
                      {isSelected && (
                        <Check className="h-5 w-5 text-green-500 ml-2" />
                      )}
                    </button>
                  );
                });
              })}
            </div>
          </div>
        ))}
      </div>
      
      {/* Apply button */}
      <div className="flex justify-end mt-4 w-full">
        <Button 
          onClick={handleApply}
          className="accent-button accent-text"
        >
          Apply
        </Button>
      </div>
    </div>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/purchase-donut-modal-views/RecieptView.tsx">
"use client";

import React from "react";
import { useSnapshot } from "valtio";
import { Button } from "@/components/ui/button";
import { Check, ArrowRight } from "lucide-react";
import { walletCheckoutManager, WalletCheckoutModalViewProps } from "@/controllers/WalletCheckoutModalManager";
import { baseSepolia, sepolia } from "viem/chains";
import { getTokenSymbolFromAsset } from "@/utils/WalletCheckoutUtil";
import { supportedPaymentsAsset } from "@/data/CheckoutPaymentAssets";
import { formatUnits } from "viem";

export const ReceiptView: React.FC<WalletCheckoutModalViewProps> = ({ onClose }) => {
  const snap = useSnapshot(walletCheckoutManager.getState());
  const result = snap.state.checkoutResult;
  
  if (!result) {
    return <div>No transaction data available</div>;
  }
  
  const { orderId, txid, recipient, asset, amount } = result;
  const tokenSymbol = getTokenSymbolFromAsset(asset);
  
  // Format timestamp
  const timestamp = new Date().toLocaleString();
  
  // Truncate address for display
  function formatAddress(address?: string): string {
    if (!address) {
      return 'N/A';
    }
    const parts = address.split(':');
    const addr = parts[parts.length - 1];
    
    if (!addr) {
      return 'N/A';
    }
    
    return `${addr.substring(0, 6)}...${addr.substring(addr.length - 4)}`;
  }

  /*
  * Extract chain ID and token address from a CAIP-19 asset identifier
  */
 function extractAssetInfo(asset: string): {
   chainNamespace: string
   chainId: string
   tokenAddress?: string
   isNative: boolean
 } {
   const parts = asset.split('/')
   const chainPart = parts[0]?.split(':') || []
   const chainNamespace = chainPart[0] || ''
   const chainId = chainPart[1] || ''
 
   // Check if this is a native asset (slip44:60 is ETH)
   if (parts[1]?.startsWith('slip44:')) {
     return { chainNamespace, chainId, isNative: true }
   }
 
   // For ERC20 tokens
   if (parts[1]?.startsWith('erc20:')) {
     const tokenAddress = parts[1].split(':')[1]
 
     return { chainNamespace, chainId, tokenAddress, isNative: false }
   }
 
   // Default case
   return { chainNamespace, chainId, isNative: !parts[1] }
 }
  // Helper function to format blockchain explorer URL
  function getExplorerUrl(txid: string, asset?: string): string {
    if (!asset) {
      return `https://sepolia.etherscan.io/tx/${txid}`
    }
  
    const { chainNamespace, chainId } = extractAssetInfo(asset)
    if (chainNamespace === 'solana') {
      if (chainId === 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1') {
        return `https://solscan.io/tx/${txid}?cluster=devnet`
      }
  
      return `https://solscan.io/tx/${txid}`
    }
  
    const chainIdNum = Number(chainId)
  
    if (chainIdNum === sepolia.id) {
      return `https://sepolia.etherscan.io/tx/${txid}`
    }
  
    if (chainIdNum === baseSepolia.id) {
      return `https://sepolia.basescan.org/tx/${txid}`
    }
  
    // Default to Sepolia explorer
    return `https://sepolia.etherscan.io/tx/${txid}`
  }
  
  const getFormattedAmount = (inputAsset: string, inputAmount: string) => {
    if (!inputAsset || !inputAmount) {
      return 
    }
    const supportedAssets = supportedPaymentsAsset
    const supportedAsset = supportedAssets.find((asset) => asset.id === inputAsset)
    if (!supportedAsset) {
      return 
    }
    const formatedAmount = formatUnits(BigInt(inputAmount), supportedAsset?.decimals)
    return formatedAmount
  }

  const getAssetName = (inputAsset: string) => {
    if (!inputAsset) {
      return 'UNSUPPORTED ASSET'
    }
    const supportedAssets = supportedPaymentsAsset
    const supportedAsset = supportedAssets.find((asset) => asset.id === inputAsset)
    if (!supportedAsset) {
      return 'UNSUPPORTED ASSET'
    }
    return supportedAsset.name
  }

   const explorerUrl = getExplorerUrl(txid, asset)
  const formattedAmount = getFormattedAmount(asset!, amount!) || 'UNSUPPORTED ASSET'
  
  return (
    <div className="flex flex-col items-start gap-4">
      {/* Success Header */}
      <div className="flex justify-center w-full">
        <div className="text-center">
          <div className="flex justify-center mb-2">
            <div className="icon-container bg-green-100">
              <Check className="h-6 w-6 text-green-600" />
            </div>
          </div>
          <h3 className="text-lg font-medium text-primary">Payment Successful</h3>
          <p className="text-sm text-secondary mt-1">{timestamp}</p>
        </div>
      </div>

      {/* Transaction Details Card */}
      <div className="w-full bg-primary-foreground p-4 rounded-3xl">
        <div className="flex flex-col gap-3">
          <div className="flex justify-between items-center">
            <p className="text-secondary">Order ID</p>
            <p className="text-primary font-medium">{orderId.substring(0, 8)}...</p>
          </div>

          <div className="flex justify-between items-center">
            <p className="text-secondary">Amount</p>
            <div className="flex items-center gap-2">
              <p className="text-secondary font-medium">{formattedAmount}</p>
              <p className="text-secondary font-medium">{getAssetName(asset!)}</p>
            </div>
          </div>

          {result.recipient && (
            <div className="flex justify-between items-center">
              <p className="text-secondary">Recipient</p>
              <p className="text-primary font-mono">{formatAddress(recipient)}</p>
            </div>
          )}

          <div className="flex justify-between items-center">
            <p className="text-secondary">Transaction</p>
            <a 
              href={explorerUrl} 
              target="_blank" 
              rel="noopener noreferrer" 
              className="accent-text hover:underline font-mono"
            >
              {result.txid.substring(0, 6)}...{result.txid.substring(result.txid.length - 4)}
            </a>
          </div>
        </div>
      </div>
      
      {/* Buttons */}
      <div className="flex gap-2 w-full mt-2">
        <Button
          onClick={onClose}
          className="flex flex-1 gap-1 accent-button"
        >
          <p className="flex items-center accent-text">
            Done <ArrowRight className="w-4 h-4 ml-1" />
          </p>
        </Button>
      </div>
    </div>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/dialog.tsx">
"use client";

import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { cn } from "@/lib/utils";
import { Cross2Icon } from "@radix-ui/react-icons";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    >
      {children}
      {/* <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close> */}
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/drawer.tsx">
"use client";

import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className,
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/separator.tsx">
"use client";

import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref,
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className,
      )}
      {...props}
    />
  ),
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/sonner.tsx">
"use client";

import { useTheme } from "next-themes";
import { Toaster as Sonner } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-primary group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster };
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ui/tooltip.tsx">
"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/BalanceDisplay.tsx">
import { type TokenBalance } from "@/utils/BalanceFetcherUtil";

interface BalanceDisplayProps {
  balances: TokenBalance[];
  isLoading: boolean;
}

export const BalanceDisplay: React.FC<BalanceDisplayProps> = ({
  balances,
  isLoading,
}) => {
  if (isLoading) {
    return null;
  }

  return (
    <div className="flex flex-col items-center gap-1 text-sm text-secondary mt-2">
      {balances.map((token) => (
        <div key={token.address}>
          Available {token.symbol} Balance: {token.balance} {token.symbol}
        </div>
      ))}
    </div>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/CheckWalletToast.tsx">
import React from "react";
import { Loader2 } from "lucide-react";

export const CheckWalletToast = () => {
  return (
    <div className="flex items-center gap-2">
      <Loader2 className="h-4 w-4 animate-spin" />
      <p className="text-sm font-medium">
        Check your wallet to approve transaction
      </p>
    </div>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/ConnectWalletButton.tsx">
import React from "react";
import { useAppKit, useAppKitAccount } from "@reown/appkit/react";
import { Button } from "./ui/button";

export function ConnectWalletButton() {
  const { open } = useAppKit();
  const { status } = useAppKitAccount();
  const [mounted, setMounted] = React.useState(false);

  React.useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return (
      <Button
        type="button"
        style={{
          background:
            "var(--foreground-foreground-secondary, hsla(0, 0%, 16%, 1))",
        }}
        className="w-full text-primary rounded-full"
        size="lg"
      >
        Connect Wallet
      </Button>
    );
  }

  return (
    <Button
      type="button"
      style={{
        background:
          "var(--foreground-foreground-secondary, hsla(0, 0%, 16%, 1))",
      }}
      className="w-full text-primary rounded-full"
      size="lg"
      onClick={() => open({ view: "Connect" })}
      disabled={status === "connecting" || status === "reconnecting"}
    >
      {status === "connecting" || status === "reconnecting"
        ? "Connecting..."
        : "Connect Wallet"}
    </Button>
  );
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/DonutImage.tsx">
import Image from "next/image";

export const DonutImage = () => (
  <div className="flex items-center justify-center h-64 relative">
    <Image
      src="/donut-cover.png"
      alt="Gift Donut"
      className="object-cover"
      fill={true}
    />
  </div>
);
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/DonutInfo.tsx">
interface DonutInfoProps {}

export const DonutInfo: React.FC<DonutInfoProps> = ({}) => (
  <div className="flex flex-col text-left">
    <p className="font-bold text-primary">Donut #1</p>
    <p className="text-secondary">Lorem ipsum dolor sit...</p>
  </div>
);
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/GiftDonutButton.tsx">
import { Loader2 } from "lucide-react";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { GiftDonutModalTrigger } from "@/components/GiftDonutModalTrigger";
import { ConnectWalletButton } from "@/components/ConnectWalletButton";

interface GiftDonutButtonProps {
  isConnected: boolean;
  isLoading: boolean;
  hasEnoughBalance: boolean;
}

export const GiftDonutButton: React.FC<GiftDonutButtonProps> = ({
  isConnected,
  isLoading,
  hasEnoughBalance,
}) => {
  if (!isConnected) {
    return (
      <div>
        <ConnectWalletButton />
      </div>
    );
  }

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <div>
            <GiftDonutModalTrigger
              triggerText={
                isLoading ? (
                  <div className="flex items-center gap-2">
                    <Loader2 className="h-4 w-4 animate-spin" />
                    Loading
                  </div>
                ) : (
                  "Gift Donut"
                )
              }
              initialView="Checkout"
              className={`${
                isLoading
                  ? "bg-blue-400"
                  : hasEnoughBalance
                    ? "bg-blue-500 hover:bg-blue-700"
                    : "bg-gray-400 cursor-not-allowed"
              } text-invert`}
              disabled={isLoading || !hasEnoughBalance}
            />
          </div>
        </TooltipTrigger>
        {!isLoading && !hasEnoughBalance && (
          <TooltipContent>
            <p>Insufficient USDC balance</p>
          </TooltipContent>
        )}
      </Tooltip>
    </TooltipProvider>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/GiftDonutModal.tsx">
"use client";
import React, { useCallback, useMemo } from "react";
import { useSnapshot } from "valtio";
import * as VisuallyHidden from "@radix-ui/react-visually-hidden";
import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog";
import { giftDonutModalManager } from "@/controllers/GiftDonutModalManager";
import { useMediaQuery } from "@/hooks/use-media-query";
import { Drawer, DrawerContent, DrawerTitle } from "./ui/drawer";

const GiftDonutModal: React.FC = () => {
  const isDesktop = useMediaQuery("(min-width: 768px)");
  const state = useSnapshot(giftDonutModalManager.getState());

  const CurrentView = useMemo(() => {
    const viewDefinition = state.views[state.currentView];
    return viewDefinition ? viewDefinition.component : null;
  }, [state.currentView, state.views]);

  const handleClose = useCallback(() => {
    giftDonutModalManager.close();
  }, []);

  const handleViewChange = useCallback((viewKey: string) => {
    giftDonutModalManager.switchView(viewKey);
  }, []);

  if (isDesktop) {
    return (
      <Dialog open={state.isOpen}>
        <DialogContent
          aria-describedby={undefined}
          className="sm:max-w-[435px] bg-background"
        >
          <VisuallyHidden.Root asChild>
            <DialogTitle>Modal Title</DialogTitle>
          </VisuallyHidden.Root>
          {CurrentView && (
            <CurrentView
              onClose={handleClose}
              onViewChange={handleViewChange}
            />
          )}
        </DialogContent>
      </Dialog>
    );
  }

  return (
    <Drawer open={state.isOpen}>
      <VisuallyHidden.Root asChild>
        <DrawerTitle>Modal Title</DrawerTitle>
      </VisuallyHidden.Root>
      <DrawerContent aria-describedby={undefined} className="bg-background p-4">
        {CurrentView && (
          <CurrentView onClose={handleClose} onViewChange={handleViewChange} />
        )}
      </DrawerContent>
    </Drawer>
  );
};

export default GiftDonutModal;
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/GiftDonutModalTrigger.tsx">
import {
  giftDonutModalManager,
  GiftDonutModalViewProps,
} from "@/controllers/GiftDonutModalManager";
import { useEffect, useState } from "react";
import { Button } from "./ui/button";
import GiftDonutModal from "./GiftDonutModal";
import { GiftDonutModalViews } from "./gift-donut-modal-views";
import { useWalletGetAssets } from "@/hooks/useWalletGetAssets";
import { useAppKitNetwork } from "@reown/appkit/react";
import { supportedNetworks } from "@/data/EIP155Data";

type GiftDonutModalTriggerProps = {
  views?: Record<string, React.FC<GiftDonutModalViewProps>>;
  initialView?: string;
  triggerText?: string | React.ReactElement;
  disabled?: boolean;
  className?: string;
  variant?:
    | "default"
    | "destructive"
    | "outline"
    | "secondary"
    | "ghost"
    | "link";
  buttonProps?: React.ButtonHTMLAttributes<HTMLButtonElement>;
};

export const GiftDonutModalTrigger: React.FC<GiftDonutModalTriggerProps> = ({
  views = GiftDonutModalViews,
  initialView = "Checkout",
  triggerText = "Gift Donut",
  disabled = false,
  className,
  variant = "default",
  buttonProps = {},
}) => {
  const [isViewsRegistered, setIsViewsRegistered] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const { fetchBalances } = useWalletGetAssets();
  const { caipNetwork } = useAppKitNetwork();

  useEffect(() => {
    Object.entries(views).forEach(([key, component]) =>
      giftDonutModalManager.registerView(key, {
        component,
        title: key,
      }),
    );

    setIsViewsRegistered(true);

    return () => {
      Object.keys(views).forEach((key) =>
        giftDonutModalManager.unregisterView(key),
      );
    };
  }, [views]);

  const handleOpenModal = async () => {
    if (!isViewsRegistered) {
      console.error("Views not yet registered");
      return;
    }

    setIsLoading(true);

    try {
      // Set initial network based on current CAIP network
      if (caipNetwork?.id) {
        const currentNetwork = supportedNetworks.find(
          (net) => net.chainId === caipNetwork.id,
        );
        if (currentNetwork) {
          giftDonutModalManager.setNetwork(currentNetwork);
        }
      }

      const balances = await fetchBalances();
      giftDonutModalManager.setBalances(balances);
    } catch (error) {
      console.error("Failed to fetch balances:", error);
    } finally {
      setIsLoading(false);
      giftDonutModalManager.open(initialView);
    }
  };

  return (
    <>
      <Button
        onClick={handleOpenModal}
        variant={variant}
        className={className}
        disabled={disabled || isLoading}
        {...buttonProps}
      >
        {isLoading ? "Loading..." : triggerText}
      </Button>
      <GiftDonutModal />
    </>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/Navbar.tsx">
import * as React from "react";
import Image from "next/image";
import { ConnectWalletButton } from "@/components/ConnectWalletButton";
import { useAppKitAccount } from "@reown/appkit/react";

const Navbar = () => {
  const { status, address } = useAppKitAccount();
  return (
    <nav className="bg-foreground w-full border-b rounded-md md:border-0 my-4">
      <div className="flex items-center justify-between px-4 max-w-screen-xl mx-auto py-4 md:px-8">
        <div className="flex items-center gap-2">
          <Image src="/donut.png" alt="Gift Donut" width={40} height={40} />
          <h3 className="text-xl font-bold text-primary">Gift Donut</h3>
        </div>

        {status === "connected" || address ? (
          <div>
            <w3m-button balance="hide" />
          </div>
        ) : (
          <div>
            <ConnectWalletButton />
          </div>
        )}
      </div>
    </nav>
  );
};

export default Navbar;
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/PurchaseDonutButton.tsx">
import { useWalletCheckout } from "@/hooks/useWalletCheckout"
import { Button } from "@/components/ui/button"
import { useAppKitProvider } from "@reown/appkit/react"
import UniversalProvider from '@walletconnect/universal-provider'
import { toast } from "sonner"
import { useEffect, useRef } from "react"
import { walletCheckoutManager } from "@/controllers/WalletCheckoutModalManager"
import { WalletCheckoutModal } from "./WalletCheckoutModal"
import { registerCheckoutViews } from "@/config/checkoutViews"


const initializeCheckoutManager = () => {
  registerCheckoutViews();
}

const PurchaseDonutButton = () => {
  const { isWalletCheckoutSupported, getPreConfiguredPaymentsOptions } = useWalletCheckout()
  const { walletProvider } = useAppKitProvider<UniversalProvider>('eip155')
  
  // Initialize checkout manager when the component mounts
  useEffect(() => {
    initializeCheckoutManager();
    
    // Configure payment options when component mounts
    const configurePaymentsOptions = async () => {
      if (isWalletCheckoutSupported) {
        try {
          const options = await getPreConfiguredPaymentsOptions();
          walletCheckoutManager.setPaymentOptions(options);
        } catch (error) {
          console.error("Failed to configure payment options:", error);
        }
      }
    };
    
    configurePaymentsOptions();
  }, [getPreConfiguredPaymentsOptions, isWalletCheckoutSupported]);
  
  const handlePurchaseDonut = async () => {
    if (!isWalletCheckoutSupported || !walletProvider) {
      toast.error('Wallet checkout not supported', {
        description: 'Your wallet does not support the checkout feature',
      });
      return;
    }
    walletCheckoutManager.resetTransactionState();
    walletCheckoutManager.setWalletProvider(walletProvider);
    walletCheckoutManager.open("checkout");
  }

  return (
    <>
      <Button onClick={handlePurchaseDonut} disabled={!isWalletCheckoutSupported}>
        Purchase Donut
      </Button>
      <WalletCheckoutModal />
    </>
  );
}

export default PurchaseDonutButton
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/theme-provider.tsx">
"use client";

import * as React from "react";
import {
  ThemeProvider as NextThemesProvider,
  ThemeProviderProps,
} from "next-themes";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/TransactionToast.tsx">
import React from "react";
import { Loader2 } from "lucide-react";

interface TransactionToastProps {
  hash?: string;
  networkName?: string;
  elapsedTime?: number; // in seconds
  status: "waiting-approval" | "pending" | "success" | "error";
}

export const TransactionToast = ({
  hash,
  networkName,
  elapsedTime,
  status,
}: TransactionToastProps) => {
  const formatTime = (seconds: number) => {
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}m ${remainingSeconds}s`;
  };

  const renderContent = () => {
    switch (status) {
      case "waiting-approval":
        return (
          <div className="flex items-center gap-2">
            <Loader2 className="h-4 w-4 animate-spin" />
            <p className="text-sm font-medium">
              Check your wallet to approve transaction
            </p>
          </div>
        );
      case "pending":
        return (
          <div className="flex items-center gap-2">
            <Loader2 className="h-4 w-4 animate-spin" />
            <div className="flex flex-col">
              <p className="text-sm font-medium">Sending Gift Donut</p>
              {hash && networkName && (
                <a
                  href={`${networkName}/tx/${hash}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-xs text-blue-500 hover:text-blue-600"
                >
                  View transaction
                </a>
              )}
              {elapsedTime && (
                <p className="text-xs text-secondary">
                  Time elapsed: {formatTime(elapsedTime)}
                </p>
              )}
            </div>
          </div>
        );
      case "success":
        return (
          <div className="flex flex-col">
            <p className="text-sm font-medium">Transaction completed!</p>
            {elapsedTime && (
              <p className="text-xs text-secondary">
                Completed in {formatTime(elapsedTime)}
              </p>
            )}
          </div>
        );
      case "error":
        return (
          <div className="flex flex-col">
            <p className="text-sm font-medium">Transaction failed</p>
            {elapsedTime && (
              <p className="text-xs text-secondary">
                Failed after {formatTime(elapsedTime)}
              </p>
            )}
          </div>
        );
    }
  };

  return <div className="w-full">{renderContent()}</div>;
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/components/WalletCheckoutModal.tsx">
"use client";

import React from "react";
import { useSnapshot } from "valtio";
import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog";
import { walletCheckoutManager } from "../controllers/WalletCheckoutModalManager";
import * as VisuallyHidden from "@radix-ui/react-visually-hidden";

export const WalletCheckoutModal: React.FC = () => {
  const snap = useSnapshot(walletCheckoutManager.getState());
  
  const handleClose = () => {
    walletCheckoutManager.close();
  };
  
  if (!snap.isOpen) return null;
  
  const CurrentView = snap.views[snap.currentView]?.component;
  
  if (!CurrentView) return null;
  
  return (
    <Dialog open={snap.isOpen} onOpenChange={handleClose}>
      <DialogContent 
        aria-describedby={undefined} 
        className="sm:max-w-[435px] bg-background"
      >
        <VisuallyHidden.Root asChild>
            <DialogTitle>Modal Title</DialogTitle>
          </VisuallyHidden.Root>
        <CurrentView 
          onClose={handleClose} 
          onViewChange={(viewKey) => walletCheckoutManager.switchView(viewKey)}
        />
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/config/checkoutViews.ts">
import { ReceiptView } from "@/components/purchase-donut-modal-views/RecieptView";
import { ErrorView } from "@/components/purchase-donut-modal-views/ErrorView";
import { CheckoutView } from "@/components/purchase-donut-modal-views/CheckoutView";
import { PaymentOptionsView } from "@/components/purchase-donut-modal-views/PaymentOptionsView";
import { walletCheckoutManager, WalletCheckoutModalView } from "@/controllers/WalletCheckoutModalManager";

export const WALLET_CHECKOUT_VIEWS: Record<string, WalletCheckoutModalView> = {
  checkout: {
    component: CheckoutView,
    title: "Checkout"
  },
  receipt: {
    component: ReceiptView,
    title: "Receipt"
  },
  error: {
    component: ErrorView,
    title: "Error"
  },
  paymentOptions: {
    component: PaymentOptionsView,
    title: "Payment Options"
  }
};

export function registerCheckoutViews(): void {
  Object.entries(WALLET_CHECKOUT_VIEWS).forEach(([key, view]) => {
    if (!walletCheckoutManager.getState().views[key]) {
      walletCheckoutManager.registerView(key, view);
    }
  });
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/config/index.tsx">
import { WagmiAdapter } from "@reown/appkit-adapter-wagmi";
import { SolanaAdapter } from "@reown/appkit-adapter-solana";
import { arbitrum, optimism, base } from "@reown/appkit/networks";

export const projectId = process.env.NEXT_PUBLIC_PROJECT_ID;

if (!projectId) {
  throw new Error("Project ID is not defined");
}

export const networks = [base, optimism, arbitrum];

export const wagmiAdapter = new WagmiAdapter({
  ssr: true,
  projectId,
  networks,
});

export const solanaAdapter = new SolanaAdapter()

export const metadata = {
  name: "Chain Abstraction Demo",
  description: "A demo of Chain Abstraction",
  url: "https://ca-demo.reown.com", // origin must match your domain & subdomain
  icons: ["https://ca-demo.reown.com/donut.png"],
};

export const config = wagmiAdapter.wagmiConfig;
</file>

<file path="advanced/dapps/chain-abstraction-demo/consts/tokens.ts">
import { Hex } from "viem";

export const usdcTokenAddresses: Record<number, Hex> = {
  42161: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831", // Arbitrum
  10: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85", // Optimism
  8453: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", // Base
};
export const usdtTokenAddresses: Record<number, Hex> = {
  42161: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9", // Arbitrum
  10: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58", // Optimism
  // 8453: "0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2", // Base - No liqiduty
};

export const usdsTokenAddresses: Record<number, Hex> = {
  // 42161: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", // Arbitrum - Not supported
  // 10: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", // Optimism - Not supported
  8453: "0x820c137fa70c8691f0e44dc420a5e53c168921dc", // Base
};

export const tokenAddresses: Record<string, Record<string, Hex>> = {
  USDC: usdcTokenAddresses,
  USDT: usdtTokenAddresses,
  USDS: usdsTokenAddresses,
};

export const getSupportedNetworks = (token: string): number[] => {
  const tokenNetworks = tokenAddresses[token];
  if (!tokenNetworks) {
    throw new Error(`Token ${token} not found`);
  }

  return Object.keys(tokenNetworks).map(Number);
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/context/index.tsx">
"use client";

import { wagmiAdapter, projectId, metadata, solanaAdapter } from "@/config";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createAppKit } from "@reown/appkit/react";
import { arbitrum, base, optimism, solanaDevnet, baseSepolia, optimismSepolia } from "@reown/appkit/networks";
import React, { type ReactNode } from "react";
import { WagmiProvider } from "wagmi";

const queryClient = new QueryClient();

if (!projectId) throw new Error("Project ID is not defined");

const modal = createAppKit({
  adapters: [solanaAdapter, wagmiAdapter],
  projectId,
  networks: [base, optimism, arbitrum, solanaDevnet, baseSepolia, optimismSepolia],
  defaultNetwork: arbitrum,
  metadata: metadata,
  features: {
    analytics: true,
  },
  universalProviderConfigOverride:{
    methods:{
      solana:[
        'solana_signMessage',
        'solana_signTransaction',
        'solana_requestAccounts',
        'solana_getAccounts',
        'solana_signAllTransactions',
        'solana_signAndSendTransaction',
        'wallet_checkout',
      ],
      eip155: [
        'eth_accounts',
        'eth_requestAccounts',
        'eth_sendRawTransaction',
        'eth_sign',
        'eth_signTransaction',
        'eth_signTypedData',
        'eth_signTypedData_v3',
        'eth_signTypedData_v4',
        'eth_sendTransaction',
        'personal_sign',
        'wallet_switchEthereumChain',
        'wallet_getPermissions',
        'wallet_requestPermissions',
        'wallet_scanQRCode',
        'wallet_getAssets',
        'wallet_checkout',
      ]
    },
  }
});

function AppKitProvider({ children }: { children: ReactNode }) {
  return (
    <WagmiProvider config={wagmiAdapter.wagmiConfig}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  );
}

export default AppKitProvider;
</file>

<file path="advanced/dapps/chain-abstraction-demo/controllers/GiftDonutModalManager.ts">
"use client";

import {
  Network,
  supportedNetworks,
  supportedTokens,
  Token,
  isTokenSupportedOnNetwork,
} from "@/data/EIP155Data";
import { TokenBalance } from "@/utils/BalanceFetcherUtil";
import React from "react";
import { proxy } from "valtio";

// Improved type definitions (expanded)
export type GiftDonutModalView = {
  component: React.FC<GiftDonutModalViewProps>;
  title?: string;
};

export type GiftDonutModalViewProps = {
  onClose: () => void;
  onViewChange: (viewKey: string) => void;
};

export type GiftDonutState = {
  donutCount: number;
  network?: Network;
  token: Token;
  recipient?: string;
  balances: TokenBalance[];
  tokenNetworkCompatible: boolean;
};

export type GiftDonutModalStateType = {
  isOpen: boolean;
  currentView: string;
  views: Record<string, GiftDonutModalView>;
  state: GiftDonutState;
};

class GiftDonutModalManager {
  private state: GiftDonutModalStateType;

  constructor() {
    this.state = proxy<GiftDonutModalStateType>({
      isOpen: false,
      currentView: "",
      views: {},
      state: {
        token: supportedTokens[0],
        donutCount: 0,
        balances: [],
        tokenNetworkCompatible: true,
      },
    });
  }

  getState(): GiftDonutModalStateType {
    return this.state;
  }

  open(viewKey?: string): void {
    const fallbackView = Object.keys(this.state.views)[0];
    const targetView = viewKey || fallbackView;

    if (!this.state.views[targetView]) {
      console.error(
        `View ${targetView} not found. Available views:`,
        Object.keys(this.state.views),
      );
      return;
    }
    this.state.isOpen = true;
    this.state.currentView = targetView;
  }

  close(): void {
    this.state.isOpen = false;
    this.state.currentView = "";
  }

  switchView(viewKey: string): void {
    if (this.state.views[viewKey]) {
      this.state.currentView = viewKey;
    } else {
      console.warn(`Attempted to switch to an unknown view: ${viewKey}`);
    }
  }

  registerView(key: string, view: GiftDonutModalView): void {
    if (this.state.views[key]) {
      console.warn(`A view with key "${key}" is already registered.`);
      return; // Prevent overwriting existing views
    }
    this.state.views[key] = view;
  }

  unregisterView(key: string): void {
    if (!this.state.views[key]) {
      console.warn(`No view found with key "${key}" to unregister.`);
      return;
    }
    delete this.state.views[key];
  }

  setToken(token: Token): void {
    this.state.state.donutCount = 0; // Reset donut count when changing token
    this.state.state.token = token;
    
    // Check compatibility with current network
    if (this.state.state.network) {
      this.checkTokenNetworkCompatibility();
    }
  }

  setNetwork(network: Network): void {
    this.state.state.network = network;
    
    // Check compatibility with current token
    this.checkTokenNetworkCompatibility();
  }

  checkTokenNetworkCompatibility(): void {
    const { token, network } = this.state.state;
    if (!network) {
      // No network selected yet, so we can't check compatibility
      this.state.state.tokenNetworkCompatible = false;
      return;
    }
    
    this.state.state.tokenNetworkCompatible = isTokenSupportedOnNetwork(token, network.chainId);
  }

  isTokenNetworkCompatible(): boolean {
    return this.state.state.tokenNetworkCompatible;
  }

  setRecipient(recipientAddress: string): void {
    this.state.state.recipient = recipientAddress;
  }

  getToken(): Token {
    return this.state.state.token;
  }

  getNetwork(): Network | undefined {
    return this.state.state.network;
  }

  getRecipient(): string | undefined {
    return this.state.state.recipient;
  }

  setDonutCount(count: number): void {
    this.state.state.donutCount = count;
  }

  getDonutCount(): number {
    return this.state.state.donutCount;
  }

  setBalances(balances: TokenBalance[]): void {
    this.state.state.balances = balances;
  }

  getBalances(): TokenBalance[] {
    return this.state.state.balances;
  }

  getBalanceBySymbol(symbol: string): string {
    const balance = this.state.state.balances.find((b) => b.symbol === symbol);
    return balance?.balance || "0.00";
  }

  getBalanceByAddress(address: `0x${string}`): string {
    const balance = this.state.state.balances.find(
      (b) => b.address === address,
    );
    return balance?.balance || "0.00";
  }
}

// Singleton instance
export const giftDonutModalManager = new GiftDonutModalManager();
</file>

<file path="advanced/dapps/chain-abstraction-demo/controllers/WalletCheckoutModalManager.ts">
"use client";

import { proxy } from "valtio";
import { PaymentOption, CheckoutRequest, CheckoutResult } from "@/types/wallet_checkout";
import UniversalProvider from '@walletconnect/universal-provider';
import React from "react";
import { SupportedAsset, supportChains } from "@/data/CheckoutPaymentAssets";

// Type definitions
export type WalletCheckoutModalView = {
  component: React.FC<WalletCheckoutModalViewProps>;
  title?: string;
};

export type WalletCheckoutModalViewProps = {
  onClose: () => void;
  onViewChange: (viewKey: string) => void;
};

export type AssetSelectionResult = {
  selectedAssetIds: string[];
};

export type PaymentOptionsModalData = {
  availableAssets: SupportedAsset[];
  selectedAssets: SupportedAsset[];
  onAssetToggled?: (result: AssetSelectionResult) => void;
  previousView?: string;
};

export type WalletCheckoutState = {
  orderId?: string;
  product: {
    name: string;
    description: string;
    imageUrl: string;
    price: string;
  };
  itemCount: number;
  paymentOptions: PaymentOption[];
  allPaymentOptions: PaymentOption[];   
  availableAssets: SupportedAsset[];  
  paymentOptionsModalData?: PaymentOptionsModalData;
  supportChains: typeof supportChains;
  checkoutResult?: CheckoutResult;
  isLoading: boolean;
  error?: Error | unknown;
};

export type WalletCheckoutModalStateType = {
  isOpen: boolean;
  currentView: string;
  views: Record<string, WalletCheckoutModalView>;
  state: WalletCheckoutState;
};

class WalletCheckoutModalManager {
  private state: WalletCheckoutModalStateType;
  private subscribers: Array<(state: WalletCheckoutModalStateType) => void> = [];
  private debounceTimeout: NodeJS.Timeout | null = null;
  private walletProvider?: UniversalProvider;

  constructor() {
    this.state = proxy<WalletCheckoutModalStateType>({
      isOpen: false,
      currentView: "",
      views: {},
      state: {
        itemCount: 1,
        product: {
          name: 'Chocolate sprinkle Delight',
          description: 'Donut with extra chocolate sprinkles on top',
          imageUrl: 'https://ca-demo.reown.com/donut.png',
          price: '$1.00'
        },
        paymentOptions: [],
        allPaymentOptions: [],  
        availableAssets: [],    
        supportChains: supportChains,
        isLoading: false
      },
    });
  }

  getState(): WalletCheckoutModalStateType {
    return this.state;
  }

  setWalletProvider(provider: UniversalProvider): void {
    this.walletProvider = provider;
  }

  getWalletProvider(): UniversalProvider | undefined {
    return this.walletProvider;
  }

  open(viewKey?: string): void {
    const fallbackView = Object.keys(this.state.views)[0];
    const targetView = viewKey || fallbackView;

    if (!this.state.views[targetView]) {
      console.error(
        `View ${targetView} not found. Available views:`,
        Object.keys(this.state.views),
      );
      return;
    }
    this.state.isOpen = true;
    this.state.currentView = targetView;
    this.notifySubscribers();
  }

  close(): void {
    this.state.isOpen = false;
    this.state.currentView = "";
    this.resetTransactionState();
    this.notifySubscribers();
  }

  switchView(viewKey: string): void {
    if (this.state.views[viewKey]) {
      this.state.currentView = viewKey;
      this.notifySubscribers();
    } else {
      console.warn(`Attempted to switch to an unknown view: ${viewKey}`);
    }
  }

  registerView(key: string, view: WalletCheckoutModalView): void {
    if (this.state.views[key]) {
      console.warn(`A view with key "${key}" is already registered.`);
      return;
    }
    this.state.views[key] = view;
    this.notifySubscribers();
  }

  unregisterView(key: string): void {
    if (!this.state.views[key]) {
      console.warn(`No view found with key "${key}" to unregister.`);
      return;
    }
    delete this.state.views[key];
    this.notifySubscribers();
  }

  setItemCount(count: number): void {
    this.state.state.itemCount = count;
    this.notifySubscribers();
  }

  getItemCount(): number {
    return this.state.state.itemCount;
  }

  setPaymentOptions(options: PaymentOption[]): void {
    this.state.state.paymentOptions = options;
    this.notifySubscribers();
  }

  getPaymentOptions(): PaymentOption[] {
    return this.state.state.paymentOptions;
  }

  // New method to store all available payment options
  setAllPaymentOptions(options: PaymentOption[]): void {
    this.state.state.allPaymentOptions = options;
    this.notifySubscribers();
  }

  getAllPaymentOptions(): PaymentOption[] {
    return this.state.state.allPaymentOptions;
  }

  setAvailableAssets(assets: SupportedAsset[]): void {
    this.state.state.availableAssets = assets;
    this.notifySubscribers();
  }

  getAvailableAssets(): SupportedAsset[] {
    return this.state.state.availableAssets;
  }

  setPaymentOptionsModalData(data: PaymentOptionsModalData): void {
    this.state.state.paymentOptionsModalData = data;
    this.notifySubscribers();
  }

  setSelectedPaymentAssets(assetIds: string[]): void {
    const selectedOptions = this.state.state.allPaymentOptions.filter(option => 
      assetIds.includes(option.asset)
    );
    
    if (selectedOptions.length > 0) {
      this.setPaymentOptions(selectedOptions);
    }
    
    this.notifySubscribers();
  }

  // Method to get the selected payment assets
  getSelectedPaymentAssets(): string[] {
    return this.state.state.paymentOptions.map(option => option.asset);
  }

  getAdjustedPaymentOptions(): PaymentOption[] {
    const { itemCount, paymentOptions } = this.state.state;
    
    // Return all options with adjusted amounts
    return paymentOptions.map(payment => {
      // Skip if amount is not present
      if (!payment.amount) {
        return payment;
      }

      // Parse hex amount and multiply by item count
      const originalAmount = parseInt(payment.amount, 16);
      const newAmount = (originalAmount * itemCount).toString(16);

      return {
        ...payment,
        amount: `0x${newAmount}`
      };
    });
  }

  setLoading(isLoading: boolean): void {
    this.state.state.isLoading = isLoading;
    this.notifySubscribers();
  }

  isLoading(): boolean {
    return this.state.state.isLoading;
  }

  setError(error?: Error | unknown): void {
    this.state.state.error = error;
    this.notifySubscribers();
  }

  getError(): Error | unknown {
    return this.state.state.error;
  }

  setCheckoutResult(result: CheckoutResult): void {
    this.state.state.checkoutResult = result;
    // When we get a result, automatically switch to receipt view
    this.switchView('receipt');
    this.notifySubscribers();
  }

  getCheckoutResult(): CheckoutResult | undefined {
    return this.state.state.checkoutResult;
  }

  // Prepares a new checkout request
  prepareCheckoutRequest(): CheckoutRequest {
    const orderId = crypto.randomUUID();
    this.state.state.orderId = orderId;
    
    const expiry = Math.floor(Date.now() / 1000) + 60 * 30; // 30 min expiry
    
    return {
      orderId,
      acceptedPayments: this.getAdjustedPaymentOptions(),
      products: [this.state.state.product],
      expiry
    };
  }

  // Execute the wallet checkout
  async executeCheckout(walletProvider?: UniversalProvider): Promise<void> {
    const provider = walletProvider || this.walletProvider;
    
    if (!provider) {
      this.setError(new Error('No supported wallet provider available'));
      if (this.state.views['error']) {
        this.switchView('error');
      }
      return;
    }
    
    this.setLoading(true);
    this.setError(undefined);
    
    try {
      const checkoutRequest = this.prepareCheckoutRequest();
      
      const result = await provider.request({
        method: 'wallet_checkout',
        params: [checkoutRequest]
      });
      
      this.setCheckoutResult(result as CheckoutResult);
    } catch (err) {
      console.error('Checkout failed:', err);
      
      this.setError(err);
      
      if (this.state.views['error']) {
        this.switchView('error');
      }
    } finally {
      this.setLoading(false);
    }
  }

  resetTransactionState(): void {
    this.state.state.orderId = undefined;
    this.state.state.checkoutResult = undefined;
    this.state.state.error = undefined;
    this.state.state.isLoading = false;
    // Don't reset paymentOptions to maintain user preference
    this.notifySubscribers();
  }
  
  // Add subscription functionality for components to react to state changes
  subscribe(callback: (state: WalletCheckoutModalStateType) => void): () => void {
    this.subscribers.push(callback);
    
    // Return unsubscribe function
    return () => {
      this.subscribers = this.subscribers.filter(cb => cb !== callback);
    };
  }
  
  // Update the notifySubscribers method to use debouncing
  private notifySubscribers(): void {
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout);
    }
    
    this.debounceTimeout = setTimeout(() => {
      for (const callback of this.subscribers) {
        callback(this.state);
      }
      this.debounceTimeout = null;
    }, 50); 
  }
}

export const walletCheckoutManager = new WalletCheckoutModalManager();
</file>

<file path="advanced/dapps/chain-abstraction-demo/data/CheckoutPaymentAssets.ts">
export interface SupportedAsset {
  id: string;          // Full CAIP-19 asset identifier
  name: string;        // Human-readable name
  symbol: string;      // Token symbol (e.g., "USDC", "ETH")
  decimals: number;    // Number of decimals for formatting
  chainId: string;     // Chain ID (e.g., "84532", "EtWTRABZaYq6iMfeYKouRu166VU2xqa1")
  chainName: string;   // Chain name (e.g., "Base Sepolia", "Solana Devnet")
  tokenAddress?: string; // Contract address for tokens (undefined for native)
  isNative: boolean;   // Whether this is a native asset
  logoUrl: string;     // URL to the asset's logo
}

export const supportedPaymentsAsset: SupportedAsset[] = [
  {
    id: 'eip155:84532/erc20:0x036CbD53842c5426634e7929541eC2318f3dCF7e',
    name: 'USDC',
    symbol: 'USDC',
    decimals: 6,
    chainId: '84532',
    chainName: 'Base Sepolia',
    tokenAddress: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',
    isNative: false,
    logoUrl: '/token-images/USDC.png'
  },
  {
    id: 'eip155:11155420/erc20:0x5fd84259d66Cd46123540766Be93DFE6D43130D7',
    name: 'USDC',
    symbol: 'USDC',
    decimals: 6,
    chainId: '11155420',
    chainName: 'Optimism Sepolia',
    tokenAddress: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7',
    isNative: false,
    logoUrl: '/token-images/USDC.png'
  },
  {
    id: 'eip155:84532/slip44:60',
    name: 'ETH',
    symbol: 'ETH',
    decimals: 18,
    chainId: '84532',
    chainName: 'Base Sepolia',
    isNative: true,
    logoUrl: '/chain-logos/ETH.png'
  },
  {
    id: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1/token:4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
    name: 'USDC',
    symbol: 'USDC',
    decimals: 6,
    chainId: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    chainName: 'Solana Devnet',
    tokenAddress: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
    isNative: false,
    logoUrl: '/token-images/USDC.png'
  },
  {
    id: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1/slip44:501',
    name: 'SOL',
    symbol: 'SOL',
    decimals: 9,
    chainId: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    chainName: 'Solana Devnet',
    isNative: true,
    logoUrl: '/chain-logos/SOL.png'
  }
]


export const supportChains = [{
  id: 'eip155:84532',
  name: 'Base Sepolia',
  logoUrl: '/chain-logos/base.webp'
}, {
  id: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
  name: 'Solana Devnet',
  logoUrl: '/chain-logos/SOL.png'
},
{
  id: 'eip155:11155420',
  name: 'Optimism Sepolia',
  logoUrl: '/chain-logos/eip155-10.png'
}
]

export const getChainLogoUrl = (chainId: string): string => {
  const chain = supportChains.find(chain => chain.id.includes(chainId));
  return chain?.logoUrl || '/chain-logos/chain-placeholder.png';
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/data/EIP155Data.ts">
import {
  AppKitNetwork,
  arbitrum,
  base,
  optimism,
} from "@reown/appkit/networks";

export interface Network {
  name: string;
  icon: string;
  chainId: number;
  chain: AppKitNetwork;
}

export interface Token {
  name: string;
  icon: string;
  address: string;
  supportedChainIds: number[];
  decimals: number;
}

export const supportedNetworks: Network[] = [
  {
    name: arbitrum.name,
    icon: "/chain-logos/arbitrum.png",
    chainId: arbitrum.id,
    chain: arbitrum,
  },
  {
    name: base.name,
    icon: "/chain-logos/base.webp",
    chainId: base.id,
    chain: base,
  },
  {
    name: optimism.name,
    icon: "/chain-logos/eip155-10.png",
    chainId: optimism.id,
    chain: optimism,
  },
];

export const supportedTokens: Token[] = [
  {
    name: "USDC",
    icon: "/token-images/USDC.png",
    address: "0x1",
    supportedChainIds: [arbitrum.id, base.id, optimism.id],
    decimals: 6
  },
  {
    name: "USDT",
    icon: "/token-images/USDT.png",
    address: "0x2",
    supportedChainIds: [arbitrum.id, optimism.id],
    decimals: 6
  },
  {
    name: "USDS",
    icon: "/token-images/USDS(DAI).png",
    address: "0x3",
    supportedChainIds: [base.id],
    decimals: 18
  },
];

export function isTokenSupportedOnNetwork(
  token: Token,
  networkChainId: number
): boolean {
  return token.supportedChainIds.includes(networkChainId);
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/hooks/use-media-query.ts">
import * as React from "react";

export function useMediaQuery(query: string) {
  const [value, setValue] = React.useState(false);

  React.useEffect(() => {
    function onChange(event: MediaQueryListEvent) {
      setValue(event.matches);
    }

    const result = matchMedia(query);
    result.addEventListener("change", onChange);
    setValue(result.matches);

    return () => result.removeEventListener("change", onChange);
  }, [query]);

  return value;
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/hooks/useWalletCheckout.ts">
import * as React from 'react'
import { useCallback, useEffect } from 'react'

import UniversalProvider from '@walletconnect/universal-provider'

import { useAppKitAccount, useAppKitProvider } from '@reown/appkit/react'

import type { EvmContractInteraction, PaymentOption } from '@/types/wallet_checkout'
import { createTokenTransferSolanaInstruction } from '@/utils/WalletCheckoutUtil'
import { parseEther, toHex } from 'viem'
import { encodeFunctionData, erc20Abi } from 'viem'

export function useWalletCheckout() {
  const { address, status } = useAppKitAccount({ namespace: 'eip155' })
  const { address: solanaAddress, status: solanaStatus } = useAppKitAccount({ namespace: 'solana' })
  const { walletProvider, walletProviderType } = useAppKitProvider<UniversalProvider>('eip155')
  const [isWalletCheckoutSupported, setIsWalletCheckoutSupported] = React.useState(false)
  const vitalikEthAddress = '0xd8da6bf26964af9d7eed9e03e53415d37aa96045'

  const getSolanaPaymentsOptions = useCallback(async () => {
    if (solanaAddress && solanaStatus === 'connected') {
      const paymentOptions: PaymentOption[] = [
        {
          asset:
            'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1/token:4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
          amount: '0xF4240',
          // Karandeep's devnet wallet
          recipient:
            'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1:2eudG2xaKDpyBJVMUMSAvSvhTWDnHJn9cCAoJeP9BZzz'
        },
        {
          asset: 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1/slip44:501',
          amount: '0xF4240',
          // Karandeep's devnet wallet
          recipient:
            'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1:2eudG2xaKDpyBJVMUMSAvSvhTWDnHJn9cCAoJeP9BZzz'
        }
        // ,{
        //   asset:
        //     'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1/token:4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
        //   amount: '0xF4240',
        //   // Karandeep's devnet wallet
        //   contractInteraction: await createTokenTransferSolanaInstruction({
        //     sourceAddress: solanaAddress,
        //     destinationAddress: '2eudG2xaKDpyBJVMUMSAvSvhTWDnHJn9cCAoJeP9BZzz',
        //     tokenMintAddress: '4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU',
        //     amount: 2
        //   })
        // }
      ]

      return paymentOptions
    }

    return []
  }, [solanaAddress, solanaStatus])

  const getEvmPaymentsOptions = useCallback(async () => {
    if (address && status === 'connected') {
      return [
        {
          recipient: `eip155:84532:${vitalikEthAddress}`,
          asset: 'eip155:84532/erc20:0x036CbD53842c5426634e7929541eC2318f3dCF7e',
          amount: '0xF4240' as `0x${string}`
        },
        {
          recipient: `eip155:84532:${vitalikEthAddress}`,
          asset: 'eip155:84532/slip44:60',
          amount: toHex(parseEther('0.0005'))
        },
        {
          asset: 'eip155:11155420/erc20:0x5fd84259d66Cd46123540766Be93DFE6D43130D7',
          amount: '0xF4240' as `0x${string}`,
          contractInteraction: {
            type: 'evm-calls',
            data: [
              {
                to: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7',
                data: encodeFunctionData({
                  abi: erc20Abi,
                  functionName: 'transfer',
                  args: [vitalikEthAddress as `0x${string}`, BigInt(1000000)]
                }),
                value: '0x0'
              }
            ]
          } as EvmContractInteraction
        }
      ]
    }

    return []
  }, [address, status])

  const isMethodSupported = useCallback(
    async ({
      provider,
      method,
      walletProviderType
    }: {
      provider: UniversalProvider
      method: string
      walletProviderType: string
    }): Promise<{ isSupported: boolean }> => {
      if (walletProviderType === 'WALLET_CONNECT') {
        const isSupported = Boolean(provider.namespaces?.['eip155']?.methods?.includes(method))

        return Promise.resolve({ isSupported })
      }

      return { isSupported: false }
    },
    []
  )

  const getPreConfiguredPaymentsOptions = useCallback(async () => {
    return [...(await getEvmPaymentsOptions()), ...(await getSolanaPaymentsOptions())]
  }, [getEvmPaymentsOptions, getSolanaPaymentsOptions])

  useEffect(() => {
    if (address && status === 'connected' && walletProvider && walletProviderType) {
      isMethodSupported({
        provider: walletProvider,
        method: 'wallet_checkout',
        walletProviderType
      }).then(({ isSupported }) => {
        setIsWalletCheckoutSupported(isSupported)
      })
    }
  }, [address, status, walletProvider, walletProviderType, isMethodSupported])


  return {
    isWalletCheckoutSupported,
    getPreConfiguredPaymentsOptions
  }
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/hooks/useWalletGetAssets.ts">
import * as React from "react";
import {
  useAppKitAccount,
  useAppKitNetwork,
  useAppKitProvider,
} from "@reown/appkit/react";
import UniversalProvider from "@walletconnect/universal-provider";
import { convertChainIdToHex, formatBalance } from "@/utils/FormatterUtil";
import {
  fetchFallbackBalances,
  type TokenBalance,
} from "@/utils/BalanceFetcherUtil";
import {
  Asset,
  WalletGetAssetsRPCRequest,
  WalletGetAssetsRPCResponse,
} from "@/types/ERC7811";
import { Capabilities } from "@/types/ERC5792";

async function getAssetDiscoveryCapabilities({
  provider,
  chainIdAsHex,
  address,
  walletProviderType,
}: {
  provider: UniversalProvider;
  chainIdAsHex: `0x${string}`;
  address: string;
  walletProviderType: string;
}): Promise<{
  hasAssetDiscovery: boolean;
  hasWalletService: boolean;
  walletServiceUrl?: string;
}> {
  try {
    // For WalletConnect, get walletService from scopedProperties CAIP-345
    if (walletProviderType === 'WALLET_CONNECT') {
      const eip155Capabilities =
        typeof provider.session?.scopedProperties?.['eip155'] === 'string'
          ? JSON.parse(provider.session.scopedProperties['eip155'])
          : {}

      const walletService = eip155Capabilities?.walletService || []

      // Handle case where walletService is undefined or not an array
      if (!Array.isArray(walletService)) {
        return {
          hasAssetDiscovery: false,
          hasWalletService: false,
          walletServiceUrl: undefined
        }
      }

      const assetDiscoveryService = walletService.find(
        (service: { url: string; methods: string[] }) =>
          service?.methods?.includes('wallet_getAssets')
      )

      return {
        hasAssetDiscovery: Boolean(assetDiscoveryService),
        hasWalletService: Boolean(assetDiscoveryService?.url),
        walletServiceUrl: assetDiscoveryService?.url
      }
    }

    const capabilities: Capabilities = await provider.request({
      method: "wallet_getCapabilities",
      params: [address],
    });

    const hasAssetDiscovery =
      capabilities[chainIdAsHex]?.assetDiscovery?.supported ?? false;

    return {
      hasAssetDiscovery,
      hasWalletService: false,
    };
  } catch (error) {
    // Some wallet don't support wallet_getCapabilities and throws error when called
    return {
      hasAssetDiscovery: false,
      hasWalletService: false,
    };
  }
}

function processAssetsToBalances(
  chainAssets: Asset[],
  chainIdNum: number,
): TokenBalance[] {
  return chainAssets.map((asset) => ({
    symbol: asset.metadata.symbol,
    balance: formatBalance(BigInt(asset.balance), asset.metadata.decimals),
    address: asset.address as `0x${string}`,
    chainId: chainIdNum,
  }));
}

async function getAssetsViaWalletService(
  request: WalletGetAssetsRPCRequest,
  walletServiceUrl: string,
): Promise<Record<`0x${string}`, Asset[]>> {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }

  const rpcRequest = {
    jsonrpc: "2.0",
    id: Math.floor(Math.random() * 1000000),
    method: "wallet_getAssets",
    params: request,
  };

  const url = new URL(walletServiceUrl);
  url.searchParams.set("projectId", projectId);

  const response = await fetch(url.toString(), {
    body: JSON.stringify(rpcRequest),
    method: "POST",
    headers: { "Content-Type": "application/json" },
  });

  const { result } = (await response.json()) as WalletGetAssetsRPCResponse;

  return result;
}

async function getAssetsViaProvider(
  provider: UniversalProvider,
  request: WalletGetAssetsRPCRequest,
): Promise<Record<`0x${string}`, Asset[]>> {
  const response: Record<`0x${string}`, Asset[]> = await provider.request({
    method: "wallet_getAssets",
    params: [request],
  });

  return response;
}

export const useWalletGetAssets = () => {
  const { address, status } = useAppKitAccount();
  const { chainId } = useAppKitNetwork();
  const { walletProvider, walletProviderType } =
    useAppKitProvider<UniversalProvider>("eip155");

  const fetchBalances = React.useCallback(async (): Promise<TokenBalance[]> => {
    if (
      !address ||
      status !== "connected" ||
      !chainId ||
      !walletProvider ||
      !walletProviderType
    ) {
      return [];
    }
    const chainIdAsHex = convertChainIdToHex(parseInt(chainId.toString(), 10));
    const request: WalletGetAssetsRPCRequest = {
      account: address,
      chainFilter: [chainIdAsHex],
    };

    try {
      // Check wallet capabilities first
      const capabilities = await getAssetDiscoveryCapabilities({
        provider: walletProvider,
        chainIdAsHex,
        address,
        walletProviderType,
      });

      let assetsResponse: Record<`0x${string}`, Asset[]> = {};

      if (capabilities.hasAssetDiscovery) {
        if (
          walletProviderType === "WALLET_CONNECT" &&
          capabilities.hasWalletService &&
          capabilities.walletServiceUrl
        ) {
          // Use WalletService to fetch assets
          assetsResponse = await getAssetsViaWalletService(
            request,
            capabilities.walletServiceUrl,
          );
        } else {
          // Fallback to direct provider call
          assetsResponse = await getAssetsViaProvider(walletProvider, request);
        }

        const chainAssets = assetsResponse[chainIdAsHex]
        if (chainAssets && chainAssets.length > 0) {
          return processAssetsToBalances(
            chainAssets,
            parseInt(chainIdAsHex.slice(2), 16),
          );
        }
      }

      // If we get here, either asset discovery isn't supported or returned no results
      return await fetchFallbackBalances(
        address as `0x${string}`,
        chainIdAsHex,
      );
    } catch (error) {
      throw new Error(
        `Error fetching assets: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }, [address, status, chainId, walletProvider, walletProviderType]);

  const getBalanceBySymbol = (balances: TokenBalance[], symbol: string) => {
    return balances.find((b) => b.symbol === symbol)?.balance || "0.00";
  };

  const getBalanceByAddress = (
    balances: TokenBalance[],
    address: `0x${string}`,
  ) => {
    return balances.find((b) => b.address === address)?.balance || "0.00";
  };

  return {
    fetchBalances,
    getBalanceByAddress,
    getBalanceBySymbol,
  };
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/public/.well-known/walletconnect.txt">
6025eb18-b3cb-471c-af2f-d4945777886a=cd9cfc50fcb49c77b511f53fcdd336589c05f1ec6e6cc5d4fbf4ebe7f8b9cb07
</file>

<file path="advanced/dapps/chain-abstraction-demo/types/ERC5792.ts">
interface WalletCapability {
  wallet_getAssets?: string;
}

interface ChainCapabilities {
  walletService?: WalletCapability;
  assetDiscovery?: {
    supported: boolean;
  };
}

export interface Capabilities {
  [chainId: string]: ChainCapabilities;
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/types/ERC7811.ts">
type Hex = `0x${string}`;

interface TokenMetadata {
  name: string;
  symbol: string;
  decimals: number;
}

export interface Asset {
  address: Hex | "native";
  balance: Hex;
  type: string;
  metadata: TokenMetadata;
}

export interface WalletGetAssetsRPCResponse {
  jsonrpc: string;
  id: number;
  result: Record<Hex, Asset[]>;
}

export type WalletGetAssetsRPCRequest = {
  account: string;
  chainFilter?: Hex[];
  assetFilter?: Record<Hex, (Hex | "native")[]>;
  assetTypeFilter?: ("NATIVE" | "ERC20")[];
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/types/wallet_checkout.ts">
/**
 * Hexadecimal string representation with '0x' prefix
 */
export type Hex = `0x${string}`

/**
 * Metadata for a product included in the checkout
 * @property name - The name of the product
 * @property description - Optional description of the product
 * @property imageUrl - Optional URL to an image of the product
 * @property price - Optional price of the product in a human-readable format (e.g. "$100.00")
 */
export type ProductMetadata = {
  /** The name of the product */
  name: string
  /** Optional description of the product */
  description?: string
  /** Optional URL to an image of the product */
  imageUrl?: string
  /** Optional price of the product in a human-readable format (e.g. "$100.00") */
  price?: string
}

/**
 * Smart contract interaction details
 * @property type - The type of contract interaction (e.g. "evm-calls", "solana-instruction")
 * @property data - Data required for the specific contract interaction type
 */
export type ContractInteraction = {
  /** The type of contract interaction (e.g. "evm-calls", "solana-instruction") */
  type: string
  /** Data required for the specific contract interaction type */
  data: Record<string, any>
}

/**
 * EVM-specific contract interaction
 * @property type - Must be "evm-calls"
 * @property data - Array of contract call data objects
 */
export type EvmContractInteraction = {
  /** Must be "evm-calls" */
  type: 'evm-calls'
  /** Array of contract call data objects */
  data: {
    /** Contract address */
    to: string
    /** Optional additional ETH value */
    value?: Hex
    /** Contract call data */
    data: Hex
  }[]
}

/**
 * Solana-specific contract interaction
 * @property type - Must be "solana-instruction"
 * @property data - Solana instruction data
 */
export type SolanaContractInteraction = {
  /** Must be "solana-instruction" */
  type: 'solana-instruction'
  /** Solana instruction data */
  data: {
    /** Program ID */
    programId: string
    /** Accounts involved in the instruction */
    accounts: {
      /** Account public key */
      pubkey: string
      /** Whether the account needs to sign the transaction */
      isSigner: boolean
      /** Whether the account's data will be modified */
      isWritable: boolean
    }[]
    /** Base64-encoded instruction data */
    data: string
  }
}

/**
 * A payment option for the checkout
 * @property asset - CAIP-19 asset identifier
 * @property amount - Hex-encoded amount of the asset to transfer
 * @property recipient - Optional CAIP-10 account ID of the recipient (required for direct payments)
 * @property contractInteraction - Optional contract interaction details (required for contract-based payments)
 */
export type PaymentOption = {
  /** CAIP-19 asset identifier */
  asset: string
  /** Hex-encoded amount of the asset to transfer */
  amount: Hex
  /** CAIP-10 account ID of the recipient (required for direct payments) */
  recipient?: string
  /** Contract interaction details (required for contract-based payments) */
  contractInteraction?: ContractInteraction
}

/**
 * Checkout request parameters
 * @property orderId - Unique identifier for this checkout request (max 128 chars)
 * @property acceptedPayments - Array of accepted payment options
 * @property products - Optional array of product metadata
 * @property expiry - Optional UNIX timestamp (seconds) after which the payment request expires
 */
export type CheckoutRequest = {
  /** Unique identifier for this checkout request (max 128 chars) */
  orderId: string
  /** Array of accepted payment options */
  acceptedPayments: PaymentOption[]
  /** Optional array of product metadata */
  products?: ProductMetadata[]
  /** Optional UNIX timestamp (seconds) after which the payment request expires */
  expiry?: number
}

/**
 * Checkout result returned by the wallet
 * @property orderId - Matching order ID from the original request
 * @property txid - Transaction identifier on the blockchain
 * @property recipient - Optional CAIP-10 account ID that received the payment
 * @property asset - Optional CAIP-19 asset identifier that was used for payment
 * @property amount - Optional hex-encoded amount that was paid
 */
export type CheckoutResult = {
  /** Matching order ID from the original request */
  orderId: string
  /** Transaction identifier on the blockchain */
  txid: string
  /** CAIP-10 account ID that received the payment */
  recipient?: string
  /** CAIP-19 asset identifier that was used for payment */
  asset?: string
  /** Hex-encoded amount that was paid */
  amount?: Hex
}

/**
 * Error codes for wallet_checkout method
 */
// eslint-disable-next-line no-shadow
export enum CheckoutErrorCode {
  /** User rejected the payment */
  USER_REJECTED = 4001,
  /** No matching assets available in user's wallet */
  NO_MATCHING_ASSETS = 4100,
  /** Checkout has expired */
  CHECKOUT_EXPIRED = 4200,
  /** Insufficient funds for the payment */
  INSUFFICIENT_FUNDS = 4300,
  /** Unsupported contract interaction type */
  UNSUPPORTED_CONTRACT_INTERACTION = 4400,
  /** Invalid contract interaction data */
  INVALID_CONTRACT_INTERACTION_DATA = 4401,
  /** Contract interaction failed during execution */
  CONTRACT_INTERACTION_FAILED = 4402,
  /** Method not found (wallet doesn't support wallet_checkout) */
  METHOD_NOT_FOUND = -32601
}

/**
 * Checkout error response
 * @property code - Error code indicating the type of error
 * @property message - Description of the error
 * @property data - Optional additional data about the error
 */
export type CheckoutError = {
  /** Error code indicating the type of error */
  code: CheckoutErrorCode
  /** Description of the error */
  message: string
  /** Optional additional data about the error */
  data?: any
}

/**
 * JSON-RPC request for wallet_checkout method
 * @property method - Must be "wallet_checkout"
 * @property params - Array containing the CheckoutRequest object
 * @property id - Request identifier
 * @property jsonrpc - JSON-RPC version, must be "2.0"
 */
export type WalletCheckoutRequest = {
  /** Must be "wallet_checkout" */
  method: 'wallet_checkout'
  /** Array containing the CheckoutRequest object */
  params: [CheckoutRequest]
  /** Request identifier */
  id: number | string
  /** JSON-RPC version, must be "2.0" */
  jsonrpc: '2.0'
}

/**
 * JSON-RPC successful response for wallet_checkout method
 * @property result - The checkout result
 * @property id - Matching request identifier
 * @property jsonrpc - JSON-RPC version, must be "2.0"
 */
export type WalletCheckoutSuccessResponse = {
  /** The checkout result */
  result: CheckoutResult
  /** Matching request identifier */
  id: number | string
  /** JSON-RPC version, must be "2.0" */
  jsonrpc: '2.0'
}

/**
 * JSON-RPC error response for wallet_checkout method
 * @property error - The error details
 * @property id - Matching request identifier
 * @property jsonrpc - JSON-RPC version, must be "2.0"
 */
export type WalletCheckoutErrorResponse = {
  /** The error details */
  error: CheckoutError
  /** Matching request identifier */
  id: number | string
  /** JSON-RPC version, must be "2.0" */
  jsonrpc: '2.0'
}

/**
 * JSON-RPC response for wallet_checkout method (success or error)
 */
export type WalletCheckoutResponse = WalletCheckoutSuccessResponse | WalletCheckoutErrorResponse
</file>

<file path="advanced/dapps/chain-abstraction-demo/utils/BalanceFetcherUtil.ts">
import { usdcTokenAddresses, usdtTokenAddresses, usdsTokenAddresses } from "@/consts/tokens";
import { createPublicClient, erc20Abi, Hex, http, PublicClient } from "viem";
import { formatBalance } from "@/utils/FormatterUtil";
import { getChain } from "@/utils/NetworksUtil";

interface TokenConfig {
  symbol: string;
  decimals: number;
  address: Hex;
}

export interface TokenBalance {
  symbol: string;
  balance: string;
  address: `0x${string}`;
  chainId: number;
}

// Helper function to fetch ERC20 token balance
async function fetchTokenBalance({
  publicClient,
  userAddress,
  tokenConfig,
  chainId,
}: {
  publicClient: PublicClient;
  userAddress: Hex;
  tokenConfig: TokenConfig;
  chainId: number;
}): Promise<TokenBalance | null> {
  try {
    const balance = await publicClient.readContract({
      address: tokenConfig.address,
      abi: erc20Abi,
      functionName: "balanceOf",
      args: [userAddress],
    });

    return {
      symbol: tokenConfig.symbol,
      balance: formatBalance(balance, tokenConfig.decimals),
      address: tokenConfig.address,
      chainId,
    };
  } catch (error) {
    console.error(`Error fetching ${tokenConfig.symbol} balance:`, error);

    return null;
  }
}
function getTransport({ chainId }: { chainId: number }) {
  return http(
    `https://rpc.walletconnect.org/v1/?chainId=eip155:${chainId}&projectId=${process.env["NEXT_PUBLIC_PROJECT_ID"]}`,
  );
}
export async function fetchFallbackBalances(
  userAddress: Hex,
  currentChainIdAsHex: Hex,
): Promise<TokenBalance[]> {
  const currentChainId = parseInt(currentChainIdAsHex.slice(2), 16);

  try {
    const chain = getChain(currentChainId);
    if (!chain) {
      console.error(`Chain not found for ID: ${currentChainId}`);

      return [];
    }

    // Create public client for current chain
    const publicClient = createPublicClient({
      chain,
      transport: getTransport({ chainId: chain.id }),
    }) as PublicClient;

    const balances: TokenBalance[] = [];

    // Fetch native token balance
    try {
      const nativeBalance = await publicClient.getBalance({
        address: userAddress,
      });

      balances.push({
        symbol: chain.nativeCurrency.symbol,
        balance: formatBalance(nativeBalance, chain.nativeCurrency.decimals),
        address: "0x" as Hex,
        chainId: currentChainId,
      });
    } catch (error) {
      console.error(`Error fetching native balance:`, error);
    }

    // Get supported tokens for current chain
    const supportedTokens: TokenConfig[] = [];

    // Add USDC if supported
    const usdcAddress = usdcTokenAddresses[currentChainId];
    if (usdcAddress) {
      supportedTokens.push({
        symbol: "USDC",
        decimals: 6,
        address: usdcAddress,
      });
    }

    // Add USDT if supported
    const usdtAddress = usdtTokenAddresses[currentChainId];
    if (usdtAddress) {
      supportedTokens.push({
        symbol: "USDT",
        decimals: 6,
        address: usdtAddress,
      });
    }

    // Add USDS if supported
    const usdsAddress = usdsTokenAddresses[currentChainId];
    if (usdsAddress) {
      supportedTokens.push({
        symbol: "USDS",
        decimals: 18,
        address: usdsAddress,
      });
    }

    // Fetch token balances
    const tokenResults = await Promise.all(
      supportedTokens.map((token) =>
        fetchTokenBalance({
          publicClient,
          userAddress,
          tokenConfig: token,
          chainId: currentChainId,
        }),
      ),
    );

    // Add successful token balances
    tokenResults.forEach((result) => {
      if (result) {
        balances.push(result);
      }
    });

    return balances;
  } catch (error) {
    console.error("Error in fetchFallbackBalances:", error);

    return [];
  }
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/utils/FormatterUtil.ts">
export const formatBalance = (balance: bigint, decimals: number): string => {
  const value = Number(balance) / Math.pow(10, decimals);
  if (value >= 0.01) return value.toFixed(2);
  const significantDecimals = Math.min(6, decimals);
  return value.toFixed(significantDecimals).replace(/\.?0+$/, "");
};

export const convertChainIdToHex = (chainId: number): `0x${string}` => {
  return `0x${parseInt(chainId.toString()).toString(16)}` as `0x${string}`;
};
</file>

<file path="advanced/dapps/chain-abstraction-demo/utils/NetworksUtil.ts">
import * as viemChains from "viem/chains";

export function getChain(chainId: number) {
  const chain = Object.values(viemChains).find((chain) => chain.id === chainId);
  if (!chain) {
    throw new Error(`Unsupported chain ID: ${chainId}`);
  }
  return chain;
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/utils/WalletCheckoutUtil.ts">
import { createTransferInstruction, getAssociatedTokenAddress } from '@solana/spl-token'
import { PublicKey } from '@solana/web3.js'
import { encodeFunctionData, parseEther, toHex } from 'viem'
import { erc20Abi } from 'viem'

import { baseSepolia, optimismSepolia } from '@reown/appkit/networks'

import type {
  EvmContractInteraction,
  PaymentOption,
  SolanaContractInteraction
} from '@/types/wallet_checkout'

// Chain IDs for supported testnets
export type AllowedChainId = 84532 | 11155420

export const ALLOWED_CHAINS = [baseSepolia, optimismSepolia]

/**
 * Token symbol to address mapping for each supported chain
 */
export const TOKEN_CONFIG: Record<number, Record<string, string>> = {
  // Base Sepolia tokens
  [baseSepolia.id]: {
    USDC: '0x036CbD53842c5426634e7929541eC2318f3dCF7e'
  },
  // Optimism Sepolia tokens
  [optimismSepolia.id]: {
    USDC: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7'
  }
}

/**
 * Get token address by chain ID and symbol
 */
export function getTokenAddress(chainId: number, symbol: string): string | undefined {
  return TOKEN_CONFIG[chainId]?.[symbol]
}

/**
 * Get token symbol by chain ID and address
 */
export function getTokenSymbol(chainId: number, address: string): string | undefined {
  const tokenMap = TOKEN_CONFIG[chainId]
  if (!tokenMap) {
    return undefined
  }

  const entry = Object.entries(tokenMap).find(
    ([_, tokenAddress]) => tokenAddress.toLowerCase() === address.toLowerCase()
  )

  return entry?.[0]
}

/**
 * Get token symbol from a CAIP-19 asset identifier
 * Example formats:
 * - 'eip155:11155111/erc20:0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238' (ERC20 token)
 * - 'eip155:11155111/slip44:60' (Native ETH)
 */
export function getTokenSymbolFromAsset(asset?: string): string {
  // Handle undefined or empty asset
  if (!asset) {
    return 'Unknown'
  }

  // Extract parts from the asset identifier
  const parts = asset.split('/')
  const chainPart = parts[0]?.split(':') || []
  const chainId = Number(chainPart[1] || '0')

  // Handle only known token types Case 1: Native ETH (slip44:60) - this is standard for Ethereum
  if (parts[1]?.startsWith('slip44:60')) {
    return 'ETH'
  }

  // Case 2: ERC20 tokens - check if we know this specific token
  if (parts[1]?.startsWith('erc20:')) {
    const tokenAddress = parts[1].split(':')[1]
    if (tokenAddress) {
      // Look up symbol in our config
      const symbol = getTokenSymbol(chainId, tokenAddress)
      if (symbol) {
        return symbol
      }

      // For unknown ERC20, display a shortened address
      return `0x${tokenAddress.substring(0, 4)}..${tokenAddress.substring(tokenAddress.length - 4)}`
    }
  }

  // For all other cases, return "Unknown" with chainId if available for some context
  return chainId ? `Unknown (Chain ${chainId})` : 'Unknown Asset'
}

// Helper function to get chain name from chain ID
export function getChainName(chainId: string | number): string {
  const chain = ALLOWED_CHAINS.find(c => c.id === Number(chainId))

  return chain?.name || `Chain ${chainId}`
}

// Get token options for the selected chain
export function getTokenOptions(
  chainId: number
): { address: string; name: string; symbol: string }[] {
  const tokensByChain = TOKEN_CONFIG[chainId]
  if (!tokensByChain) {
    return []
  }

  return Object.entries(tokensByChain).map(([symbol, address]) => ({
    symbol,
    address,
    name: `${symbol} on ${getChainName(chainId)}`
  }))
}

// Get token symbol by address and chainId
export function getTokenSymbolByAddress(assetString?: string): string | undefined {
  if (!assetString) {
    return undefined
  }

  // Parse CAIP-19 asset format: 'eip155:1/erc20:0x6b175474e89094c44da98b954eedeac495271d0f'
  const assetParts = assetString.split('/')
  if (assetParts.length !== 2) {
    return undefined
  }

  const chainPart = assetParts[0]?.split(':') || []
  const tokenPart = assetParts[1]?.split(':') || []

  if (chainPart.length !== 2 || tokenPart.length !== 2) {
    return undefined
  }
  // Handle only known token types Case 1: Native ETH (slip44:60) - this is standard for Ethereum
  if (assetParts[1]?.startsWith('slip44:60')) {
    return 'ETH'
  }
  const chainId = Number(chainPart[1])
  const tokenAddress = tokenPart[1] ? tokenPart[1].toLowerCase() : ''

  // Skip lookup if tokenAddress is empty
  if (!tokenAddress) {
    return undefined
  }

  // Look up the token symbol in our token configuration
  const tokenSymbol = getTokenSymbol(chainId, tokenAddress)

  return tokenSymbol
}

// Function to shorten an address for display
export function shortenAddress(addressInput?: string): string {
  if (!addressInput) {
    return ''
  }

  // If it's a CAIP format, extract the actual address part
  let displayAddress = addressInput
  if (displayAddress.includes(':')) {
    const parts = displayAddress.split(':')
    displayAddress = parts[parts.length - 1] || ''
  }

  if (displayAddress.length <= 10) {
    return displayAddress
  }

  return `${displayAddress.substring(0, 6)}...${displayAddress.substring(displayAddress.length - 4)}`
}

export async function createTokenTransferSolanaInstruction(params: {
  sourceAddress: string
  destinationAddress: string
  tokenMintAddress: string
  amount: number
}): Promise<SolanaContractInteraction> {
  const { sourceAddress, destinationAddress, tokenMintAddress, amount } = params
  // Convert string addresses to PublicKey objects
  const sourcePublicKey = new PublicKey(sourceAddress)
  const destinationPublicKey = new PublicKey(destinationAddress)
  const tokenMintPublicKey = new PublicKey(tokenMintAddress)

  // Get the token accounts
  const sourceTokenAccount = await getAssociatedTokenAddress(tokenMintPublicKey, sourcePublicKey)

  const destinationTokenAccount = await getAssociatedTokenAddress(
    tokenMintPublicKey,
    destinationPublicKey
  )

  // Create the transfer instruction
  const transferInstruction = createTransferInstruction(
    sourceTokenAccount,
    destinationTokenAccount,
    sourcePublicKey,
    amount
  )

  // Format the instruction in the required structure
  const formattedInstruction: SolanaContractInteraction = {
    type: 'solana-instruction',
    data: {
      programId: transferInstruction.programId.toString(),
      accounts: transferInstruction.keys.map(key => ({
        pubkey: key.pubkey.toString(),
        isSigner: key.isSigner,
        isWritable: key.isWritable
      })),
      data: Buffer.from(transferInstruction.data).toString('base64')
    }
  }

  return formattedInstruction
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/.env.example">
NEXT_PUBLIC_PROJECT_ID=
</file>

<file path="advanced/dapps/chain-abstraction-demo/.eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="advanced/dapps/chain-abstraction-demo/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
</file>

<file path="advanced/dapps/chain-abstraction-demo/package.json">
{
  "name": "chain-abstraction-demo",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,css,md}\""
  },
  "dependencies": {
    "@radix-ui/react-dialog": "1.1.4",
    "@radix-ui/react-icons": "1.3.1",
    "@radix-ui/react-label": "2.1.1",
    "@radix-ui/react-separator": "1.1.1",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tooltip": "1.1.7",
    "@radix-ui/react-visually-hidden": "1.1.1",
    "@reown/appkit": "1.7.2-848ad47d64ddbea4cbe4768f7374f63f2fcdf8a5.0",
    "@reown/appkit-adapter-solana": "1.7.2-848ad47d64ddbea4cbe4768f7374f63f2fcdf8a5.0",
    "@reown/appkit-adapter-wagmi": "1.7.2-848ad47d64ddbea4cbe4768f7374f63f2fcdf8a5.0",
    "@reown/appkit-wallet": "1.7.2-848ad47d64ddbea4cbe4768f7374f63f2fcdf8a5.0",
    "@solana/spl-token": "^0.4.13",
    "@tanstack/react-query": "5.59.19",
    "class-variance-authority": "0.7.0",
    "clsx": "2.1.1",
    "lucide-react": "0.439.0",
    "next": "14.2.26",
    "next-themes": "^0.4.4",
    "ox": "0.6.9",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "sonner": "1.7.1",
    "tailwind-merge": "2.5.2",
    "tailwindcss-animate": "1.0.7",
    "vaul": "1.1.2",
    "viem": "2.23.5",
    "wagmi": "2.14.12"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "encoding": "0.1.13",
    "eslint": "^8",
    "eslint-config-next": "14.2.25",
    "pino-pretty": "^11.3.0",
    "postcss": "^8",
    "prettier": "^3.3.3",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}
</file>

<file path="advanced/dapps/chain-abstraction-demo/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="advanced/dapps/chain-abstraction-demo/README.md">
# Chain Abstraction Demo

This application demonstrates chain abstraction functionality using Reown's AppKit, allowing users to send stablecoins across multiple networks seamlessly.

![Chain Abstraction Flow Diagram](./chain-abstraction-flow.png)

## Setup and Installation

### Step 1: Configure Environment Variables

1. Locate the `.env.example` file in the project root
2. Copy it to create a new file named `.env`
3. Get your Project ID from [Reown Cloud](https://cloud.reown.com/)
4. Add your Project ID to the `.env` file:

### Step 2: Install Dependencies

```bash
npm install
# or
yarn install
# or
pnpm install
# or
bun install
```

### Step 3: Start the Development Server

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Reown, take a look at the following resources:

- [Reown Website](https://reown.com/)
- [Reown Documentation](https://docs.reown.com/)
- [Reown Cloud](https://cloud.reown.com/)
- [Reown AppKit](https://demo.reown.com/)
</file>

<file path="advanced/dapps/chain-abstraction-demo/tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
</file>

<file path="advanced/dapps/chain-abstraction-demo/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="advanced/dapps/chat-demo-agent/public/.well-known/walletconnect.txt">
253b0e1f-1ab1-4f7f-ab08-ffa25599ba5c=cd9cfc50fcb49c77b511f53fcdd336589c05f1ec6e6cc5d4fbf4ebe7f8b9cb07
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/api/send-message/request-validation.ts">
import { MessageWithContext } from '@/types/chat/types';
import { ErrorCodes, AppError } from '@/errors/api-errors';
import { SmartSessionGrantPermissionsResponse } from '@reown/appkit-experimental/smart-session';

/**
 * Maximum allowed length for message text to prevent abuse
 */
const MAX_MESSAGE_LENGTH = 300;

/**
 * Maximum allowed number of messages in history to prevent memory issues
 */
const MAX_HISTORY_LENGTH = 20;

/**
 * Type guard to validate the structure and content of message history
 * @param history - The message history to validate
 * @returns Boolean indicating if the history is valid
 */
function isValidMessageHistory(
  history: unknown
): history is Array<{ sender: 'user' | 'system'; text: string }> {
  if (!Array.isArray(history)) {
    return false;
  }

  if (history.length > MAX_HISTORY_LENGTH) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      `Message history exceeds maximum length of ${MAX_HISTORY_LENGTH}`
    );
  }

  return history.every((msg, index) => {
    if (!msg || typeof msg !== 'object') {
      throw new AppError(
        ErrorCodes.INVALID_REQUEST_BODY,
        `Invalid message object at index ${index}`
      );
    }

    if (!('sender' in msg) || !('text' in msg)) {
      throw new AppError(
        ErrorCodes.INVALID_REQUEST_BODY,
        `Missing required fields at message index ${index}`
      );
    }

    if (msg.sender !== 'user' && msg.sender !== 'system') {
      throw new AppError(
        ErrorCodes.INVALID_REQUEST_BODY,
        `Invalid sender type at message index ${index}`
      );
    }

    if (typeof msg.text !== 'string') {
      throw new AppError(
        ErrorCodes.INVALID_REQUEST_BODY,
        `Message text must be a string at index ${index}`
      );
    }

    if ( msg.sender !== 'system' && msg.text.length > MAX_MESSAGE_LENGTH) {
      throw new AppError(
        ErrorCodes.INVALID_REQUEST_BODY,
        `Message text exceeds maximum length at index ${index}`
      );
    }

    return true;
  });
}

/**
 * Validates the structure and content of permissions object
 * @param permissions - The permissions object to validate
 * @returns Boolean indicating if the permissions are valid
 * @throws AppError if validation fails
 */
function isValidPermissions(
  permissions: unknown
): permissions is SmartSessionGrantPermissionsResponse {
  if (!permissions || typeof permissions !== 'object') {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Permissions must be a non-null object'
    );
  }

  const p = permissions as SmartSessionGrantPermissionsResponse;

  // Validate chainId
  if (!p.chainId || !/^0x[0-9a-fA-F]+$/.test(p.chainId)) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Invalid chainId format'
    );
  }

  // Validate address
  if (!p.address || !/^0x[0-9a-fA-F]{40}$/.test(p.address)) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Invalid address format'
    );
  }

  // Validate expiry
  if (!Number.isInteger(p.expiry) || p.expiry < Date.now()/1000) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Invalid or expired permissions'
    );
  }

  // Validate permissions array
  if (!Array.isArray(p.permissions)) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Permissions must be an array'
    );
  }

  // Validate context
  if (typeof p.context !== 'string') {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Context must be a string'
    );
  }

  return true;
}

/**
 * Type guard to validate the complete message with context
 * @param data - The data to validate
 * @returns Boolean indicating if the data is valid
 * @throws AppError if validation fails
 */
function isValidMessageWithContext(data: unknown): data is MessageWithContext {
  if (!data || typeof data !== 'object') {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Request body must be an object'
    );
  }

  const { currentMessage, messageHistory, permissions } = data as Partial<MessageWithContext>;

  // Validate currentMessage
  if (!currentMessage || typeof currentMessage !== 'string') {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'currentMessage must be a non-empty string'
    );
  }

  if (currentMessage.length > MAX_MESSAGE_LENGTH) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      `currentMessage exceeds maximum length of ${MAX_MESSAGE_LENGTH}`
    );
  }

  // Validate messageHistory
  if (!messageHistory) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'messageHistory is required'
    );
  }
  isValidMessageHistory(messageHistory);

  // Validate permissions
  if (!permissions) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'permissions object is required'
    );
  }
  isValidPermissions(permissions);

  return true;
}

/**
 * Parses and validates an incoming request
 * @param request - The incoming HTTP request
 * @returns Promise resolving to validated MessageWithContext
 * @throws AppError for any validation or parsing errors
 */
async function parseRequest(request: Request): Promise<MessageWithContext> {
  // Validate content type
  const contentType = request.headers.get('content-type');
  if (!contentType?.includes('application/json')) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Content-Type must be application/json'
    );
  }

  let body: unknown;

  try {
    body = await request.json();
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  } catch (e) {
    throw new AppError(
      ErrorCodes.INVALID_REQUEST_BODY,
      'Failed to parse JSON body'
    );
  }

  isValidMessageWithContext(body);

  return body as MessageWithContext;
}

export { parseRequest };
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/api/send-message/route.ts">
import { NextResponse } from 'next/server';
import { getOpenAIResponse } from '@/lib/services/openai';
import { SwapService } from '@/lib/services/swap';
import { ExpectedResponse } from '@/types/api';
import { ErrorCodes, ErrorDescriptions, AppError, ErrorCodeType } from '@/errors/api-errors';
import { SmartSessionGrantPermissionsResponse } from '@reown/appkit-experimental/smart-session';
import { parseRequest } from './request-validation';

export const runtime = 'edge';

// Updated type guard for new response format
function isValidResponse(response: unknown): response is ExpectedResponse {
  if (!response || typeof response !== 'object' || !('intent' in response)) {
    return false;
  }

  const typedResponse = response as Record<string, unknown>;

  if (typedResponse.intent === 'SWAP') {
    return typeof typedResponse.amount === 'string';
  }

  if (typedResponse.intent === 'GET_SWAP_RECEIPT') {
    return typeof typedResponse.purchaseId === 'string';
  }

  if (typedResponse.intent === 'NOT_SWAP') {
    return typeof typedResponse.responseText === 'string';
  }

  return false;
}

// Separate intent handler functions
async function handleSwapIntent(permissions: SmartSessionGrantPermissionsResponse, amount:string) {
  const swapResult = await SwapService.executeSwap(permissions, amount);
  return NextResponse.json(swapResult);
}

async function handleReceiptIntent(purchaseId: string | undefined) {
  if (!purchaseId) {
    throw new AppError(
      ErrorCodes.RECEIPT_FETCH_ERROR,
      'Missing required fields for receipt'
    );
  }
  
  const receipt = await SwapService.getSwapReceipt(purchaseId);
  return NextResponse.json(receipt);
}

function handleNotSwapIntent(responseText: string | undefined) {
  return NextResponse.json({
    message: responseText || "I'm sorry, I didn't understand that.",
    status: 'success'
  });
}

// Process OpenAI response
async function processOpenAIResponse(
  currentMessage: string,
  chatHistory: Array<{ role: 'system' | 'user'; content: string }>
) {
  try {
    const completion = await getOpenAIResponse(currentMessage, chatHistory);
    const response = completion.choices[0].message;

    if (!response?.content) {
      throw new AppError(
        ErrorCodes.INVALID_OPENAI_RESPONSE,
        'Empty response from OpenAI'
      );
    }

    const parsedResponse = JSON.parse(response.content);
    
    if (!isValidResponse(parsedResponse)) {
      throw new AppError(
        ErrorCodes.INVALID_OPENAI_RESPONSE,
        'Invalid response structure from OpenAI'
      );
    }

    return parsedResponse;
  } catch (e) {
    if (e instanceof AppError) throw e;
    throw new AppError(
      ErrorCodes.OPENAI_RESPONSE_ERROR,
      'Failed to process OpenAI response'
    );
  }
}

// Main handler
async function handlePost(request: Request) {
  try {
    const { currentMessage, messageHistory, permissions } = await parseRequest(request);

    const chatHistory = messageHistory.map(msg => ({
      role: msg.sender === 'user' ? 'user' : 'system',
      content: msg.text
    } as const));

    const parsedResponse = await processOpenAIResponse(currentMessage, chatHistory);

    switch (parsedResponse.intent) {
      case "SWAP":
        return handleSwapIntent(permissions, parsedResponse.amount);

      case "GET_SWAP_RECEIPT":
        return handleReceiptIntent(parsedResponse.purchaseId);

      case "NOT_SWAP":
        return handleNotSwapIntent(parsedResponse.responseText);

      default:
        throw new AppError(
          ErrorCodes.INVALID_INTENT,
          `Unhandled intent: ${parsedResponse}`
        );
    }

  } catch (error: unknown) {
    const { errorCode, errorMessage } = error instanceof AppError
      ? { errorCode: error.code, errorMessage: error.message }
      : { errorCode: ErrorCodes.UNKNOWN_ERROR as ErrorCodeType, errorMessage: ErrorDescriptions[ErrorCodes.UNKNOWN_ERROR] };

    console.error('API Error:', {
      code: errorCode,
      message: errorMessage,
      error
    });
    
    return NextResponse.json(
      { 
        status: 'error',
        message: `Unable to process the request [${errorCode}]`
      },
      { status: 500 }
    );
  }
}

export const POST = handlePost;
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/api/signer/route.ts">
import { NextResponse } from "next/server";
import { privateKeyToAccount } from "viem/accounts";

export const dynamic = "force-static"

export function GET() {
  try {
    const APPLICATION_PRIVATE_KEY = process.env
      .APPLICATION_PRIVATE_KEY as `0x${string}`;
    const account = privateKeyToAccount(APPLICATION_PRIVATE_KEY);

    return NextResponse.json({ key: account.publicKey });
  } catch (e) {
    console.warn("Error getting signer:", e);

    return NextResponse.json(
      { message: "Error getting application signer" },
      { status: 500 },
    );
  }
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 15%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 15%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 13%;
    --foreground: 0 0% 15%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 15%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 15%;
    --primary: 0 0% 15%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 60%;
    --secondary-foreground: 0 0% 15%;
    --muted: 0 0% 60%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 60%;
    --accent-foreground: 0 0% 15%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 15%;
    --border: 0 0% 60%;
    --input: 0 0% 60%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Toaster } from "@/components/ui/toaster";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Demo Chat Agent",
  description: "Demo Chat Agent using smart-sessions and ai-agent",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-background`}
      >
        {children}
        <Toaster />
      </body>
    </html>
  );
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/page.tsx">
"use client";
import React from "react";
import ChatInterface from "@/components/chat-components/ChatInterface";
import AppkitProvider from "./provider";

export default function Home() {
    return (
      <AppkitProvider>
          <ChatInterface />
      </AppkitProvider>
    );
  
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/provider.tsx">
import React, { ReactNode } from "react";
import { createAppKit } from "@reown/appkit/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import { base, type AppKitNetwork } from "@reown/appkit/networks";
import { WagmiAdapter } from "@reown/appkit-adapter-wagmi";
import { ConstantsUtil } from "@/utils/ConstantsUtil";
import { ChatProvider } from "@/context/ChatContext";
import { ThemeProvider } from "./theme-provider";

const queryClient = new QueryClient();

const networks = [base] as [AppKitNetwork, ...AppKitNetwork[]];

const wagmiAdapter = new WagmiAdapter({
  ssr: true,
  networks,
  projectId: ConstantsUtil.ProjectId,
});

createAppKit({
  adapters: [wagmiAdapter],
  networks,
  defaultNetwork: base,
  projectId: ConstantsUtil.ProjectId,
  features: {
    email: true, 
    socials: [],
    emailShowWallets: false, 
    analytics: true,
  },
  allWallets: 'HIDE', 
  themeMode: "dark",
  termsConditionsUrl: "https://reown.com/terms-of-service",
  privacyPolicyUrl: "https://reown.com/privacy-policy",
});



export default function AppkitProvider({ children }: { children: ReactNode }) {
  return (
    <ThemeProvider
            attribute="class"
            defaultTheme="dark"
            disableTransitionOnChange
          >
      <WagmiProvider config={wagmiAdapter.wagmiConfig}>
        <QueryClientProvider client={queryClient}>
        
            <ChatProvider>
              {children}
            </ChatProvider>
        </QueryClientProvider>
      </WagmiProvider>
    </ThemeProvider>
  );
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/app/theme-provider.tsx">
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider,  } from "next-themes";
import { ThemeProviderProps } from "next-themes/dist/types";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/chat-components/ChatHeader.tsx">
import React from "react";
import { Trash2 } from "lucide-react";
import { useChat } from "@/hooks/use-chat";
import { Button } from "../ui/button";
import Image from "next/image";


const ChatHeader: React.FC = () => {
  const { clearChat } = useChat();

  const handleClearChat = () => {
    if (window.confirm("Are you sure you want to clear the chat history?")) {
      clearChat();
    }
  };


  return (
    <header className="sticky top-0 z-50 bg-foreground">
      <div className="h-16 flex items-center justify-between px-4">
        <div className="flex items-center gap-4">
          {/* Logo and Title */}
          <div className="flex items-center gap-2">
              <Image src="/bot-avatar.svg" alt="Bot Avatar" width={32} />
              <h1 className="text-lg font-bold text-secondary m-0">Agent</h1>
          </div>
        </div>

        <div className="hidden sm:flex items-center gap-3">
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClearChat}
            className="text-red-500 bg-red-400/20 hover:text-red-400 hover:bg-red-400/10"
          >
            <Trash2 className="h-4 w-4" /> Clear Chat
          </Button>
        </div>
        
      </div>
    </header>
  );
};

export default ChatHeader;
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/chat-components/ChatInterface.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";
import { useAppKit, useAppKitAccount, useAppKitNetwork } from '@reown/appkit/react';
import { useChat } from '@/hooks/use-chat';
import MessagesArea from './MessageArea';
import Header from './Header';
import MessageInput from './MessageInput';
import ChatHeader from './ChatHeader';
import ConnectionScreen from './ConnectionScreen';
import { useBalance } from 'wagmi';
import { parseUnits } from 'viem';

const ChatInterface = () => {
  const { state, startChat, sendMessage } = useChat();
  const { address, isConnected, status, embeddedWalletInfo } = useAppKitAccount();
  const { chainId } = useAppKitNetwork();
  const { accountType, user } = embeddedWalletInfo ?? {}
  const balance = useBalance({ address: address as `0x${string}` });
  const { open } = useAppKit();
  const { messages, isLoading } = state;
  const { grantedPermissions } = state;
  const permissionAddress = grantedPermissions?.address;

  const isSmartAccount = accountType === 'smartAccount';
  const isDisabled = !balance.data || balance.data.value < parseUnits('0.0005', 18); 
  const isEmailAllowed = user?.email?.includes('+smart-sessions@');

  // First check if there's a granted permissions address
  // If yes, show chat screen regardless of other conditions
  if (permissionAddress) {
    return (
      <div className="h-screen flex flex-col ">
        <Header />
        <div className="flex-1 flex flex-col overflow-hidden sm:mx-40 sm:my-16 sm:rounded-3xl">
          <ChatHeader />
          <MessagesArea messages={messages} isLoading={isLoading} />
          <MessageInput onSubmit={sendMessage} isLoading={isLoading} />
        </div>
      </div>
    );
  }

  // If no permissions granted, check wallet connection
  if (!address || !isConnected) {
    return <ConnectionScreen onConnect={() => open({ view: "Connect" })} isConnected={isConnected} status={status} />;
  }

  // Wallet is connected but no permissions granted yet
  return (
    <div className="h-screen flex bg-background">
      <div className="flex-1 flex flex-col">
        <Header />
        <div className="h-full flex items-center justify-center px-4 sm:px-6 md:px-8">
          <div className="flex flex-col gap-6 text-center max-w-xs sm:max-w-md">
            {!isEmailAllowed && (
              <div className="bg-red-500 text-white p-2 rounded">
                Please use an email format: youremail+smart-sessions@domain.com
              </div>
            )}
            {isEmailAllowed && !isSmartAccount && (
              <div className="bg-red-500 text-white p-2 rounded">
                Please switch to a Smart Account to use this feature.
              </div>
            )}
            {/* Main Description */}
            <div className="bg-zinc-800/50 p-4 rounded-lg">
              <h2 className="text-sm sm:text-base md:text-lg text-white mb-4">
                Setup Your AI Agent Account
              </h2>
              
              <div className="flex flex-col gap-4 text-left">
                <div className="flex gap-3">
                  <span className="text-blue-400">1.</span>
                  <p className="text-sm sm:text-base text-zinc-400">
                    AppKit Embedded Wallet provides you with a secure Safe ERC-7579 compatible account with Smart Sessions module enabled
                  </p>
                </div>

                <div className="flex gap-3">
                  <span className="text-blue-400">2.</span>
                  <p className="text-sm sm:text-base text-zinc-400">
                    Agent will request permission to spend <span className="text-white">0.001 ETH</span> on Base mainnet
                  </p>
                </div>

                <div className="flex gap-3">
                  <span className="text-blue-400">3.</span>
                  <p className="text-sm sm:text-base text-zinc-400">
                    Permissions will be valid for <span className="text-white">1 hour</span>
                  </p>
                </div>

                <div className="flex gap-3">
                  <span className="text-blue-400">4.</span>
                  <p className="text-sm sm:text-base text-zinc-400">
                    Please ensure you have atleast <span className="text-white">0.0005 ETH</span> in your wallet for account deployment
                  </p>
                </div>
              </div>
            </div>

            {/* Action Button */}
            {isSmartAccount && isEmailAllowed && (
              <Button 
                disabled={isDisabled}
                onClick={() => startChat(Number(chainId), address as `0x${string}`)}
                className="px-4 py-2 sm:px-6 sm:py-3 text-sm sm:text-base text-white bg-blue-400 hover:bg-blue-400/50"
              >
                {isDisabled ? 'Insufficient ETH to Start Chat' : 'Start New Chat'}
              </Button>
            )}
          </div>
        </div>
      </div>
    </div>
  );
  
};

export default ChatInterface;
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/chat-components/ChatMessage.tsx">
import React from 'react';
import { IChatMessage } from '@/types/chat/types';
import DOMPurify from 'dompurify';

interface ChatMessageProps {
  message: IChatMessage;
}

export const ChatMessage = ({ message }: ChatMessageProps) => {
  // Function to safely render HTML content
  const createMarkup = (content: string) => {
    return {
      __html: DOMPurify.sanitize(content, {
        ALLOWED_TAGS: ['a', 'br', 'p', 'span', 'strong', 'em'],
        ALLOWED_ATTR: ['href', 'target', 'rel', 'style', 'class']
      })
    };
  };

  return (
    <div
      className={`flex w-full ${
        message.sender === 'user' ? 'justify-end' : 'justify-start'
      }`}
    >
      <div
        className={`max-w-[80%] px-4 py-2 rounded-md break-words whitespace-pre-wrap overflow-hidden ${
          message.sender === 'user'
            ? 'bg-blue-400/10 text-blue-500'
            : 'bg-foreground text-secondary'
        }`}
      >
        {message.type === 'error' ? (
          <span className="text-red-500">{message.text}</span>
        ) : (
          <div
            dangerouslySetInnerHTML={createMarkup(message.text)}
            className="chat-message-content [&_a]:text-blue-400 [&_a]:hover:text-blue-300 [&_a]:underline"
          />
        )}
      </div>
    </div>
  );
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/chat-components/ConnectionScreen.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";

type ConnectionScreenProps = {
  onConnect: () => void;
  isConnected: boolean;
  status: "reconnecting" | "connected" | "disconnected" | "connecting" | undefined;
};
const ConnectionScreen = ({ onConnect, isConnected, status }: ConnectionScreenProps) => (
  <div className="h-screen flex flex-col items-center justify-center bg-background gap-4 px-4 sm:px-6 md:px-8">
    <h1 className="text-xl sm:text-2xl md:text-3xl font-bold text-white mb-4 text-center">
      Welcome to Smart-Session x AI Agent
    </h1>
    
    <div className="flex flex-col gap-4 text-center max-w-xs sm:max-w-md">
      <div className="bg-zinc-800/50 p-4 rounded-lg">
        <p className="text-sm sm:text-base text-zinc-400 mb-2">
          When connecting, use Email Wallet with:
        </p>
        <p className="font-mono text-white bg-zinc-700/50 p-2 rounded">
          youremail<span className="text-blue-400">+smart-sessions</span>@domain.com
        </p>
        <p className="text-sm text-zinc-400 mt-2">
          Example: john<span className="text-blue-400">+smart-sessions</span>@doe.com
        </p>
      </div>
    </div>
    {status === 'connecting' && (
        <Button 
          disabled
          style={{background: "var(hsla(0, 0%, 16%, 1))" }}
          className="text-white whitespace-nowrap"
        >
          Connecting...
        </Button>
      )}
      { !isConnected && (status === 'disconnected' || !status) && (
        <Button 
        onClick={onConnect}
        className="px-4 py-2 sm:px-6 sm:py-3 text-sm sm:text-base text-white mt-4 bg-blue-400 hover:bg-blue-400/50"
      >
        Connect Wallet
      </Button>
    )}
  </div>
);

export default ConnectionScreen;
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/chat-components/Header.tsx">
import React, { useEffect, useState } from "react";
import { Clock, LogOut, Trash2, XCircle, Menu } from "lucide-react";
import { useChat } from "@/hooks/use-chat";
import { Button } from "../ui/button";
import { useAppKit, useAppKitAccount, useDisconnect } from "@reown/appkit/react";
import { ChainUtil } from "@/utils/ChainUtil";
import { formatDistanceToNow } from "date-fns";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuLabel,
  DropdownMenuTrigger,
} from "../ui/dropdown-menu";
import Image from "next/image";

const Header = () => {
  const { clearChat, clearPermissions, state } = useChat();
  const { grantedPermissions } = state;
  const [timeLeft, setTimeLeft] = useState<string>("");
  const [, setChainName] = useState<string>("");
  const { disconnect } = useDisconnect();
  const { isConnected, status } = useAppKitAccount();
  const { open } = useAppKit();

  useEffect(() => {
    if (!grantedPermissions?.expiry) return;

    try {
      const parsedChainId = parseInt(grantedPermissions.chainId, 16);
      const chain = ChainUtil.getChain(parsedChainId);
      setChainName(chain?.name || "Unknown Network");

      const updateTimeLeft = () => {
        const now = new Date().getTime();
        const expiryTime = new Date(grantedPermissions.expiry * 1000).getTime();
        const difference = expiryTime - now;

        if (difference <= 0) {
          setTimeLeft("Expired");
          return;
        }

        setTimeLeft(
          formatDistanceToNow(new Date(grantedPermissions.expiry * 1000), {
            addSuffix: true,
          })
        );
      };

      updateTimeLeft();
      const timer = setInterval(updateTimeLeft, 60000);

      return () => clearInterval(timer);
    } catch (error) {
      console.error("Error processing permissions:", error);
      setTimeLeft("Error calculating time");
    }
  }, [grantedPermissions]);

  const handleClearChat = () => {
    if (window.confirm("Are you sure you want to clear the chat history?")) {
      clearChat();
    }
  };

  const handleClearPermissions = () => {
    if (window.confirm("Are you sure you want to clear permissions? This will require you to restart the chat.")) {
      clearPermissions();
    }
  };

  const handleDisconnect = () => {
    if (window.confirm("Are you sure you want to disconnect?")) {
      disconnect();
    }
  };

  return (
    <header className="sticky top-0 z-50 bg-background">
      <div className="grid h-20 border-b-2 border-foreground px-4">
      <div className="hidden lg:grid grid-cols-[1fr_auto_1fr] items-center gap-4 w-full">
        {/* Left section - Logo */}
        <div className="justify-self-start">
          <Image src="/reown-logo.svg" alt="Reown Logo" width={64} />
        </div>

        {/* Middle section - Permissions */}
        <div className="justify-self-center">
          {grantedPermissions?.expiry && (
            <div className="flex items-center gap-1 px-2 text-blue-500 bg-blue-400/10 rounded-full whitespace-nowrap">
              <Clock size={14} />
              <span>Permissions expires {timeLeft}</span>
            </div>
          )}
        </div>

        {/* Right section - Actions */}
        <div className="justify-self-end flex items-center gap-3">
          {status === 'connecting' && (
            <Button 
              disabled
              style={{background: "var(hsla(0, 0%, 16%, 1))" }}
              className="text-white whitespace-nowrap"
            >
              Connecting...
            </Button>
          )}
          {status === 'disconnected' && !isConnected && (
            <Button 
              onClick={() => open({ view: "Connect" })}
              className="px-4 py-2 sm:px-6 sm:py-3 text-sm sm:text-base text-white mt-4 bg-blue-400 hover:bg-blue-400/50"
            >
              Connect Wallet
            </Button>
            
          )}
          {isConnected && status === 'connected' && (
            <>
              {/* @ts-expect-error - Custom web component */}
              <w3m-button />
            </>
          )}
          <div className="h-6 w-px bg-zinc-700" />
          {grantedPermissions && <Button
            variant="ghost"
            size="sm"
            onClick={handleClearPermissions}
            className="text-red-500 bg-red-400/20 hover:text-red-400 hover:bg-red-400/10 whitespace-nowrap"
          >
            <XCircle className="h-4 w-4" /> Clear Permissions
          </Button> }
          {isConnected && status === 'connected' && (
            <Button
              variant="ghost"
              size="sm"
              onClick={handleDisconnect}
              className="text-white bg-red-400 hover:bg-red-400/50 whitespace-nowrap"
            >
              <LogOut className="h-4 w-4" /> Sign out
            </Button>
          )}
        </div>
      </div>

        {/* Mobile view */}
        <div className="lg:hidden flex items-center justify-between">
          <div className="flex items-center">
            <Image src="/reown-logo.svg" alt="Reown Logo" width={64} />
          </div>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="text-zinc-400 hover:text-zinc-300">
                <Menu className="h-5 w-5" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-56 bg-background border border-zinc-700">
              {grantedPermissions && (
                <>
                  <DropdownMenuLabel className="text-xs font-normal text-zinc-400">
                    Session Details
                  </DropdownMenuLabel>
                  <DropdownMenuItem className="flex flex-col items-start gap-1">
                    <div className="flex items-center gap-1 px-2 text-blue-500 bg-blue-400/10 rounded-full">
                      <Clock size={14} />
                      <span>Permissions expires {timeLeft}</span>
                    </div>
                  </DropdownMenuItem>
                  <DropdownMenuSeparator className="bg-zinc-700" />
                </>
              )}
              <DropdownMenuLabel className="text-xs font-normal text-zinc-400">
                Wallet
              </DropdownMenuLabel>
              {isConnected && status === 'connected' ? (
                <DropdownMenuItem className="gap-2">
                  {/* @ts-expect-error - Custom web component */}
                  <w3m-button />
                </DropdownMenuItem>
              ) : status === 'connecting' ? (
                <DropdownMenuItem disabled className="gap-2 bg-blue-400 text-white hover:bg-[rgb(0,116,61)] focus:bg-[rgb(0,116,61)]">
                  Connecting...
                </DropdownMenuItem>
              ) : (
                <DropdownMenuItem
                  onClick={() => open({ view: "Connect" })}
                  className="gap-2 bg-blue-400 text-white hover:bg-[rgb(0,116,61)] focus:bg-[rgb(0,116,61)]"
                >
                  Connect Wallet
                </DropdownMenuItem>
              )}
              <DropdownMenuSeparator className="bg-zinc-700" />
              <DropdownMenuLabel className="text-xs font-normal text-zinc-400">
                Actions
              </DropdownMenuLabel>
              <DropdownMenuItem onClick={handleClearPermissions} className="gap-2 text-red-400 hover:text-red-300 focus:bg-red-400/10">
                <XCircle className="h-4 w-4" />
                Clear Permissions
              </DropdownMenuItem>
              <DropdownMenuItem onClick={handleClearChat} className="sm:hidden gap-2 text-red-400 hover:text-red-300 focus:bg-red-400/10">
                <Trash2 className="h-4 w-4" />
                Clear Chat
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </header>
  );
};

export default Header;
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/chat-components/MessageArea.tsx">
import { IChatMessage } from "@/types/chat/types";
import { ScrollArea } from "../ui/scroll-area";
import { ChatMessage } from "./ChatMessage";

// Messages Area Component
const MessagesArea: React.FC<{ messages: IChatMessage[]; isLoading: boolean }> = ({ messages, isLoading }) => (
  <ScrollArea className="flex-1 p-4 overflow-x-hidden bg-foreground/30">
    <div className="space-y-4">
      {messages.map((message) => (
        <ChatMessage key={message.id} message={message} />
      ))}
      {isLoading && (
        <div className="text-zinc-400 italic">Agent is typing...</div>
      )}
    </div>
  </ScrollArea>
);

export default MessagesArea;
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/chat-components/MessageInput.tsx">
import { FormEvent, useState } from "react";
import { Button } from "../ui/button";
import { Send, AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface MessageInputProps {
  onSubmit: (message: string) => void;
  isLoading: boolean;
}

const MAX_LENGTH = 300;

const MessageInput = ({ onSubmit, isLoading }: MessageInputProps) => {
  const [inputMessage, setInputMessage] = useState('');
  const [showError, setShowError] = useState(false);

  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (inputMessage.trim() && inputMessage.length <= MAX_LENGTH) {
      onSubmit(inputMessage);
      setInputMessage('');
      setShowError(false);
    }
  };

  const handleInputChange = (value: string) => {
    setInputMessage(value);
    setShowError(value.length > MAX_LENGTH);
  };

  const remainingChars = MAX_LENGTH - inputMessage.length;
  const isOverLimit = remainingChars < 0;

  return (
    <div className="w-full">
      {showError && (
        <Alert variant="destructive" className="mb-2">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            Message exceeds maximum length of {MAX_LENGTH} characters. Please shorten your message by {Math.abs(remainingChars)} characters.
          </AlertDescription>
        </Alert>
      )}
      <form
        onSubmit={handleSubmit}
        className="p-3 sm:p-2 bg-foreground w-full overflow-x-hidden"
      >
        <div className="flex flex-col gap-1 w-full">
          <div className="flex gap-2 items-center w-full">
            <input
              type="text"
              value={inputMessage}
              onChange={(e) => handleInputChange(e.target.value)}
              placeholder="Type your message..."
              className="flex-1 bg-foreground text-secondary px-3 py-2 sm:px-4 sm:py-3 text-sm sm:text-base w-full ring-0 focus:ring-0 outline-none"
              disabled={isLoading}
            />
            <Button
              type="submit"
              className={`bg-blue-500 hover:bg-blue-400 ${
                (isLoading || isOverLimit) ? 'opacity-50 cursor-not-allowed' : ''
              }`}
              disabled={isLoading || isOverLimit}
            >
              {isLoading ? '...' : <Send className="h-4 w-4 sm:h-5 sm:w-5" />}
            </Button>
          </div>
          <div className={`text-xs text-right ${isOverLimit ? 'text-red-500' : 'text-secondary'}`}>
            {remainingChars} characters remaining
          </div>
        </div>
      </form>
    </div>
  );
};

export default MessageInput;
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-secondary",
  {
    variants: {
      variant: {
        default: "bg-background text-secondary",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/ui/toast.tsx">
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-secondary",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-secondary/50 opacity-0 transition-opacity hover:text-secondary focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/ui/toaster.tsx">
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/components/ConnectWalletButton.tsx">
import React from "react";
import { useAppKit } from "@reown/appkit/react";
import { Button } from "./ui/button";

export function ConnectWalletButton() {
  const { open } = useAppKit();

  return (
    <Button
      type="button"
      className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded transition-colors"
      size="lg"
      onClick={() => open({ view: "Connect" })}
    >
      Connect Wallet
    </Button>
  );
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/config/constants.ts">
export const SWAP_CONFIG = {
  AMOUNT_ETH: '0.00005',
  ETH_ADDRESS: '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' as const,
  USDC_ADDRESS: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913' as const,
  DEFAULT_SLIPPAGE: 1,
} as const;

export const CHATGPT_MODEL = 'gpt-4o-mini' as const;
export const SYSTEM_PROMPT = `You are an AI assistant specialized in processing chat messages for a Web3 application.
Your primary function is to identify ETH to USDC swap requests, recommend buying USDC when asked for token purchase suggestions, process receipt requests, and provide helpful responses for other queries.

RESPONSE FORMAT REQUIREMENTS:
You must always respond with a JSON object following these exact structures:
For SWAP intents:
{
    "intent": "SWAP",
    "amount": string    // Extracted ETH amount or "0.00005" if not specified
}
For receipt requests:
{
    "intent": "GET_SWAP_RECEIPT",
    "purchaseId": string    // Extracted purchase ID from the message
}
For non-SWAP intents:
{
    "intent": "NOT_SWAP",
    "responseText": string    // Your helpful response as text
}
IMPORTANT:
- Always return valid JSON
- Never include additional fields
- Never include explanatory text outside the JSON structure
- Treat "buy it" and "swap it" as equivalent when identifying SWAP intents
- Only process ETH to USDC swap requests
- Always recommend buying USDC when the user asks for token purchase suggestions
- Use the default amount of 0.00005 ETH when no specific amount is mentioned
- For questions about buying USDC or token recommendations, respond with NOT_SWAP intent and a message encouraging USDC purchase
- For any other token swap requests, respond with a helpful message explaining only ETH to USDC swaps are supported
- When a user asks about a transaction status or receipt, extract the purchase ID and return GET_SWAP_RECEIPT intent
Example valid responses:
For "I want to swap ETH to USDC":
{
    "intent": "SWAP",
    "amount": "0.00005"
}
For "I want to swap 0.1 ETH to USDC":
{
    "intent": "SWAP",
    "amount": "0.1"
}
For "Can I get the receipt for transaction 0x7b22636861696e...":
{
    "intent": "GET_SWAP_RECEIPT",
    "purchaseId": "0x7b22636861696e..."
}
For "What's the gas fee?":
{
    "intent": "NOT_SWAP",
    "responseText": "Gas fees vary depending on network congestion. Would you like me to explain how gas fees work?"
}
For "What token should I buy?":
{
    "intent": "NOT_SWAP",
    "responseText": "I recommend buying USDC as a stable and reliable token for your portfolio."
}
For "Can you buy USDC for me?":
{
    "intent": "SWAP",
    "amount": "0.00005"
}
For "Swap it for me":
{
    "intent": "SWAP",
    "amount": "0.00005"
}
Consider the chat history provided for context in your responses.`;
</file>

<file path="advanced/dapps/chat-demo-agent/src/context/ChatContext.tsx">
import React, { createContext, useEffect, useReducer } from 'react';
import { toast } from '@/hooks/use-toast';
import { getRecentMessageHistory, createMessage } from '../utils/messageUtils';
import { getRequiredPermissions } from '@/utils/ChatSmartSessionsPermissionsUtil';
import { PERMISSIONS_STORAGE_KEY, STORAGE_KEY } from '@/utils/ChatContants';
import { chatReducer, initialState } from '@/reducers/chatReducer';
import { ChatContextType, MessageWithContext } from '@/types/chat/types';
import { sendChatMessageToApi } from '@/lib/chatApi';

export const ChatContext = createContext<ChatContextType | undefined>(undefined);

export const ChatProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(chatReducer, initialState);

  useEffect(() => {
    const savedState = localStorage.getItem(STORAGE_KEY);
    if (savedState) {
      try {
        const parsedState = JSON.parse(savedState, (key, value) => {
          if (key === 'timestamp') {
            return new Date(value);
          }
          return value;
        });
        dispatch({ type: 'LOAD_STATE', payload: parsedState });
      } catch (error) {
        console.error('Error loading chat state:', error);
        toast({
          title: "Error",
          description: "Failed to load chat history.",
          variant: "destructive",
        });
      }
    }
  }, []);

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }, [state]);

  const startChat = async (chainId: number, address: `0x${string}`) => {
    try {
      const storedPermissions = localStorage.getItem(PERMISSIONS_STORAGE_KEY);
      let grantedPermissions = storedPermissions ? JSON.parse(storedPermissions) : null;

      if (!grantedPermissions) {
        grantedPermissions = await getRequiredPermissions(chainId, address);
        localStorage.setItem(PERMISSIONS_STORAGE_KEY, JSON.stringify(grantedPermissions));
      }

      dispatch({ type: 'START_CHAT', payload: grantedPermissions });
    } catch (error) {
      console.error('Error starting chat:', error);
      toast({
        title: "Error",
        description: "Failed to start chat. Please try again.",
        variant: "destructive",
      });
    }
  };

  const sendMessage = async (text: string) => {
    try {
      const grantedPermissions = state.grantedPermissions;
      if (!grantedPermissions) {
        throw new Error('Permissions not granted');
      }

      dispatch({ type: 'SET_LOADING', payload: true });
      
      const userMessage = createMessage(text, 'user', 'text');
      dispatch({ type: 'ADD_MESSAGE', payload: userMessage });

      const messageWithContext: MessageWithContext = {
        currentMessage: text,
        messageHistory: getRecentMessageHistory(state.messages),
        permissions: grantedPermissions,
      };

      const data = await sendChatMessageToApi(messageWithContext);
      
      const botResponse = createMessage(data.message, 'system', 'text');
      dispatch({ type: 'ADD_MESSAGE', payload: botResponse });
    } catch (error) {
      const errorMessage = createMessage(
        `Error: ${error instanceof Error ? error.message : 'Unable to process the request'}`,
        'system',
        'error'
      );
      dispatch({ type: 'ADD_MESSAGE', payload: errorMessage });
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  };

  const clearChat = () => {
    dispatch({ type: 'CLEAR_CHAT' });
    toast({
      title: "Success",
      description: "Chat history has been cleared.",
    });
  };

  const clearPermissions = () => {
    localStorage.removeItem(PERMISSIONS_STORAGE_KEY);
    dispatch({ type: 'CLEAR_PERMISSIONS' });
    dispatch({ type: 'CLEAR_CHAT' });
    toast({
      title: "Success",
      description: "Permissions have been cleared. Please restart the chat.",
    });
  };

  return (
    <ChatContext.Provider value={{ 
      state, 
      startChat, 
      sendMessage,
      clearChat,
      clearPermissions
    }}>
      {children}
    </ChatContext.Provider>
  );
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/errors/api-errors.ts">
// error-codes.ts

export const ErrorCodes = {
  INVALID_REQUEST_BODY: 'ERR001',
  OPENAI_RESPONSE_ERROR: 'ERR002',
  INVALID_OPENAI_RESPONSE: 'ERR003',
  INVALID_INTENT: 'ERR004',
  SWAP_EXECUTION_ERROR: 'ERR005',
  RECEIPT_FETCH_ERROR: 'ERR006',
  TIMEOUT_ERROR: 'ERR007',
  CONFIGURATION_ERROR: 'ERR008',
  UNAUTHORIZED: 'ERR009',
  UNKNOWN_ERROR: 'ERR999',
} as const;

// Create a type from the ErrorCodes values
export type ErrorCodeType = typeof ErrorCodes[keyof typeof ErrorCodes];

// Private error descriptions - only for logging, not for client response
export const ErrorDescriptions: Record<ErrorCodeType, string> = {
  [ErrorCodes.UNAUTHORIZED]: 'Unauthorized',
  [ErrorCodes.CONFIGURATION_ERROR]: 'Configuration error',
  [ErrorCodes.INVALID_REQUEST_BODY]: 'Failed to parse request body',
  [ErrorCodes.OPENAI_RESPONSE_ERROR]: 'Error getting response from OpenAI',
  [ErrorCodes.INVALID_OPENAI_RESPONSE]: 'Invalid or empty response from OpenAI',
  [ErrorCodes.INVALID_INTENT]: 'Unhandled or invalid intent received',
  [ErrorCodes.SWAP_EXECUTION_ERROR]: 'Error executing swap operation',
  [ErrorCodes.RECEIPT_FETCH_ERROR]: 'Error fetching swap receipt',
  [ErrorCodes.TIMEOUT_ERROR]: 'Operation timed out',
  [ErrorCodes.UNKNOWN_ERROR]: 'An unknown error occurred',
};

export class AppError extends Error {
  constructor(
    public readonly code: ErrorCodeType,
    message: string
  ) {
    super(message);
    this.name = 'AppError';
  }
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/hooks/use-chat.ts">
import { useContext } from 'react';
import { ChatContext } from '../context/ChatContext';

export const useChat = () => {
  const context = useContext(ChatContext);
  if (context === undefined) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

type ActionTypes = {
  ADD_TOAST: "ADD_TOAST"
  UPDATE_TOAST: "UPDATE_TOAST"
  DISMISS_TOAST: "DISMISS_TOAST"
  REMOVE_TOAST: "REMOVE_TOAST"
}

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = ActionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="advanced/dapps/chat-demo-agent/src/lib/services/1inch.ts">
import { base } from 'viem/chains';
import { createWalletClient, http } from 'viem';
import { AppError, ErrorCodes } from '@/errors/api-errors';
import type { 
  AllowanceResponse, 
  ApprovalTransaction, 
  SwapParams,
  SwapTransactionResponse 
} from '@/types/1inch';

export class OneInchApiService {
  private static instance: OneInchApiService;
  private readonly chainId: number;
  private readonly client;
  private readonly apiKey: string;

  private constructor() {
    const apiKey = process.env.ONEINCH_API_KEY;
    if (!apiKey) {
      throw new AppError(
        ErrorCodes.SWAP_EXECUTION_ERROR,
        'ONEINCH_API_KEY is not configured'
      );
    }
    
    this.apiKey = apiKey;
    this.chainId = base.id;
    this.client = createWalletClient({
      chain: base,
      transport: http(),
    });
  }

  public static getInstance(): OneInchApiService {
    if (!OneInchApiService.instance) {
      OneInchApiService.instance = new OneInchApiService();
    }
    return OneInchApiService.instance;
  }

  private async callApi<T>(path: string, params: Record<string, string> = {}): Promise<T> {
    const queryParams = new URLSearchParams(params);
    const apiPath = `https://api.1inch.dev/swap/v6.0/${this.chainId}${path}`;
    const url = queryParams.toString() ? `${apiPath}?${queryParams}` : apiPath;

    try {
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${this.apiKey}`,
          Accept: 'application/json',
        },
      });

      if (!response.ok) {
        const errorMessage = await response.text().catch(() => response.statusText);
        throw new AppError(ErrorCodes.SWAP_EXECUTION_ERROR, errorMessage);
      }

      return await response.json();
    } catch (error) {
      if (error instanceof AppError) throw error;
      throw new AppError(ErrorCodes.SWAP_EXECUTION_ERROR, 'Failed to fetch data from 1Inch API');
    }
  }

  async checkAllowance(tokenAddress: string, walletAddress: string): Promise<string> {
    try {
      const data = await this.callApi<AllowanceResponse>('/approve/allowance', { 
        tokenAddress, 
        walletAddress 
      });
      return data.allowance;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (error) {
      throw new AppError(
        ErrorCodes.SWAP_EXECUTION_ERROR, 
        `Failed to check allowance for token ${tokenAddress}`, 
      );
    }
  }

  async buildApprovalTransaction(tokenAddress: string, amount?: string): Promise<ApprovalTransaction> {
    try {
      const params: Record<string, string> = { 
        tokenAddress, 
        ...(amount && { amount }) 
      };
      
      const transaction = await this.callApi<ApprovalTransaction>('/approve/transaction', params);

      const gasEstimate = await this.client.prepareTransactionRequest({
        ...transaction,
        account: transaction.from,
      });

      return {
        ...transaction,
        gas: gasEstimate.gas ?? BigInt(0),
      };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (error) {
      throw new AppError(
        ErrorCodes.SWAP_EXECUTION_ERROR, 
        `Failed to build approval transaction for token ${tokenAddress}`, 
      );
    }
  }

  async buildSwapTransaction(swapParams: SwapParams): Promise<SwapTransactionResponse> {
    try {
      return await this.callApi<SwapTransactionResponse>(
        '/swap', 
        swapParams as unknown as Record<string, string>
      );
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (error) {
      throw new AppError(
        ErrorCodes.SWAP_EXECUTION_ERROR, 
        'Failed to build swap transaction', 
      );
    }
  }
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/lib/services/blockchainapi.ts">
import { createWalletClient, http } from 'viem';
import { base } from 'viem/chains';
import { AppError, ErrorCodes } from '@/errors/api-errors';

interface ConvertRequestBody {
  projectId: string;
  userAddress: string;
  from: string;         // CAIP-10 address
  to: string;          // CAIP-10 address
  amount: string;
  eip155?: {
    slippage: number;
    permit?: unknown;  // EIP-2612 gasless approvals
  };
}

interface ConvertTransactionResponse {
  tx: {
    from: string;
    to: string;
    data: string;
    amount: string;
    value: string;
    eip155?: {
      gas: bigint;
      gasPrice: bigint;
    };
  };
}

export class ConvertTransactionService {
  private static instance: ConvertTransactionService;
  private readonly baseUrl: string;
  private readonly projectId: string;
  private readonly client;

  private constructor() {
    const projectId = process.env.NEXT_PUBLIC_PROJECT_ID;
    const baseUrl = 'https://rpc.walletconnect.org';

    if (!projectId) {
      throw new AppError(
        ErrorCodes.CONFIGURATION_ERROR,
        'PROJECT_ID is not configured'
      );
    }

    if (!baseUrl) {
      throw new AppError(
        ErrorCodes.CONFIGURATION_ERROR,
        'API_BASE_URL is not configured'
      );
    }

    this.projectId = projectId;
    this.baseUrl = baseUrl;
    this.client = createWalletClient({
      chain: base,
      transport: http(),
    });
  }

  public static getInstance(): ConvertTransactionService {
    if (!ConvertTransactionService.instance) {
      ConvertTransactionService.instance = new ConvertTransactionService();
    }
    return ConvertTransactionService.instance;
  }

  async buildTransaction(params: Omit<ConvertRequestBody, 'projectId'>): Promise<ConvertTransactionResponse> {
    try {
      // Validate slippage if provided
      if (params.eip155?.slippage && params.eip155.slippage > 50) {
        throw new AppError(
          ErrorCodes.SWAP_EXECUTION_ERROR, 
          'Slippage cannot exceed 50'
        );
      }
      const response = await fetch(`${this.baseUrl}/v1/convert/build-transaction`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...params,
          projectId: this.projectId,
        }),
      });

      if (!response.ok) {
        if (response.status === 400) {
          throw new AppError(
            ErrorCodes.SWAP_EXECUTION_ERROR, 
            'Invalid parameters provided for swap transaction'
          );
        }
        
        if (response.status === 401) {
          throw new AppError(
            ErrorCodes.UNAUTHORIZED,
            'Project ID verification failed'
          );
        }

        const errorText = await response.text().catch(() => 'Unknown error');
        throw new AppError(
          ErrorCodes.SWAP_EXECUTION_ERROR, 
          `API request failed: ${errorText}`
        );
      }

      const data = await response.json() as ConvertTransactionResponse;

      return data;
    } catch (error) {
      if (error instanceof AppError) throw error;
      throw new AppError(
        ErrorCodes.SWAP_EXECUTION_ERROR, 
        'Failed to build convert transaction'
      );
    }
  }
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/lib/services/openai.ts">
import { CHATGPT_MODEL, SYSTEM_PROMPT } from '@/config/constants';
import { AppError, ErrorCodes } from '@/errors/api-errors';

type Message = {
  role: 'system' | 'user' | 'assistant';
  content: string;
};

type ChatResponse = {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message: {
      role: string;
      content: string;
    };
    finish_reason: string;
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
};

export async function getOpenAIResponse(
  currentMessage: string,
  chatHistory: Array<{ role: 'system' | 'user'; content: string }>
) {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new AppError(
      ErrorCodes.INVALID_OPENAI_RESPONSE,
      'OPENAI_API_KEY is not set'
    );
  }

  const messages: Message[] = [
    { 
      role: "system", 
      content: SYSTEM_PROMPT
    },
    ...chatHistory,
    {
      role: "user",
      content: currentMessage,
    }
  ];

  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: CHATGPT_MODEL,
      messages,
      store: true,
    }),
  });

  if (!response.ok) {
    const error = await response.json().catch(() => null);
    throw new AppError(
      ErrorCodes.INVALID_OPENAI_RESPONSE,
      `OpenAI API error: ${error?.error?.message || response.statusText}`
    );
  }

  const data = await response.json() as ChatResponse;
  return data;
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/lib/services/swap.ts">
import { parseEther } from 'viem';
import { executeActionsWithECDSAKey } from '@/utils/ERC7715PermissionsAsyncUtils';
import { SmartSessionGrantPermissionsResponse } from '@reown/appkit-experimental/smart-session';
import { SWAP_CONFIG } from '@/config/constants';
import { ChainUtil } from '@/utils/ChainUtil';
import { SwapReceipt, SwapResponse } from '@/types/api';
// import { OneInchApiService } from './1inch';
import type { SwapParams } from '@/types/1inch';
import { AppError, ErrorCodes } from '@/errors/api-errors';
import { getCallsStatus } from '@/utils/UserOpBuilderServiceUtils';
import { ConvertTransactionService } from './blockchainapi';

export class SwapService {
  private static async prepareSwapTransaction(swapParams: SwapParams) {
    // const oneInchApi = OneInchApiService.getInstance();
    // return await oneInchApi.buildSwapTransaction(swapParams);

    const convertService = ConvertTransactionService.getInstance()
    const data = await convertService.buildTransaction({
      amount: swapParams.amount,
      from: `eip155:8453:${swapParams.src}`,
      to: `eip155:8453:${swapParams.dst}`,
      userAddress: `eip155:8453:${swapParams.from}`,
      eip155:{
        slippage: swapParams.slippage
      }
    })
    return data;

  }

  static async executeSwap(
    permissions: SmartSessionGrantPermissionsResponse,
    ethAmount: string
  ): Promise<SwapResponse> {
    const amount = parseEther(ethAmount || SWAP_CONFIG.AMOUNT_ETH);
    
    if(amount > parseEther('0.001')){
      throw new AppError(
        ErrorCodes.SWAP_EXECUTION_ERROR,
        'Amount must be less than 0.001 ETH'
      );
    }
    const swapParams: SwapParams = {
      src: SWAP_CONFIG.ETH_ADDRESS,
      dst: SWAP_CONFIG.USDC_ADDRESS,
      amount: amount.toString(10),
      from: permissions.address,
      slippage: SWAP_CONFIG.DEFAULT_SLIPPAGE,
      disableEstimate: false,
      allowPartialFill: false
    };

    const chain = ChainUtil.getValidatedChain(permissions.chainId);
    const privateKey = process.env.APPLICATION_PRIVATE_KEY as `0x${string}`;
    
    if (!privateKey) {
      throw new AppError(
        ErrorCodes.SWAP_EXECUTION_ERROR,
        'APPLICATION_PRIVATE_KEY is not set'
      );
    }

    const swapTransaction = await this.prepareSwapTransaction(swapParams);
    const calls = [{
      to: swapTransaction.tx.to.split(':')[2] as `0x${string}`,
      data: swapTransaction.tx.data  as `0x${string}`,
      value: BigInt(amount.toString(10)),
    }];
    const userOpHash = await executeActionsWithECDSAKey({
      actions: calls,
      ecdsaPrivateKey: privateKey,
      chain,
      accountAddress: swapParams.from,
      permissionsContext: permissions.context
    });
    try {
      const receipt = await handleFetchReceipt(userOpHash);
      const txHash = receipt.receipts?.[0]?.transactionHash;
      
      return {
        message: `Successfully swapped ${ethAmount} ETH to USDC`,
        status: receipt.receipts?.[0]?.status === '0x1' ? 'success' : 'error',
        userOpHash,
        txLink: txHash ? `https://basescan.org/tx/${txHash}` : '',
        amount: ethAmount
      };
    } catch (error) {
      if (error instanceof AppError && error.code === ErrorCodes.TIMEOUT_ERROR) {
        // Return a response with the known information when timeout occurs
        return {
          message: `Swap initiated for ${ethAmount} ETH to USDC. Transaction is still processing.`,
          status: 'pending',
          userOpHash,
          amount: ethAmount,
          txLink: ''
        };
      }
      throw error; // Re-throw other errors
    }
  }

  static async getSwapReceipt(userOpHash: string): Promise<SwapReceipt> {
    try {
      const receipt = await handleFetchReceipt(userOpHash);
      
      if (receipt.status === "CONFIRMED") {
        return {
          message: "Swap completed successfully",
          userOpHash,
          txLink: receipt.receipts ? `https://basescan.org/tx/${receipt.receipts[0].transactionHash}` : '',
          status: 'success'
        };
      }
      
      return {
        message: "Swap is still processing",
        userOpHash,
        txLink: '',
        status: 'pending'
      };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (error) {
      
      return {
        message: "Unable to fetch swap details. Please try again later.",
        txLink: '',
        userOpHash,
        status: 'error'
      };
    }
  }
}

async function handleFetchReceipt(userOpHash: string, options: { timeout?: number; interval?: number } = {}) {
  const { timeout = 30000, interval = 3000 } = options;
  const endTime = Date.now() + timeout;

  while (Date.now() < endTime) {
    const response = await getCallsStatus(userOpHash);

    if (response.status === "CONFIRMED") {
      return response;
    }

    await new Promise((resolve) => setTimeout(resolve, interval));
  }

  throw new AppError(
    ErrorCodes.TIMEOUT_ERROR,
    'Timeout: Transaction is still processing'
  );
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/lib/chatApi.ts">
import { MessageWithContext } from "@/types/chat/types";

interface BaseResponse {
  message: string;
  status: 'success' | 'error' | 'pending';
  userOpHash?: string;
  txHash?: string;
  txLink?: string;
}

interface SwapResponse extends BaseResponse {
  amount: string;
}

interface BasicResponse {
  message: string;
  status: string;
}

type SendMessageApiResponse = SwapResponse | BasicResponse;

// Generic function to fetch API with type-safe body
const fetchApi = async <T extends object>(
  url: string, 
  body: T
): Promise<Response> => {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    throw new Error(await parseErrorResponse(response));
  }

  return response;
};

const parseErrorResponse = async (response: Response): Promise<string> => {
  const errorMessage = `Failed to get response from server: ${response.status}`;
  
  try {
    const errorData = await response.json();
    return errorData.message || errorMessage;
  } catch {
    const errorText = await response.text();
    return errorText || errorMessage;
  }
};

const formatLink = (text: string, url: string) => 
  `<a href="${url}" target="_blank" rel="noopener noreferrer" style="text-decoration: underline;">${text}</a>`;

// Helper function to truncate hash
const truncateUserOpHash = (hash: string) => `<span onclick="navigator.clipboard.writeText('${hash}')" class="underline cursor-pointer" title="Click to copy full hash"> ${hash.substring(0, 6)}...${hash.substring(hash.length - 4)}</span>`;

// Helper function to truncate hash
const hiddenTruncateUserOpHash = (hash: string) => `<span class="hidden" title="PurchaseId" >${hash}</span>`;

const formatApiResponse = (data: SendMessageApiResponse): { message: string } => {
  let statusMessage = '';

  if ('txLink' in data) {
    statusMessage = data.txLink && data.userOpHash
      ? `\n${hiddenTruncateUserOpHash(data.userOpHash)}View details: ${formatLink('Transaction Link', data.txLink)}`
      : data.status === 'pending' && data.userOpHash
        ? `\nYou can check the status later using the purchase id: ${truncateUserOpHash(data.userOpHash)}`
        :  '';
  }

  return { message: `${data.message}${statusMessage}` };
};


// Main function to send chat message to the API
export const sendChatMessageToApi = async (
  messageWithContext: MessageWithContext
): Promise<{ message: string }> => {
  const API_URL = '/api/send-message';

  try {
    const response = await fetchApi(API_URL, messageWithContext);
    const data: SendMessageApiResponse = await response.json();
    return formatApiResponse(data);
  } catch (error) {
    throw new Error(
      error instanceof Error ? error.message : 'Failed to send message: Unknown error'
    );
  }
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/reducers/chatReducer.ts">
import { v4 as uuidv4 } from 'uuid';
import { SmartSessionGrantPermissionsResponse } from "@reown/appkit-experimental/smart-session";
import { ChatState, IChatMessage } from '@/types/chat/types';
import { INITIAL_MESSAGE } from '@/utils/ChatContants';

export type ChatAction =
  | { type: 'START_CHAT'; payload: SmartSessionGrantPermissionsResponse }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'ADD_MESSAGE'; payload: IChatMessage }
  | { type: 'LOAD_STATE'; payload: ChatState }
  | { type: 'CLEAR_CHAT' }
  | { type: 'CLEAR_PERMISSIONS' };

export const initialState: ChatState = {
  messages: [{
    id: uuidv4(),
    text: INITIAL_MESSAGE,
    sender: "system",
    timestamp: new Date(),
    type: "text",
  }],
  isChatStarted: false,
  isLoading: false,
  grantedPermissions: undefined,
};

export const chatReducer = (state: ChatState, action: ChatAction): ChatState => {
  switch (action.type) {
    case 'START_CHAT':
      return {
        ...state,
        isChatStarted: true,
        grantedPermissions: action.payload,
      };
    case 'SET_LOADING':
      return {
        ...state,
        isLoading: action.payload,
      };
    case 'ADD_MESSAGE':
      return {
        ...state,
        messages: [...state.messages, action.payload],
      };
    case 'LOAD_STATE':
      return action.payload;
    case 'CLEAR_CHAT':
      return {
        ...initialState,
        grantedPermissions: state.grantedPermissions,
        isChatStarted: state.isChatStarted,
      };
      case 'CLEAR_PERMISSIONS':
      return {
        ...state,
        grantedPermissions: undefined,
        isChatStarted: false,
      };
    default:
      return state;
  }
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/types/chat/types.ts">
import { SmartSessionGrantPermissionsResponse } from "@reown/appkit-experimental/smart-session";

export interface IChatMessage {
  id: string;
  text: string;
  sender: 'user' | 'system';
  timestamp: Date;
  type: 'text' | 'error' 
}

export interface ChatState {
  messages: IChatMessage[];
  isChatStarted: boolean;
  isLoading: boolean;
  grantedPermissions?: SmartSessionGrantPermissionsResponse;
}

export interface MessageWithContext {
  currentMessage: string;
  messageHistory: IChatMessage[];
  permissions: SmartSessionGrantPermissionsResponse;
}

export type ChatContextType = {
  state: ChatState;
  startChat: (chainId: number, address: `0x${string}`) => Promise<void>;
  sendMessage: (text: string) => void;
  clearChat: () => void;
  clearPermissions: () => void;
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/types/1inch.ts">
export interface SwapParams {
  src: `0x${string}`;
  dst: `0x${string}`;
  amount: string;
  from: `0x${string}`;
  slippage: number;
  disableEstimate?: boolean;
  allowPartialFill?: boolean;
}

export interface AllowanceResponse {
  allowance: string;
}

export interface ApprovalTransaction {
  from: `0x${string}`;
  to: `0x${string}`;
  data: `0x${string}`;
  value: bigint;
  gas: bigint;
}

export interface SwapTransactionResponse {
  tx: {
    from: `0x${string}`;
    to: `0x${string}`;
    data: `0x${string}`;
    value: string;
    gas: number;
    gasPrice: string;
  };
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/types/api.ts">
export interface SwapResponse {
  message: string;
  status: 'success' | 'error' | 'pending';
  userOpHash: string;
  amount: string;
  txLink: string;
}
export interface ChatResponse {
  message: string;
  status: 'success' | 'error';
}

export type ExpectedResponse = {
  intent: 'SWAP';
  amount: string;
} | {
  intent: 'GET_SWAP_RECEIPT';
  purchaseId: string;
} | {
  intent: 'NOT_SWAP';
  responseText: string;
}

export interface SwapReceipt {
  message: string;
  txLink: string;
  userOpHash: string;
  status: 'success' | 'error' | 'pending';
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/ChainUtil.ts">
import * as viemChains from "viem/chains";

export class ChainUtil {
  static getChain(id: number): viemChains.Chain | undefined {
    const chains = Object.values(viemChains) as viemChains.Chain[];
    return chains.find((x) => x.id === id);
  }

  static getValidatedChain(chainIdHex: string): viemChains.Chain {
    const chainId = parseInt(chainIdHex, 16);
    if (!chainId) {
      throw new Error("Chain ID not available in granted permissions");
    }

    const chain = this.getChain(chainId);
    if (!chain) {
      throw new Error(`Unsupported chain ID: ${chainId}`);
    }
    
    return chain;
  }
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/ChatContants.ts">
export const STORAGE_KEY = 'chat_state';
export const PERMISSIONS_STORAGE_KEY = 'granted_permissions';
export const MAX_CONTEXT_MESSAGES = 10;
export const INITIAL_MESSAGE = "Hello! How can I help you today?";
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/ChatSmartSessionsPermissionsUtil.ts">
import { grantPermissions, SmartSessionGrantPermissionsRequest, SmartSessionGrantPermissionsResponse } from "@reown/appkit-experimental/smart-session";
import { parseEther, toHex } from "viem";


const getCurrentTimestampInSeconds = () => Math.floor(Date.now() / 1000) + 20;
const PERMISSION_PERIOD =  60 * 60; //  1 hour
const ALLOWANCE_VALUE = parseEther("0.001");

export function getChatAgentPermissions(): Omit<
    SmartSessionGrantPermissionsRequest,
    "signer" | "chainId" | "address" | "expiry"
  > {
    return {
      permissions: [
        {
          type: "native-token-recurring-allowance",
          data: {
            period: PERMISSION_PERIOD,
            start: getCurrentTimestampInSeconds(),
            allowance: toHex(ALLOWANCE_VALUE),
          },
        },
      ],
      policies: [],
    };
  }
  // Method to get required permissions
  export const getRequiredPermissions = async (chainId: number, address: `0x${string}`): Promise<SmartSessionGrantPermissionsResponse> => {
    const getDappKeyResponse = await fetch("/api/signer", {
      method: "GET",
    });
    const dappSignerData = await getDappKeyResponse.json();
    const dAppECDSAPublicKey = dappSignerData.key;

    const chatAgentPermission = getChatAgentPermissions();
    const smartSessionChatAgentPermissions: SmartSessionGrantPermissionsRequest = {
      // Adding 1 hours to the current time
      expiry: getCurrentTimestampInSeconds() +  60 * 60,
      chainId: toHex(chainId),
      address: address as `0x${string}`,
      signer: {
        type: "keys",
        data: {
          keys: [
            {
              type: "secp256k1",
              publicKey: dAppECDSAPublicKey,
            },
          ],
        },
      },
      permissions: chatAgentPermission["permissions"],
      policies: chatAgentPermission["policies"] || [],
    };
    const approvedPermissions = await grantPermissions(smartSessionChatAgentPermissions);

    return approvedPermissions;
  };
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/CommonUtils.ts">
export function parseJSON(str: string) {
  try {
    return JSON.parse(str);
  } catch (error) {
    return { error: `Invalid JSON: ${error}` };
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function bigIntReplacer(_key: string, value: any) {
  if (typeof value === "bigint") {
    return `0x${value.toString(16)}`;
  }

  return value;
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/ConstantsUtil.ts">
const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
if (!projectId) {
  throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
}
export const WALLET_URL =
  process.env["WALLET_URL"] || "https://react-wallet.walletconnect.com/";
export function getPublicUrl() {
  const vercelUrl = process.env["NEXT_PUBLIC_VERCEL_URL"];
  if (vercelUrl) {
    return `https://${vercelUrl}`;
  }

  return "https://lab.web3modal.com";
}

export const CUSTOM_WALLET = "wc:custom_wallet";
export const USEROP_BUILDER_SERVICE_BASE_URL =
  "https://rpc.walletconnect.org/v1/wallet";

let storedCustomWallet;
if (typeof window !== "undefined") {
  storedCustomWallet = localStorage.getItem(CUSTOM_WALLET);
}

const customWallet = storedCustomWallet ? [JSON.parse(storedCustomWallet)] : [];

export const ConstantsUtil = {
  SigningSucceededToastTitle: "Signing Succeeded",
  SigningFailedToastTitle: "Signing Failed",
  TestIdSiweAuthenticationStatus: "w3m-authentication-status",
  Metadata: {
    name: "Demo Agent",
    description: "Smart Sessions x Demo AI Agent demo app",
    url: getPublicUrl(),
    icons: [`${getPublicUrl()}/metadata-icon.svg`],
    verifyUrl: "",
  },
  CustomWallets: [
    ...customWallet,
    {
      id: "react-wallet-v2",
      name: "React Sample Wallet",
      homepage: WALLET_URL,
      mobile_link: WALLET_URL,
      desktop_link: WALLET_URL,
      webapp_link: WALLET_URL,
      image_url: "/sample-wallets/react.svg",
    },
    {
      id: "kotlin-web3wallet",
      name: "Kotlin Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "kotlin-web3wallet://",
      image_url: "/sample-wallets/kotlin.svg",
    },
    {
      id: "swift-web3wallet",
      name: "Swift Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "walletapp://",
      image_url: "/sample-wallets/swift.svg",
    },
    {
      id: "flutter-web3wallet",
      name: "Flutter Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "wcflutterwallet://",
      image_url: "/sample-wallets/flutter.svg",
    },
    {
      id: "rn-web3wallet",
      name: "React Native Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "rn-web3wallet://",
      image_url: "/sample-wallets/react-native.svg",
    },
  ],
  ProjectId: projectId,
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/ERC7715PermissionsAsyncUtils.ts">
import { signMessage } from "viem/accounts";
import { toHex, type Chain } from "viem";
import {
  Call,
  prepareCalls,
  sendPreparedCalls,
} from "./UserOpBuilderServiceUtils";

export type MultikeySigner = {
  type: "keys";
  data: {
    ids: string[];
  };
};

export async function executeActionsWithECDSAKey(args: {
  actions: Call[];
  ecdsaPrivateKey: `0x${string}`;
  chain: Chain;
  accountAddress: `0x${string}`;
  permissionsContext: string;
}): Promise<string> {
  const {
    ecdsaPrivateKey,
    actions,
    chain,
    accountAddress,
    permissionsContext,
  } = args;
  if (!permissionsContext) {
    throw new Error("No permissions available");
  }
  if (!accountAddress) {
    throw new Error("No account Address available");
  }

  const prepareCallsResponse = await prepareCalls({
    from: accountAddress,
    chainId: toHex(chain.id),
    calls: actions.map((call) => ({
      to: call.to,
      data: call.data,
      value: toHex(call.value),
    })),
    capabilities: {
      permissions: { context: permissionsContext },
    },
  });
  if (prepareCallsResponse.length !== 1 && prepareCallsResponse[0]) {
    throw new Error("Invalid response type");
  }
  const response = prepareCallsResponse[0];
  if (!response || response.preparedCalls.type !== "user-operation-v07") {
    throw new Error("Invalid response type");
  }
  const signatureRequest = response.signatureRequest;
  const dappSignature = await signMessage({
    privateKey: ecdsaPrivateKey,
    message: { raw: signatureRequest.hash },
  });

  const sendPreparedCallsResponse = await sendPreparedCalls({
    context: response.context,
    preparedCalls: response.preparedCalls,
    signature: dappSignature,
  });

  const userOpIdentifier = sendPreparedCallsResponse[0];

  return userOpIdentifier;
}
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/messageUtils.ts">
import { IChatMessage } from "@/types/chat/types";
import { MAX_CONTEXT_MESSAGES } from "./ChatContants";
import { v4 as uuidv4 } from 'uuid';

export const getRecentMessageHistory = (messages: IChatMessage[]) => {
  return messages.slice(-MAX_CONTEXT_MESSAGES);
};

export const getLastMessage = (messages: IChatMessage[]) => {
  return messages[messages.length - 1];
};

export const createMessage = (text: string, sender: 'user' | 'system', type: 'text'|'error'): IChatMessage => {
  return {
    id: uuidv4(),
    text,
    sender,
    timestamp: new Date(),
    type
  };
};
</file>

<file path="advanced/dapps/chat-demo-agent/src/utils/UserOpBuilderServiceUtils.ts">
import { bigIntReplacer } from "../utils/CommonUtils";
import type { Address, Hex } from "viem";
import { USEROP_BUILDER_SERVICE_BASE_URL } from "./ConstantsUtil";

export type Call = { to: Address; value: bigint; data: Hex };

export type UserOperationWithBigIntAsHex = {
  sender: Address;
  nonce: Hex;
  factory: Address | undefined;
  factoryData: Hex | undefined;
  callData: Hex;
  callGasLimit: Hex;
  verificationGasLimit: Hex;
  preVerificationGas: Hex;
  maxFeePerGas: Hex;
  maxPriorityFeePerGas: Hex;
  paymaster: Address | undefined;
  paymasterVerificationGasLimit: Hex | undefined;
  paymasterPostOpGasLimit: Hex | undefined;
  paymasterData: Hex | undefined;
  signature: Hex;
  initCode?: never;
  paymasterAndData?: never;
};

/**
 * UserOperation v0.7
 */
export type UserOperation = {
  sender: Address;
  nonce: bigint;
  factory?: Address;
  factoryData?: Hex;
  callData: Hex;
  callGasLimit: bigint;
  verificationGasLimit: bigint;
  preVerificationGas: bigint;
  maxFeePerGas: bigint;
  maxPriorityFeePerGas: bigint;
  paymaster?: Address;
  paymasterVerificationGasLimit?: bigint;
  paymasterPostOpGasLimit?: bigint;
  paymasterData?: Hex;
  signature: Hex;
  initCode?: never;
  paymasterAndData?: never;
};

export type ErrorResponse = {
  message: string;
  error: string;
};

export type PrepareCallsParams = {
  from: `0x${string}`;
  chainId: `0x${string}`;
  calls: {
    to: `0x${string}`;
    data: `0x${string}`;
    value: `0x${string}`;
  }[];
  capabilities: Record<string, unknown>;
};

export type PrepareCallsReturnValue = {
  preparedCalls: {
    type: string;
    data: unknown;
    chainId: `0x${string}`;
  };
  signatureRequest: {
    hash: `0x${string}`;
  };
  context: string;
};

export type SendPreparedCallsParams = {
  preparedCalls: {
    type: string;
    data: unknown;
    chainId: `0x${string}`;
  };
  signature: `0x${string}`;
  context: string;
};

export type SendPreparedCallsReturnValue = string;
export type GetCallsStatusParams = string;
export type GetCallsStatusReturnValue = {
  status: "PENDING" | "CONFIRMED";
  receipts?: {
    logs: {
      address: `0x${string}`;
      data: `0x${string}`;
      topics: `0x${string}`[];
    }[];
    status: `0x${string}`; // Hex 1 or 0 for success or failure, respectively
    blockHash: `0x${string}`;
    blockNumber: `0x${string}`;
    gasUsed: `0x${string}`;
    transactionHash: `0x${string}`;
  }[];
};

// Define a custom error type
export class UserOpBuilderApiError extends Error {
  constructor(
    public status: number,
    message: string,
  ) {
    super(message);
    this.name = "UserOpBuilderApiError";
  }
}

async function jsonRpcRequest<TParams, TResult>(
  method: string,
  params: TParams,
  url: string,
): Promise<TResult> {
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(
      {
        jsonrpc: "2.0",
        id: "1",
        method,
        params,
      },
      bigIntReplacer,
    ),
  });

  if (!response.ok) {
    throw new UserOpBuilderApiError(response.status, await response.text());
  }

  const data = await response.json();

  if ("error" in data) {
    throw new UserOpBuilderApiError(500, JSON.stringify(data.error));
  }

  return data.result; // Return the result if successful
}

export async function prepareCalls(
  args: PrepareCallsParams,
): Promise<PrepareCallsReturnValue[]> {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }
  const url = `${USEROP_BUILDER_SERVICE_BASE_URL}?projectId=${projectId}`;

  return jsonRpcRequest<PrepareCallsParams[], PrepareCallsReturnValue[]>(
    "wallet_prepareCalls",
    [args],
    url,
  );
}

export async function sendPreparedCalls(
  args: SendPreparedCallsParams,
): Promise<SendPreparedCallsReturnValue[]> {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }
  const url = `${USEROP_BUILDER_SERVICE_BASE_URL}?projectId=${projectId}`;

  return jsonRpcRequest<
    SendPreparedCallsParams[],
    SendPreparedCallsReturnValue[]
  >("wallet_sendPreparedCalls", [args], url);
}

export async function getCallsStatus(
  args: GetCallsStatusParams
): Promise<GetCallsStatusReturnValue> {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }

  const url = `${USEROP_BUILDER_SERVICE_BASE_URL}?projectId=${projectId}`;

  return await jsonRpcRequest<
    GetCallsStatusParams[],
    GetCallsStatusReturnValue
  >("wallet_getCallsStatus", [args], url);
}
</file>

<file path="advanced/dapps/chat-demo-agent/.env.example">
OPENAI_API_KEY=
NEXT_PUBLIC_PROJECT_ID=
APPLICATION_PRIVATE_KEY=
</file>

<file path="advanced/dapps/chat-demo-agent/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env
.env.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

.open-next
.dev.vars
.wrangler
</file>

<file path="advanced/dapps/chat-demo-agent/.node-version">
20.0.0
</file>

<file path="advanced/dapps/chat-demo-agent/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="advanced/dapps/chat-demo-agent/eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript","plugin:eslint-plugin-next-on-pages/recommended"),
  ...compat.plugins("eslint-plugin-next-on-pages")
];

export default eslintConfig;
</file>

<file path="advanced/dapps/chat-demo-agent/next.config.ts">
import { setupDevPlatform } from '@cloudflare/next-on-pages/next-dev';

/** @type {import('next').NextConfig} */
const nextConfig = {};

 if (process.env.NODE_ENV === 'development') {
   await setupDevPlatform();
 }

export default nextConfig;
</file>

<file path="advanced/dapps/chat-demo-agent/package.json">
{
  "name": "chat-demo-agent",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "pages:build": "npx @cloudflare/next-on-pages",
    "preview": "npm run pages:build && wrangler pages dev",
    "deploy": "npm run pages:build && wrangler pages deploy"
  },
  "dependencies": {
    "@radix-ui/react-dropdown-menu": "^2.1.4",
    "@radix-ui/react-scroll-area": "^1.2.2",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.4",
    "@reown/appkit": "1.6.8",
    "@reown/appkit-adapter-wagmi": "1.6.8",
    "@reown/appkit-experimental": "1.6.8",
    "@shadcn/ui": "^0.0.4",
    "@tanstack/react-query": "5.24.8",
    "autoprefixer": "10.4.18",
    "class-variance-authority": "^0.7.1",
    "clsx": "2.1.0",
    "date-fns": "^4.1.0",
    "dompurify": "^3.2.4",
    "lucide-react": "^0.427.0",
    "next": "15.2.3",
    "next-themes": "^0.3.0",
    "openai": "^4.78.1",
    "pino-pretty": "^11.2.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "2.2.1",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.0.5",
    "viem": "2.22.8",
    "wagmi": "2.14.7"
  },
  "devDependencies": {
    "@cloudflare/next-on-pages": "^1.13.7",
    "@eslint/eslintrc": "^3",
    "@types/dompurify": "^3.2.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.4",
    "eslint-plugin-next-on-pages": "^1.13.7",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5",
    "wrangler": "^3.103.2"
  }
}
</file>

<file path="advanced/dapps/chat-demo-agent/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="advanced/dapps/chat-demo-agent/tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="advanced/dapps/chat-demo-agent/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="advanced/dapps/chat-demo-agent/wrangler.json">
{
  "name": "demo-chat-agent",
  "compatibility_date": "2025-01-17",
  "compatibility_flags": [
    "nodejs_compat"
  ],
  "pages_build_output_dir": ".vercel/output/static"
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/bip122.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const BIP122_MAINNET = "000000000019d6689c085ae165831e93";
export const BIP122_TESTNET = "000000000933ea01ad0ee984209779ba";
export const BIP122_DUST_LIMIT = "1001";

export const BtcChainData: ChainsMap = {
  [BIP122_MAINNET]: {
    id: `bip122:${BIP122_MAINNET}`,
    name: "BTC Mainnet",
    rpc: [],
    slip44: 0,
    testnet: false,
  },
  [BIP122_TESTNET]: {
    id: `bip122:${BIP122_TESTNET}`,
    name: "BTC Testnet",
    rpc: [],
    slip44: 501,
    testnet: true,
  },
};

export const BtcMetadata: NamespaceMetadata = {
  [BIP122_MAINNET]: {
    logo: "/assets/btc-testnet.png",
    rgb: "247, 147, 25",
  },
  [BIP122_TESTNET]: {
    logo: "/assets/btc-testnet.png",
    rgb: "247, 147, 25",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = BtcMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/cosmos.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const CosmosChainData: ChainsMap = {
  "cosmoshub-4": {
    name: "Cosmos Hub",
    id: "cosmos:cosmoshub-4",
    rpc: ["https://rpc.cosmos.network"],
    slip44: 118,
    testnet: false,
  },
  "irishub-1": {
    name: "Irisnet",
    id: "cosmos:irishub-1",
    rpc: ["https://rpc.irisnet.org"],
    slip44: 566,
    testnet: false,
  },
  "kava-4": {
    name: "Kava",
    id: "cosmos:kava-4",
    rpc: ["https://kava4.data.kava.io"],
    slip44: 459,
    testnet: false,
  },
  "columbus-4": {
    name: "Terra",
    id: "cosmos:columbus-4",
    rpc: [],
    slip44: 330,
    testnet: false,
  },
};

export const CosmosMetadata: NamespaceMetadata = {
  "cosmoshub-4": {
    logo: "/assets/" + "cosmos-cosmoshub-4.png",
    rgb: "27, 31, 53",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = CosmosMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/eip155.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  convertHexToNumber,
  convertHexToUtf8,
  ChainsMap,
} from "../helpers";

export const EIP155Colors = {
  ethereum: "99, 125, 234",
  optimism: "233, 1, 1",
  goerli: "189, 174, 155",
  xdai: "73, 169, 166",
  polygon: "130, 71, 229",
  zksync: "90, 90, 90",
  celo: "60, 203, 132",
  arbitrum: "44, 55, 75",
};

export const EIP155ChainData: ChainsMap = {
  "1": {
    name: "Ethereum Mainnet",
    id: "eip155:1",
    rpc: ["https://api.mycryptoapi.com/eth"],
    slip44: 60,
    testnet: false,
  },
  "5": {
    name: "Ethereum Goerli",
    id: "eip155:5",
    rpc: ["https://rpc.goerli.mudit.blog"],
    slip44: 60,
    testnet: true,
  },
  "11155111": {
    name: "Ethereum Sepolia",
    id: "eip155:11155111",
    rpc: ["https://gateway.tenderly.co/public/sepolia	"],
    slip44: 60,
    testnet: true,
  },
  "10": {
    name: "Optimism Mainnet",
    id: "eip155:10",
    rpc: ["https://mainnet.optimism.io"],
    slip44: 60,
    testnet: false,
  },
  "42": {
    name: "Ethereum Kovan",
    id: "eip155:42",
    rpc: ["https://kovan.poa.network"],
    slip44: 60,
    testnet: true,
  },
  "69": {
    name: "Optimism Kovan",
    id: "eip155:69",
    rpc: ["https://kovan.optimism.io"],
    slip44: 60,
    testnet: true,
  },
  "100": {
    name: "xDAI",
    id: "eip155:100",
    rpc: ["https://dai.poa.network"],
    slip44: 60,
    testnet: false,
  },
  "280": {
    name: "zkSync Era Testnet",
    id: "eip155:280",
    rpc: ["https://testnet.era.zksync.dev"],
    slip44: 60,
    testnet: true,
  },
  "324": {
    name: "zkSync Era",
    id: "eip155:324",
    rpc: ["https://mainnet.era.zksync.io"],
    slip44: 60,
    testnet: false,
  },
  "137": {
    name: "Polygon Mainnet",
    id: "eip155:137",
    rpc: ["https://rpc-mainnet.matic.network"],
    slip44: 60,
    testnet: false,
  },
  "420": {
    name: "Optimism Goerli",
    id: "eip155:420",
    rpc: ["https://goerli.optimism.io"],
    slip44: 60,
    testnet: true,
  },
  "42161": {
    name: "Arbitrum One",
    id: "eip155:42161",
    rpc: ["https://arb1.arbitrum.io/rpc"],
    slip44: 60,
    testnet: false,
  },
  "42220": {
    name: "Celo Mainnet",
    id: "eip155:42220",
    rpc: ["https://forno.celo.org"],
    slip44: 52752,
    testnet: false,
  },
  "44787": {
    name: "Celo Alfajores",
    id: "eip155:44787",
    rpc: ["https://alfajores-forno.celo-testnet.org"],
    slip44: 52752,
    testnet: true,
  },
  "80001": {
    name: "Polygon Mumbai",
    id: "eip155:80001",
    rpc: ["https://rpc-mumbai.matic.today"],
    slip44: 60,
    testnet: true,
  },
  "421611": {
    name: "Arbitrum Rinkeby",
    id: "eip155:421611",
    rpc: ["https://rinkeby.arbitrum.io/rpc"],
    slip44: 60,
    testnet: true,
  },
};

export const EIP155Metadata: NamespaceMetadata = {
  "1": {
    name: "Ethereum",
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "5": {
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "11155111": {
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "10": {
    name: "Optimism",
    logo: "/assets/" + "eip155-10.png",
    rgb: EIP155Colors.optimism,
  },
  "42": {
    logo: "/assets/" + "eip155-42.png",
    rgb: EIP155Colors.ethereum,
  },
  "420": {
    logo: "/assets/" + "eip155-420.png",
    rgb: EIP155Colors.optimism,
  },
  "100": {
    logo: "/assets/" + "eip155-100.png",
    rgb: EIP155Colors.xdai,
  },
  "280": {
    name: "zkSync Era Testnet",
    logo: "/assets/" + "eip155-324.svg",
    rgb: EIP155Colors.zksync,
  },
  "324": {
    name: "zkSync Era",
    logo: "/assets/" + "eip155-324.svg",
    rgb: EIP155Colors.zksync,
  },
  "137": {
    name: "Polygon",
    logo: "/assets/" + "eip155-137.png",
    rgb: EIP155Colors.polygon,
  },
  "80001": {
    logo: "/assets/" + "eip155-80001.png",
    rgb: EIP155Colors.polygon,
  },
  "42161": {
    name: "Arbitrum",
    logo: "/assets/" + "eip155-42161.png",
    rgb: EIP155Colors.arbitrum,
  },
  "42220": {
    name: "Celo",
    logo: "/assets/" + "eip155-42220.png",
    rgb: EIP155Colors.celo,
  },
  "44787": {
    logo: "/assets/" + "eip155-44787.png",
    rgb: EIP155Colors.celo,
  },
  "421611": {
    logo: "/assets/" + "eip155-421611.png",
    rgb: EIP155Colors.arbitrum,
  },
};
export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = EIP155Metadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  let params = [{ label: "Method", value: request.method }];

  switch (request.method) {
    case "eth_sendTransaction":
    case "eth_signTransaction":
      params = [
        ...params,
        { label: "From", value: request.params[0].from },
        { label: "To", value: request.params[0].to },
        {
          label: "Gas Limit",
          value: request.params[0].gas
            ? convertHexToNumber(request.params[0].gas)
            : request.params[0].gasLimit
            ? convertHexToNumber(request.params[0].gasLimit)
            : "",
        },
        {
          label: "Gas Price",
          value: convertHexToNumber(request.params[0].gasPrice),
        },
        {
          label: "Nonce",
          value: convertHexToNumber(request.params[0].nonce),
        },
        {
          label: "Value",
          value: request.params[0].value
            ? convertHexToNumber(request.params[0].value)
            : "",
        },
        { label: "Data", value: request.params[0].data },
      ];
      break;

    case "eth_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[0] },
        { label: "Message", value: request.params[1] },
      ];
      break;
    case "personal_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[1] },
        {
          label: "Message",
          value: convertHexToUtf8(request.params[0]),
        },
      ];
      break;
    default:
      params = [
        ...params,
        {
          label: "params",
          value: JSON.stringify(request.params, null, "\t"),
        },
      ];
      break;
  }
  return params;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/index.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import * as eip155 from "./eip155";
import * as cosmos from "./cosmos";
import * as polkadot from "./polkadot";
import * as solana from "./solana";
import * as near from "./near";
import * as multiversx from "./multiversx";
import * as tron from "./tron";
import * as tezos from "./tezos";
import * as kadena from "./kadena";
import * as bip122 from "./bip122";

import { ChainMetadata, ChainRequestRender } from "../helpers";

export function getChainMetadata(chainId: string): ChainMetadata {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainMetadata(chainId);
    case "cosmos":
      return cosmos.getChainMetadata(chainId);
    case "polkadot":
      return polkadot.getChainMetadata(chainId);
    case "solana":
      return solana.getChainMetadata(chainId);
    case "near":
      return near.getChainMetadata(chainId);
    case "kadena":
      return kadena.getChainMetadata(chainId);
    case "mvx":
      return multiversx.getChainMetadata(chainId);
    case "tron":
      return tron.getChainMetadata(chainId);
    case "tezos":
      return tezos.getChainMetadata(chainId);
    case "bip122":
      return bip122.getChainMetadata(chainId);
    default:
      throw new Error(`No metadata handler for namespace ${namespace}`);
  }
}

export function getChainRequestRender(
  request: JsonRpcRequest,
  chainId: string
): ChainRequestRender[] {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainRequestRender(request);
    case "cosmos":
      return cosmos.getChainRequestRender(request);
    case "polkadot":
      return polkadot.getChainRequestRender(request);
    case "near":
      return near.getChainRequestRender(request);
    case "tezos":
      return tezos.getChainRequestRender(request);
    case "kadena":
      return kadena.getChainRequestRender(request);
    default:
      throw new Error(`No render handler for namespace ${namespace}`);
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/kadena.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const KadenaMetadata: NamespaceMetadata = {
  mainnet01: {
    logo: "/assets/kadena.png",
    rgb: "237, 9, 143",
  },
  testnet04: {
    logo: "/assets/kadena.png",
    rgb: "237, 9, 143",
  },
};

// TODO: add `kadena` namespace to `caip-api` package to avoid manual specification here.
export const KadenaChainData: ChainsMap = {
  mainnet01: {
    name: "Kadena",
    id: "kadena:mainnet01",
    rpc: ["https://api.chainweb.com"],
    slip44: 626,
    testnet: false,
  },
  testnet04: {
    name: "Kadena Testnet",
    id: "kadena:testnet04",
    rpc: ["https://api.chainweb.com"],
    slip44: 626,
    testnet: true,
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = KadenaMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/multiversx.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const MultiversxChainData: ChainsMap = {
  "1": {
    id: "mvx:1",
    name: "MultiversX Mainnet",
    rpc: ["https://api.multiversx.com"],
    slip44: 508,
    testnet: false,
  },
  D: {
    id: "mvx:D",
    name: "MultiversX Devnet",
    rpc: ["https://devnet-api.multiversx.com"],
    slip44: 508,
    testnet: true,
  },
  // Keep only one Test Chain visible
  // T: {
  //   id: "mvx:T",
  //   name: "MultiversX Testnet",
  //   rpc: ["https://testnet-api.multiversx.com"],
  //   slip44: 508,
  //   testnet: true,
  // },
};

export const MultiversxMetadata: NamespaceMetadata = {
  // MultiversX Mainnet
  "1": {
    logo: "/assets/multiversx_logo.svg",
    rgb: "0, 0, 0",
  },
  // MultiversX Testnet
  T: {
    logo: "/assets/multiversx_logo.svg",
    rgb: "0, 0, 0",
  },
  // MultiversX Devnet
  D: {
    logo: "/assets/multiversx_logo.svg",
    rgb: "0, 0, 0",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = MultiversxMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/near.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const NearMetadata: NamespaceMetadata = {
  testnet: {
    logo: "https://avatars.githubusercontent.com/u/7613128?s=200&v=4",
    rgb: "27, 31, 53",
  },
};

export const NearChainData: ChainsMap = {
  testnet: {
    name: "NEAR Testnet",
    id: "near:testnet",
    rpc: ["https://rpc.testnet.near.org"],
    slip44: 397,
    testnet: true,
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = NearMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/polkadot.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";
import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const PolkadotChainData: ChainsMap = {
  ["91b171bb158e2d3848fa23a9f1c25182"]: {
    id: "polkadot:91b171bb158e2d3848fa23a9f1c25182",
    name: "Polkadot Mainnet",
    rpc: ["wss://rpc.polkadot.io"],
    slip44: 0,
    testnet: false,
  },
  ["e143f23803ac50e8f6f8e62695d1ce9e"]: {
    id: "polkadot:e143f23803ac50e8f6f8e62695d1ce9e",
    name: "Polkadot Testnet (Westend)",
    rpc: ["wss://westend-rpc.polkadot.io"],
    slip44: 0,
    testnet: false,
  },
};

export const PolkadotMetadata: NamespaceMetadata = {
  // eslint-disable-next-line no-useless-computed-key
  ["91b171bb158e2d3848fa23a9f1c25182"]: {
    logo: "/assets/polkadot.svg",
    rgb: "230, 1, 122",
  },
  ["e143f23803ac50e8f6f8e62695d1ce9e"]: {
    logo: "/assets/westend-logo.svg",
    rgb: "218, 104, 167",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = PolkadotMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/solana.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const SolanaChainData: ChainsMap = {
  "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
    id: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    name: "Solana Mainnet",
    rpc: [
      "https://api.mainnet-beta.solana.com",
      "https://solana-api.projectserum.com",
    ],
    slip44: 501,
    testnet: false,
  },
  EtWTRABZaYq6iMfeYKouRu166VU2xqa1: {
    id: "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
    name: "Solana Devnet",
    rpc: ["https://api.devnet.solana.com"],
    slip44: 501,
    testnet: true,
  },
  "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": {
    id: "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
    name: "Solana Testnet",
    rpc: ["https://api.testnet.solana.com"],
    slip44: 501,
    testnet: true,
  },
};

export const SolanaMetadata: NamespaceMetadata = {
  // Solana Mainnet
  "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": {
    logo: "/assets/solana_logo.png",
    rgb: "0, 0, 0",
  },
  // Solana Devnet
  EtWTRABZaYq6iMfeYKouRu166VU2xqa1: {
    logo: "/assets/solana_logo.png",
    rgb: "0, 0, 0",
  },
  // Solana Testnet
  "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": {
    logo: "/assets/solana_logo.png",
    rgb: "0, 0, 0",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = SolanaMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/tezos.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  ChainsMap,
} from "../helpers";

export const TezosMetadata: NamespaceMetadata = {
  mainnet: {
    logo: "/assets/tezos.svg",
    rgb: "44, 125, 247",
  },
  testnet: {
    logo: "/assets/tezos.svg",
    rgb: "44, 125, 247",
  },
};

export const TezosChainData: ChainsMap = {
  mainnet: {
    name: "Tezos",
    id: "tezos:mainnet",
    rpc: ["https://mainnet.api.tez.ie"],
    slip44: 1729,
    testnet: false,
  },
  testnet: {
    name: "Tezos Testnet",
    id: "tezos:testnet",
    rpc: ["https://ghostnet.ecadinfra.com"],
    slip44: 1729,
    testnet: true,
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = TezosMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(
  request: JsonRpcRequest
): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/chains/tron.ts">
import { NamespaceMetadata, ChainMetadata, ChainsMap } from "../helpers";

export const TronChainData: ChainsMap = {
  "0x2b6653dc": {
    id: "tron:0x2b6653dc",
    name: "Tron Mainnet",
    rpc: [],
    slip44: 195,
    testnet: false,
  },
  "0xcd8690dc": {
    id: "tron:0xcd8690dc",
    name: "Tron Testnet",
    rpc: [],
    slip44: 195,
    testnet: true,
  },
};

export const TronMetadata: NamespaceMetadata = {
  // Tron Mainnet
  "0x2b6653dc": {
    logo: "https://tronscan.io/static/media/TRON.4a760cebd163969b2ee874abf2415e9a.svg",
    rgb: "183, 62, 49",
  },
  // Tron TestNet
  "0xcd8690dc": {
    logo: "https://tronscan.io/static/media/TRON.4a760cebd163969b2ee874abf2415e9a.svg",
    rgb: "183, 62, 49",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = TronMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/app/index.tsx">
import styled from "styled-components";
import { fonts } from "../../styles";
import Button from "../Button";
import Column from "../Column";
import Wrapper from "../Wrapper";

export const SLayout = styled.div`
  position: relative;
  width: 100%;
  min-height: 100vh;
  text-align: center;
`;

export const SContent = styled(Wrapper as any)`
  width: 100%;
  height: 100%;
  padding: 0 16px;
`;

export const SLanding = styled(Column as any)`
  /* height: 600px; */
`;

export const SButtonContainer = styled(Column as any)`
  width: 250px;
  margin: 50px 0;
`;

export const SConnectButton = styled(Button as any)`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
`;

export const SAccountsContainer = styled(SLanding as any)`
  height: 100%;
  padding-bottom: 30px;
  & h3 {
    padding-top: 30px;
  }
`;

export const SToggleContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 10px auto;
  & > p {
    margin-right: 10px;
  }
`;

export const SDropDownContainer = styled.div`
  padding-top: 20px;
  display: flex;
  justify-content: center;
  align-items: flex-end;
`;

export const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

export const SAccounts = styled(SFullWidthContainer)`
  justify-content: space-between;
  align-items: start;
  & > div {
    margin: 12px 0;
    flex: 1 0 100%;
    @media (min-width: 648px) {
      flex: 0 1 48%;
    }
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/shared/index.ts">
import styled from "styled-components";

export const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

export const STable = styled(SContainer)`
  flex-direction: column;
  text-align: left;
`;

export const SRow = styled.div`
  width: 100%;
  display: flex;
  margin: 6px 0;
`;

export const SKey = styled.div`
  width: 30%;
  font-weight: 700;
`;

export const SValue = styled.div`
  width: 70%;
  font-family: monospace;
`;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Asset.tsx">
import * as React from "react";
import styled from "styled-components";

import Icon from "./Icon";

import { AssetData, fromWad } from "../helpers";

import { getChainMetadata } from "../chains";

const xdaiLogo = getChainMetadata("eip155:100").logo;
const maticLogo = getChainMetadata("eip155:137").logo;
const kadenaLogo = getChainMetadata("kadena:testnet04").logo;
const btcLogo = getChainMetadata(
  "bip122:000000000933ea01ad0ee984209779ba"
).logo;

const SAsset = styled.div`
  width: 100%;
  padding: 20px;
  display: flex;
  justify-content: space-between;
`;
const SAssetLeft = styled.div`
  display: flex;
`;

const SAssetName = styled.div`
  display: flex;
  margin-left: 10px;
`;

const SAssetRight = styled.div`
  display: flex;
`;

const SAssetBalance = styled.div`
  display: flex;
`;

function getAssetIcon(asset: AssetData): JSX.Element {
  if (!!asset.contractAddress) {
    const src = `https://raw.githubusercontent.com/TrustWallet/tokens/master/tokens/${asset.contractAddress.toLowerCase()}.png`;
    return <Icon src={src} fallback={"/assets/erc20.svg"} />;
  }
  switch (asset.symbol.toLowerCase()) {
    case "eth":
      return <Icon src={"/assets/eth.svg"} />;
    case "xdai":
      return <Icon src={xdaiLogo} />;
    case "matic":
      return <Icon src={maticLogo} />;
    case "kda":
      return <Icon src={kadenaLogo} />;
    case "btc":
      return <Icon src={btcLogo} />;
    default:
      return <Icon src={"/assets/eth20.svg"} />;
  }
}

interface AssetProps {
  asset: AssetData;
}

const Asset = (props: AssetProps) => {
  const { asset } = props;
  return (
    <SAsset {...props}>
      <SAssetLeft>
        {getAssetIcon(asset)}
        <SAssetName>{asset.name}</SAssetName>
      </SAssetLeft>
      <SAssetRight>
        <SAssetBalance>
          {fromWad(asset.balance || "0")} {asset.symbol}
        </SAssetBalance>
      </SAssetRight>
    </SAsset>
  );
};

export default Asset;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Banner.tsx">
import * as React from "react";
import styled from "styled-components";

const SBannerWrapper = styled.div`
  display: flex;
  align-items: center;
  position: relative;
`;

const SBanner = styled.div`
  width: 275px;
  height: 45px;
  background: url(/assets/walletconnect.png) no-repeat;
  background-size: cover;
  background-position: center;
`;

const Banner = () => (
  <SBannerWrapper>
    <SBanner />
  </SBannerWrapper>
);

export default Banner;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Blockchain.tsx">
import React, { PropsWithChildren, FC } from "react";
import { styled } from "styled-components";

import Asset from "./Asset";
import Button from "./Button";
import Column from "./Column";
import Loader from "./Loader";

import { getChainMetadata } from "../chains";
import {
  AccountAction,
  ellipseAddress,
  AccountBalances,
  ChainMetadata,
  ChainNamespaces,
  ChainData,
} from "../helpers";
import { fonts } from "../styles";

interface AccountStyleProps {
  rgb: string;
  children?: React.ReactNode;
  onClick?: () => void;
  className?: string;
}

const SAccount = styled.div<AccountStyleProps>`
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  border-radius: 8px;
  padding: 8px;
  margin: 5px 0;
  border: ${({ rgb }) => `2px solid rgb(${rgb})`};
  &.active {
    box-shadow: ${({ rgb }) => `0 0 8px rgb(${rgb})`};
  }
`;

const SChain = styled.div`
  width: 100%;
  display: flex;
  align-items: center;
  & p {
    font-weight: 600;
  }
  & img {
    border-radius: 50%;
    width: 35px;
    height: 35px;
    margin-right: 10px;
  }
`;

const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

interface ActionProps {
  rgb: string;
}

const SAction = styled(Button)<ActionProps>`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
  background-color: ${({ rgb }) => `rgb(${rgb})`};
`;

const SBlockchainChildrenContainer = styled(SFullWidthContainer)`
  flex-direction: column;
`;

interface BlockchainProps {
  chainData: ChainNamespaces;
  fetching?: boolean;
  active?: boolean;
  chainId: string;
  address?: string;
  onClick?: (chain: string) => void;
  balances?: AccountBalances;
  actions?: AccountAction[];
}

interface BlockchainDisplayData {
  data: ChainData;
  meta: ChainMetadata;
}

function getBlockchainDisplayData(
  chainId: string,
  chainData: ChainNamespaces
): BlockchainDisplayData | undefined {
  const [namespace, reference] = chainId.split(":");
  let meta: ChainMetadata;
  try {
    meta = getChainMetadata(chainId);
  } catch (e) {
    return undefined;
  }
  const data: ChainData = chainData[namespace][reference];
  if (typeof data === "undefined") return undefined;
  return { data, meta };
}

const Blockchain: FC<PropsWithChildren<BlockchainProps>> = (
  props: PropsWithChildren<BlockchainProps>
) => {
  const {
    chainData,
    fetching,
    chainId,
    address,
    onClick,
    active,
    balances,
    actions,
  } = props;
  if (!Object.keys(chainData).length) return null;

  const chain = getBlockchainDisplayData(chainId, chainData);

  if (typeof chain === "undefined") return null;

  const name = chain.meta.name || chain.data.name;
  const account =
    typeof address !== "undefined" ? `${chainId}:${address}` : undefined;
  const assets =
    typeof account !== "undefined" && typeof balances !== "undefined"
      ? balances[account]
      : [];
  return (
    <React.Fragment>
      <SAccount
        rgb={chain.meta.rgb}
        onClick={() => onClick && onClick(props.chainId)}
        className={active ? "active" : ""}
      >
        <SChain>
          <img src={chain.meta.logo} alt={name} />
          <p>{name}</p>
        </SChain>
        {!!address && <p>{ellipseAddress(address)}</p>}
        <SBlockchainChildrenContainer>
          {fetching ? (
            <Column center>
              <SContainer>
                <Loader rgb={`rgb(${chain.meta.rgb})`} />
              </SContainer>
            </Column>
          ) : (
            <>
              {!!assets && assets.length ? (
                <SFullWidthContainer>
                  <h6>Balances</h6>
                  <Column center>
                    {assets.map((asset) =>
                      asset.symbol ? (
                        <Asset key={asset.symbol} asset={asset} />
                      ) : null
                    )}
                  </Column>
                </SFullWidthContainer>
              ) : null}
              {address && !!actions && actions.length ? (
                <SFullWidthContainer>
                  <h6>Methods</h6>
                  {actions.map((action) => (
                    <SAction
                      key={action.method}
                      left
                      rgb={chain.meta.rgb}
                      onClick={() => action.callback(chainId, address)}
                    >
                      {action.method}
                    </SAction>
                  ))}
                </SFullWidthContainer>
              ) : null}
            </>
          )}
        </SBlockchainChildrenContainer>
      </SAccount>
    </React.Fragment>
  );
};
export default Blockchain;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Button.tsx">
import * as React from "react";
import { styled, keyframes } from "styled-components";
import Loader from "./Loader";
import { colors, fonts, shadows, transitions } from "../styles";

interface ButtonStyleProps {
  fetching: boolean;
  outline: boolean;
  type: "button" | "submit" | "reset";
  color: string;
  disabled: boolean;
  icon: any;
  left: boolean;
}

interface ButtonProps extends ButtonStyleProps {
  children: React.ReactNode;
  onClick?: any;
}

const SIcon = styled.div`
  position: absolute;
  height: 15px;
  width: 15px;
  margin: 0 8px;
  top: calc((100% - 15px) / 2);
`;

const SHoverLayer = styled.div`
  transition: ${transitions.button};
  position: absolute;
  height: 100%;
  width: 100%;
  background-color: rgb(${colors.white}, 0.1);
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  pointer-events: none;
  opacity: 0;
  visibility: hidden;
`;

const SButton = styled.button<ButtonStyleProps>`
  transition: ${transitions.button};
  position: relative;
  border: none;
  border-style: none;
  box-sizing: border-box;
  background-color: ${({ outline, color }) =>
    outline ? "transparent" : `rgb(${colors[color]})`};
  border: ${({ outline, color }) =>
    outline ? `1px solid rgb(${colors[color]})` : "none"};
  color: ${({ outline, color }) =>
    outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`};
  box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  font-weight: ${fonts.weight.semibold};
  padding: ${({ icon, left }) =>
    icon ? (left ? "7px 12px 8px 28px" : "7px 28px 8px 12px") : "8px 12px"};
  cursor: ${({ disabled }) => (disabled ? "auto" : "pointer")};
  will-change: transform;

  &:disabled {
    opacity: 0.6;
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  }

  @media (hover: hover) {
    &:hover {
      transform: ${({ disabled }) => (!disabled ? "translateY(-1px)" : "none")};
      box-shadow: ${({ disabled, outline }) =>
        !disabled
          ? outline
            ? "none"
            : `${shadows.hover}`
          : `${shadows.soft}`};
    }

    &:hover ${SHoverLayer} {
      opacity: 1;
      visibility: visible;
    }
  }

  &:active {
    transform: ${({ disabled }) => (!disabled ? "translateY(1px)" : "none")};
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
    color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgba(${colors.white}, 0.24)`};

    & ${SIcon} {
      opacity: 0.8;
    }
  }

  & ${SIcon} {
    right: ${({ left }) => (left ? "auto" : "0")};
    left: ${({ left }) => (left ? "0" : "auto")};
    display: ${({ icon }) => (icon ? "block" : "none")};
    mask: ${({ icon }) => (icon ? `url(${icon}) center no-repeat` : "none")};
    background-color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`};
    transition: 0.15s ease;
  }
`;

const Button = (props: ButtonProps) => (
  <SButton
    {...props}
    type={props.type}
    outline={props.outline}
    color={props.color}
    disabled={props.disabled}
    icon={props.icon}
    left={props.left}
  >
    <SHoverLayer />
    <SIcon />
    {props.fetching ? <Loader size={20} color="white" /> : props.children}
  </SButton>
);

Button.defaultProps = {
  fetching: false,
  outline: false,
  type: "button",
  color: "lightBlue",
  disabled: false,
  icon: null,
  left: false,
};

export default Button;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Column.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled } from "styled-components";

interface ColumnStyleProps {
  spanHeight: boolean;
  maxWidth: number;
  center: boolean;
  children?: React.ReactNode;
}

interface ColumnProps extends ColumnStyleProps {
  children: React.ReactNode;
}

const SColumn = styled.div<ColumnStyleProps>`
  position: relative;
  width: 100%;
  height: ${({ spanHeight }) => (spanHeight ? "100%" : "auto")};
  max-width: ${({ maxWidth }) => `${maxWidth}px`};
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: ${({ center }) => (center ? "center" : "flex-start")};
`;

const Column = (props: ColumnProps) => {
  const { children, spanHeight, maxWidth, center } = props;
  return (
    <SColumn
      {...props}
      spanHeight={spanHeight}
      maxWidth={maxWidth}
      center={center}
    >
      {children}
    </SColumn>
  );
};

Column.propTypes = {
  children: PropTypes.node.isRequired,
  spanHeight: PropTypes.bool,
  maxWidth: PropTypes.number,
  center: PropTypes.bool,
};

Column.defaultProps = {
  spanHeight: false,
  maxWidth: 600,
  center: false,
};

export default Column;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Header.tsx">
import * as React from "react";
import styled from "styled-components";
import { SessionTypes } from "@walletconnect/types";

import { fonts, responsive } from "../styles";
import Button from "./Button";
import Icon from "./Icon";
import { DEFAULT_GITHUB_REPO_URL } from "../constants";

const SHeader = styled.div`
  margin-top: -1px;
  margin-bottom: 1px;
  width: 100%;
  height: 100px;
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 16px;
  @media screen and (${responsive.sm.max}) {
    font-size: ${fonts.size.small};
  }
`;

const SHeaderActions = styled.div`
  display: flex;
  & button {
    margin-left: 10px;
  }
`;

const SActiveAccount = styled.div`
  display: flex;
  align-items: center;
  position: relative;
  font-weight: 500;
`;

const GithubLogoContainer = styled.div`
  padding-top: 8px;
`;

const SActiveSession = styled(SActiveAccount as any)`
  flex-direction: column;
  text-align: left;
  align-items: flex-start;
  & p {
    font-size: 0.8em;
    margin: 0;
    padding: 0;
  }
  & p:nth-child(n + 2) {
    font-weight: bold;
  }
`;

interface HeaderProps {
  ping: () => Promise<void>;
  emit: () => Promise<void>;
  disconnect: () => Promise<void>;
  session: SessionTypes.Struct | undefined;
}

const Header = (props: HeaderProps) => {
  const { ping, disconnect, session, emit } = props;
  return (
    <SHeader {...props}>
      {session ? (
        <>
          <SActiveSession>
            <p>{`Connected to`}</p>
            <p>{session.peer.metadata.name}</p>
          </SActiveSession>
          <SHeaderActions>
            <GithubLogoContainer>
              <a
                href={DEFAULT_GITHUB_REPO_URL}
                target="_blank"
                rel="noreferrer"
              >
                <Icon size={24} src={"/assets/githubLogo.svg"} />
              </a>
            </GithubLogoContainer>
            <Button outline color="black" onClick={ping}>
              {"Ping"}
            </Button>
            <Button outline color="black" onClick={emit}>
              {"Emit"}
            </Button>
            <Button outline color="red" onClick={disconnect}>
              {"Disconnect"}
            </Button>
          </SHeaderActions>
        </>
      ) : null}
    </SHeader>
  );
};

export default Header;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Icon.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

interface IconStyleProps {
  size: number;
}

const SIcon = styled.img<IconStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
`;

const Icon = (props: any) => {
  const { src, fallback, size } = props;
  return (
    <SIcon
      {...props}
      src={src}
      size={size}
      onError={(event: any) => {
        if (fallback) {
          event.target.src = fallback;
        }
      }}
    />
  );
};

Icon.propTypes = {
  src: PropTypes.string,
  fallback: PropTypes.string,
  size: PropTypes.number,
};

Icon.defaultProps = {
  src: null,
  fallback: "",
  size: 20,
};

export default Icon;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Loader.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled, keyframes } from "styled-components";
import { colors } from "../styles";

const load = keyframes`
  0% {
    transform: scale(1.0);
  }
  5% {
    transform: scale(1.0);
  }
  50% {
    transform: scale(0.8);
  }
  95% {
    transform: scale(1.0);
  }
  100% {
    transform: scale(1.0);
  }
`;

interface LoaderStyleProps {
  size: number;
  children?: React.ReactNode;
  viewBox?: string;
}

interface LoaderProps extends LoaderStyleProps {
  color: string;
  rgb?: string;
}

const SLoader = styled.svg<LoaderStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  animation: ${load} 1s infinite cubic-bezier(0.25, 0, 0.75, 1);
  transform: translateZ(0);
`;

const Loader = (props: LoaderProps) => {
  const { size, color } = props;
  const rgb = props.rgb || `rgb(${colors[color]})`;
  return (
    <SLoader viewBox="0 0 186 187" size={size}>
      <g stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
        <path
          d="M60,10.34375 C32.3857625,10.34375 10,32.7295125 10,60.34375 L10,126.34375 C10,153.957987 32.3857625,176.34375 60,176.34375 L126,176.34375 C153.614237,176.34375 176,153.957987 176,126.34375 L176,60.34375 C176,32.7295125 153.614237,10.34375 126,10.34375 L60,10.34375 Z M60,0.34375 L126,0.34375 C159.137085,0.34375 186,27.206665 186,60.34375 L186,126.34375 C186,159.480835 159.137085,186.34375 126,186.34375 L60,186.34375 C26.862915,186.34375 0,159.480835 0,126.34375 L0,60.34375 C0,27.206665 26.862915,0.34375 60,0.34375 Z"
          id="Rectangle-Copy"
          fill={rgb}
          fillRule="nonzero"
        />
        <rect
          id="Rectangle"
          fill={rgb}
          x="44"
          y="44.34375"
          width="98"
          height="98"
          rx="35"
        />
      </g>
    </SLoader>
  );
};

Loader.propTypes = {
  size: PropTypes.number,
  color: PropTypes.string,
};

Loader.defaultProps = {
  size: 40,
  color: "lightBlue",
};

export default Loader;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Metadata.tsx">
import Head from "next/head";
import * as React from "react";
import { DEFAULT_APP_METADATA } from "../constants";

const Metadata = () => (
  <Head>
    <title>{DEFAULT_APP_METADATA.name}</title>
    <meta name="description" content={DEFAULT_APP_METADATA.description} />
    <meta name="url" content={DEFAULT_APP_METADATA.url} />

    {DEFAULT_APP_METADATA.icons.map((icon, index) => (
      <link key={index} rel="icon" href={icon} />
    ))}
  </Head>
);

export default Metadata;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Modal.tsx">
import React, { useEffect, useRef, useState } from "react";
import { styled } from "styled-components";
import { colors, transitions } from "../styles";

interface LightboxProps {
  show: boolean;
  offset: number;
  opacity?: number;
  children?: React.ReactNode;
  ref?: React.RefObject<HTMLDivElement>;
}

const SLightbox = styled.div<LightboxProps>`
  transition: opacity 0.1s ease-in-out;
  text-align: center;
  position: absolute;
  width: 100vw;
  height: 100%;
  margin-left: -50vw;
  top: ${({ offset }) => (offset ? `-${offset}px` : 0)};
  left: 50%;
  z-index: 2;
  will-change: opacity;
  background-color: ${({ opacity }) => {
    let alpha = 0.4;
    if (typeof opacity === "number") {
      alpha = opacity;
    }
    return `rgba(0, 0, 0, ${alpha})`;
  }};
  opacity: ${({ show }) => (show ? 1 : 0)};
  visibility: ${({ show }) => (show ? "visible" : "hidden")};
  pointer-events: ${({ show }) => (show ? "auto" : "none")};
  display: flex;
  justify-content: center;
  align-items: center;
`;

const SModalContainer = styled.div`
  position: relative;
  width: 100%;
  height: 100%;
  padding: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

interface HitboxProps {
  onClick?: () => void;
}

const SHitbox = styled.div<HitboxProps>`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
`;

interface CloseButtonStyleProps {
  size: number;
  color: string;
  onClick?: any;
}

const SCloseButton = styled.div<CloseButtonStyleProps>`
  transition: ${transitions.short};
  position: absolute;
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  right: ${({ size }) => `${size / 1.6667}px`};
  top: ${({ size }) => `${size / 1.6667}px`};
  opacity: 0.5;
  cursor: pointer;

  &:hover {
    opacity: 1;
  }
  &:before,
  &:after {
    position: absolute;
    content: " ";
    height: ${({ size }) => `${size}px`};
    width: 2px;
    background: ${({ color }) => `rgb(${colors[color]})`};
  }
  &:before {
    transform: rotate(45deg);
  }
  &:after {
    transform: rotate(-45deg);
  }
`;

const SCard = styled.div`
  position: relative;
  width: 100%;
  max-width: 500px;
  padding: 25px;
  background-color: rgb(${colors.white});
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;

const SModalContent = styled.div`
  position: relative;
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

interface IProps {
  children: React.ReactNode;
  show: boolean;
  closeModal: () => void;
  opacity?: number;
}

export default function Modal({ children, show, opacity, closeModal }: IProps) {
  const [offset, setOffset] = useState(0);
  const lightboxRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (lightboxRef.current) {
      const lightboxRect = lightboxRef.current.getBoundingClientRect();
      const nextOffset = lightboxRect.top > 0 ? lightboxRect.top : 0;

      if (nextOffset !== 0 && nextOffset !== offset) {
        setOffset(nextOffset);
      }
    }
  }, [offset]);

  return (
    <SLightbox show={show} offset={offset} opacity={opacity} ref={lightboxRef}>
      <SModalContainer>
        <SHitbox onClick={closeModal} />
        <SCard>
          <SCloseButton size={25} color="dark" onClick={closeModal} />
          <SModalContent>{children}</SModalContent>
        </SCard>
      </SModalContainer>
    </SLightbox>
  );
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/OriginSimulationDropdown.tsx">
import * as React from "react";
import { ORIGIN_OPTIONS } from "../constants/default";
import { styled } from "styled-components";

interface OriginSimulationProps {
  origin: string;
  show: boolean;
}

interface SelectContainerProps {
  value?: string;
  onChange?: (e: any) => void;
  children?: React.ReactNode;
}

const SelectContainer = styled.select<SelectContainerProps>`
  width: 150px;
  background: transparent;
  color: black;
  height: 30px;
  border-radius: 4px;
  padding: 2px;
  font-size: "1.25em";
  bottom: 40px;
  left: 50px;
  direction: ltr;
  unicode-bidi: embed;
  margin: 5px;
`;

interface SelectOptionProps {
  value?: string;
  selected?: boolean;
  children?: React.ReactNode;
}

const SelectOption = styled.option<SelectOptionProps>`
  font-size: "1.25em";
`;

const OriginSimulationDropdown = (props: OriginSimulationProps) => {
  const { show } = props;
  const [selectedOrigin, setSelectedOrigin] = React.useState(props.origin);
  React.useEffect(() => {
    if (!show) {
      return;
    }

    setSelectedOrigin(
      localStorage.getItem("wallet_connect_dapp_origin") || props.origin
    );
  }, [show, props.origin]);

  const setOrigin = React.useCallback((origin: string) => {
    localStorage.setItem("wallet_connect_dapp_origin", origin);
    location.reload();
  }, []);
  return (
    <div>
      {show && (
        <SelectContainer
          value={selectedOrigin}
          onChange={(e) => setOrigin(e?.target?.value)}
        >
          <option disabled>Origin Url:</option>
          {ORIGIN_OPTIONS.map((e, i) => {
            const seleted = e.value === selectedOrigin;
            console.log("selected", seleted, e.value);
            return (
              <SelectOption key={i} value={e.value} selected={seleted}>
                {e.label}
              </SelectOption>
            );
          })}
        </SelectContainer>
      )}
    </div>
  );
};

export default OriginSimulationDropdown;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Pairing.tsx">
import * as React from "react";
import styled from "styled-components";

import { PairingTypes } from "@walletconnect/types";

import Peer from "./Peer";

interface PairingProps {
  pairing: PairingTypes.Struct;
  onClick?: any;
}

const SPairingContainer = styled.div`
  width: 100%;
  cursor: pointer;
`;

const Pairing = (props: PairingProps) => {
  const { peerMetadata } = props.pairing;
  return (
    <SPairingContainer onClick={props.onClick}>
      <div>
        {typeof peerMetadata !== "undefined" ? (
          <Peer oneLiner metadata={peerMetadata} />
        ) : (
          <div>{`Unknown Wallet`}</div>
        )}
      </div>
    </SPairingContainer>
  );
};

export default Pairing;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Peer.tsx">
import { SignClientTypes } from "@walletconnect/types";
import * as React from "react";
import styled from "styled-components";
import { colors, fonts } from "../styles";

const SPeerOneLiner = styled.div`
  display: flex;
  align-items: center;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;

  & img {
    width: 40px;
    height: 40px;
  }
  & > div {
    margin-left: 10px;
  }
`;

const SPeerCard = styled.div`
  align-items: center;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-direction: column;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;
  & > div {
    margin: 4px auto;
  }
`;

const SIcon = styled.img`
  width: 100px;
  margin: 0 auto;
`;

const SCenter = styled.div`
  text-align: center;
`;

const SUrl = styled(SCenter as any)`
  font-size: ${fonts.size.small};
  opacity: 0.8;
`;

const SName = styled(SCenter as any)`
  font-weight: bold;
`;

interface PeerProps {
  oneLiner?: boolean;
  metadata: SignClientTypes.Metadata;
}

const Peer = (props: PeerProps) =>
  props.oneLiner ? (
    <SPeerOneLiner>
      <img src={props.metadata.icons[0]} alt={props.metadata.name} />
      <div>{props.metadata.name}</div>
    </SPeerOneLiner>
  ) : (
    <SPeerCard>
      <SIcon src={props.metadata.icons[0]} alt={props.metadata.name} />
      <SName>{props.metadata.name}</SName>
      <SCenter>{props.metadata.description}</SCenter>
      <SUrl>{props.metadata.url}</SUrl>
    </SPeerCard>
  );

export default Peer;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/RelayRegionDropdown.tsx">
import * as React from "react";
import { REGIONALIZED_RELAYER_ENDPOINTS } from "../constants/default";
import styled from "styled-components";
import Icon from "./Icon";
import { useState } from "react";

interface RelayRegionDropdownProps {
  relayerRegion: string;
  setRelayerRegion?: (relayer: string) => void;
  show: boolean;
}

const SelectContainer = styled.select`
  width: 150px;
  background: transparent;
  color: black;
  height: 30px;
  border-radius: 4px;
  padding: 2px;
  font-size: "1.25em";
  bottom: 40px;
  left: 50px;
  direction: ltr;
  unicode-bidi: embed;
  margin: 5px;
`;

const SelectOption = styled.option`
  font-size: "1.25em";
`;

const RelayRegionDropdown = (props: RelayRegionDropdownProps) => {
  const { relayerRegion, setRelayerRegion, show } = props;
  return (
    <div>
      {show && (
        <SelectContainer
          value={relayerRegion}
          onChange={(e) => setRelayerRegion?.(e?.target?.value)}
        >
          <option disabled>Relayer Region:</option>
          {REGIONALIZED_RELAYER_ENDPOINTS.map((e, i) => {
            return (
              <SelectOption key={i} value={e.value}>
                {e.label}
              </SelectOption>
            );
          })}
        </SelectContainer>
      )}
    </div>
  );
};

export default RelayRegionDropdown;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Toggle.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

import { colors, transitions } from "../styles";

interface IToggleStyleProps {
  color: string;
  active: boolean;
}

const SToggle = styled.div<IToggleStyleProps>`
  position: relative;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  transition: ${transitions.base};
  & div {
    transition: ${transitions.base};
    appearance: none;
    transition: all 0.3s ease;
    box-shadow: ${({ active, color }) =>
      active
        ? `inset 0px 0px 0px 20px rgb(${colors[color]})`
        : `inset 0px 0px 0px 1px rgb(${colors.grey})`};
    border-radius: 1rem;
    background-color: rgb(${colors.white});
    padding: 1px;
    display: inline-block;
    width: 46px;
    height: 26px;
    position: relative;
    cursor: pointer;
    margin: 0px;
    vertical-align: bottom;
    outline: none;
    border: none;
  }
  & div:after {
    transition: ${transitions.base};
    box-shadow: inset 0 1px 0 rgb(${colors.grey}),
      0px 2px 2px 1px rgba(${colors.black}, 0.2);
    border-radius: 1rem;
    left: ${({ active }) => (active ? `20px` : `0`)};
    content: "";
    position: absolute;
    width: 24px;
    height: 24px;
    cursor: pointer;
    background-color: rgb(${colors.white});
  }
`;

interface IToggleProps extends IToggleStyleProps {
  onClick?: any;
}

const Toggle = (props: IToggleProps) => (
  <SToggle color={props.color} active={props.active} onClick={props.onClick}>
    <div />
  </SToggle>
);

Toggle.propTypes = {
  active: PropTypes.bool,
  color: PropTypes.string,
  onClick: PropTypes.func,
};

Toggle.defaultProps = {
  active: false,
  color: "green",
};

export default Toggle;
</file>

<file path="advanced/dapps/react-dapp-v2/src/components/Wrapper.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled, { keyframes } from "styled-components";

const fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

interface WrapperStyleProps {
  center: boolean;
}

const SWrapper = styled.div<WrapperStyleProps>`
  will-change: transform, opacity;
  animation: ${fadeIn} 0.7s ease 0s normal 1;
  min-height: 200px;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: ${({ center }) => (center ? `center` : `flex-start`)};
`;

interface WrapperProps extends WrapperStyleProps {
  children: React.ReactNode;
}

const Wrapper = (props: WrapperProps) => {
  const { children, center } = props;
  return (
    <SWrapper {...props} center={center}>
      {children}
    </SWrapper>
  );
};

Wrapper.propTypes = {
  children: PropTypes.node.isRequired,
  center: PropTypes.bool,
};

Wrapper.defaultProps = {
  center: false,
};

export default Wrapper;
</file>

<file path="advanced/dapps/react-dapp-v2/src/constants/default.ts">
import { getAppMetadata } from "@walletconnect/utils";

if (!process.env.NEXT_PUBLIC_PROJECT_ID)
  throw new Error("`NEXT_PUBLIC_PROJECT_ID` env variable is missing.");

export const DEFAULT_MAIN_CHAINS = [
  // mainnets
  "eip155:1",
  "eip155:10",
  "eip155:100",
  "eip155:137",
  "eip155:324",
  "eip155:42161",
  "eip155:42220",
  "cosmos:cosmoshub-4",
  "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  "polkadot:91b171bb158e2d3848fa23a9f1c25182",
  "mvx:1",
  "tron:0x2b6653dc",
  "tezos:mainnet",
  "kadena:mainnet01",
  "bip122:000000000019d6689c085ae165831e93",
];

export const DEFAULT_TEST_CHAINS = [
  // testnets
  "eip155:5",
  "eip155:11155111",
  "eip155:280",
  "eip155:420",
  "eip155:80001",
  "eip155:421611",
  "eip155:44787",
  "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  "polkadot:e143f23803ac50e8f6f8e62695d1ce9e",
  "near:testnet",
  "mvx:D",
  "tron:0xcd8690dc",
  "tezos:testnet",
  "kadena:testnet04",
  "bip122:000000000933ea01ad0ee984209779ba",
];

export const DEFAULT_CHAINS = [...DEFAULT_MAIN_CHAINS, ...DEFAULT_TEST_CHAINS];

export const DEFAULT_PROJECT_ID = process.env.NEXT_PUBLIC_PROJECT_ID;
export const DEFAULT_RELAY_URL = process.env.NEXT_PUBLIC_RELAY_URL;

export const DEFAULT_LOGGER = "debug";

export const DEFAULT_APP_METADATA = {
  name: "React App",
  description: "React App for WalletConnect",
  url: "https://walletconnect.com/",
  icons: ["https://avatars.githubusercontent.com/u/37784886"],
  verifyUrl: "https://verify.walletconnect.com",
};

/**
 * EIP5792
 */
export const DEFAULT_EIP5792_METHODS = {
  WALLET_GET_CAPABILITIES: "wallet_getCapabilities",
  WALLET_SEND_CALLS: "wallet_sendCalls",
  WALLET_GET_CALLS_STATUS: "wallet_getCallsStatus",
} as const;

export type SendCallsParams = {
  version: string;
  chainId: `0x${string}`; // Hex chain id
  from: `0x${string}`;
  calls: {
    to?: `0x${string}` | undefined;
    data?: `0x${string}` | undefined;
    value?: `0x${string}` | undefined; // Hex value
  }[];
  capabilities?: Record<string, any> | undefined;
};

// capability names as string literals
export type CapabilityName = "atomicBatch" | "paymasterService" | "sessionKey";
// Capability type where each key is a capability name and value has `supported` field
export type Capabilities = {
  [K in CapabilityName]: {
    supported: boolean;
  };
};
// GetCapabilitiesResult type using mapped types
export type GetCapabilitiesResult = Record<string, Capabilities>;

export type GetCallsResult = {
  status: "PENDING" | "CONFIRMED";
  receipts?: {
    logs: {
      address: `0x${string}`;
      data: `0x${string}`;
      topics: `0x${string}`[];
    }[];
    status: `0x${string}`; // Hex 1 or 0 for success or failure, respectively
    blockHash: `0x${string}`;
    blockNumber: `0x${string}`;
    gasUsed: `0x${string}`;
    transactionHash: `0x${string}`;
  }[];
};
/**
 * EIP7715
 */
export const DEFAULT_EIP7715_METHODS = {
  WALLET_GRANT_PERMISSIONS: "wallet_grantPermissions",
} as const;
export type WalletGrantPermissionsParameters = {
  signer?:
    | {
        type: string;
        data?: unknown | undefined;
      }
    | undefined;
  permissions: readonly {
    data: unknown;
    policies: readonly {
      data: unknown;
      type: string;
    }[];
    required?: boolean | undefined;
    type: string;
  }[];
  expiry: number;
};

export type WalletGrantPermissionsReturnType = {
  expiry: number;
  factory?: `0x${string}` | undefined;
  factoryData?: string | undefined;
  grantedPermissions: readonly {
    data: unknown;
    policies: readonly {
      data: unknown;
      type: string;
    }[];
    required?: boolean | undefined;
    type: string;
  }[];
  permissionsContext: string;
  signerData?:
    | {
        userOpBuilder?: `0x${string}` | undefined;
        submitToAddress?: `0x${string}` | undefined;
      }
    | undefined;
};
/**
 * EIP155
 */
export const DEFAULT_EIP155_METHODS = {
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  PERSONAL_SIGN: "personal_sign",
};

export const DEFAULT_EIP155_OPTIONAL_METHODS = {
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
} as const;

export const DEFAULT_OPTIONAL_METHODS = {
  ...DEFAULT_EIP155_OPTIONAL_METHODS,
  ...DEFAULT_EIP5792_METHODS,
  ...DEFAULT_EIP7715_METHODS,
};

export enum DEFAULT_EIP_155_EVENTS {
  ETH_CHAIN_CHANGED = "chainChanged",
  ETH_ACCOUNTS_CHANGED = "accountsChanged",
}

/**
 * COSMOS
 */
export enum DEFAULT_COSMOS_METHODS {
  COSMOS_SIGN_DIRECT = "cosmos_signDirect",
  COSMOS_SIGN_AMINO = "cosmos_signAmino",
}

export enum DEFAULT_COSMOS_EVENTS {}

/**
 * SOLANA
 */
export enum DEFAULT_SOLANA_METHODS {
  SOL_SIGN_TRANSACTION = "solana_signTransaction",
  SOL_SIGN_MESSAGE = "solana_signMessage",
  SOL_SIGN_AND_SEND_TRANSACTION = "solana_signAndSendTransaction",
  SOL_SIGN_ALL_TRANSACTIONS = "solana_signAllTransactions",
}

export enum DEFAULT_SOLANA_EVENTS {}

/**
 * POLKADOT
 */
export enum DEFAULT_POLKADOT_METHODS {
  POLKADOT_SIGN_TRANSACTION = "polkadot_signTransaction",
  POLKADOT_SIGN_MESSAGE = "polkadot_signMessage",
}

export enum DEFAULT_POLKADOT_EVENTS {}

/**
 * NEAR
 */
export enum DEFAULT_NEAR_METHODS {
  NEAR_SIGN_IN = "near_signIn",
  NEAR_SIGN_OUT = "near_signOut",
  NEAR_GET_ACCOUNTS = "near_getAccounts",
  NEAR_SIGN_AND_SEND_TRANSACTION = "near_signAndSendTransaction",
  NEAR_SIGN_AND_SEND_TRANSACTIONS = "near_signAndSendTransactions",
}

export enum DEFAULT_NEAR_EVENTS {}

/**
 * MULTIVERSX
 */
export enum DEFAULT_MULTIVERSX_METHODS {
  MULTIVERSX_SIGN_TRANSACTION = "mvx_signTransaction",
  MULTIVERSX_SIGN_TRANSACTIONS = "mvx_signTransactions",
  MULTIVERSX_SIGN_MESSAGE = "mvx_signMessage",
  MULTIVERSX_SIGN_LOGIN_TOKEN = "mvx_signLoginToken",
  MULTIVERSX_SIGN_NATIVE_AUTH_TOKEN = "mvx_signNativeAuthToken",
  MULTIVERSX_CANCEL_ACTION = "mvx_cancelAction",
}

export enum DEFAULT_MULTIVERSX_EVENTS {}

/**
 * TRON
 */
export enum DEFAULT_TRON_METHODS {
  TRON_SIGN_TRANSACTION = "tron_signTransaction",
  TRON_SIGN_MESSAGE = "tron_signMessage",
}

export enum DEFAULT_TRON_EVENTS {}

/**
 * TEZOS
 */
export enum DEFAULT_TEZOS_METHODS {
  TEZOS_GET_ACCOUNTS = "tezos_getAccounts",
  TEZOS_SEND = "tezos_send",
  TEZOS_SIGN = "tezos_sign",
}

export enum DEFAULT_TEZOS_EVENTS {}

export const DEFAULT_GITHUB_REPO_URL =
  "https://github.com/WalletConnect/web-examples/tree/main/dapps/react-dapp-v2";

type RelayerType = {
  value: string | undefined;
  label: string;
};

/**
 * KADENA
 */
export enum DEFAULT_KADENA_METHODS {
  KADENA_GET_ACCOUNTS = "kadena_getAccounts_v1",
  KADENA_SIGN = "kadena_sign_v1",
  KADENA_QUICKSIGN = "kadena_quicksign_v1",
}

export enum DEFAULT_KADENA_EVENTS {}
/**
 * BITCOIN
 */
export enum DEFAULT_BIP122_METHODS {
  BIP122_SEND_TRANSACTION = "sendTransfer",
  BIP122_GET_ACCOUNT_ADDRESSES = "getAccountAddresses",
  BIP122_SIGN_MESSAGE = "signMessage",
  BIP122_SIGN_PSBT = "signPsbt",
}
export enum DEFAULT_BIP122_EVENTS {
  BIP122_ADDRESS_CHANGED = "bip122_addressesChanged",
}

export const REGIONALIZED_RELAYER_ENDPOINTS: RelayerType[] = [
  {
    value: DEFAULT_RELAY_URL,
    label: "Default",
  },

  {
    value: "wss://us-east-1.relay.walletconnect.com",
    label: "US",
  },
  {
    value: "wss://eu-central-1.relay.walletconnect.com",
    label: "EU",
  },
  {
    value: "wss://ap-southeast-1.relay.walletconnect.com",
    label: "Asia Pacific",
  },
];

export const ORIGIN_OPTIONS = [
  {
    value: getAppMetadata().url,
    label: "VALID",
  },
  {
    value: "https://invalid.origin",
    label: "INVALID",
  },
  {
    value: "unknown",
    label: "UNKNOWN",
  },
];
</file>

<file path="advanced/dapps/react-dapp-v2/src/constants/index.ts">
export * from "./default";
</file>

<file path="advanced/dapps/react-dapp-v2/src/contexts/ChainDataContext.tsx">
import {
  createContext,
  ReactNode,
  useContext,
  useEffect,
  useState,
} from "react";
import { SolanaChainData } from "../chains/solana";
import { PolkadotChainData } from "../chains/polkadot";
import { MultiversxChainData } from "../chains/multiversx";
import { TronChainData } from "../chains/tron";

import { ChainNamespaces, ChainsMap, getAllChainNamespaces } from "../helpers";
import { NearChainData } from "../chains/near";
import { CosmosChainData } from "../chains/cosmos";
import { EIP155ChainData } from "../chains/eip155";
import { TezosChainData } from "../chains/tezos";
import { KadenaChainData } from "../chains/kadena";
import { BtcChainData } from "../chains/bip122";

/**
 * Types
 */
interface IContext {
  chainData: ChainNamespaces;
}

/**
 * Context
 */
export const ChainDataContext = createContext<IContext>({} as IContext);

/**
 * Provider
 */
export function ChainDataContextProvider({
  children,
}: {
  children: ReactNode | ReactNode[];
}) {
  const [chainData, setChainData] = useState<ChainNamespaces>({});

  const loadChainData = async () => {
    const namespaces = getAllChainNamespaces();
    const chainData: ChainNamespaces = {};
    await Promise.all(
      namespaces.map(async (namespace) => {
        let chains: ChainsMap | undefined;
        switch (namespace) {
          case "solana":
            chains = SolanaChainData;
            break;
          case "polkadot":
            chains = PolkadotChainData;
            break;
          case "near":
            chains = NearChainData;
            break;
          case "mvx":
            chains = MultiversxChainData;
            break;
          case "tron":
            chains = TronChainData;
            break;
          case "cosmos":
            chains = CosmosChainData;
            break;
          case "eip155":
            chains = EIP155ChainData;
            break;
          case "tezos":
            chains = TezosChainData;
            break;
          case "kadena":
            chains = KadenaChainData;
            break;
          case "bip122":
            chains = BtcChainData;
            break;
          default:
            console.error("Unknown chain namespace: ", namespace);
        }

        if (typeof chains !== "undefined") {
          chainData[namespace] = chains;
        }
      })
    );

    setChainData(chainData);
  };

  useEffect(() => {
    loadChainData();
  }, []);

  return (
    <ChainDataContext.Provider
      value={{
        chainData,
      }}
    >
      {children}
    </ChainDataContext.Provider>
  );
}

export function useChainData() {
  const context = useContext(ChainDataContext);
  if (context === undefined) {
    throw new Error(
      "useChainData must be used within a ChainDataContextProvider"
    );
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/contexts/ClientContext.tsx">
import Client from "@walletconnect/sign-client";
import { PairingTypes, SessionTypes } from "@walletconnect/types";
import { Web3Modal } from "@web3modal/standalone";
import { RELAYER_EVENTS } from "@walletconnect/core";
import toast from "react-hot-toast";

import { PublicKey } from "@solana/web3.js";
import {
  createContext,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { getAppMetadata, getSdkError } from "@walletconnect/utils";
import {
  DEFAULT_APP_METADATA,
  DEFAULT_LOGGER,
  DEFAULT_PROJECT_ID,
  DEFAULT_RELAY_URL,
} from "../constants";
import { AccountBalances, apiGetAccountBalance } from "../helpers";
import {
  getOptionalNamespaces,
  getRequiredNamespaces,
} from "../helpers/namespaces";
import { getPublicKeysFromAccounts } from "../helpers/solana";

/**
 * Types
 */
interface IContext {
  client: Client | undefined;
  session: SessionTypes.Struct | undefined;
  connect: (pairing?: { topic: string }) => Promise<void>;
  disconnect: () => Promise<void>;
  isInitializing: boolean;
  chains: string[];
  relayerRegion: string;
  pairings: PairingTypes.Struct[];
  accounts: string[];
  solanaPublicKeys?: Record<string, PublicKey>;
  balances: AccountBalances;
  isFetchingBalances: boolean;
  setChains: any;
  setRelayerRegion: any;
  origin: string;
  setAccounts: any;
}

/**
 * Context
 */
export const ClientContext = createContext<IContext>({} as IContext);

/**
 * Web3Modal Config
 */
const web3Modal = new Web3Modal({
  projectId: DEFAULT_PROJECT_ID,
  themeMode: "light",
  walletConnectVersion: 2,
  mobileWallets: [
    {
      id: "bifrost",
      name: "Bifrost Wallet",
      links: {
        native: "bifrostwallet://",
        universal: "https://bifrostwallet.com",
      },
    },
  ],
});

/**
 * Provider
 */
export function ClientContextProvider({
  children,
}: {
  children: ReactNode | ReactNode[];
}) {
  const [client, setClient] = useState<Client>();
  const [pairings, setPairings] = useState<PairingTypes.Struct[]>([]);
  const [session, setSession] = useState<SessionTypes.Struct>();

  const [isFetchingBalances, setIsFetchingBalances] = useState(false);
  const [isInitializing, setIsInitializing] = useState(false);
  const prevRelayerValue = useRef<string>("");

  const [balances, setBalances] = useState<AccountBalances>({});
  const [accounts, setAccounts] = useState<string[]>([]);
  const [solanaPublicKeys, setSolanaPublicKeys] =
    useState<Record<string, PublicKey>>();
  const [chains, setChains] = useState<string[]>([]);
  const [relayerRegion, setRelayerRegion] = useState<string>(
    DEFAULT_RELAY_URL!
  );
  const [origin, setOrigin] = useState<string>(getAppMetadata().url);
  const reset = () => {
    setSession(undefined);
    setBalances({});
    setAccounts([]);
    setChains([]);
    setRelayerRegion(DEFAULT_RELAY_URL!);
  };

  const getAccountBalances = async (_accounts: string[]) => {
    setIsFetchingBalances(true);
    try {
      const arr = await Promise.all(
        _accounts.map(async (account) => {
          const [namespace, reference, address] = account.split(":");
          const chainId = `${namespace}:${reference}`;
          const assets = await apiGetAccountBalance(address, chainId);
          return { account, assets: [assets] };
        })
      );

      const balances: AccountBalances = {};
      arr.forEach(({ account, assets }) => {
        balances[account] = assets;
      });
      setBalances(balances);
    } catch (e) {
      console.error(e);
    } finally {
      setIsFetchingBalances(false);
    }
  };

  useMemo(() => {
    if (!accounts.length) return;
    getAccountBalances(accounts);
  }, [accounts]);

  const onSessionConnected = useCallback(
    async (_session: SessionTypes.Struct) => {
      const allNamespaceAccounts = Object.values(_session.namespaces)
        .map((namespace) => namespace.accounts)
        .flat();
      const allNamespaceChains = Object.keys(_session.namespaces);

      setSession(_session);
      setChains(allNamespaceChains);
      setAccounts(allNamespaceAccounts);
      setSolanaPublicKeys(getPublicKeysFromAccounts(allNamespaceAccounts));

      await getAccountBalances(allNamespaceAccounts);
    },
    []
  );

  const connect = useCallback(
    async (pairing: any) => {
      if (typeof client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }
      console.log("connect, pairing topic is:", pairing?.topic);
      try {
        const namespacesToRequest = getRequiredNamespaces(chains);
        const { uri, approval } = await client.connect({
          pairingTopic: pairing?.topic,
          requiredNamespaces: {},
          optionalNamespaces: namespacesToRequest,
        });

        // Open QRCode modal if a URI was returned (i.e. we're not connecting an existing pairing).
        if (uri) {
          // Create a flat array of all requested chains across namespaces.
          const standaloneChains = Object.values(namespacesToRequest)
            .map((namespace) => namespace.chains)
            .flat() as string[];

          web3Modal.openModal({ uri, standaloneChains });
        }

        const session = await approval();
        console.log("Established session:", session);
        await onSessionConnected(session);
        // Update known pairings after session is connected.
        setPairings(client.pairing.getAll({ active: true }));
      } catch (e) {
        console.error(e);
        toast.error((e as Error).message, {
          position: "bottom-left",
        });
        throw e;
      } finally {
        // close modal in case it was open
        web3Modal.closeModal();
      }
    },
    [chains, client, onSessionConnected]
  );

  const disconnect = useCallback(async () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    if (typeof session === "undefined") {
      throw new Error("Session is not connected");
    }

    await client.disconnect({
      topic: session.topic,
      reason: getSdkError("USER_DISCONNECTED"),
    });

    // Reset app state after disconnect.
    reset();
  }, [client, session]);

  const _subscribeToEvents = useCallback(
    async (_client: Client) => {
      if (typeof _client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }

      _client.on("session_ping", (args) => {
        console.log("EVENT", "session_ping", args);
      });

      _client.on("session_event", (args) => {
        console.log("EVENT", "session_event", args);
      });

      _client.on("session_update", ({ topic, params }) => {
        console.log("EVENT", "session_update", { topic, params });
        const { namespaces } = params;
        const _session = _client.session.get(topic);
        const updatedSession = { ..._session, namespaces };
        onSessionConnected(updatedSession);
      });

      _client.on("session_delete", () => {
        console.log("EVENT", "session_delete");
        reset();
      });
    },
    [onSessionConnected]
  );

  const _checkPersistedState = useCallback(
    async (_client: Client) => {
      if (typeof _client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }
      // populates existing pairings to state
      setPairings(_client.pairing.getAll({ active: true }));
      console.log(
        "RESTORED PAIRINGS: ",
        _client.pairing.getAll({ active: true })
      );

      if (typeof session !== "undefined") return;
      // populates (the last) existing session to state
      if (_client.session.length) {
        const lastKeyIndex = _client.session.keys.length - 1;
        const _session = _client.session.get(
          _client.session.keys[lastKeyIndex]
        );
        console.log("RESTORED SESSION:", _session);
        await onSessionConnected(_session);
        return _session;
      }
    },
    [session, onSessionConnected]
  );

  const _logClientId = useCallback(async (_client: Client) => {
    if (typeof _client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    try {
      const clientId = await _client.core.crypto.getClientId();
      console.log("WalletConnect ClientID: ", clientId);
      localStorage.setItem("WALLETCONNECT_CLIENT_ID", clientId);
    } catch (error) {
      console.error(
        "Failed to set WalletConnect clientId in localStorage: ",
        error
      );
    }
  }, []);

  const createClient = useCallback(async () => {
    try {
      setIsInitializing(true);
      const claimedOrigin =
        localStorage.getItem("wallet_connect_dapp_origin") || origin;
      const _client = await Client.init({
        logger: DEFAULT_LOGGER,
        relayUrl: relayerRegion,
        projectId: DEFAULT_PROJECT_ID,
        metadata: {
          name: "React App",
          description: "App to test WalletConnect network",
          url: claimedOrigin,
          icons: [],
        },
      });
      if (claimedOrigin === "unknown") {
        //@ts-expect-error - private property
        _client.core.verify.verifyUrlV3 = "0xdeafbeef";
        console.log("verify", _client.core.verify);
      }
      setClient(_client);
      setOrigin(_client.metadata.url);
      console.log("metadata url:", _client.metadata);

      prevRelayerValue.current = relayerRegion;
      await _subscribeToEvents(_client);
      await _checkPersistedState(_client);
      await _logClientId(_client);
    } catch (err) {
      throw err;
    } finally {
      setIsInitializing(false);
    }
  }, [
    _checkPersistedState,
    _subscribeToEvents,
    _logClientId,
    relayerRegion,
    origin,
  ]);

  useEffect(() => {
    const claimedOrigin =
      localStorage.getItem("wallet_connect_dapp_origin") || origin;
    console.log("claimedOrigin:", claimedOrigin);
    let interval: NodeJS.Timer;
    // simulates `UNKNOWN` validation by removing the verify iframe thus preventing POST message
    if (claimedOrigin === "unknown") {
      //The interval is needed as Verify tries to init new iframe(with different urls) multiple times
      interval = setInterval(
        () => document.getElementById("verify-api")?.remove(),
        500
      );
    }
    return () => {
      clearInterval(interval);
    };
  }, [origin]);

  useEffect(() => {
    if (!client) {
      createClient();
    } else if (
      prevRelayerValue.current &&
      prevRelayerValue.current !== relayerRegion
    ) {
      client.core.relayer.restartTransport(relayerRegion);
      prevRelayerValue.current = relayerRegion;
    }
  }, [createClient, relayerRegion, client]);

  useEffect(() => {
    if (!client) return;
    client.core.relayer.on(RELAYER_EVENTS.connect, () => {
      toast.success("Network connection is restored!", {
        position: "bottom-left",
      });
    });

    client.core.relayer.on(RELAYER_EVENTS.disconnect, () => {
      toast.error("Network connection lost.", {
        position: "bottom-left",
      });
    });
  }, [client]);

  const value = useMemo(
    () => ({
      pairings,
      isInitializing,
      balances,
      isFetchingBalances,
      accounts,
      solanaPublicKeys,
      chains,
      relayerRegion,
      client,
      session,
      connect,
      disconnect,
      setChains,
      setRelayerRegion,
      origin,
      setAccounts,
    }),
    [
      pairings,
      isInitializing,
      balances,
      isFetchingBalances,
      accounts,
      solanaPublicKeys,
      chains,
      relayerRegion,
      client,
      session,
      connect,
      disconnect,
      setChains,
      setRelayerRegion,
      origin,
      setAccounts,
    ]
  );

  return (
    <ClientContext.Provider
      value={{
        ...value,
      }}
    >
      {children}
    </ClientContext.Provider>
  );
}

export function useWalletConnectClient() {
  const context = useContext(ClientContext);
  if (context === undefined) {
    throw new Error(
      "useWalletConnectClient must be used within a ClientContextProvider"
    );
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/contexts/JsonRpcContext.tsx">
import { BigNumber, utils } from "ethers";
import { createContext, ReactNode, useContext, useState } from "react";
import * as encoding from "@walletconnect/encoding";
import { Transaction as EthTransaction } from "@ethereumjs/tx";
import { recoverTransaction } from "@celo/wallet-base";
import * as bitcoin from "bitcoinjs-lib";

import {
  formatDirectSignDoc,
  stringifySignDocValues,
  verifyAminoSignature,
  verifyDirectSignature,
} from "cosmos-wallet";
import bs58 from "bs58";
import { verifyMessageSignature } from "solana-wallet";
import {
  Connection,
  Keypair,
  SystemProgram,
  Transaction as SolanaTransaction,
  clusterApiUrl,
} from "@solana/web3.js";
// @ts-expect-error
import TronWeb from "tronweb";
import {
  IPactCommand,
  PactCommand,
  createWalletConnectQuicksign,
  createWalletConnectSign,
} from "@kadena/client";
import { PactNumber } from "@kadena/pactjs";
import {
  IUTXO,
  KadenaAccount,
  eip712,
  formatTestBatchCall,
  formatTestTransaction,
  getLocalStorageTestnetFlag,
  getProviderUrl,
  hashPersonalMessage,
  hashTypedDataMessage,
  verifySignature,
} from "../helpers";
import { useWalletConnectClient } from "./ClientContext";
import {
  DEFAULT_COSMOS_METHODS,
  DEFAULT_EIP155_METHODS,
  DEFAULT_SOLANA_METHODS,
  DEFAULT_POLKADOT_METHODS,
  DEFAULT_NEAR_METHODS,
  DEFAULT_MULTIVERSX_METHODS,
  DEFAULT_TRON_METHODS,
  DEFAULT_TEZOS_METHODS,
  DEFAULT_KADENA_METHODS,
  DEFAULT_EIP155_OPTIONAL_METHODS,
  DEFAULT_EIP5792_METHODS,
  SendCallsParams,
  GetCapabilitiesResult,
  GetCallsResult,
  DEFAULT_BIP122_METHODS,
  DEFAULT_EIP7715_METHODS,
  WalletGrantPermissionsParameters,
  WalletGrantPermissionsReturnType,
} from "../constants";
import { useChainData } from "./ChainDataContext";
import { rpcProvidersByChainId } from "../../src/helpers/api";
import { signatureVerify, cryptoWaitReady } from "@polkadot/util-crypto";

import {
  Transaction as MultiversxTransaction,
  TransactionPayload,
  Address,
  SignableMessage,
} from "@multiversx/sdk-core";
import { UserVerifier } from "@multiversx/sdk-wallet/out/userVerifier";
import { parseEther } from "ethers/lib/utils";
import {
  apiGetAddressUtxos,
  calculateChange,
  getAvailableBalanceFromUtxos,
  isBip122Testnet,
  isOrdinalAddress,
  isValidBip122Signature,
} from "../helpers/bip122";
import { getAddressFromAccount } from "@walletconnect/utils";
import { BIP122_DUST_LIMIT } from "../chains/bip122";

/**
 * Types
 */
interface IFormattedRpcResponse {
  method?: string;
  address?: string;
  valid: boolean;
  result: string;
}

type TRpcRequestCallback = (
  chainId: string,
  address: string,
  message?: string
) => Promise<void>;

interface IContext {
  ping: () => Promise<void>;
  ethereumRpc: {
    testSendTransaction: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
    testEthSign: TRpcRequestCallback;
    testSignPersonalMessage: TRpcRequestCallback;
    testSignTypedData: TRpcRequestCallback;
    testSignTypedDatav4: TRpcRequestCallback;
    testWalletGetCapabilities: TRpcRequestCallback;
    testWalletSendCalls: TRpcRequestCallback;
    testWalletGrantPermissions: TRpcRequestCallback;
    testWalletGetCallsStatus: TRpcRequestCallback;
  };
  cosmosRpc: {
    testSignDirect: TRpcRequestCallback;
    testSignAmino: TRpcRequestCallback;
  };
  solanaRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  polkadotRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  nearRpc: {
    testSignAndSendTransaction: TRpcRequestCallback;
    testSignAndSendTransactions: TRpcRequestCallback;
  };
  multiversxRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
    testSignTransactions: TRpcRequestCallback;
  };
  tronRpc: {
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  tezosRpc: {
    testGetAccounts: TRpcRequestCallback;
    testSignMessage: TRpcRequestCallback;
    testSignTransaction: TRpcRequestCallback;
  };
  kadenaRpc: {
    testGetAccounts: TRpcRequestCallback;
    testSign: TRpcRequestCallback;
    testQuicksign: TRpcRequestCallback;
  };
  bip122Rpc: {
    testGetAccountAddresses: TRpcRequestCallback;
    testSignMessage: TRpcRequestCallback;
    testSendTransaction: TRpcRequestCallback;
    testSignPsbt: TRpcRequestCallback;
  };
  rpcResult?: IFormattedRpcResponse | null;
  isRpcRequestPending: boolean;
  isTestnet: boolean;
  setIsTestnet: (isTestnet: boolean) => void;
}

/**
 * Context
 */
export const JsonRpcContext = createContext<IContext>({} as IContext);

/**
 * Provider
 */
export function JsonRpcContextProvider({
  children,
}: {
  children: ReactNode | ReactNode[];
}) {
  const [pending, setPending] = useState(false);
  const [result, setResult] = useState<IFormattedRpcResponse | null>();
  const [isTestnet, setIsTestnet] = useState(getLocalStorageTestnetFlag());
  const [lastTxId, setLastTxId] = useState<`0x${string}`>();
  const [kadenaAccount, setKadenaAccount] = useState<KadenaAccount | null>(
    null
  );

  const { client, session, accounts, balances, solanaPublicKeys, setAccounts } =
    useWalletConnectClient();

  const { chainData } = useChainData();

  const _createJsonRpcRequestHandler =
    (
      rpcRequest: (
        chainId: string,
        address: string
      ) => Promise<IFormattedRpcResponse>
    ) =>
    async (chainId: string, address: string) => {
      if (typeof client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }
      if (typeof session === "undefined") {
        throw new Error("Session is not connected");
      }

      try {
        setPending(true);
        const result = await rpcRequest(chainId, address);
        setResult(result);
      } catch (err: any) {
        console.error("RPC request failed: ", err);
        setResult({
          address,
          valid: false,
          result: err?.message ?? err,
        });
      } finally {
        setPending(false);
      }
    };

  const _verifyEip155MessageSignature = (
    message: string,
    signature: string,
    address: string
  ) =>
    utils.verifyMessage(message, signature).toLowerCase() ===
    address.toLowerCase();

  const ping = async () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    if (typeof session === "undefined") {
      throw new Error("Session is not connected");
    }

    try {
      setPending(true);

      let valid = false;

      try {
        await client.ping({ topic: session.topic });
        valid = true;
      } catch (e) {
        valid = false;
      }

      // display result
      setResult({
        method: "ping",
        valid,
        result: valid ? "Ping succeeded" : "Ping failed",
      });
    } catch (e) {
      console.error(e);
      setResult(null);
    } finally {
      setPending(false);
    }
  };

  // -------- ETHEREUM/EIP155 RPC METHODS --------

  const ethereumRpc = {
    testSendTransaction: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);

        const tx = await formatTestTransaction(account);

        const balance = BigNumber.from(balances[account][0].balance || "0");
        if (balance.lt(BigNumber.from(tx.gasPrice).mul(tx.gasLimit))) {
          return {
            method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
            address,
            valid: false,
            result: "Insufficient funds for intrinsic transaction cost",
          };
        }

        const result = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
            params: [tx],
          },
        });

        // format displayed result
        return {
          method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
          address,
          valid: true,
          result,
        };
      }
    ),
    testSignTransaction: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);

        const tx = await formatTestTransaction(account);

        const signedTx = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION,
            params: [tx],
          },
        });

        const CELO_ALFAJORES_CHAIN_ID = 44787;
        const CELO_MAINNET_CHAIN_ID = 42220;

        let valid = false;
        const [, reference] = chainId.split(":");
        if (
          reference === CELO_ALFAJORES_CHAIN_ID.toString() ||
          reference === CELO_MAINNET_CHAIN_ID.toString()
        ) {
          const [, signer] = recoverTransaction(signedTx);
          valid = signer.toLowerCase() === address.toLowerCase();
        } else {
          valid = EthTransaction.fromSerializedTx(
            signedTx as any
          ).verifySignature();
        }

        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION,
          address,
          valid,
          result: signedTx,
        };
      }
    ),
    testSignPersonalMessage: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // test message
        const message = `My email is john@doe.com - ${Date.now()}`;

        // encode message (hex)
        const hexMsg = encoding.utf8ToHex(message, true);
        // personal_sign params
        const params = [hexMsg, address];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_METHODS.PERSONAL_SIGN,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashMsg = hashPersonalMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashMsg,
          rpc.baseURL
        );

        // format displayed result
        return {
          method: DEFAULT_EIP155_METHODS.PERSONAL_SIGN,
          address,
          valid,
          result: signature,
        };
      }
    ),
    testEthSign: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // test message
        const message = `My email is john@doe.com - ${Date.now()}`;
        // encode message (hex)
        const hexMsg = encoding.utf8ToHex(message, true);
        // eth_sign params
        const params = [address, hexMsg];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashMsg = hashPersonalMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashMsg,
          rpc.baseURL
        );

        // format displayed result
        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN + " (standard)",
          address,
          valid,
          result: signature,
        };
      }
    ),
    testSignTypedData: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const message = JSON.stringify(eip712.example);

        // eth_signTypedData params
        const params = [address, message];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashedTypedData = hashTypedDataMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashedTypedData,
          rpc.baseURL
        );

        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
          address,
          valid,
          result: signature,
        };
      }
    ),
    testSignTypedDatav4: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const message = JSON.stringify(eip712.example);
        console.log("eth_signTypedData_v4");

        // eth_signTypedData_v4 params
        const params = [address, message];

        // send message
        const signature = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA_V4,
            params,
          },
        });

        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        const hashedTypedData = hashTypedDataMessage(message);
        const valid = await verifySignature(
          address,
          signature,
          hashedTypedData,
          rpc.baseURL
        );

        return {
          method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
          address,
          valid,
          result: signature,
        };
      }
    ),
    testWalletGetCapabilities: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }

        // The wallet_getCapabilities "caching" should ultimately move into the provider.
        // check the session.sessionProperties first for capabilities
        const capabilitiesJson = session?.sessionProperties?.["capabilities"];
        const walletCapabilities =
          capabilitiesJson && JSON.parse(capabilitiesJson);
        let capabilities = walletCapabilities[address] as
          | GetCapabilitiesResult
          | undefined;
        // send request for wallet_getCapabilities
        if (!capabilities)
          capabilities = await client!.request<GetCapabilitiesResult>({
            topic: session!.topic,
            chainId,
            request: {
              method: DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES,
              params: [address],
            },
          });

        // format displayed result
        return {
          method: DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES,
          address,
          valid: true,
          result: JSON.stringify(capabilities),
        };
      }
    ),
    testWalletGetCallsStatus: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];

        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }
        if (lastTxId === undefined)
          throw new Error(
            `Last transaction ID is undefined, make sure previous call to sendCalls returns successfully. `
          );
        const params = [lastTxId];
        // send request for wallet_getCallsStatus
        const getCallsStatusResult = await client!.request<GetCallsResult>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS,
            params: params,
          },
        });

        // format displayed result
        return {
          method: DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS,
          address,
          valid: true,
          result: JSON.stringify(getCallsStatusResult),
        };
      }
    ),
    testWalletSendCalls: _createJsonRpcRequestHandler(
      //Sample test call - batch multiple native send tx

      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);

        const balance = BigNumber.from(balances[account][0].balance || "0");
        if (balance.lt(parseEther("0.0002"))) {
          return {
            method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
            address,
            valid: false,
            result:
              "Insufficient funds for batch call [minimum 0.0002ETH required excluding gas].",
          };
        }
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];
        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }
        const sendCallsRequestParams: SendCallsParams =
          await formatTestBatchCall(account);
        // send batch Tx
        const txId = await client!.request<string>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
            params: [sendCallsRequestParams],
          },
        });
        // store the last transactionId to use it for wallet_getCallsReceipt
        setLastTxId(
          txId && txId.startsWith("0x") ? (txId as `0x${string}`) : undefined
        );
        // format displayed result
        return {
          method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
          address,
          valid: true,
          result: txId,
        };
      }
    ),
    testWalletGrantPermissions: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        const caipAccountAddress = `${chainId}:${address}`;
        const account = accounts.find(
          (account) => account === caipAccountAddress
        );
        if (account === undefined)
          throw new Error(`Account for ${caipAccountAddress} not found`);
        //  split chainId
        const [namespace, reference] = chainId.split(":");
        const rpc = rpcProvidersByChainId[Number(reference)];
        if (typeof rpc === "undefined") {
          throw new Error(
            `Missing rpcProvider definition for chainId: ${chainId}`
          );
        }
        const walletGrantPermissionsParameters: WalletGrantPermissionsParameters =
          {
            signer: {
              type: "key",
              data: {
                id: "0xc3cE257B5e2A2ad92747dd486B38d7b4B36Ac7C9",
              },
            },
            permissions: [
              {
                type: "native-token-limit",
                data: {
                  amount: parseEther("0.5"),
                },
                policies: [],
                required: true,
              },
            ],

            expiry: 1716846083638,
          } as WalletGrantPermissionsParameters;
        // send wallet_grantPermissions rpc request
        const issuePermissionResponse =
          await client!.request<WalletGrantPermissionsReturnType>({
            topic: session!.topic,
            chainId,
            request: {
              method: DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS,
              params: [walletGrantPermissionsParameters],
            },
          });

        // format displayed result
        return {
          method: DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS,
          address,
          valid: true,
          result: JSON.stringify(issuePermissionResponse),
        };
      }
    ),
  };

  // -------- COSMOS RPC METHODS --------

  const cosmosRpc = {
    testSignDirect: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // test direct sign doc inputs
        const inputs = {
          fee: [{ amount: "2000", denom: "ucosm" }],
          pubkey: "AgSEjOuOr991QlHCORRmdE5ahVKeyBrmtgoYepCpQGOW",
          gasLimit: 200000,
          accountNumber: 1,
          sequence: 1,
          bodyBytes:
            "0a90010a1c2f636f736d6f732e62616e6b2e763162657461312e4d736753656e6412700a2d636f736d6f7331706b707472653766646b6c366766727a6c65736a6a766878686c63337234676d6d6b38727336122d636f736d6f7331717970717870713971637273737a673270767871367273307a716733797963356c7a763778751a100a0575636f736d120731323334353637",
          authInfoBytes:
            "0a500a460a1f2f636f736d6f732e63727970746f2e736563703235366b312e5075624b657912230a21034f04181eeba35391b858633a765c4a0c189697b40d216354d50890d350c7029012040a020801180112130a0d0a0575636f736d12043230303010c09a0c",
        };

        // split chainId
        const [namespace, reference] = chainId.split(":");

        // format sign doc
        const signDoc = formatDirectSignDoc(
          inputs.fee,
          inputs.pubkey,
          inputs.gasLimit,
          inputs.accountNumber,
          inputs.sequence,
          inputs.bodyBytes,
          reference
        );

        // cosmos_signDirect params
        const params = {
          signerAddress: address,
          signDoc: stringifySignDocValues(signDoc),
        };

        // send message
        const result = await client!.request<{ signature: string }>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_DIRECT,
            params,
          },
        });

        const targetChainData = chainData[namespace][reference];

        if (typeof targetChainData === "undefined") {
          throw new Error(`Missing chain data for chainId: ${chainId}`);
        }

        const valid = await verifyDirectSignature(
          address,
          result.signature,
          signDoc
        );

        // format displayed result
        return {
          method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_DIRECT,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
    testSignAmino: _createJsonRpcRequestHandler(
      async (chainId: string, address: string) => {
        // split chainId
        const [namespace, reference] = chainId.split(":");

        // test amino sign doc
        const signDoc = {
          msgs: [],
          fee: { amount: [], gas: "23" },
          chain_id: "foochain",
          memo: "hello, world",
          account_number: "7",
          sequence: "54",
        };

        // cosmos_signAmino params
        const params = { signerAddress: address, signDoc };

        // send message
        const result = await client!.request<{ signature: string }>({
          topic: session!.topic,
          chainId,
          request: {
            method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
            params,
          },
        });

        const targetChainData = chainData[namespace][reference];

        if (typeof targetChainData === "undefined") {
          throw new Error(`Missing chain data for chainId: ${chainId}`);
        }

        const valid = await verifyAminoSignature(
          address,
          result.signature,
          signDoc
        );

        // format displayed result
        return {
          method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
  };

  // -------- SOLANA RPC METHODS --------

  const solanaRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        if (!solanaPublicKeys) {
          throw new Error("Could not find Solana PublicKeys.");
        }

        const senderPublicKey = solanaPublicKeys[address];

        // rpc.walletconnect.com doesn't support solana testnet yet
        const connection = new Connection(
          isTestnet ? clusterApiUrl("testnet") : getProviderUrl(chainId)
        );

        // Using deprecated `getRecentBlockhash` over `getLatestBlockhash` here, since `mainnet-beta`
        // cluster only seems to support `connection.getRecentBlockhash` currently.
        const { blockhash } = await connection.getRecentBlockhash();

        const transaction = new SolanaTransaction({
          feePayer: senderPublicKey,
          recentBlockhash: blockhash,
        }).add(
          SystemProgram.transfer({
            fromPubkey: senderPublicKey,
            toPubkey: Keypair.generate().publicKey,
            lamports: 1,
          })
        );

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_SOLANA_METHODS.SOL_SIGN_TRANSACTION,
            params: {
              feePayer: transaction.feePayer!.toBase58(),
              recentBlockhash: transaction.recentBlockhash!,
              instructions: transaction.instructions.map((instruction) => ({
                programId: instruction.programId.toBase58(),
                keys: instruction.keys.map((key) => ({
                  ...key,
                  pubkey: key.pubkey.toBase58(),
                })),
                data: bs58.encode(instruction.data),
              })),
              partialSignatures: transaction.signatures.map((sign) => ({
                pubkey: sign.publicKey.toBase58(),
                signature: bs58.encode(sign.signature!),
              })),
              transaction: transaction
                .serialize({ verifySignatures: false })
                .toString("base64"),
            },
          },
        });

        // We only need `Buffer.from` here to satisfy the `Buffer` param type for `addSignature`.
        // The resulting `UInt8Array` is equivalent to just `bs58.decode(...)`.
        transaction.addSignature(
          senderPublicKey,
          Buffer.from(bs58.decode(result.signature))
        );

        const valid = transaction.verifySignatures();

        return {
          method: DEFAULT_SOLANA_METHODS.SOL_SIGN_TRANSACTION,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        if (!solanaPublicKeys) {
          throw new Error("Could not find Solana PublicKeys.");
        }

        const senderPublicKey = solanaPublicKeys[address];

        // Encode message to `UInt8Array` first via `TextEncoder` so we can pass it to `bs58.encode`.
        const message = bs58.encode(
          new TextEncoder().encode(
            `This is an example message to be signed - ${Date.now()}`
          )
        );

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_SOLANA_METHODS.SOL_SIGN_MESSAGE,
            params: {
              pubkey: senderPublicKey.toBase58(),
              message,
            },
          },
        });

        const valid = verifyMessageSignature(
          senderPublicKey.toBase58(),
          result.signature,
          message
        );

        return {
          method: DEFAULT_SOLANA_METHODS.SOL_SIGN_MESSAGE,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
  };

  // -------- POLKADOT RPC METHODS --------
  const polkadotRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const transactionPayload = {
          specVersion: "0x00002468",
          transactionVersion: "0x0000000e",
          address: `${address}`,
          blockHash:
            "0x554d682a74099d05e8b7852d19c93b527b5fae1e9e1969f6e1b82a2f09a14cc9",
          blockNumber: "0x00cb539c",
          era: "0xc501",
          genesisHash:
            "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e",
          method:
            "0x0001784920616d207369676e696e672074686973207472616e73616374696f6e21",
          nonce: "0x00000000",
          signedExtensions: [
            "CheckNonZeroSender",
            "CheckSpecVersion",
            "CheckTxVersion",
            "CheckGenesis",
            "CheckMortality",
            "CheckNonce",
            "CheckWeight",
            "ChargeTransactionPayment",
          ],
          tip: "0x00000000000000000000000000000000",
          version: 4,
        };

        const result = await client!.request<{
          payload: string;
          signature: string;
        }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_TRANSACTION,
            params: {
              address,
              transactionPayload,
            },
          },
        });

        return {
          method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_TRANSACTION,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const message = `This is an example message to be signed - ${Date.now()}`;

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_MESSAGE,
            params: {
              address,
              message,
            },
          },
        });

        // sr25519 signatures need to wait for WASM to load
        await cryptoWaitReady();
        const { isValid: valid } = signatureVerify(
          message,
          result.signature,
          address
        );

        return {
          method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_MESSAGE,
          address,
          valid,
          result: result.signature,
        };
      }
    ),
  };

  // -------- NEAR RPC METHODS --------

  const nearRpc = {
    testSignAndSendTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTION;
        const result = await client!.request({
          topic: session!.topic,
          chainId,
          request: {
            method,
            params: {
              transaction: {
                signerId: address,
                receiverId: "guest-book.testnet",
                actions: [
                  {
                    type: "FunctionCall",
                    params: {
                      methodName: "addMessage",
                      args: { text: "Hello from Wallet Connect!" },
                      gas: "30000000000000",
                      deposit: "0",
                    },
                  },
                ],
              },
            },
          },
        });

        return {
          method,
          address,
          valid: true,
          result: JSON.stringify((result as any).transaction),
        };
      }
    ),
    testSignAndSendTransactions: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTIONS;
        const result = await client!.request({
          topic: session!.topic,
          chainId,
          request: {
            method,
            params: {
              transactions: [
                {
                  signerId: address,
                  receiverId: "guest-book.testnet",
                  actions: [
                    {
                      type: "FunctionCall",
                      params: {
                        methodName: "addMessage",
                        args: { text: "Hello from Wallet Connect! (1/2)" },
                        gas: "30000000000000",
                        deposit: "0",
                      },
                    },
                  ],
                },
                {
                  signerId: address,
                  receiverId: "guest-book.testnet",
                  actions: [
                    {
                      type: "FunctionCall",
                      params: {
                        methodName: "addMessage",
                        args: { text: "Hello from Wallet Connect! (2/2)" },
                        gas: "30000000000000",
                        deposit: "0",
                      },
                    },
                  ],
                },
              ],
            },
          },
        });

        return {
          method,
          address,
          valid: true,
          result: JSON.stringify(
            (result as any).map((r: any) => r.transaction)
          ),
        };
      }
    ),
  };

  // -------- MULTIVERSX RPC METHODS --------

  const multiversxRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const reference = chainId.split(":")[1];

        const userAddress = new Address(address);
        const verifier = UserVerifier.fromAddress(userAddress);
        const transactionPayload = new TransactionPayload("testdata");

        const testTransaction = new MultiversxTransaction({
          nonce: 1,
          value: "10000000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
          data: transactionPayload,
        });
        const transaction = testTransaction.toPlainObject();

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTION,
            params: {
              transaction,
            },
          },
        });

        const valid = verifier.verify(
          testTransaction.serializeForSigning(),
          Buffer.from(result.signature, "hex")
        );

        return {
          method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTION,
          address,
          valid,
          result: result.signature.toString(),
        };
      }
    ),
    testSignTransactions: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const reference = chainId.split(":")[1];

        const userAddress = new Address(address);
        const verifier = UserVerifier.fromAddress(userAddress);
        const testTransactionPayload = new TransactionPayload("testdata");

        const testTransaction = new MultiversxTransaction({
          nonce: 1,
          value: "10000000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
          data: testTransactionPayload,
        });

        // no data for this Transaction
        const testTransaction2 = new MultiversxTransaction({
          nonce: 2,
          value: "20000000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
        });

        const testTransaction3Payload = new TransactionPayload("third");
        const testTransaction3 = new MultiversxTransaction({
          nonce: 3,
          value: "300000000000000000",
          receiver: Address.fromBech32(address),
          sender: userAddress,
          gasPrice: 1000000000,
          gasLimit: 50000,
          chainID: reference,
          data: testTransaction3Payload,
        });

        const transactions = [
          testTransaction,
          testTransaction2,
          testTransaction3,
        ].map((transaction) => transaction.toPlainObject());

        const result = await client!.request<{
          signatures: { signature: string }[];
        }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTIONS,
            params: {
              transactions,
            },
          },
        });

        const valid = [
          testTransaction,
          testTransaction2,
          testTransaction3,
        ].reduce((acc, current, index) => {
          return (
            acc &&
            verifier.verify(
              current.serializeForSigning(),
              Buffer.from(result.signatures[index].signature, "hex")
            )
          );
        }, true);

        const resultSignatures = result.signatures.map(
          (signature: any) => signature.signature
        );

        return {
          method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTIONS,
          address,
          valid,
          result: resultSignatures.join(", "),
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const userAddress = new Address(address);
        const verifier = UserVerifier.fromAddress(userAddress);

        const testMessage = new SignableMessage({
          address: userAddress,
          message: Buffer.from(`Sign this message - ${Date.now()}`, "ascii"),
        });

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_MESSAGE,
            params: {
              address,
              message: testMessage.message.toString(),
            },
          },
        });

        const valid = verifier.verify(
          testMessage.serializeForSigning(),
          Buffer.from(result.signature, "hex")
        );

        return {
          method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_MESSAGE,
          address,
          valid,
          result: result.signature.toString(),
        };
      }
    ),
  };

  // -------- TRON RPC METHODS --------

  const tronRpc = {
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        // Nile TestNet, if you want to use in MainNet, change the fullHost to 'https://api.trongrid.io'
        const fullHost = isTestnet
          ? "https://nile.trongrid.io/"
          : "https://api.trongrid.io/";

        const tronWeb = new TronWeb({
          fullHost,
        });

        // Take USDT as an example:
        // Nile TestNet: https://nile.tronscan.org/#/token20/TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf
        // MainNet: https://tronscan.org/#/token20/TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t

        const testContract = isTestnet
          ? "TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf"
          : "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
        const testTransaction =
          await tronWeb.transactionBuilder.triggerSmartContract(
            testContract,
            "approve(address,uint256)",
            { feeLimit: 200000000 },
            [
              { type: "address", value: address },
              { type: "uint256", value: 0 },
            ],
            address
          );

        const { result } = await client!.request<{ result: any }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TRON_METHODS.TRON_SIGN_TRANSACTION,
            params: {
              address,
              transaction: {
                ...testTransaction,
              },
            },
          },
        });

        return {
          method: DEFAULT_TRON_METHODS.TRON_SIGN_TRANSACTION,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const message = "This is a message to be signed for Tron";

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TRON_METHODS.TRON_SIGN_MESSAGE,
            params: {
              address,
              message,
            },
          },
        });

        return {
          method: DEFAULT_TRON_METHODS.TRON_SIGN_MESSAGE,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
  };

  // -------- TEZOS RPC METHODS --------

  const tezosRpc = {
    testGetAccounts: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TEZOS_METHODS.TEZOS_GET_ACCOUNTS,
            params: {},
          },
        });

        return {
          method: DEFAULT_TEZOS_METHODS.TEZOS_GET_ACCOUNTS,
          address,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
    testSignTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const result = await client!.request<{ hash: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TEZOS_METHODS.TEZOS_SEND,
            params: {
              account: address,
              operations: [
                {
                  kind: "transaction",
                  amount: "1", // 1 mutez, smallest unit
                  destination: address, // send to ourselves
                },
              ],
            },
          },
        });

        return {
          method: DEFAULT_TEZOS_METHODS.TEZOS_SEND,
          address,
          valid: true,
          result: result.hash,
        };
      }
    ),
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const payload = "05010000004254";

        const result = await client!.request<{ signature: string }>({
          chainId,
          topic: session!.topic,
          request: {
            method: DEFAULT_TEZOS_METHODS.TEZOS_SIGN,
            params: {
              account: address,
              payload,
            },
          },
        });

        return {
          method: DEFAULT_TEZOS_METHODS.TEZOS_SIGN,
          address,
          valid: true,
          result: result.signature,
        };
      }
    ),
  };

  // -------- KADENA RPC METHODS --------

  const kadenaRpc = {
    testGetAccounts: _createJsonRpcRequestHandler(
      async (
        WCNetworkId: string,
        publicKey: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_KADENA_METHODS.KADENA_GET_ACCOUNTS;

        const result = await client!.request<any>({
          topic: session!.topic,
          chainId: WCNetworkId,
          request: {
            method,
            params: {
              account: `${WCNetworkId}:${publicKey}`,
              contracts: ["coin"],
            },
          },
        });

        // In a real app you would let the user pick which account they want to use. For this example we'll just set it to the first one.
        const [firstAccount] = result.accounts;

        // The information below will later be used to create a transaction
        setKadenaAccount({
          publicKey: firstAccount.publicKey, // Kadena public key
          account: firstAccount.kadenaAccounts[0].name, // Kadena account
          chainId: firstAccount.kadenaAccounts[0].chains[0], // Kadena ChainId
        });

        return {
          method,
          address: publicKey,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
    testSign: _createJsonRpcRequestHandler(
      async (
        WCNetworkId: string,
        publicKey: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_KADENA_METHODS.KADENA_SIGN;
        const [_, networkId] = WCNetworkId.split(":");

        if (!kadenaAccount) {
          throw new Error("No Kadena account selected. Call getAccounts first");
        }

        if (!client) {
          throw new Error("No client found");
        }

        const pactCommand = new PactCommand();
        pactCommand.code = `(coin.transfer "${
          kadenaAccount.account
        }" "k:abcabcabcabc" ${new PactNumber(1).toDecimal()})`;

        pactCommand
          .setMeta(
            {
              chainId: kadenaAccount.chainId,
              gasLimit: 1000,
              gasPrice: 1.0e-6,
              ttl: 10 * 60,
              sender: kadenaAccount.account,
            },
            networkId as IPactCommand["networkId"]
          )
          .addCap("coin.GAS", kadenaAccount.publicKey)
          .addCap(
            "coin.TRANSFER",
            kadenaAccount.publicKey, // public key of sender
            kadenaAccount.account, // account of sender
            "k:abcabcabcabc", // account of receiver
            { decimal: `1` } // amount
          );

        const signWithWalletConnect = createWalletConnectSign(
          client as any,
          session as any,
          WCNetworkId as any
        );

        const result = await signWithWalletConnect(pactCommand);

        return {
          method,
          address: kadenaAccount.publicKey,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
    testQuicksign: _createJsonRpcRequestHandler(
      async (
        WCNetworkId: string,
        publicKey: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_KADENA_METHODS.KADENA_QUICKSIGN;
        const [_, networkId] = WCNetworkId.split(":");

        if (!kadenaAccount) {
          throw new Error("No Kadena account selected. Call getAccounts first");
        }

        const pactCommand = new PactCommand();
        pactCommand.code = `(coin.transfer "${
          kadenaAccount.account
        }" "k:abcabcabcabc" ${new PactNumber(1).toDecimal()})`;

        pactCommand
          .setMeta(
            {
              chainId: kadenaAccount.chainId,
              gasLimit: 1000,
              gasPrice: 1.0e-6,
              ttl: 10 * 60,
              sender: kadenaAccount.account,
            },
            networkId as IPactCommand["networkId"]
          )
          .addCap("coin.GAS", publicKey)
          .addCap(
            "coin.TRANSFER",
            publicKey, // pubKey of sender
            kadenaAccount.account, // account of sender
            "k:abcabcabcabc", // account of receiver
            { decimal: `1` } // amount
          );

        const quicksignWithWalletConnect = createWalletConnectQuicksign(
          client as any,
          session as any,
          WCNetworkId as any
        );

        const result = await quicksignWithWalletConnect(pactCommand);

        return {
          method,
          address: publicKey,
          valid: true,
          result: JSON.stringify(result, null, 2),
        };
      }
    ),
  };

  const bip122Rpc = {
    testSignMessage: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        console.log("testSignMessage", chainId, address);
        const method = DEFAULT_BIP122_METHODS.BIP122_SIGN_MESSAGE;
        const message = "This is a message to be signed for BIP122";
        const shouldAddAddress = address !== getAddressFromAccount(accounts[0]);
        const result = await client!.request<{
          signature: string;
          address: string;
        }>({
          topic: session!.topic,
          chainId: chainId,
          request: {
            method,
            params: {
              message,
              account: getAddressFromAccount(accounts[0]),
              address: shouldAddAddress ? address : undefined,
            },
          },
        });

        return {
          method,
          address: address,
          valid: await isValidBip122Signature(
            address,
            result.signature,
            message
          ),
          result: result.signature,
        };
      }
    ),
    testSendTransaction: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_BIP122_METHODS.BIP122_SEND_TRANSACTION;

        const utxos = await apiGetAddressUtxos(address, chainId);
        console.log("utxos", utxos);
        const availableBalance = getAvailableBalanceFromUtxos(utxos); // in satoshis
        console.log("availableBalance", availableBalance);
        const req = {
          account: address,
          recipientAddress: address,
          amount: BIP122_DUST_LIMIT,
        };
        console.log("request", {
          method,
          params: req,
          chainId,
        });

        const result = await client!.request<{ txid: string }>({
          topic: session!.topic,
          chainId: chainId,
          request: {
            method,
            params: req,
          },
        });
        console.log("result", result);
        return {
          method,
          address: address,
          valid: true,
          result: result?.txid,
        };
      }
    ),
    testSignPsbt: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_BIP122_METHODS.BIP122_SIGN_PSBT;

        const network = isBip122Testnet(chainId)
          ? bitcoin.networks.testnet
          : bitcoin.networks.bitcoin;

        console.log("network", isBip122Testnet(chainId), network);
        const utxos = (await apiGetAddressUtxos(address, chainId)) as IUTXO[];
        if (!utxos || utxos.length === 0) {
          throw new Error("No UTXOs found for address: " + address);
        }

        const availableBalance = getAvailableBalanceFromUtxos(utxos); // in satoshis
        const satoshisToTransfer = parseInt(BIP122_DUST_LIMIT, 10);
        if (availableBalance < satoshisToTransfer) {
          throw new Error(
            "Insufficient balance: " + availableBalance + " satoshis"
          );
        }

        const psbt = new bitcoin.Psbt({ network });

        const utxosToSpend: any[] = [];
        let utxosValue = 0;
        utxos.forEach((utxo) => {
          utxosValue += utxo.value;
          utxosToSpend.push(utxo);
          if (utxosValue >= satoshisToTransfer) {
            return;
          }
        });
        const signInputs: unknown[] = [];

        utxosToSpend.forEach((utxo, index) => {
          psbt.addInput({
            hash: utxo.txid,
            index: utxo.vout,
            witnessUtxo: {
              script: bitcoin.address.toOutputScript(address, network),
              value: utxo.value,
            },
          });
          signInputs.push({
            address,
            index,
            sighashTypes: [bitcoin.Transaction.SIGHASH_ALL],
          });
        });

        const change = calculateChange(utxosToSpend, satoshisToTransfer, 5);
        if (change > 0) {
          psbt.addOutput({
            address: address,
            value: change,
          });
        }

        psbt.addOutput({
          address: address,
          value: satoshisToTransfer,
        });

        const transaction = psbt.toBase64();

        console.log("availableBalance", availableBalance);
        const req = {
          account: address,
          psbt: transaction,
          signInputs,
          broadcast: false,
        };
        console.log("signPsbt", {
          method,
          params: req,
          chainId,
        });

        const result = await client!.request<{ psbt: string }>({
          topic: session!.topic,
          chainId: chainId,
          request: {
            method,
            params: req,
          },
        });
        console.log("result", result);
        const reconstructed = bitcoin.Psbt.fromBase64(result.psbt, { network });
        return {
          method,
          address: address,
          valid: true,
          result: reconstructed.extractTransaction().toHex(),
        };
      }
    ),
    testGetAccountAddresses: _createJsonRpcRequestHandler(
      async (
        chainId: string,
        address: string
      ): Promise<IFormattedRpcResponse> => {
        const method = DEFAULT_BIP122_METHODS.BIP122_GET_ACCOUNT_ADDRESSES;
        const isOrdinal = isOrdinalAddress(address);
        const req = {
          account: address,
          intentions: isOrdinal ? ["ordinal"] : ["payment"],
        };
        const addresses =
          session?.sessionProperties?.[
            `bip122_${DEFAULT_BIP122_METHODS.BIP122_GET_ACCOUNT_ADDRESSES}`
          ];
        let result;
        if (addresses) {
          console.log("cached addresses", addresses);
          const parsed = JSON.parse(addresses);
          result = isOrdinal ? parsed.ordinal : parsed.payment;
          console.log("parsed", result);
        } else {
          console.log("request", {
            method,
            params: req,
            chainId,
          });

          result = await client!.request<any>({
            topic: session!.topic,
            chainId: chainId,
            request: {
              method,
              params: req,
            },
          });

          console.log("result", result);
        }

        const accounts = result.map((r: any) => `${chainId}:${r.address}`);
        setAccounts((prev: string[]) => [...new Set([...prev, ...accounts])]);

        return {
          method,
          address: address,
          valid: true,
          result: result.map((r: any) => r.address).join(", "),
        };
      }
    ),
  };

  return (
    <JsonRpcContext.Provider
      value={{
        ping,
        ethereumRpc,
        cosmosRpc,
        solanaRpc,
        polkadotRpc,
        nearRpc,
        multiversxRpc,
        tronRpc,
        tezosRpc,
        kadenaRpc,
        rpcResult: result,
        isRpcRequestPending: pending,
        isTestnet,
        setIsTestnet,
        bip122Rpc,
      }}
    >
      {children}
    </JsonRpcContext.Provider>
  );
}

export function useJsonRpc() {
  const context = useContext(JsonRpcContext);
  if (context === undefined) {
    throw new Error("useJsonRpc must be used within a JsonRpcContextProvider");
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/api.ts">
import axios, { AxiosInstance } from "axios";
import { apiGetKadenaAccountBalance } from "./kadena";

import { AssetData } from "./types";
import { PactCommand } from "@kadena/client";
import { apiGetBip122AccountBalance } from "./bip122";

export type RpcProvidersByChainId = Record<
  number,
  {
    name: string;
    baseURL: string;
    token: {
      name: string;
      symbol: string;
    };
  }
>;

const WALLETCONNECT_RPC_BASE_URL = `https://rpc.walletconnect.com/v1?projectId=${process.env.NEXT_PUBLIC_PROJECT_ID}`;

export const rpcProvidersByChainId: RpcProvidersByChainId = {
  1: {
    name: "Ethereum Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:1",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  5: {
    name: "Ethereum Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:5",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  11155111: {
    name: "Ethereum Sepolia",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:11155111",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  137: {
    name: "Polygon Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:137",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  280: {
    name: "zkSync Era Testnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:280",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  324: {
    name: "zkSync Era",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:324",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  80001: {
    name: "Polygon Mumbai",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:80001",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  10: {
    name: "Optimism",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:10",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  420: {
    name: "Optimism Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:420",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  42161: {
    name: "Arbitrum",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:42161",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  421611: {
    name: "Arbitrum Rinkeby",
    baseURL: "https://rinkeby.arbitrum.io/rpc",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  100: {
    name: "xDAI",
    baseURL: "https://xdai-archive.blockscout.com",
    token: {
      name: "xDAI",
      symbol: "xDAI",
    },
  },
  42220: {
    name: "Celo",
    baseURL: "https://rpc.walletconnect.com/v1",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
  44787: {
    name: "Celo Alfajores",
    baseURL: "https://alfajores-forno.celo-testnet.org",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
};

const api: AxiosInstance = axios.create({
  baseURL: "https://rpc.walletconnect.com/v1",
  timeout: 10000, // 10 secs
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json",
  },
});

export async function apiGetAccountBalance(
  address: string,
  chainId: string
): Promise<AssetData> {
  const [namespace, networkId] = chainId.split(":");

  if (namespace === "kadena") {
    return apiGetKadenaAccountBalance(
      address,
      networkId as PactCommand["networkId"]
    );
  }

  if (namespace === "bip122") {
    return apiGetBip122AccountBalance(address, networkId as string);
  }

  if (namespace !== "eip155") {
    return { balance: "", symbol: "", name: "" };
  }

  const ethChainId = chainId.split(":")[1];
  const rpc = rpcProvidersByChainId[Number(ethChainId)];
  if (!rpc) {
    return { balance: "", symbol: "", name: "" };
  }
  const { baseURL, token } = rpc;
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_getBalance",
    params: [address, "latest"],
    id: 1,
  });
  const { result } = response.data;
  const balance = parseInt(result, 16).toString();
  return { balance, ...token };
}

export const apiGetAccountNonce = async (
  address: string,
  chainId: string
): Promise<number> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_getTransactionCount",
    params: [address, "latest"],
    id: 1,
  });
  const { result } = response.data;
  const nonce = parseInt(result, 16);
  return nonce;
};

export const apiGetGasPrice = async (chainId: string): Promise<string> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_gasPrice",
    params: [],
    id: 1,
  });
  const { result } = response.data;
  return result;
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/bip122.ts">
import { schnorr } from "@noble/curves/secp256k1";
import * as bitcoin from "bitcoinjs-lib";
import BitcoinMessage from "bitcoinjs-message";
import { convertHexToBase64 } from "./utilities";
import { IUTXO } from "./types";
import { BIP122_TESTNET } from "../chains/bip122";

export async function apiGetBip122AccountBalance(
  address: string,
  chainId: string
) {
  const utxo = await apiGetAddressUtxos(address, chainId);
  const balanceInSatoshis = getAvailableBalanceFromUtxos(utxo);
  const balanceInBtc = balanceInSatoshis * 0.00000001;
  return { balance: balanceInBtc.toString(), symbol: "BTC", name: "BTC" };
}

export async function apiGetAddressUtxos(address: string, chainId: string) {
  const isTestnet = chainId.includes(BIP122_TESTNET);
  return await (
    await fetch(
      `https://mempool.space${
        isTestnet ? "/testnet" : ""
      }/api/address/${address}/utxo`
    )
  ).json();
}

export function getAvailableBalanceFromUtxos(utxos: IUTXO[]) {
  if (!utxos || !utxos.length) {
    return 0;
  }
  return utxos.reduce((acc, { value }) => acc + value, 0);
}

export function calculateChange(
  utxos: IUTXO[],
  amount: number,
  feeRate: number
): number {
  const inputSum = utxos.reduce((sum, utxo) => sum + utxo.value, 0); // Sum of all UTXO values
  const estimatedSize = 10 + 148 * utxos.length + 34 * 2; // Rough estimate of transaction size
  const fee = estimatedSize * feeRate; // Transaction fee
  const change = inputSum - amount - fee; // Calculate change
  return change;
}

export async function isValidBip122Signature(
  address: string,
  signature: string,
  message: string
) {
  // if taproot address
  if (address.startsWith("bc1p") || address.startsWith("tb1p")) {
    // Convert the Ordinals address (Taproot) to the internal public key
    const decoded = bitcoin.address.fromBech32(address);
    if (decoded.version !== 1 || decoded.data.length !== 32) {
      throw new Error("Invalid Taproot address");
    }

    const publicKey = decoded.data; // The 32-byte internal public key (X coordinate of pubkey)

    // Hash the message using SHA256 (standard Bitcoin message hashing)
    const messageHash = bitcoin.crypto.sha256(Buffer.from(message));

    // Verify the Schnorr signature using tiny-secp256k1
    return schnorr.verify(
      new Uint8Array(Buffer.from(signature, "hex")),
      new Uint8Array(messageHash),
      new Uint8Array(publicKey)
    );
  }

  return BitcoinMessage.verify(
    message,
    address,
    convertHexToBase64(signature),
    undefined,
    true
  );
}

export function isOrdinalAddress(address: string) {
  return address.startsWith("tb1p");
}

export function isBip122Testnet(chainId: string) {
  return chainId.includes(BIP122_TESTNET);
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/eip1271.ts">
import { Contract, providers, utils } from "ethers";

const spec = {
  magicValue: "0x1626ba7e",
  abi: [
    {
      constant: true,
      inputs: [
        {
          name: "_hash",
          type: "bytes32",
        },
        {
          name: "_sig",
          type: "bytes",
        },
      ],
      name: "isValidSignature",
      outputs: [
        {
          name: "magicValue",
          type: "bytes4",
        },
      ],
      payable: false,
      stateMutability: "view",
      type: "function",
    },
  ],
};

async function isValidSignature(
  address: string,
  sig: string,
  data: string,
  provider: providers.Provider,
  abi = eip1271.spec.abi,
  magicValue = eip1271.spec.magicValue
): Promise<boolean> {
  let returnValue;
  try {
    returnValue = await new Contract(address, abi, provider).isValidSignature(
      utils.arrayify(data),
      sig
    );
  } catch (e) {
    return false;
  }
  return returnValue.toLowerCase() === magicValue.toLowerCase();
}

export const eip1271 = {
  spec,
  isValidSignature,
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/eip712.ts">
// From spec: https://eips.ethereum.org/EIPS/eip-712
const example = {
  types: {
    EIP712Domain: [
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
    ],
    Person: [
      { name: "name", type: "string" },
      { name: "wallet", type: "address" },
    ],
    Mail: [
      { name: "from", type: "Person" },
      { name: "to", type: "Person" },
      { name: "contents", type: "string" },
    ],
  },
  primaryType: "Mail",
  domain: {
    name: "Ether Mail",
    version: "1",
    chainId: 1,
    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
  },
  message: {
    from: { name: "Cow", wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826" },
    to: { name: "Bob", wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB" },
    contents: "Hello, Bob!",
  },
};

export const eip712 = {
  example,
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/index.ts">
export * from "./api";
export * from "./eip712";
export * from "./eip1271";
export * from "./tx";
export * from "./types";
export * from "./utilities";
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/kadena.ts">
import { IPactCommand, PactCommand } from "@kadena/client";

export async function getKadenaChainAmount(
  WCNetworkId: string
): Promise<number> {
  const ENDPOINT = WCNetworkId === "testnet04" ? "testnet." : "";

  try {
    const response = await fetch(`https://api.${ENDPOINT}chainweb.com/info`, {
      mode: "cors",
    });

    const json = await response.json();
    return json.nodeNumberOfChains;
  } catch (e) {
    console.error("Error fetching Kadena chain info", e);
    return 0;
  }
}

async function getKadenaBalanceForChain(
  publicKey: string,
  WCNetworkId: IPactCommand["networkId"],
  kadenaChainID: IPactCommand["publicMeta"]["chainId"]
): Promise<number> {
  const ENDPOINT = WCNetworkId === "testnet04" ? "testnet." : "";
  const API_HOST = `https://api.${ENDPOINT}chainweb.com/chainweb/0.0/${WCNetworkId}/chain/${kadenaChainID}/pact`;

  // This request will fail if there is no on-chain activity for the given account yet
  try {
    const command = new PactCommand();
    command.code = `(coin.get-balance "k:${publicKey}")`;
    command.setMeta(
      { sender: `k:${publicKey}`, chainId: kadenaChainID },
      WCNetworkId
    );
    const { result } = await command.local(API_HOST, {
      preflight: false,
      signatureVerification: false,
    });

    if (result.status !== "success") return 0;

    return result.data * 10e17;
  } catch (e) {
    return 0;
  }
}

const kadenaNumberOfChains: Record<string, number> = {
  mainnet01: 0,
  testnet04: 0,
};

export async function apiGetKadenaAccountBalance(
  publicKey: string,
  WCNetworkId: IPactCommand["networkId"]
) {
  if (!kadenaNumberOfChains[WCNetworkId]) {
    kadenaNumberOfChains[WCNetworkId] = await getKadenaChainAmount(WCNetworkId);
  }

  const chainBalances = await Promise.all(
    Array.from(Array(kadenaNumberOfChains[WCNetworkId])).map(
      async (_val, chainNumber) =>
        getKadenaBalanceForChain(
          publicKey,
          WCNetworkId,
          chainNumber.toString() as IPactCommand["publicMeta"]["chainId"]
        )
    )
  );

  const totalBalance = chainBalances.reduce((acc, item) => acc + item, 0);

  return {
    balance: totalBalance.toString(),
    symbol: "KDA",
    name: "KDA",
  };
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/namespaces.ts">
import { ProposalTypes } from "@walletconnect/types";
import {
  DEFAULT_COSMOS_EVENTS,
  DEFAULT_COSMOS_METHODS,
  DEFAULT_EIP155_METHODS,
  DEFAULT_EIP_155_EVENTS,
  DEFAULT_SOLANA_EVENTS,
  DEFAULT_SOLANA_METHODS,
  DEFAULT_POLKADOT_EVENTS,
  DEFAULT_POLKADOT_METHODS,
  DEFAULT_NEAR_METHODS,
  DEFAULT_NEAR_EVENTS,
  DEFAULT_KADENA_METHODS,
  DEFAULT_KADENA_EVENTS,
  DEFAULT_MULTIVERSX_EVENTS,
  DEFAULT_MULTIVERSX_METHODS,
  DEFAULT_TRON_METHODS,
  DEFAULT_TRON_EVENTS,
  DEFAULT_TEZOS_METHODS,
  DEFAULT_TEZOS_EVENTS,
  DEFAULT_OPTIONAL_METHODS,
  DEFAULT_BIP122_METHODS,
  DEFAULT_BIP122_EVENTS,
} from "../constants";

export const getNamespacesFromChains = (chains: string[]) => {
  const supportedNamespaces: string[] = [];
  chains.forEach((chainId) => {
    const [namespace] = chainId.split(":");
    if (!supportedNamespaces.includes(namespace)) {
      supportedNamespaces.push(namespace);
    }
  });

  return supportedNamespaces;
};

export const getSupportedRequiredMethodsByNamespace = (namespace: string) => {
  switch (namespace) {
    case "eip155":
      return Object.values(DEFAULT_EIP155_METHODS);
    case "cosmos":
      return Object.values(DEFAULT_COSMOS_METHODS);
    case "solana":
      return Object.values(DEFAULT_SOLANA_METHODS);
    case "polkadot":
      return Object.values(DEFAULT_POLKADOT_METHODS);
    case "near":
      return Object.values(DEFAULT_NEAR_METHODS);
    case "mvx":
      return Object.values(DEFAULT_MULTIVERSX_METHODS);
    case "tron":
      return Object.values(DEFAULT_TRON_METHODS);
    case "tezos":
      return Object.values(DEFAULT_TEZOS_METHODS);
    case "kadena":
      return Object.values(DEFAULT_KADENA_METHODS);
    case "bip122":
      return Object.values(DEFAULT_BIP122_METHODS);
    default:
      throw new Error(
        `No default required methods for namespace: ${namespace}`
      );
  }
};

export const getSupportedOptionalMethodsByNamespace = (namespace: string) => {
  switch (namespace) {
    case "eip155":
      return Object.values(DEFAULT_OPTIONAL_METHODS);
    case "cosmos":
    case "solana":
    case "polkadot":
    case "near":
    case "mvx":
    case "tron":
    case "tezos":
    case "kadena":
    case "bip122":
      return [];
    default:
      throw new Error(
        `No default optional methods for namespace: ${namespace}`
      );
  }
};

export const getSupportedEventsByNamespace = (namespace: string) => {
  switch (namespace) {
    case "eip155":
      return Object.values(DEFAULT_EIP_155_EVENTS);
    case "cosmos":
      return Object.values(DEFAULT_COSMOS_EVENTS);
    case "solana":
      return Object.values(DEFAULT_SOLANA_EVENTS);
    case "polkadot":
      return Object.values(DEFAULT_POLKADOT_EVENTS);
    case "near":
      return Object.values(DEFAULT_NEAR_EVENTS);
    case "mvx":
      return Object.values(DEFAULT_MULTIVERSX_EVENTS);
    case "tron":
      return Object.values(DEFAULT_TRON_EVENTS);
    case "tezos":
      return Object.values(DEFAULT_TEZOS_EVENTS);
    case "kadena":
      return Object.values(DEFAULT_KADENA_EVENTS);
    case "bip122":
      return Object.values(DEFAULT_BIP122_EVENTS);
    default:
      throw new Error(`No default events for namespace: ${namespace}`);
  }
};

export const getRequiredNamespaces = (
  chains: string[]
): ProposalTypes.RequiredNamespaces => {
  const selectedNamespaces = getNamespacesFromChains(chains);
  console.log("selected required namespaces:", selectedNamespaces);

  return Object.fromEntries(
    selectedNamespaces.map((namespace) => [
      namespace,
      {
        methods: getSupportedRequiredMethodsByNamespace(namespace),
        chains: chains.filter((chain) => chain.startsWith(namespace)),
        events: getSupportedEventsByNamespace(namespace) as any[],
      },
    ])
  );
};

export const getOptionalNamespaces = (
  chains: string[]
): ProposalTypes.OptionalNamespaces => {
  const selectedNamespaces = getNamespacesFromChains(chains);
  console.log("selected optional namespaces:", selectedNamespaces);

  return Object.fromEntries(
    selectedNamespaces.map((namespace) => [
      namespace,
      {
        methods: getSupportedOptionalMethodsByNamespace(namespace),
        chains: chains.filter((chain) => chain.startsWith(namespace)),
        events: [],
      },
    ])
  );
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/solana.ts">
import { PublicKey } from "@solana/web3.js";

export function getPublicKeysFromAccounts(accounts: string[]) {
  return (
    accounts
      // Filter out any non-solana accounts.
      .filter((account) => account.startsWith("solana:"))
      // Create a map of Solana address -> publicKey.
      .reduce((map: Record<string, PublicKey>, account) => {
        const address = account.split(":").pop();
        if (!address) {
          throw new Error(
            `Could not derive Solana address from CAIP account: ${account}`
          );
        }
        map[address] = new PublicKey(address);
        return map;
      }, {})
  );
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/tx.ts">
import * as encoding from "@walletconnect/encoding";

import { apiGetAccountNonce, apiGetGasPrice } from "./api";
import { parseEther } from "ethers/lib/utils";
import { SendCallsParams } from "../constants";

export async function formatTestTransaction(account: string) {
  const [namespace, reference, address] = account.split(":");
  const chainId = `${namespace}:${reference}`;

  let _nonce;
  try {
    _nonce = await apiGetAccountNonce(address, chainId);
  } catch (error) {
    throw new Error(
      `Failed to fetch nonce for address ${address} on chain ${chainId}`
    );
  }

  const nonce = encoding.sanitizeHex(encoding.numberToHex(_nonce));

  // gasPrice
  const _gasPrice = await apiGetGasPrice(chainId);
  const gasPrice = encoding.sanitizeHex(_gasPrice);

  // gasLimit
  const _gasLimit = 21000;
  const gasLimit = encoding.sanitizeHex(encoding.numberToHex(_gasLimit));

  // value
  const _value = 0;
  const value = encoding.sanitizeHex(encoding.numberToHex(_value));

  const tx = {
    from: address,
    to: address,
    data: "0x",
    nonce,
    gasPrice,
    gasLimit,
    value,
  };

  return tx;
}

export async function formatTestBatchCall(account: string) {
  const [namespace, reference, address] = account.split(":");
  // preparing calldata for batch send
  //sepolia pow faucet address
  const receiverAddress = "0x6Cc9397c3B38739daCbfaA68EaD5F5D77Ba5F455";
  const amountToSend = parseEther("0.0001").toHexString();
  const calls = [
    {
      to: receiverAddress as `0x${string}`,
      data: "0x" as `0x${string}`,
      value: amountToSend as `0x${string}`,
    },
    {
      to: receiverAddress as `0x${string}`,
      data: "0x" as `0x${string}`,
      value: amountToSend as `0x${string}`,
    },
  ];
  const sendCallsRequestParams: SendCallsParams = {
    version: "1.0",
    chainId: `0x${BigInt(reference).toString(16)}`,
    from: address as `0x${string}`,
    calls: calls,
  };

  return sendCallsRequestParams;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/types.ts">
import { IPactCommand } from "@kadena/client";
import { ChainId } from "@kadena/types";

export interface AssetData {
  symbol: string;
  name: string;
  contractAddress?: string;
  balance?: string;
}

export interface ChainData {
  name: string;
  id: string;
  rpc: string[];
  slip44: number;
  testnet: boolean;
}
export interface ChainsMap {
  [reference: string]: ChainData;
}
export interface TxData {
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasLimit: string;
  value: string;
  data: string;
}

export interface BlockScoutTx {
  value: string;
  txreceipt_status: string;
  transactionIndex: string;
  to: string;
  timeStamp: string;
  nonce: string;
  isError: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface BlockScoutTokenTx {
  value: string;
  transactionIndex: string;
  tokenSymbol: string;
  tokenName: string;
  tokenDecimal: string;
  to: string;
  timeStamp: string;
  nonce: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface ParsedTx {
  timestamp: string;
  hash: string;
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasUsed: string;
  fee: string;
  value: string;
  input: string;
  error: boolean;
  asset: AssetData;
  operations: TxOperation[];
}

export interface TxOperation {
  asset: AssetData;
  value: string;
  from: string;
  to: string;
  functionName: string;
}

export interface GasPricesResponse {
  fastWait: number;
  avgWait: number;
  blockNum: number;
  fast: number;
  fastest: number;
  fastestWait: number;
  safeLow: number;
  safeLowWait: number;
  speed: number;
  block_time: number;
  average: number;
}

export interface GasPrice {
  time: number;
  price: number;
}

export interface GasPrices {
  timestamp: number;
  slow: GasPrice;
  average: GasPrice;
  fast: GasPrice;
}

export interface MethodArgument {
  type: string;
}

export interface Method {
  signature: string;
  name: string;
  args: MethodArgument[];
}

export interface ChainRequestRender {
  label: string;
  value: string;
}

export interface ChainMetadata {
  name?: string;
  logo: string;
  rgb: string;
}

export interface NamespaceMetadata {
  [reference: string]: ChainMetadata;
}
export interface ChainNamespaces {
  [namespace: string]: ChainsMap;
}

export interface AccountAction {
  method: string;
  callback: (chainId: string, address: string) => Promise<void>;
}

export interface AccountBalances {
  [account: string]: AssetData[];
}

export interface KadenaAccount {
  publicKey: string; // Kadena public key
  account: string; // Kadena account
  chainId: ChainId; // Kadena ChainId
}

export interface IUTXO {
  txid: string;
  vout: number;
  value: number;
  status: {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
  };
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/helpers/utilities.ts">
import { BigNumber, BigNumberish, providers, utils } from "ethers";
import * as encoding from "@walletconnect/encoding";
import { TypedDataUtils } from "eth-sig-util";
import * as ethUtil from "ethereumjs-util";

import { eip1271 } from "./eip1271";
import { DEFAULT_CHAINS } from "../constants";

export function capitalize(string: string): string {
  return string
    .split(" ")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(" ");
}

export function ellipseText(text = "", maxLength = 9999): string {
  if (text.length <= maxLength) {
    return text;
  }
  const _maxLength = maxLength - 3;
  let ellipse = false;
  let currentLength = 0;
  const result =
    text
      .split(" ")
      .filter((word) => {
        currentLength += word.length;
        if (ellipse || currentLength >= _maxLength) {
          ellipse = true;
          return false;
        } else {
          return true;
        }
      })
      .join(" ") + "...";
  return result;
}

export function ellipseAddress(address = "", width = 10): string {
  return `${address.slice(0, width)}...${address.slice(-width)}`;
}

export function getDataString(func: string, arrVals: any[]): string {
  let val = "";
  for (let i = 0; i < arrVals.length; i++) {
    val += encoding.padLeft(arrVals[i], 64);
  }
  const data = func + val;
  return data;
}

export function isMobile(): boolean {
  let mobile = false;

  function hasTouchEvent(): boolean {
    try {
      document.createEvent("TouchEvent");
      return true;
    } catch (e) {
      return false;
    }
  }

  function hasMobileUserAgent(): boolean {
    if (
      /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
        navigator.userAgent
      ) ||
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
        navigator.userAgent.substr(0, 4)
      )
    ) {
      return true;
    } else if (hasTouchEvent()) {
      return true;
    }
    return false;
  }

  mobile = hasMobileUserAgent();

  return mobile;
}

export function encodePersonalMessage(msg: string): string {
  const data = encoding.utf8ToBuffer(msg);
  const buf = Buffer.concat([
    Buffer.from(
      "\u0019Ethereum Signed Message:\n" + data.length.toString(),
      "utf8"
    ),
    data,
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashPersonalMessage(msg: string): string {
  const data = encodePersonalMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function encodeTypedDataMessage(msg: string): string {
  const data = TypedDataUtils.sanitizeData(JSON.parse(msg));
  const buf = Buffer.concat([
    Buffer.from("1901", "hex"),
    TypedDataUtils.hashStruct("EIP712Domain", data.domain, data.types),
    TypedDataUtils.hashStruct(
      data.primaryType as string,
      data.message,
      data.types
    ),
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashTypedDataMessage(msg: string): string {
  const data = encodeTypedDataMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function recoverAddress(sig: string, hash: string): string {
  const params = ethUtil.fromRpcSig(sig);
  const result = ethUtil.ecrecover(
    ethUtil.toBuffer(hash),
    params.v,
    params.r,
    params.s
  );
  const signer = ethUtil.bufferToHex(ethUtil.publicToAddress(result));
  return signer;
}

export function recoverPersonalSignature(sig: string, msg: string): string {
  const hash = hashPersonalMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export function recoverTypedMessage(sig: string, msg: string): string {
  const hash = hashTypedDataMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export async function verifySignature(
  address: string,
  sig: string,
  hash: string,
  rpcUrl: string
): Promise<boolean> {
  const provider = new providers.JsonRpcProvider(rpcUrl);
  const bytecode = await provider.getCode(address);
  if (
    !bytecode ||
    bytecode === "0x" ||
    bytecode === "0x0" ||
    bytecode === "0x00"
  ) {
    const signer = recoverAddress(sig, hash);
    return signer.toLowerCase() === address.toLowerCase();
  } else {
    return eip1271.isValidSignature(address, sig, hash, provider);
  }
}

export function convertHexToNumber(hex: string) {
  try {
    return encoding.hexToNumber(hex);
  } catch (e) {
    return hex;
  }
}

export function convertHexToUtf8(hex: string) {
  try {
    return encoding.hexToUtf8(hex);
  } catch (e) {
    return hex;
  }
}
export function convertHexToBase64(hex: string) {
  try {
    return encoding.hexToBuffer(hex).toString("base64");
  } catch (e) {
    return hex;
  }
}

export const sanitizeDecimals = (value: string, decimals = 18): string => {
  const [integer, fractional] = value.split(".");
  const _fractional = fractional
    ? fractional.substring(0, decimals).replace(/0+$/gi, "")
    : undefined;
  return _fractional ? [integer, _fractional].join(".") : integer;
};

export const toWad = (amount: string, decimals = 18): BigNumber => {
  return utils.parseUnits(sanitizeDecimals(amount, decimals), decimals);
};

export const fromWad = (wad: BigNumberish, decimals = 18): string => {
  try {
    return sanitizeDecimals(utils.formatUnits(wad, decimals), decimals);
  } catch (e) {
    return wad?.toString();
  }
};

export const LOCALSTORAGE_KEY_TESTNET = "TESTNET";
export const INITIAL_STATE_TESTNET_DEFAULT = true;

export function setLocaleStorageTestnetFlag(value: boolean): void {
  if (typeof window !== "undefined") {
    window.localStorage.setItem(LOCALSTORAGE_KEY_TESTNET, `${value}`);
  }
}

export function getLocalStorageTestnetFlag(): boolean {
  if (typeof window === "undefined") return false;
  let value = INITIAL_STATE_TESTNET_DEFAULT;
  const persisted = window.localStorage.getItem(LOCALSTORAGE_KEY_TESTNET);
  if (!persisted) {
    setLocaleStorageTestnetFlag(value);
  } else {
    value = persisted === "true" ? true : false;
  }
  return value;
}

export const getAllChainNamespaces = () => {
  const namespaces: string[] = [];
  DEFAULT_CHAINS.forEach((chainId) => {
    const [namespace] = chainId.split(":");
    if (!namespaces.includes(namespace)) {
      namespaces.push(namespace);
    }
  });
  return namespaces;
};

export const getProviderUrl = (chainId: string) => {
  return `https://rpc.walletconnect.com/v1/?chainId=${chainId}&projectId=${process.env.NEXT_PUBLIC_PROJECT_ID}`;
};
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/shared/index.ts">
import styled from "styled-components";

export const SModalContainer = styled.div`
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

export const SModalTitle = styled.div`
  margin: 1em 0;
  font-size: 20px;
  font-weight: 700;
`;

export const SModalParagraph = styled.p`
  margin-top: 30px;
`;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/LoaderModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer } from "../components/shared";

import { SModalContainer, SModalParagraph, SModalTitle } from "./shared";

interface LoaderModal {
  title: string;
  text?: string;
}

const LoaderModal = (props: LoaderModal) => {
  const { title, text } = props;
  return (
    <>
      <SModalContainer>
        <SModalTitle>{title}</SModalTitle>
        <SContainer>
          <Loader />
          <br />
          <SModalParagraph>{text}</SModalParagraph>
        </SContainer>
      </SModalContainer>
    </>
  );
};

export default LoaderModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/PairingModal.tsx">
import * as React from "react";

import { PairingTypes } from "@walletconnect/types";

import Button from "../components/Button";
import Pairing from "../components/Pairing";
import { STable } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";
import LoaderModal from "./LoaderModal";
import toast from "react-hot-toast";

interface PairingModalProps {
  pairings: PairingTypes.Struct[];
  connect: (pairing?: { topic: string }) => Promise<void>;
}

const PairingModal = (props: PairingModalProps) => {
  const { pairings, connect } = props;
  const [pairing, setPairing] = React.useState<PairingTypes.Struct>();

  const onConnect = React.useCallback(
    async (pairing: PairingTypes.Struct) => {
      try {
        setPairing(pairing);
        await connect({ topic: pairing.topic });
      } catch (error) {
        toast.error((error as Error).message, {
          position: "bottom-left",
        });
        setPairing(undefined);
      }
    },
    [connect]
  );
  return pairing ? (
    <LoaderModal
      title={`Connecting to ${pairing?.peerMetadata?.name}`}
      text="Open your wallet to approve the connection request"
    />
  ) : (
    <SModalContainer>
      <SModalTitle>{"Select available pairing or create new one"}</SModalTitle>
      <STable>
        {pairings.map((pairing) => (
          <Pairing
            key={pairing.topic}
            pairing={pairing}
            onClick={() => onConnect(pairing)}
          />
        ))}
      </STable>
      <Button onClick={() => connect()}>{`New Pairing`}</Button>
    </SModalContainer>
  );
};

export default PairingModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/PingModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";

interface PingModalProps {
  pending: boolean;
  result: any;
}

const PingModal = (props: PingModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending Session Ping"}</SModalTitle>
          <SContainer>
            <Loader />
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid ? "Successful Session Ping" : "Failed Session Ping"}
          </SModalTitle>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"Unknown Error with Session Ping"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default PingModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/RequestLoaderModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer, STable, SRow, SKey, SValue } from "../components/shared";

import { SModalContainer, SModalTitle, SModalParagraph } from "./shared";

interface RequestModalProps {
  pending: boolean;
  result: any;
}

const RequestLoaderModal = (props: RequestModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending JSON-RPC Request"}</SModalTitle>
          <SContainer>
            <Loader />
            <SModalParagraph>
              {"Waiting response from your wallet"}
            </SModalParagraph>
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid
              ? "JSON-RPC Request Success"
              : "JSON-RPC Request Failed"}
          </SModalTitle>
          <STable>
            {Object.keys(result).map((key) => (
              <SRow key={key}>
                <SKey>{key}</SKey>
                <SValue>{result[key].toString()}</SValue>
              </SRow>
            ))}
          </STable>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"JSON-RPC Request Failed"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default RequestLoaderModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/modals/RequestModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer, STable, SRow, SKey, SValue } from "../components/shared";

import { SModalContainer, SModalTitle, SModalParagraph } from "./shared";

interface RequestModalProps {
  pending: boolean;
  result: any;
}

const RequestModal = (props: RequestModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending JSON-RPC Request"}</SModalTitle>
          <SContainer>
            <Loader />
            <SModalParagraph>
              {"Approve or reject request using your wallet"}
            </SModalParagraph>
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid
              ? "JSON-RPC Request Approved"
              : "JSON-RPC Request Failed"}
          </SModalTitle>
          <STable>
            {Object.keys(result).map((key) => (
              <SRow key={key}>
                <SKey>{key}</SKey>
                <SValue>{result[key].toString()}</SValue>
              </SRow>
            ))}
          </STable>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"JSON-RPC Request Rejected"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default RequestModal;
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/_app.tsx">
import "../styles/globals.css";
import type { AppProps } from "next/app";
import { createGlobalStyle } from "styled-components";
import { Toaster } from "react-hot-toast";

import { ClientContextProvider } from "../contexts/ClientContext";
import { JsonRpcContextProvider } from "../contexts/JsonRpcContext";
import { ChainDataContextProvider } from "../contexts/ChainDataContext";
import Metadata from "../components/Metadata";

import { globalStyle } from "../styles";
const GlobalStyle = createGlobalStyle`
  ${globalStyle}
`;

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Toaster />
      <Metadata />
      <GlobalStyle />
      <ChainDataContextProvider>
        <ClientContextProvider>
          <JsonRpcContextProvider>
            <Component {...pageProps} />
          </JsonRpcContextProvider>
        </ClientContextProvider>
      </ChainDataContextProvider>
    </>
  );
}

export default MyApp;
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/_error.tsx">
export default function Error() {
  return <div>An error as occured</div>;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/404.tsx">
export default function FourOhFour() {
  return <h1>404 Page Not Found</h1>;
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/pages/index.tsx">
import type { NextPage } from "next";
import React, { useCallback, useEffect, useRef, useState } from "react";
import toast from "react-hot-toast";

import Banner from "../components/Banner";
import Blockchain from "../components/Blockchain";
import Column from "../components/Column";
import RelayRegionDropdown from "../components/RelayRegionDropdown";
import Header from "../components/Header";
import Modal from "../components/Modal";
import {
  DEFAULT_COSMOS_METHODS,
  DEFAULT_EIP155_METHODS,
  DEFAULT_MAIN_CHAINS,
  DEFAULT_SOLANA_METHODS,
  DEFAULT_POLKADOT_METHODS,
  DEFAULT_MULTIVERSX_METHODS,
  DEFAULT_TEST_CHAINS,
  DEFAULT_NEAR_METHODS,
  DEFAULT_KADENA_METHODS,
  DEFAULT_TRON_METHODS,
  DEFAULT_TEZOS_METHODS,
  DEFAULT_EIP155_OPTIONAL_METHODS,
  DEFAULT_EIP5792_METHODS,
  GetCapabilitiesResult,
  DEFAULT_BIP122_METHODS,
  DEFAULT_EIP7715_METHODS,
} from "../constants";
import { AccountAction, setLocaleStorageTestnetFlag } from "../helpers";
import Toggle from "../components/Toggle";
import RequestModal from "../modals/RequestModal";
import PairingModal from "../modals/PairingModal";
import PingModal from "../modals/PingModal";
import {
  SAccounts,
  SAccountsContainer,
  SButtonContainer,
  SConnectButton,
  SContent,
  SDropDownContainer,
  SLanding,
  SLayout,
  SToggleContainer,
} from "../components/app";
import { useWalletConnectClient } from "../contexts/ClientContext";
import { useJsonRpc } from "../contexts/JsonRpcContext";
import { useChainData } from "../contexts/ChainDataContext";
import Icon from "../components/Icon";
import OriginSimulationDropdown from "../components/OriginSimulationDropdown";
import LoaderModal from "../modals/LoaderModal";
import { numberToHex } from "@walletconnect/encoding";
import RequestLoaderModal from "../modals/RequestLoaderModal";

// Normal import does not work here
const { version } = require("@walletconnect/sign-client/package.json");

const Home: NextPage = () => {
  const [modal, setModal] = useState("");

  const closeModal = () => setModal("");
  const openPairingModal = () => setModal("pairing");
  const openPingModal = () => setModal("ping");
  const openRequestModal = () => setModal("request");
  const openRequestLoaderModal = () => setModal("requestLoader");
  const openDisconnectModal = () => setModal("disconnect");

  // Initialize the WalletConnect client.
  const {
    client,
    pairings,
    session,
    connect,
    disconnect,
    chains,
    relayerRegion,
    accounts,
    balances,
    isFetchingBalances,
    isInitializing,
    setChains,
    setRelayerRegion,
    origin,
    setAccounts,
  } = useWalletConnectClient();

  // Use `JsonRpcContext` to provide us with relevant RPC methods and states.
  const {
    ping,
    ethereumRpc,
    cosmosRpc,
    solanaRpc,
    polkadotRpc,
    nearRpc,
    multiversxRpc,
    tronRpc,
    tezosRpc,
    kadenaRpc,
    bip122Rpc,
    isRpcRequestPending,
    rpcResult,
    isTestnet,
    setIsTestnet,
  } = useJsonRpc();

  const { chainData } = useChainData();

  // Close the pairing modal after a session is established.
  useEffect(() => {
    if (session && modal === "pairing") {
      closeModal();
    }
  }, [session, modal]);

  const onConnect = () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }
    // Suggest existing pairings (if any).
    if (pairings.length) {
      openPairingModal();
    } else {
      // If no existing pairings are available, trigger `WalletConnectClient.connect`.
      connect();
    }
  };

  const onPing = async () => {
    openPingModal();
    await ping();
  };

  const onDisconnect = useCallback(async () => {
    openDisconnectModal();
    try {
      await disconnect();
    } catch (error) {
      toast.error((error as Error).message, {
        position: "bottom-left",
      });
    }
    closeModal();
  }, [disconnect]);

  async function emit() {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect is not initialized");
    }

    await client.emit({
      topic: session?.topic || "",
      event: { name: "chainChanged", data: {} },
      chainId: "eip155:5",
    });
  }

  const getEthereumActions = (
    chainId: string,
    address: string
  ): AccountAction[] => {
    const actions = {
      [DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION]: {
        method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSendTransaction(chainId, address);
        },
      },
      [DEFAULT_EIP155_METHODS.PERSONAL_SIGN]: {
        method: DEFAULT_EIP155_METHODS.PERSONAL_SIGN,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignPersonalMessage(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TRANSACTION,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignTransaction(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN + " (standard)",
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testEthSign(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignTypedData(chainId, address);
        },
      },
      [DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA_V4]: {
        method: DEFAULT_EIP155_OPTIONAL_METHODS.ETH_SIGN_TYPED_DATA_V4,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testSignTypedDatav4(chainId, address);
        },
      },
      [DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES]: {
        method: DEFAULT_EIP5792_METHODS.WALLET_GET_CAPABILITIES,
        callback: async (chainId: string, address: string) => {
          openRequestLoaderModal();
          await ethereumRpc.testWalletGetCapabilities(chainId, address);
        },
      },
      [DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS]: {
        method: DEFAULT_EIP5792_METHODS.WALLET_SEND_CALLS,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testWalletSendCalls(chainId, address);
        },
      },
      [DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS]: {
        method: DEFAULT_EIP5792_METHODS.WALLET_GET_CALLS_STATUS,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testWalletGetCallsStatus(chainId, address);
        },
      },
      [DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS]: {
        method: DEFAULT_EIP7715_METHODS.WALLET_GRANT_PERMISSIONS,
        callback: async (chainId: string, address: string) => {
          openRequestModal();
          await ethereumRpc.testWalletGrantPermissions(chainId, address);
        },
      },
    };

    let availableActions: AccountAction[] = [];
    const chainIdAsHex = `0x${numberToHex(parseInt(chainId))}`;
    const capabilitiesJson = session?.sessionProperties?.["capabilities"];
    const walletCapabilities = capabilitiesJson && JSON.parse(capabilitiesJson);
    session?.namespaces?.["eip155"].methods.forEach((methodName) => {
      const action: AccountAction | undefined =
        actions[methodName as keyof typeof actions];
      // Determine if the method requires additional capability checks
      const requiresCapabilityCheck = [
        "wallet_sendCalls",
        "wallet_getCallsStatus",
        "wallet_grantPermissions",
      ].includes(methodName);
      // Check capabilities only if the method requires it
      if (
        !requiresCapabilityCheck ||
        hasEIP7592RequiredCapabilities(
          address,
          chainIdAsHex,
          walletCapabilities
        )
      ) {
        availableActions.push(action);
      }
    });

    // if a method is approved in the session thats not supported by the app, it will result in an undefined item in the array
    return availableActions.filter((action) => action !== undefined);
  };

  const hasEIP7592RequiredCapabilities = (
    address: string,
    chainId: string,
    walletCapabilities: any
  ): boolean => {
    if (!walletCapabilities) return false;
    const addressCapabilities: GetCapabilitiesResult | undefined =
      walletCapabilities[address];
    if (
      addressCapabilities &&
      addressCapabilities[chainId] &&
      (addressCapabilities[chainId]["atomicBatch"]?.supported ||
        addressCapabilities[chainId]["paymasterService"]?.supported ||
        addressCapabilities[chainId]["sessionKey"]?.supported)
    )
      return true; // Capabilities are supported
    return false; // Capabilities are not supported or not defined
  };

  const getCosmosActions = (): AccountAction[] => {
    const onSignDirect = async (chainId: string, address: string) => {
      openRequestModal();
      await cosmosRpc.testSignDirect(chainId, address);
    };
    const onSignAmino = async (chainId: string, address: string) => {
      openRequestModal();
      await cosmosRpc.testSignAmino(chainId, address);
    };
    return [
      {
        method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_DIRECT,
        callback: onSignDirect,
      },
      {
        method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
        callback: onSignAmino,
      },
    ];
  };

  const getSolanaActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await solanaRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await solanaRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_SOLANA_METHODS.SOL_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_SOLANA_METHODS.SOL_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getPolkadotActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await polkadotRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await polkadotRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_POLKADOT_METHODS.POLKADOT_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getNearActions = (): AccountAction[] => {
    const onSignAndSendTransaction = async (
      chainId: string,
      address: string
    ) => {
      openRequestModal();
      await nearRpc.testSignAndSendTransaction(chainId, address);
    };
    const onSignAndSendTransactions = async (
      chainId: string,
      address: string
    ) => {
      openRequestModal();
      await nearRpc.testSignAndSendTransactions(chainId, address);
    };
    return [
      {
        method: DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTION,
        callback: onSignAndSendTransaction,
      },
      {
        method: DEFAULT_NEAR_METHODS.NEAR_SIGN_AND_SEND_TRANSACTIONS,
        callback: onSignAndSendTransactions,
      },
    ];
  };

  const getMultiversxActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await multiversxRpc.testSignTransaction(chainId, address);
    };
    const onSignTransactions = async (chainId: string, address: string) => {
      openRequestModal();
      await multiversxRpc.testSignTransactions(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await multiversxRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_TRANSACTIONS,
        callback: onSignTransactions,
      },
      {
        method: DEFAULT_MULTIVERSX_METHODS.MULTIVERSX_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getTronActions = (): AccountAction[] => {
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await tronRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await tronRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_TRON_METHODS.TRON_SIGN_TRANSACTION,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_TRON_METHODS.TRON_SIGN_MESSAGE,
        callback: onSignMessage,
      },
    ];
  };

  const getTezosActions = (): AccountAction[] => {
    const onGetAccounts = async (chainId: string, address: string) => {
      openRequestModal();
      await tezosRpc.testGetAccounts(chainId, address);
    };
    const onSignTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await tezosRpc.testSignTransaction(chainId, address);
    };
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await tezosRpc.testSignMessage(chainId, address);
    };
    return [
      {
        method: DEFAULT_TEZOS_METHODS.TEZOS_GET_ACCOUNTS,
        callback: onGetAccounts,
      },
      {
        method: DEFAULT_TEZOS_METHODS.TEZOS_SEND,
        callback: onSignTransaction,
      },
      {
        method: DEFAULT_TEZOS_METHODS.TEZOS_SIGN,
        callback: onSignMessage,
      },
    ];
  };

  const getKadenaActions = (): AccountAction[] => {
    const testGetAccounts = async (chainId: string, address: string) => {
      openRequestModal();
      await kadenaRpc.testGetAccounts(chainId, address);
    };
    const testSign = async (chainId: string, address: string) => {
      openRequestModal();
      await kadenaRpc.testSign(chainId, address);
    };

    const testSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await kadenaRpc.testQuicksign(chainId, address);
    };

    return [
      {
        method: DEFAULT_KADENA_METHODS.KADENA_GET_ACCOUNTS,
        callback: testGetAccounts,
      },
      {
        method: DEFAULT_KADENA_METHODS.KADENA_SIGN,
        callback: testSign,
      },
      {
        method: DEFAULT_KADENA_METHODS.KADENA_QUICKSIGN,
        callback: testSignMessage,
      },
    ];
  };

  const getBip122Actions = (): AccountAction[] => {
    const onSignMessage = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testSignMessage(chainId, address);
    };
    const onGetAccountAddresses = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testGetAccountAddresses(chainId, address);
    };
    const onSendTransaction = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testSendTransaction(chainId, address);
    };
    const onSignPsbt = async (chainId: string, address: string) => {
      openRequestModal();
      await bip122Rpc.testSignPsbt(chainId, address);
    };
    return [
      {
        method: DEFAULT_BIP122_METHODS.BIP122_SEND_TRANSACTION,
        callback: onSendTransaction,
      },
      {
        method: DEFAULT_BIP122_METHODS.BIP122_GET_ACCOUNT_ADDRESSES,
        callback: onGetAccountAddresses,
      },
      {
        method: DEFAULT_BIP122_METHODS.BIP122_SIGN_MESSAGE,
        callback: onSignMessage,
      },
      {
        method: DEFAULT_BIP122_METHODS.BIP122_SIGN_PSBT,
        callback: onSignPsbt,
      },
    ];
  };

  const getBlockchainActions = (account: string) => {
    const [namespace, chainId, address] = account.split(":");
    switch (namespace) {
      case "eip155":
        return getEthereumActions(chainId, address);
      case "cosmos":
        return getCosmosActions();
      case "solana":
        return getSolanaActions();
      case "polkadot":
        return getPolkadotActions();
      case "near":
        return getNearActions();
      case "mvx":
        return getMultiversxActions();
      case "tron":
        return getTronActions();
      case "tezos":
        return getTezosActions();
      case "kadena":
        return getKadenaActions();
      case "bip122":
        return getBip122Actions();
      default:
        break;
    }
  };

  // Toggle between displaying testnet or mainnet chains as selection options.
  const toggleTestnets = () => {
    const nextIsTestnetState = !isTestnet;
    setIsTestnet(nextIsTestnetState);
    setLocaleStorageTestnetFlag(nextIsTestnetState);
  };

  const handleChainSelectionClick = (chainId: string) => {
    if (chains.includes(chainId)) {
      setChains(chains.filter((chain) => chain !== chainId));
    } else {
      setChains([...chains, chainId]);
    }
  };

  // Renders the appropriate model for the given request that is currently in-flight.
  const renderModal = () => {
    switch (modal) {
      case "pairing":
        if (typeof client === "undefined") {
          throw new Error("WalletConnect is not initialized");
        }
        return <PairingModal pairings={pairings} connect={connect} />;
      case "request":
        return (
          <RequestModal pending={isRpcRequestPending} result={rpcResult} />
        );
      case "ping":
        return <PingModal pending={isRpcRequestPending} result={rpcResult} />;
      case "requestLoader":
        return (
          <RequestLoaderModal
            pending={isRpcRequestPending}
            result={rpcResult}
          />
        );
      case "disconnect":
        return <LoaderModal title={"Disconnecting..."} />;
      default:
        return null;
    }
  };

  const [openSelect, setOpenSelect] = useState(false);

  const openDropdown = () => {
    setOpenSelect(!openSelect);
  };

  const renderContent = () => {
    const chainOptions = isTestnet ? DEFAULT_TEST_CHAINS : DEFAULT_MAIN_CHAINS;

    return !accounts.length && !Object.keys(balances).length ? (
      <SLanding center>
        <Banner />
        <h6>{`Using v${version || "2.0.0-beta"}`}</h6>
        <SButtonContainer>
          <h6>Select chains:</h6>
          <SToggleContainer>
            <p>Testnets Only?</p>
            <Toggle active={isTestnet} onClick={toggleTestnets} />
          </SToggleContainer>
          {chainOptions.map((chainId) => (
            <Blockchain
              key={chainId}
              chainId={chainId}
              chainData={chainData}
              onClick={handleChainSelectionClick}
              active={chains.includes(chainId)}
            />
          ))}
          <SConnectButton left onClick={onConnect} disabled={!chains.length}>
            Connect
          </SConnectButton>
          <SDropDownContainer>
            <RelayRegionDropdown
              relayerRegion={relayerRegion}
              setRelayerRegion={setRelayerRegion}
              show={openSelect}
            />
            <OriginSimulationDropdown origin={origin} show={openSelect} />
          </SDropDownContainer>
          <button onClick={openDropdown} style={{ background: "transparent" }}>
            <Icon size={30} src={"/assets/settings.svg"} />
          </button>
        </SButtonContainer>
      </SLanding>
    ) : (
      <SAccountsContainer>
        <h3>Accounts</h3>
        <SAccounts>
          {accounts.map((account) => {
            const [namespace, reference, address] = account.split(":");
            const chainId = `${namespace}:${reference}`;
            return (
              <Blockchain
                key={account}
                active
                chainData={chainData}
                fetching={isFetchingBalances}
                address={address}
                chainId={chainId}
                balances={balances}
                actions={getBlockchainActions(account)}
              />
            );
          })}
        </SAccounts>
      </SAccountsContainer>
    );
  };

  return (
    <SLayout>
      <Column maxWidth={1000} spanHeight>
        <Header
          ping={onPing}
          disconnect={onDisconnect}
          session={session}
          emit={emit}
        />
        <SContent>{isInitializing ? "Loading..." : renderContent()}</SContent>
      </Column>
      <Modal show={!!modal} closeModal={closeModal}>
        {renderModal()}
      </Modal>
    </SLayout>
  );
};

export default Home;
</file>

<file path="advanced/dapps/react-dapp-v2/src/styles/globals.css">
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
  body {
    color: white;
    background: black;
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/styles/Home.module.css">
.container {
  padding: 0 2rem;
}

.main {
  min-height: 100vh;
  padding: 4rem 0;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.footer {
  display: flex;
  flex: 1;
  padding: 2rem 0;
  border-top: 1px solid #eaeaea;
  justify-content: center;
  align-items: center;
}

.footer a {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-grow: 1;
}

.title a {
  color: #0070f3;
  text-decoration: none;
}

.title a:hover,
.title a:focus,
.title a:active {
  text-decoration: underline;
}

.title {
  margin: 0;
  line-height: 1.15;
  font-size: 4rem;
}

.title,
.description {
  text-align: center;
}

.description {
  margin: 4rem 0;
  line-height: 1.5;
  font-size: 1.5rem;
}

.code {
  background: #fafafa;
  border-radius: 5px;
  padding: 0.75rem;
  font-size: 1.1rem;
  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,
    Bitstream Vera Sans Mono, Courier New, monospace;
}

.grid {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  max-width: 800px;
}

.card {
  margin: 1rem;
  padding: 1.5rem;
  text-align: left;
  color: inherit;
  text-decoration: none;
  border: 1px solid #eaeaea;
  border-radius: 10px;
  transition: color 0.15s ease, border-color 0.15s ease;
  max-width: 300px;
}

.card:hover,
.card:focus,
.card:active {
  color: #0070f3;
  border-color: #0070f3;
}

.card h2 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.card p {
  margin: 0;
  font-size: 1.25rem;
  line-height: 1.5;
}

.logo {
  height: 1em;
  margin-left: 0.5rem;
}

@media (max-width: 600px) {
  .grid {
    width: 100%;
    flex-direction: column;
  }
}

@media (prefers-color-scheme: dark) {
  .card,
  .footer {
    border-color: #222;
  }
  .code {
    background: #111;
  }
  .logo img {
    filter: invert(1);
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/src/styles.ts">
export const colors: Record<string, string> = {
  white: "255, 255, 255",
  black: "0, 0, 0",
  dark: "12, 12, 13",
  grey: "169, 169, 188",
  darkGrey: "113, 119, 138",
  lightGrey: "212, 212, 212",
  blue: "101, 127, 230",
  lightBlue: "64, 153, 255",
  yellow: "250, 188, 45",
  orange: "246, 133, 27",
  green: "84, 209, 146",
  pink: "255, 51, 102",
  red: "214, 75, 71",
  purple: "110, 107, 233",
};

export const fonts = {
  size: {
    tiny: "10px",
    small: "14px",
    medium: "16px",
    large: "18px",
    h1: "60px",
    h2: "50px",
    h3: "40px",
    h4: "32px",
    h5: "24px",
    h6: "20px",
  },
  weight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
  },
  family: {
    OpenSans: `"Open Sans", sans-serif`,
  },
};

export const transitions = {
  short: "all 0.1s ease-in-out",
  base: "all 0.2s ease-in-out",
  long: "all 0.3s ease-in-out",
  button: "all 0.15s ease-in-out",
};

export const shadows = {
  soft: "0 4px 6px 0 rgba(50, 50, 93, 0.11), 0 1px 3px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
  medium:
    "0 3px 6px 0 rgba(0, 0, 0, 0.06), 0 0 1px 0 rgba(50, 50, 93, 0.02), 0 5px 10px 0 rgba(59, 59, 92, 0.08)",
  big: "0 15px 35px 0 rgba(50, 50, 93, 0.06), 0 5px 15px 0 rgba(50, 50, 93, 0.15)",
  hover:
    "0 7px 14px 0 rgba(50, 50, 93, 0.1), 0 3px 6px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
};

export const responsive = {
  xs: {
    min: "min-width: 467px",
    max: "max-width: 468px",
  },
  sm: {
    min: "min-width: 639px",
    max: "max-width: 640px",
  },
  md: {
    min: "min-width: 959px",
    max: "max-width: 960px",
  },
  lg: {
    min: "min-width: 1023px",
    max: "max-width: 1024px",
  },
  xl: {
    min: "min-width: 1399px",
    max: "max-width: 1400px",
  },
};

export const globalStyle = `

  html, body, #root {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: ${fonts.family.OpenSans};
    font-style: normal;
    font-stretch: normal;
    font-weight: ${fonts.weight.normal};
    font-size: ${fonts.size.medium};
    background-color: rgb(${colors.white});
    color: rgb(${colors.dark});
    overflow-y:auto;
    text-rendering: optimizeLegibility;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  	-webkit-text-size-adjust: 100%;
    -webkit-overflow-scrolling: touch;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;  
  }

  button {
    border-style: none;
    line-height: 1em;
    background-image: none;
    outline: 0;
    -webkit-box-shadow: none;
            box-shadow: none;
  }

  [tabindex] {
    outline: none;
    width: 100%;
    height: 100%;
  }

  a, p, h1, h2, h3, h4, h5, h6 {
  	text-decoration: none;
  	margin: 0;
    padding: 0;
    margin: 0.7em 0;
  }

  h1 {
    font-size: ${fonts.size.h1}
  }
  h2 {
    font-size: ${fonts.size.h2}
  }
  h3 {
    font-size: ${fonts.size.h3}
  }
  h4 {
    font-size: ${fonts.size.h4}
  }
  h5 {
    font-size: ${fonts.size.h5}
  }
  h6 {
    font-size: ${fonts.size.h6}
  }

  a {
    background-color: transparent;
    -webkit-text-decoration-skip: objects;  
    text-decoration: none;
    color: inherit;
    outline: none;
  }

  b,
  strong {
    font-weight: inherit;
    font-weight: bolder;
  }

  ul, li {
  	list-style: none;
  	margin: 0;
  	padding: 0;
  }

  * {
    box-sizing: border-box !important;
  }


  input {
    -webkit-appearance: none;
  }

  article,
  aside,
  details,
  figcaption,
  figure,
  footer,
  header,
  main,
  menu,
  nav,
  section,
  summary {
    display: block;
  }
  audio,
  canvas,
  progress,
  video {
    display: inline-block;
  }

  input[type="color"],
  input[type="date"],
  input[type="datetime"],
  input[type="datetime-local"],
  input[type="email"],
  input[type="month"],
  input[type="number"],
  input[type="password"],
  input[type="search"],
  input[type="tel"],
  input[type="text"],
  input[type="time"],
  input[type="url"],
  input[type="week"],
  select:focus,
  textarea {
    font-size: 16px;
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2/.env.local.example">
NEXT_PUBLIC_PROJECT_ID=39bc...
NEXT_PUBLIC_RELAY_URL=wss://relay.walletconnect.com
</file>

<file path="advanced/dapps/react-dapp-v2/.eslintrc.json">
{
  "extends": "next/core-web-vitals",
  "rules": {
    "no-trailing-spaces": 1,
    "@next/next/no-img-element": "off"
  },
  "overrides": [
		{
			"extends": ["plugin:package-json/recommended"],
			"files": ["package.json"],
			"parser": "jsonc-eslint-parser",
			"plugins": ["package-json"]
		}
	]
}
</file>

<file path="advanced/dapps/react-dapp-v2/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="advanced/dapps/react-dapp-v2/.prettierignore">
.changeset
coverage
.idea
.next
node_modules
</file>

<file path="advanced/dapps/react-dapp-v2/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  distDir: "build",
  webpack(config) {
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
    };

    return config;
  },
};

module.exports = nextConfig;
</file>

<file path="advanced/dapps/react-dapp-v2/package.json">
{
  "name": "react-dapp-v2-next",
  "version": "2.3.3",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prettier": "prettier --check '**/*.{js,ts,jsx,tsx}'",
    "prettier:write": "prettier --write '**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@celo/wallet-base": "^5.1.1",
    "@ethereumjs/tx": "^3.5.0",
    "@kadena/client": "^0.5.0",
    "@kadena/cryptography-utils": "^0.4.0",
    "@kadena/pactjs": "^0.4.3",
    "@kadena/types": "^0.6.0",
    "@multiversx/sdk-core": "12.18.0",
    "@multiversx/sdk-wallet": "4.2.0",
    "@noble/curves": "^1.8.1",
    "@noble/secp256k1": "^2.2.3",
    "@polkadot/util-crypto": "^10.1.2",
    "@solana/web3.js": "^1.36.0",
    "@walletconnect/core": "^2.19.1",
    "@walletconnect/encoding": "^1.0.1",
    "@walletconnect/jsonrpc-utils": "^1.0.8",
    "@walletconnect/sign-client": "2.19.2",
    "@walletconnect/types": "2.19.2",
    "@walletconnect/utils": "2.19.2",
    "@web3modal/standalone": "2.4.3",
    "axios": "^1.0.0",
    "bitcoinjs-lib": "^6.1.5",
    "bitcoinjs-message": "^2.2.0",
    "blockies-ts": "^1.0.0",
    "bs58": "^5.0.0",
    "cosmos-wallet": "^1.2.0",
    "eth-sig-util": "^2.5.3",
    "ethereumjs-util": "^7.0.6",
    "ethers": "^5.3.0",
    "fp-ts": "^2.13.1",
    "next": "14.2.25",
    "prop-types": "^15.7.2",
    "qr-image": "^3.2.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hot-toast": "^2.4.1",
    "react-scripts": "^4.0.3",
    "solana-wallet": "^1.0.1",
    "styled-components": "^6.1.15",
    "tronweb": "^4.4.0",
    "web-vitals": "^0.2.4"
  },
  "devDependencies": {
    "@types/eth-sig-util": "^2.1.1",
    "@types/jest": "^27.4.0",
    "@types/node": "^17.0.14",
    "@types/pino": "^7.0.5",
    "@types/prop-types": "^15.7.4",
    "@types/qr-image": "^3.2.5",
    "@types/react": "18.0.15",
    "@types/react-dom": "18.0.6",
    "@types/styled-components": "^5.1.34",
    "eslint": "8.21.0",
    "eslint-config-next": "14.2.25",
    "eslint-plugin-package-json": "^0.13.1",
    "jsonc-eslint-parser": "^2.4.0",
    "pino-pretty": "^13.0.0",
    "prettier": "^2.8.8",
    "typescript": "^4.7.4"
  },
  "pnpm": {
    "overrides": {
      "node-forge@<1.0.0": ">=1.0.0",
      "node-forge@<1.3.0": ">=1.3.0",
      "ejs@<3.1.7": ">=3.1.7",
      "browserslist@>=4.0.0 <4.16.5": ">=4.16.5",
      "loader-utils@>=2.0.0 <2.0.3": ">=2.0.3",
      "postcss@<8.4.31": ">=8.4.31",
      "next@>=0.9.9 <13.4.20-canary.13": ">=13.4.20-canary.13",
      "yaml@>=2.0.0-5 <2.2.2": ">=2.2.2",
      "loader-utils@>=2.0.0 <2.0.4": ">=2.0.4",
      "nth-check@<2.0.1": ">=2.0.1",
      "shell-quote@<=1.7.2": ">=1.7.3",
      "minimist@<0.2.1": ">=0.2.1",
      "minimatch@<3.0.5": ">=3.0.5",
      "webpack-dev-middleware@<=5.3.3": ">=5.3.4",
      "immer@>=7.0.0 <9.0.6": ">=9.0.6",
      "tar@<6.2.1": ">=6.2.1",
      "minimist@<0.2.4": ">=0.2.4",
      "axios@>=0.8.1 <0.28.0": ">=0.28.0",
      "tough-cookie@<4.1.3": ">=4.1.3",
      "protobufjs@>=7.0.0 <7.2.5": ">=7.2.5",
      "protobufjs@>=6.10.0 <6.11.4": ">=6.11.4",
      "braces@<3.0.3": ">=3.0.3",
      "ejs@<3.1.10": ">=3.1.10",
      "ws@>=2.1.0 <5.2.4": ">=5.2.4",
      "micromatch@<4.0.8": ">=4.0.8",
      "rollup@<2.79.2": ">=2.79.2",
      "http-proxy-middleware@<2.0.7": ">=2.0.7",
      "next@>=10.0.0 <14.2.7": ">=14.2.7",
      "cross-spawn@>=7.0.0 <7.0.5": ">=7.0.5",
      "semver@>=7.0.0 <7.5.2": ">=7.5.2",
      "next@>=9.5.5 <14.2.15": ">=14.2.15",
      "ansi-html@<0.0.8": ">=0.0.8",
      "axios@<1.8.2": ">=1.8.2"
    }
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2/README.md">
# React dApp (with standalone v2 client)

🔗 Live dapp demo - https://react-app.walletconnect.com/ <br />
🔗 Live wallet demo - https://react-wallet.walletconnect.com/ <br />
📚 WalletConnect v2 Docs - https://docs.walletconnect.com/2.0

## Overview

This is an example implementation of a React dApp (generated via `create-react-app`) using the standalone
client for WalletConnect v2 to:

- handle pairings
- manage sessions
- send JSON-RPC requests to a paired wallet

## Running locally

Install the app's dependencies:

```bash
yarn
```

Set up your local environment variables by copying the example into your own `.env.local` file:

```bash
cp .env.local.example .env.local
```

Your `.env.local` now contains the following environment variables:

- `NEXT_PUBLIC_PROJECT_ID` (placeholder) - You can generate your own ProjectId at https://cloud.walletconnect.com
- `NEXT_PUBLIC_RELAY_URL` (already set)

## Develop

```bash
yarn dev
```

## Test

```bash
yarn test
```

## Build

```bash
yarn build
```
</file>

<file path="advanced/dapps/react-dapp-v2/tsconfig.json">
{
  "compilerOptions": {
    "target": "es2015",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="theme-color" content="#000000" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
    <meta name="description" content="React App for WalletConnect" />
    <style>
      @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,500,600,700,800");
    </style>
  </head>
  <body>
    <noscript> You need to enable JavaScript to run this app. </noscript>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/public/manifest.json">
{
  "short_name": "WalletConnect",
  "name": "WalletConnect React App",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": "./index.html",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/chains/cosmos.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import { NamespaceMetadata, ChainMetadata, ChainRequestRender } from "../helpers";

export const CosmosChainData = {
  "cosmoshub-4": {
    name: "Cosmos Hub",
    id: "cosmos:cosmoshub-4",
    rpc: ["https://rpc.cosmos.network"],
    slip44: 118,
    testnet: false,
  },
  "irishub-1": {
    name: "Irisnet",
    id: "cosmos:irishub-1",
    rpc: ["https://rpc.irisnet.org"],
    slip44: 566,
    testnet: false,
  },
  "kava-4": {
    name: "Kava",
    id: "cosmos:kava-4",
    rpc: ["https://kava4.data.kava.io"],
    slip44: 459,
    testnet: false,
  },
  "columbus-4": {
    name: "Terra",
    id: "cosmos:columbus-4",
    rpc: [],
    slip44: 330,
    testnet: false,
  },
};

export const CosmosMetadata: NamespaceMetadata = {
  "cosmoshub-4": {
    logo: "/assets/" + "cosmos-cosmoshub-4.png",
    rgb: "27, 31, 53",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = CosmosMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(request: JsonRpcRequest): ChainRequestRender[] {
  return [
    { label: "Method", value: request.method },
    {
      label: "params",
      value: JSON.stringify(request.params, null, "\t"),
    },
  ];
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/chains/eip155.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  convertHexToNumber,
  convertHexToUtf8,
} from "../helpers";

export const EIP155Colors = {
  ethereum: "99, 125, 234",
  optimism: "233, 1, 1",
  goerli: "189, 174, 155",
  xdai: "73, 169, 166",
  polygon: "130, 71, 229",
  celo: "60, 203, 132",
  arbitrum: "44, 55, 75",
};

export const EIP155Metadata: NamespaceMetadata = {
  "1": {
    name: "Ethereum",
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "5": {
    logo: "/assets/" + "eip155-5.png",
    rgb: EIP155Colors.goerli,
  },
  "10": {
    name: "Optimism",
    logo: "/assets/" + "eip155-10.png",
    rgb: EIP155Colors.optimism,
  },
  "42": {
    logo: "/assets/" + "eip155-42.png",
    rgb: EIP155Colors.ethereum,
  },
  "69": {
    logo: "/assets/" + "eip155-69.png",
    rgb: EIP155Colors.optimism,
  },
  "100": {
    logo: "/assets/" + "eip155-100.png",
    rgb: EIP155Colors.xdai,
  },
  "137": {
    name: "Polygon",
    logo: "/assets/" + "eip155-137.png",
    rgb: EIP155Colors.polygon,
  },
  "80001": {
    logo: "/assets/" + "eip155-80001.png",
    rgb: EIP155Colors.polygon,
  },
  "42161": {
    name: "Arbitrum",
    logo: "/assets/" + "eip155-42161.png",
    rgb: EIP155Colors.arbitrum,
  },
  "42220": {
    name: "Celo",
    logo: "/assets/" + "eip155-42220.png",
    rgb: EIP155Colors.celo,
  },
  "44787": {
    logo: "/assets/" + "eip155-44787.png",
    rgb: EIP155Colors.celo,
  },
  "421611": {
    logo: "/assets/" + "eip155-421611.png",
    rgb: EIP155Colors.arbitrum,
  },
};
export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = EIP155Metadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(request: JsonRpcRequest): ChainRequestRender[] {
  let params = [{ label: "Method", value: request.method }];

  switch (request.method) {
    case "eth_sendTransaction":
    case "eth_signTransaction":
      params = [
        ...params,
        { label: "From", value: request.params[0].from },
        { label: "To", value: request.params[0].to },
        {
          label: "Gas Limit",
          value: request.params[0].gas
            ? convertHexToNumber(request.params[0].gas)
            : request.params[0].gasLimit
            ? convertHexToNumber(request.params[0].gasLimit)
            : "",
        },
        {
          label: "Gas Price",
          value: convertHexToNumber(request.params[0].gasPrice),
        },
        {
          label: "Nonce",
          value: convertHexToNumber(request.params[0].nonce),
        },
        {
          label: "Value",
          value: request.params[0].value ? convertHexToNumber(request.params[0].value) : "",
        },
        { label: "Data", value: request.params[0].data },
      ];
      break;

    case "eth_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[0] },
        { label: "Message", value: request.params[1] },
      ];
      break;
    case "personal_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[1] },
        {
          label: "Message",
          value: convertHexToUtf8(request.params[0]),
        },
      ];
      break;
    default:
      params = [
        ...params,
        {
          label: "params",
          value: JSON.stringify(request.params, null, "\t"),
        },
      ];
      break;
  }
  return params;
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/chains/index.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import * as eip155 from "./eip155";
import * as cosmos from "./cosmos";
import * as polkadot from "./polkadot";

import { ChainMetadata, ChainRequestRender } from "../helpers";

export function getChainMetadata(chainId: string): ChainMetadata {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainMetadata(chainId);
    case "cosmos":
      return cosmos.getChainMetadata(chainId);
    case "polkadot":
      return polkadot.getChainMetadata(chainId);
    default:
      throw new Error(`No metadata handler for namespace ${namespace}`);
  }
}

export function getChainRequestRender(
  request: JsonRpcRequest,
  chainId: string,
): ChainRequestRender[] {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainRequestRender(request);
    case "cosmos":
      return cosmos.getChainRequestRender(request);
    case "polkadot":
      return polkadot.getChainRequestRender(request);
    default:
      throw new Error(`No render handler for namespace ${namespace}`);
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/chains/polkadot.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import { NamespaceMetadata, ChainMetadata, ChainRequestRender } from "../helpers";

export const PolkadotMetadata: NamespaceMetadata = {
  // eslint-disable-next-line no-useless-computed-key
  ["91b171bb158e2d3848fa23a9f1c25182"]: {
    logo: "/assets/polkadot.svg",
    rgb: "230, 1, 122",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = PolkadotMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(request: JsonRpcRequest): ChainRequestRender[] {
  let params = [{ label: "Method", value: request.method }];

  switch (request.method) {
    default:
      params = [
        ...params,
        {
          label: "params",
          value: JSON.stringify(request.params, null, "\t"),
        },
      ];
      break;
  }
  return params;
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/app/index.tsx">
import styled from "styled-components";
import { fonts } from "../../styles";
import Button from "../Button";
import Column from "../Column";
import Wrapper from "../Wrapper";

export const SLayout = styled.div`
  position: relative;
  width: 100%;
  min-height: 100vh;
  text-align: center;
`;

export const SContent = styled(Wrapper as any)`
  width: 100%;
  height: 100%;
  padding: 0 16px;
`;

export const SLanding = styled(Column as any)`
  /* height: 600px; */
`;

export const SButtonContainer = styled(Column as any)`
  width: 250px;
  margin: 50px 0;
`;

export const SConnectButton = styled(Button as any)`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
`;

export const SAccountsContainer = styled(SLanding as any)`
  height: 100%;
  padding-bottom: 30px;
  & h3 {
    padding-top: 30px;
  }
`;

export const SToggleContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 10px auto;
  & > p {
    margin-right: 10px;
  }
`;

export const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

export const SAccounts = styled(SFullWidthContainer)`
  justify-content: space-between;
  & > div {
    margin: 12px 0;
    flex: 1 0 100%;
    @media (min-width: 648px) {
      flex: 0 1 48%;
    }
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/shared/index.ts">
import styled from "styled-components";

export const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

export const STable = styled(SContainer as any)`
  flex-direction: column;
  text-align: left;
`;

export const SRow = styled.div`
  width: 100%;
  display: flex;
  margin: 6px 0;
`;

export const SKey = styled.div`
  width: 30%;
  font-weight: 700;
`;

export const SValue = styled.div`
  width: 70%;
  font-family: monospace;
`;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Asset.tsx">
import * as React from "react";
import styled from "styled-components";

import Icon from "./Icon";

import { AssetData } from "../helpers";

import { getChainMetadata } from "../chains";

const xdai = getChainMetadata("eip155:100").logo;
const matic = getChainMetadata("eip155:137").logo;

const SAsset = styled.div`
  width: 100%;
  padding: 20px;
  display: flex;
  justify-content: space-between;
`;
const SAssetLeft = styled.div`
  display: flex;
`;

const SAssetName = styled.div`
  display: flex;
  margin-left: 10px;
`;

const SAssetRight = styled.div`
  display: flex;
`;

const SAssetBalance = styled.div`
  display: flex;
`;

// eslint-disable-next-line
function getAssetIcon(asset: AssetData): JSX.Element {
  if (!!asset.contractAddress) {
    const src = `https://raw.githubusercontent.com/TrustWallet/tokens/master/tokens/${asset.contractAddress.toLowerCase()}.png`;
    return <Icon src={src} fallback={"/assets/erc20.svg"} />;
  }
  switch (asset.symbol.toLowerCase()) {
    case "eth":
      return <Icon src={"assets/eth.svg"} />;
    case "xdai":
      return <Icon src={xdai} />;
    case "matic":
      return <Icon src={matic} />;
    default:
      return <Icon src={"/assets/erc20.svg"} />;
  }
}

interface AssetProps {
  asset: { symbol: string; balance: string };
}

const Asset = (props: AssetProps) => {
  const { asset } = props;
  return (
    <SAsset {...props}>
      <SAssetLeft>
        {/* {getAssetIcon(asset)} */}
        <SAssetName>{asset.symbol}</SAssetName>
      </SAssetLeft>
      <SAssetRight>
        <SAssetBalance>{`${asset.balance}`}</SAssetBalance>
      </SAssetRight>
    </SAsset>
  );
};

export default Asset;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Banner.tsx">
import * as React from "react";
import styled from "styled-components";

const SBannerWrapper = styled.div`
  display: flex;
  align-items: center;
  position: relative;
`;

const SBanner = styled.div`
  width: 275px;
  height: 45px;
  background: url(/assets/walletconnect.png) no-repeat;
  background-size: cover;
  background-position: center;
`;

const Banner = () => (
  <SBannerWrapper>
    <SBanner />
  </SBannerWrapper>
);

export default Banner;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Blockchain.tsx">
import React, { PropsWithChildren, FC } from "react";
import { styled } from "styled-components";

import Asset from "./Asset";
import Button from "./Button";
import Column from "./Column";
import Loader from "./Loader";

import { getChainMetadata } from "../chains";
import {
  AccountAction,
  ellipseAddress,
  ChainMetadata,
  ChainNamespaces,
  AccountBalances,
} from "../helpers";
import { fonts } from "../styles";

interface AccountStyleProps {
  rgb: string;
  children?: React.ReactNode;
  onClick?: () => void;
  className?: string;
}

const SAccount = styled.div<AccountStyleProps>`
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  border-radius: 8px;
  padding: 8px;
  margin: 5px 0;
  border: ${({ rgb }) => `2px solid rgb(${rgb})`};
  &.active {
    box-shadow: ${({ rgb }) => `0 0 8px rgb(${rgb})`};
  }
`;

const SChain = styled.div`
  width: 100%;
  display: flex;
  align-items: center;
  & p {
    font-weight: 600;
  }
  & img {
    border-radius: 50%;
    width: 35px;
    height: 35px;
    margin-right: 10px;
  }
`;

const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

interface ActionProps {
  rgb: string;
}

const SAction = styled(Button)<ActionProps>`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
  background-color: ${({ rgb }) => `rgb(${rgb})`};
`;

const SBlockchainChildrenContainer = styled(SFullWidthContainer)`
  flex-direction: column;
`;

interface BlockchainProps {
  chainData: ChainNamespaces;
  fetching?: boolean;
  active?: boolean;
  chainId: string;
  address?: string;
  onClick?: (chain: string) => void;
  balances?: AccountBalances;
  actions?: AccountAction[];
}

interface BlockchainDisplayData {
  data: any;
  meta: ChainMetadata;
}

function getBlockchainDisplayData(
  chainId: string,
  chainData: ChainNamespaces,
): BlockchainDisplayData | undefined {
  const [namespace, reference] = chainId.split(":");
  let meta: ChainMetadata;
  try {
    meta = getChainMetadata(chainId);
  } catch (e) {
    return undefined;
  }
  if (typeof chainData[namespace] === "undefined") return undefined;
  const data = chainData[namespace][reference];
  if (typeof data === "undefined") return undefined;
  return { data, meta };
}

const Blockchain: FC<PropsWithChildren<BlockchainProps>> = (
  props: PropsWithChildren<BlockchainProps>,
) => {
  const { chainData, fetching, chainId, address, onClick, balances, active, actions } = props;

  if (!Object.keys(chainData).length) return null;

  const chain = getBlockchainDisplayData(chainId, chainData);
  if (typeof chain === "undefined") {
    return null;
  }
  const name = chain.meta.name || chain.data.name;

  return (
    <React.Fragment>
      <SAccount
        rgb={chain.meta.rgb}
        onClick={() => onClick && onClick(props.chainId)}
        className={active ? "active" : ""}
      >
        <SChain>
          <img src={chain.meta.logo} alt={name} />
          <p>{name}</p>
        </SChain>
        {!!address && <p>{ellipseAddress(address)}</p>}
        <SBlockchainChildrenContainer>
          {fetching ? (
            <Column center>
              <SContainer>
                <Loader rgb={`rgb(${chain.meta.rgb})`} />
              </SContainer>
            </Column>
          ) : (
            <>
              {!!address && !!balances && balances[address] ? (
                <SFullWidthContainer>
                  <h6>Balances</h6>
                  <Column center>
                    <Asset key={balances[address].symbol} asset={balances[address]} />
                  </Column>
                </SFullWidthContainer>
              ) : null}
              {address && !!actions && actions.length ? (
                <SFullWidthContainer>
                  <h6>Methods</h6>
                  {actions.map(action => (
                    <SAction
                      key={action.method}
                      left
                      rgb={chain.meta.rgb}
                      onClick={() => action.callback(address)}
                    >
                      {action.method}
                    </SAction>
                  ))}
                </SFullWidthContainer>
              ) : null}
            </>
          )}
        </SBlockchainChildrenContainer>
      </SAccount>
    </React.Fragment>
  );
};
export default Blockchain;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Button.tsx">
import * as React from "react";
import { styled, keyframes } from "styled-components";
import Loader from "./Loader";
import { colors, fonts, shadows, transitions } from "../styles";

interface ButtonStyleProps {
  fetching: boolean;
  outline: boolean;
  type: "button" | "submit" | "reset";
  color: string;
  disabled: boolean;
  icon: any;
  left: boolean;
}

interface ButtonProps extends ButtonStyleProps {
  children: React.ReactNode;
  onClick?: any;
}

const SIcon = styled.div`
  position: absolute;
  height: 15px;
  width: 15px;
  margin: 0 8px;
  top: calc((100% - 15px) / 2);
`;

const SHoverLayer = styled.div`
  transition: ${transitions.button};
  position: absolute;
  height: 100%;
  width: 100%;
  background-color: rgb(${colors.white}, 0.1);
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  pointer-events: none;
  opacity: 0;
  visibility: hidden;
`;

const SButton = styled.button<ButtonStyleProps>`
  transition: ${transitions.button};
  position: relative;
  border: none;
  border-style: none;
  box-sizing: border-box;
  background-color: ${({ outline, color }) => (outline ? "transparent" : `rgb(${colors[color]})`)};
  border: ${({ outline, color }) => (outline ? `1px solid rgb(${colors[color]})` : "none")};
  color: ${({ outline, color }) => (outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`)};
  box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  font-weight: ${fonts.weight.semibold};
  padding: ${({ icon, left }) =>
    icon ? (left ? "7px 12px 8px 28px" : "7px 28px 8px 12px") : "8px 12px"};
  cursor: ${({ disabled }) => (disabled ? "auto" : "pointer")};
  will-change: transform;

  &:disabled {
    opacity: 0.6;
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  }

  @media (hover: hover) {
    &:hover {
      transform: ${({ disabled }) => (!disabled ? "translateY(-1px)" : "none")};
      box-shadow: ${({ disabled, outline }) =>
        !disabled ? (outline ? "none" : `${shadows.hover}`) : `${shadows.soft}`};
    }

    &:hover ${SHoverLayer} {
      opacity: 1;
      visibility: visible;
    }
  }

  &:active {
    transform: ${({ disabled }) => (!disabled ? "translateY(1px)" : "none")};
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
    color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgba(${colors.white}, 0.24)`};

    & ${SIcon} {
      opacity: 0.8;
    }
  }

  & ${SIcon} {
    right: ${({ left }) => (left ? "auto" : "0")};
    left: ${({ left }) => (left ? "0" : "auto")};
    display: ${({ icon }) => (icon ? "block" : "none")};
    mask: ${({ icon }) => (icon ? `url(${icon}) center no-repeat` : "none")};
    background-color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`};
    transition: 0.15s ease;
  }
`;

const Button = (props: ButtonProps) => (
  <SButton
    {...props}
    type={props.type}
    outline={props.outline}
    color={props.color}
    disabled={props.disabled}
    icon={props.icon}
    left={props.left}
  >
    <SHoverLayer />
    <SIcon />
    {props.fetching ? <Loader size={20} color="white" /> : props.children}
  </SButton>
);

Button.defaultProps = {
  fetching: false,
  outline: false,
  type: "button",
  color: "lightBlue",
  disabled: false,
  icon: null,
  left: false,
};

export default Button;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Column.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled } from "styled-components";

interface ColumnStyleProps {
  spanHeight: boolean;
  maxWidth: number;
  center: boolean;
  children?: React.ReactNode;
}

interface ColumnProps extends ColumnStyleProps {
  children: React.ReactNode;
}

const SColumn = styled.div<ColumnStyleProps>`
  position: relative;
  width: 100%;
  height: ${({ spanHeight }) => (spanHeight ? "100%" : "auto")};
  max-width: ${({ maxWidth }) => `${maxWidth}px`};
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: ${({ center }) => (center ? "center" : "flex-start")};
`;

const Column = (props: ColumnProps) => {
  const { children, spanHeight, maxWidth, center } = props;
  return (
    <SColumn {...props} spanHeight={spanHeight} maxWidth={maxWidth} center={center}>
      {children}
    </SColumn>
  );
};

Column.propTypes = {
  children: PropTypes.node.isRequired,
  spanHeight: PropTypes.bool,
  maxWidth: PropTypes.number,
  center: PropTypes.bool,
};

Column.defaultProps = {
  spanHeight: false,
  maxWidth: 600,
  center: false,
};

export default Column;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Header.tsx">
import { SessionTypes } from "@walletconnect/types";
import * as React from "react";
import styled from "styled-components";

import { fonts, responsive } from "../styles";
import Button from "./Button";

const SHeader = styled.div`
  margin-top: -1px;
  margin-bottom: 1px;
  width: 100%;
  height: 100px;
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 16px;
  @media screen and (${responsive.sm.max}) {
    font-size: ${fonts.size.small};
  }
`;

const SHeaderActions = styled.div`
  display: flex;
  & > button:first-child {
    margin-right: 10px !important;
  }
`;

const SActiveAccount = styled.div`
  display: flex;
  align-items: center;
  position: relative;
  font-weight: 500;
`;

const SActiveSession = styled(SActiveAccount as any)`
  flex-direction: column;
  text-align: left;
  align-items: flex-start;
  & p {
    font-size: 0.8em;
    margin: 0;
    padding: 0;
  }
  & p:nth-child(n + 2) {
    font-weight: bold;
  }
`;

interface HeaderProps {
  ping: () => Promise<void>;
  disconnect: () => Promise<void>;
  session: SessionTypes.Struct | undefined;
}

const Header = (props: HeaderProps) => {
  const { ping, disconnect, session } = props;
  return (
    <SHeader {...props}>
      {session ? (
        <>
          <SActiveSession>
            <p>{`Connected to`}</p>
            <p>{session.peer.metadata.name}</p>
          </SActiveSession>
          <SHeaderActions>
            <Button outline color="black" onClick={ping}>
              {"Ping"}
            </Button>
            <Button outline color="red" onClick={disconnect}>
              {"Disconnect"}
            </Button>
          </SHeaderActions>
        </>
      ) : null}
    </SHeader>
  );
};

export default Header;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Icon.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

interface IconStyleProps {
  size: number;
}

const SIcon = styled.img<IconStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
`;

const Icon = (props: any) => {
  const { src, fallback, size } = props;
  return (
    <SIcon
      {...props}
      src={src}
      size={size}
      onError={(event: any) => {
        if (fallback) {
          event.target.src = fallback;
        }
      }}
    />
  );
};

Icon.propTypes = {
  src: PropTypes.string,
  fallback: PropTypes.string,
  size: PropTypes.number,
};

Icon.defaultProps = {
  src: null,
  fallback: "",
  size: 20,
};

export default Icon;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Loader.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled, keyframes } from "styled-components";
import { colors } from "../styles";

const load = keyframes`
  0% {
    transform: scale(1.0);
  }
  5% {
    transform: scale(1.0);
  }
  50% {
    transform: scale(0.8);
  }
  95% {
    transform: scale(1.0);
  }
  100% {
    transform: scale(1.0);
  }
`;

interface LoaderStyleProps {
  size: number;
  children?: React.ReactNode;
  viewBox?: string;
}

interface LoaderProps extends LoaderStyleProps {
  color: string;
  rgb?: string;
}

const SLoader = styled.svg<LoaderStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  animation: ${load} 1s infinite cubic-bezier(0.25, 0, 0.75, 1);
  transform: translateZ(0);
`;

const Loader = (props: LoaderProps) => {
  const { size, color } = props;
  const rgb = props.rgb || `rgb(${colors[color]})`;
  return (
    <SLoader viewBox="0 0 186 187" size={size}>
      <g stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
        <path
          d="M60,10.34375 C32.3857625,10.34375 10,32.7295125 10,60.34375 L10,126.34375 C10,153.957987 32.3857625,176.34375 60,176.34375 L126,176.34375 C153.614237,176.34375 176,153.957987 176,126.34375 L176,60.34375 C176,32.7295125 153.614237,10.34375 126,10.34375 L60,10.34375 Z M60,0.34375 L126,0.34375 C159.137085,0.34375 186,27.206665 186,60.34375 L186,126.34375 C186,159.480835 159.137085,186.34375 126,186.34375 L60,186.34375 C26.862915,186.34375 0,159.480835 0,126.34375 L0,60.34375 C0,27.206665 26.862915,0.34375 60,0.34375 Z"
          id="Rectangle-Copy"
          fill={rgb}
          fillRule="nonzero"
        />
        <rect id="Rectangle" fill={rgb} x="44" y="44.34375" width="98" height="98" rx="35" />
      </g>
    </SLoader>
  );
};

Loader.propTypes = {
  size: PropTypes.number,
  color: PropTypes.string,
};

Loader.defaultProps = {
  size: 40,
  color: "lightBlue",
};

export default Loader;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Metadata.tsx">
import Head from "next/head";
import * as React from "react";
import { DEFAULT_APP_METADATA } from "../constants";

const Metadata = () => (
  <Head>
    <title>{DEFAULT_APP_METADATA.name}</title>
    <meta name="description" content={DEFAULT_APP_METADATA.description} />
    <meta name="url" content={DEFAULT_APP_METADATA.url} />

    {DEFAULT_APP_METADATA.icons.map((icon, index) => (
      <link key={index} rel="icon" href={icon} />
    ))}
  </Head>
);

export default Metadata;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Modal.tsx">
import React, { useEffect, useRef, useState } from "react";
import { styled } from "styled-components";
import { colors, transitions } from "../styles";

interface LightboxProps {
  show: boolean;
  offset: number;
  opacity?: number;
  children?: React.ReactNode;
  ref?: React.RefObject<HTMLDivElement>;
}

const SLightbox = styled.div<LightboxProps>`
  transition: opacity 0.1s ease-in-out;
  text-align: center;
  position: absolute;
  width: 100vw;
  height: 100%;
  margin-left: -50vw;
  top: ${({ offset }) => (offset ? `-${offset}px` : 0)};
  left: 50%;
  z-index: 2;
  will-change: opacity;
  background-color: ${({ opacity }) => {
    let alpha = 0.4;
    if (typeof opacity === "number") {
      alpha = opacity;
    }
    return `rgba(0, 0, 0, ${alpha})`;
  }};
  opacity: ${({ show }) => (show ? 1 : 0)};
  visibility: ${({ show }) => (show ? "visible" : "hidden")};
  pointer-events: ${({ show }) => (show ? "auto" : "none")};
  display: flex;
  justify-content: center;
  align-items: center;
`;

const SModalContainer = styled.div`
  position: relative;
  width: 100%;
  height: 100%;
  padding: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

interface HitboxProps {
  onClick?: () => void;
}

const SHitbox = styled.div<HitboxProps>`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
`;

interface CloseButtonStyleProps {
  size: number;
  color: string;
  onClick?: any;
}

const SCloseButton = styled.div<CloseButtonStyleProps>`
  transition: ${transitions.short};
  position: absolute;
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  right: ${({ size }) => `${size / 1.6667}px`};
  top: ${({ size }) => `${size / 1.6667}px`};
  opacity: 0.5;
  cursor: pointer;
  &:hover {
    opacity: 1;
  }
  &:before,
  &:after {
    position: absolute;
    content: " ";
    height: ${({ size }) => `${size}px`};
    width: 2px;
    background: ${({ color }) => `rgb(${colors[color]})`};
  }
  &:before {
    transform: rotate(45deg);
  }
  &:after {
    transform: rotate(-45deg);
  }
`;

const SCard = styled.div`
  position: relative;
  width: 100%;
  max-width: 500px;
  padding: 25px;
  background-color: rgb(${colors.white});
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;

const SModalContent = styled.div`
  position: relative;
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

interface IProps {
  children: React.ReactNode;
  show: boolean;
  closeModal: () => void;
  opacity?: number;
}

export default function Modal({ children, show, opacity, closeModal }: IProps) {
  const [offset, setOffset] = useState(0);
  const lightboxRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (lightboxRef.current) {
      const lightboxRect = lightboxRef.current.getBoundingClientRect();
      const nextOffset = lightboxRect.top > 0 ? lightboxRect.top : 0;

      if (nextOffset !== 0 && nextOffset !== offset) {
        setOffset(nextOffset);
      }
    }
  }, [offset]);

  return (
    <SLightbox show={show} offset={offset} opacity={opacity} ref={lightboxRef}>
      <SModalContainer>
        <SHitbox onClick={closeModal} />

        <SCard>
          <SCloseButton size={25} color={"dark"} onClick={closeModal} />
          <SModalContent>{children}</SModalContent>
        </SCard>
      </SModalContainer>
    </SLightbox>
  );
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Pairing.tsx">
import * as React from "react";
import styled from "styled-components";

import { PairingTypes } from "@walletconnect/types";

import Peer from "./Peer";

interface PairingProps {
  pairing: PairingTypes.Struct;
  onClick?: any;
}

const SPairingContainer = styled.div`
  width: 100%;
  cursor: pointer;
`;

const Pairing = (props: PairingProps) => {
  const { peerMetadata } = props.pairing;
  return (
    <SPairingContainer onClick={props.onClick}>
      <div>
        {typeof peerMetadata !== "undefined" ? (
          <Peer oneLiner metadata={peerMetadata} />
        ) : (
          <div>{`Unknown`}</div>
        )}
      </div>
    </SPairingContainer>
  );
};

export default Pairing;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Peer.tsx">
import * as React from "react";
import styled from "styled-components";
import { colors, fonts } from "../styles";
import { Metadata } from "@walletconnect/universal-provider";

const SPeerOneLiner = styled.div`
  display: flex;
  align-items: center;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;

  & img {
    width: 40px;
    height: 40px;
  }
  & > div {
    margin-left: 10px;
  }
`;

const SPeerCard = styled.div`
  align-items: center;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-direction: column;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;
  & > div {
    margin: 4px auto;
  }
`;

const SIcon = styled.img`
  width: 100px;
  margin: 0 auto;
`;

const SCenter = styled.div`
  text-align: center;
`;

const SUrl = styled(SCenter as any)`
  font-size: ${fonts.size.small};
  opacity: 0.8;
`;

const SName = styled(SCenter as any)`
  font-weight: bold;
`;

interface PeerProps {
  oneLiner?: boolean;
  metadata: Metadata;
}

const Peer = (props: PeerProps) =>
  props.oneLiner ? (
    <SPeerOneLiner>
      <img src={props.metadata.icons[0]} alt={props.metadata.name} />
      <div>{props.metadata.name}</div>
    </SPeerOneLiner>
  ) : (
    <SPeerCard>
      <SIcon src={props.metadata.icons[0]} alt={props.metadata.name} />
      <SName>{props.metadata.name}</SName>
      <SCenter>{props.metadata.description}</SCenter>
      <SUrl>{props.metadata.url}</SUrl>
    </SPeerCard>
  );

export default Peer;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Toggle.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

import { colors, transitions } from "../styles";

interface IToggleStyleProps {
  color: string;
  active: boolean;
}

const SToggle = styled.div<IToggleStyleProps>`
  position: relative;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  transition: ${transitions.base};
  & div {
    transition: ${transitions.base};
    appearance: none;
    transition: all 0.3s ease;
    box-shadow: ${({ active, color }) =>
      active
        ? `inset 0px 0px 0px 20px rgb(${colors[color]})`
        : `inset 0px 0px 0px 1px rgb(${colors.grey})`};
    border-radius: 1rem;
    background-color: rgb(${colors.white});
    padding: 1px;
    display: inline-block;
    width: 46px;
    height: 26px;
    position: relative;
    cursor: pointer;
    margin: 0px;
    vertical-align: bottom;
    outline: none;
    border: none;
  }
  & div:after {
    transition: ${transitions.base};
    box-shadow: inset 0 1px 0 rgb(${colors.grey}), 0px 2px 2px 1px rgba(${colors.black}, 0.2);
    border-radius: 1rem;
    left: ${({ active }) => (active ? `20px` : `0`)};
    content: "";
    position: absolute;
    width: 24px;
    height: 24px;
    cursor: pointer;
    background-color: rgb(${colors.white});
  }
`;

interface IToggleProps extends IToggleStyleProps {
  onClick?: any;
}

const Toggle = (props: IToggleProps) => (
  <SToggle color={props.color} active={props.active} onClick={props.onClick}>
    <div />
  </SToggle>
);

Toggle.propTypes = {
  active: PropTypes.bool,
  color: PropTypes.string,
  onClick: PropTypes.func,
};

Toggle.defaultProps = {
  active: false,
  color: "green",
};

export default Toggle;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/components/Wrapper.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled, { keyframes } from "styled-components";

const fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

interface WrapperStyleProps {
  center: boolean;
}

const SWrapper = styled.div<WrapperStyleProps>`
  will-change: transform, opacity;
  animation: ${fadeIn} 0.7s ease 0s normal 1;
  min-height: 200px;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: ${({ center }) => (center ? `center` : `flex-start`)};
`;

interface WrapperProps extends WrapperStyleProps {
  children: React.ReactNode;
}

const Wrapper = (props: WrapperProps) => {
  const { children, center } = props;
  return (
    <SWrapper {...props} center={center}>
      {children}
    </SWrapper>
  );
};

Wrapper.propTypes = {
  children: PropTypes.node.isRequired,
  center: PropTypes.bool,
};

Wrapper.defaultProps = {
  center: false,
};

export default Wrapper;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/constants/default.ts">
export const DEFAULT_MAIN_CHAINS = [
  // mainnets
  "cosmos:cosmoshub-4",
];

export const DEFAULT_TEST_CHAINS = [
  // testnets
];

export const DEFAULT_CHAINS = [...DEFAULT_MAIN_CHAINS, ...DEFAULT_TEST_CHAINS];

export const DEFAULT_PROJECT_ID = process.env.NEXT_PUBLIC_PROJECT_ID;

export const DEFAULT_INFURA_ID = process.env.NEXT_PUBLIC_INFURA_ID;

export const DEFAULT_RELAY_URL = process.env.NEXT_PUBLIC_RELAY_URL;

export const DEFAULT_EIP155_METHODS = ["eth_sendTransaction", "personal_sign", "eth_signTypedData"];

export const DEFAULT_COSMOS_METHODS = ["cosmos_signDirect", "cosmos_signAmino"];

export const DEFAULT_LOGGER = "debug";

export const DEFAULT_APP_METADATA = {
  name: "React App",
  description: "React App for WalletConnect",
  url: "https://walletconnect.com/",
  icons: ["https://avatars.githubusercontent.com/u/37784886"],
};
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/constants/index.ts">
export * from "./default";
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/contexts/ClientContext.tsx">
import { ISignClient, PairingTypes, SessionTypes } from "@walletconnect/types";
import UniversalProvider, { IUniversalProvider } from "@walletconnect/universal-provider";
import { Web3Modal } from "@web3modal/standalone";
import {
  createContext,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from "react";
import {
  DEFAULT_COSMOS_METHODS,
  DEFAULT_LOGGER,
  DEFAULT_PROJECT_ID,
  DEFAULT_RELAY_URL,
} from "../constants";
import { AccountBalances, ChainNamespaces, getAllChainNamespaces } from "../helpers";
import { CosmosChainData } from "../chains/cosmos";

/**
 * Types
 */
interface IContext {
  client: ISignClient | undefined;
  session: SessionTypes.Struct | undefined;
  disconnect: () => Promise<void>;
  isInitializing: boolean;
  chain: string;
  pairings: PairingTypes.Struct[];
  accounts: string[];
  balances: AccountBalances;
  chainData: ChainNamespaces;
  onEnable: (chainId: string) => Promise<void>;
  cosmosProvider?: IUniversalProvider;
}

/**
 * Context
 */
export const ClientContext = createContext<IContext>({} as IContext);

/**
 * Provider
 */
export function ClientContextProvider({ children }: { children: ReactNode | ReactNode[] }) {
  const [client, setClient] = useState<ISignClient>();
  const [pairings, setPairings] = useState<PairingTypes.Struct[]>([]);
  const [session, setSession] = useState<SessionTypes.Struct>();
  const [web3Modal, setWeb3Modal] = useState<Web3Modal>();

  const [cosmosProvider, setCosmosProvider] = useState<UniversalProvider>();

  const [isInitializing, setIsInitializing] = useState(false);
  const [hasCheckedPersistedSession, setHasCheckedPersistedSession] = useState(false);

  const [balances, setBalances] = useState<AccountBalances>({});
  const [accounts, setAccounts] = useState<string[]>([]);
  const [chainData, setChainData] = useState<ChainNamespaces>({});
  const [chain, setChain] = useState<string>("");

  const resetApp = () => {
    setPairings([]);
    setSession(undefined);
    setBalances({});
    setAccounts([]);
    setChain("");
  };

  const loadChainData = async () => {
    const namespaces = getAllChainNamespaces();
    const chainData: ChainNamespaces = {};
    await Promise.all(
      namespaces.map(async namespace => {
        let chains;
        switch (namespace) {
          case "cosmos":
            chains = CosmosChainData;
            break;

          default:
            console.error("Unknown chain namespace: ", namespace);
        }

        if (typeof chains !== "undefined") {
          chainData[namespace] = chains;
        }
      }),
    );
    setChainData(chainData);
  };

  const disconnect = useCallback(async () => {
    if (typeof cosmosProvider === "undefined") {
      throw new Error("cosmosProvider is not initialized");
    }
    cosmosProvider.disconnect();
    resetApp();
  }, [cosmosProvider]);

  const onSessionConnected = useCallback(async (_session: SessionTypes.Struct) => {
    setSession(_session);
  }, []);

  const _subscribeToProviderEvents = useCallback(
    async (provider: UniversalProvider) => {
      provider.on("display_uri", async (uri: string) => {
        console.log("EVENT", "QR Code Modal open", uri);
        web3Modal?.openModal({ uri });
      });

      provider.on("session_delete", () => {
        console.log("EVENT", "session_deleted");
        resetApp();
      });
    },
    [web3Modal],
  );

  const createClient = useCallback(async () => {
    try {
      setIsInitializing(true);

      const provider = await UniversalProvider.init({
        projectId: DEFAULT_PROJECT_ID,
        logger: DEFAULT_LOGGER,
        relayUrl: DEFAULT_RELAY_URL,
      });

      setCosmosProvider(provider);
      setClient(provider.client);

      const web3Modal = new Web3Modal({
        projectId: DEFAULT_PROJECT_ID || "",
        walletConnectVersion: 2,
      });

      setWeb3Modal(web3Modal);
    } catch (err) {
      throw err;
    } finally {
      setIsInitializing(false);
    }
  }, []);

  const onEnable = useCallback(
    async (caipChainId: string) => {
      if (!cosmosProvider) {
        throw new ReferenceError("WalletConnect Client is not initialized.");
      }

      const chainId = caipChainId.split(":").pop();

      if (!chainId) {
        throw new Error("Could not derive chainId from CAIP chainId");
      }

      console.log("Enabling cosmosProvider for chainId: ", chainId);

      //  Create WalletConnect Provider
      const session = await cosmosProvider.connect({
        namespaces: {
          cosmos: {
            methods: DEFAULT_COSMOS_METHODS,
            chains: [caipChainId],
            events: [],
          },
        },
      });

      const _accounts = await cosmosProvider.enable();
      setAccounts(_accounts);
      setSession(session);
      onSessionConnected(session!);
      setChain(caipChainId);

      web3Modal?.closeModal();
    },
    [cosmosProvider, onSessionConnected, web3Modal],
  );

  const _checkForPersistedSession = useCallback(
    async (provider: IUniversalProvider) => {
      if (!provider) {
        throw new Error("Universal Provider is not initialized");
      }
      // populates existing pairings to state
      setPairings(provider.client!.pairing.getAll({ active: true }));
      if (typeof session !== "undefined") return;
      // populates existing session to state (assume only the top one)
      if (provider.session) {
        console.log("provider.session", provider.session);
        const session = provider.session;

        const accounts = session.namespaces[Object.keys(session.namespaces)[0]].accounts;
        const [namespace, chainId] = accounts[0].split(":");
        const caipChainId = `${namespace}:${chainId}`;
        setAccounts(accounts);
        setSession(session);
        setChain(caipChainId);
        onSessionConnected(session!);
      }
    },
    [session, onSessionConnected],
  );

  useEffect(() => {
    loadChainData();
  }, []);

  useEffect(() => {
    if (!client) {
      createClient();
    }
  }, [client, createClient]);

  useEffect(() => {
    if (cosmosProvider && web3Modal) _subscribeToProviderEvents(cosmosProvider);
  }, [_subscribeToProviderEvents, cosmosProvider, web3Modal]);

  useEffect(() => {
    const getPersistedSession = async () => {
      if (cosmosProvider && !hasCheckedPersistedSession) {
        await _checkForPersistedSession(cosmosProvider);
        setHasCheckedPersistedSession(true);
      }
    };

    getPersistedSession();
  }, [cosmosProvider, _checkForPersistedSession, hasCheckedPersistedSession]);

  const value = useMemo(
    () => ({
      pairings,
      isInitializing,
      balances,
      accounts,
      chain,
      client,
      session,
      disconnect,
      chainData,
      onEnable,
      cosmosProvider,
    }),
    [
      pairings,
      isInitializing,
      balances,
      accounts,
      chain,
      client,
      session,
      disconnect,
      chainData,
      onEnable,
      cosmosProvider,
    ],
  );

  return (
    <ClientContext.Provider
      value={{
        ...value,
      }}
    >
      {children}
    </ClientContext.Provider>
  );
}

export function useWalletConnectClient() {
  const context = useContext(ClientContext);
  if (context === undefined) {
    throw new Error("useWalletConnectClient must be used within a ClientContextProvider");
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/helpers/api.ts">
import axios, { AxiosInstance } from "axios";

export type RpcProvidersByChainId = Record<
  number,
  {
    name: string;
    baseURL: string;
    token: {
      name: string;
      symbol: string;
    };
  }
>;

const WALLETCONNECT_RPC_BASE_URL = `https://rpc.walletconnect.com/v1?projectId=${process.env.NEXT_PUBLIC_PROJECT_ID}`;

export const rpcProvidersByChainId: RpcProvidersByChainId = {
  1: {
    name: "Ethereum Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:1",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  5: {
    name: "Ethereum Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:5",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  137: {
    name: "Polygon Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:137",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  280: {
    name: "zkSync Era Testnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:280",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  324: {
    name: "zkSync Era",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:324",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  80001: {
    name: "Polygon Mumbai",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:80001",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  10: {
    name: "Optimism",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:10",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  420: {
    name: "Optimism Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:420",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  42161: {
    name: "Arbitrum",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:42161",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  421611: {
    name: "Arbitrum Rinkeby",
    baseURL: "https://rinkeby.arbitrum.io/rpc",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  100: {
    name: "xDAI",
    baseURL: "https://xdai-archive.blockscout.com",
    token: {
      name: "xDAI",
      symbol: "xDAI",
    },
  },
  42220: {
    name: "Celo",
    baseURL: "https://rpc.walletconnect.com/v1",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
  44787: {
    name: "Celo Alfajores",
    baseURL: "https://alfajores-forno.celo-testnet.org",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
};

const api: AxiosInstance = axios.create({
  baseURL: "https://rpc.walletconnect.com/v1",
  timeout: 10000, // 10 secs
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json",
  },
});

export const apiGetAccountNonce = async (address: string, chainId: string): Promise<number> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_getTransactionCount",
    params: [address, "latest"],
    id: 1,
  });
  const { result } = response.data;
  const nonce = parseInt(result, 16);
  return nonce;
};

export const apiGetGasPrice = async (chainId: string): Promise<string> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_gasPrice",
    params: [],
    id: 1,
  });
  const { result } = response.data;
  return result;
};
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/helpers/eip1271.ts">
import { Contract, providers, utils } from "ethers";

const spec = {
  magicValue: "0x1626ba7e",
  abi: [
    {
      constant: true,
      inputs: [
        {
          name: "_hash",
          type: "bytes32",
        },
        {
          name: "_sig",
          type: "bytes",
        },
      ],
      name: "isValidSignature",
      outputs: [
        {
          name: "magicValue",
          type: "bytes4",
        },
      ],
      payable: false,
      stateMutability: "view",
      type: "function",
    },
  ],
};

async function isValidSignature(
  address: string,
  sig: string,
  data: string,
  provider: providers.Provider,
  abi = eip1271.spec.abi,
  magicValue = eip1271.spec.magicValue,
): Promise<boolean> {
  let returnValue;
  try {
    returnValue = await new Contract(address, abi, provider).isValidSignature(
      utils.arrayify(data),
      sig,
    );
  } catch (e) {
    return false;
  }
  return returnValue.toLowerCase() === magicValue.toLowerCase();
}

export const eip1271 = {
  spec,
  isValidSignature,
};
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/helpers/eip712.ts">
const example = {
  types: {
    EIP712Domain: [
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "verifyingContract", type: "address" },
    ],
    RelayRequest: [
      { name: "target", type: "address" },
      { name: "encodedFunction", type: "bytes" },
      { name: "gasData", type: "GasData" },
      { name: "relayData", type: "RelayData" },
    ],
    GasData: [
      { name: "gasLimit", type: "uint256" },
      { name: "gasPrice", type: "uint256" },
      { name: "pctRelayFee", type: "uint256" },
      { name: "baseRelayFee", type: "uint256" },
    ],
    RelayData: [
      { name: "senderAddress", type: "address" },
      { name: "senderNonce", type: "uint256" },
      { name: "relayWorker", type: "address" },
      { name: "paymaster", type: "address" },
    ],
  },
  domain: {
    name: "GSN Relayed Transaction",
    version: "1",
    chainId: 42,
    verifyingContract: "0x6453D37248Ab2C16eBd1A8f782a2CBC65860E60B",
  },
  primaryType: "RelayRequest",
  message: {
    target: "0x9cf40ef3d1622efe270fe6fe720585b4be4eeeff",
    encodedFunction:
      "0xa9059cbb0000000000000000000000002e0d94754b348d208d64d52d78bcd443afa9fa520000000000000000000000000000000000000000000000000000000000000007",
    gasData: { gasLimit: "39507", gasPrice: "1700000000", pctRelayFee: "70", baseRelayFee: "0" },
    relayData: {
      senderAddress: "0x22d491bde2303f2f43325b2108d26f1eaba1e32b",
      senderNonce: "3",
      relayWorker: "0x3baee457ad824c94bd3953183d725847d023a2cf",
      paymaster: "0x957F270d45e9Ceca5c5af2b49f1b5dC1Abb0421c",
    },
  },
};

export const eip712 = {
  example,
};
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/helpers/index.ts">
export * from "./api";
export * from "./eip712";
export * from "./eip1271";
export * from "./tx";
export * from "./types";
export * from "./utilities";
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/helpers/tx.ts">
import * as encoding from "@walletconnect/encoding";

import { apiGetAccountNonce, apiGetGasPrice } from "./api";

export async function getGasPrice(chainId: string): Promise<string> {
  const gasPrice = await apiGetGasPrice(chainId);
  return gasPrice;
}

export async function formatTestTransaction(account: string) {
  const [namespace, reference, address] = account.split(":");
  const chainId = `${namespace}:${reference}`;
  // nonce
  const _nonce = await apiGetAccountNonce(address, chainId);

  const nonce = encoding.sanitizeHex(encoding.numberToHex(_nonce));

  // gasPrice
  const _gasPrice = await getGasPrice(chainId);
  const gasPrice = encoding.sanitizeHex(_gasPrice);

  // gasLimit
  const _gasLimit = 21000;
  const gasLimit = encoding.sanitizeHex(encoding.numberToHex(_gasLimit));

  // value
  const _value = 0;
  const value = encoding.sanitizeHex(encoding.numberToHex(_value));

  const tx = { from: address, to: address, data: "0x", nonce, gasPrice, gasLimit, value };

  return tx;
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/helpers/types.ts">
export interface AssetData {
  account: string;
  symbol: string;
  balance: string;
  contractAddress?: string;
}

export interface ChainData {
  name: string;
  short_name: string;
  chain: string;
  network: string;
  chain_id: number;
  network_id: number;
  rpc_url: string;
  native_currency: AssetData;
}
export interface TxData {
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasLimit: string;
  value: string;
  data: string;
}

export interface BlockScoutTx {
  value: string;
  txreceipt_status: string;
  transactionIndex: string;
  to: string;
  timeStamp: string;
  nonce: string;
  isError: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface BlockScoutTokenTx {
  value: string;
  transactionIndex: string;
  tokenSymbol: string;
  tokenName: string;
  tokenDecimal: string;
  to: string;
  timeStamp: string;
  nonce: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface ParsedTx {
  timestamp: string;
  hash: string;
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasUsed: string;
  fee: string;
  value: string;
  input: string;
  error: boolean;
  asset: AssetData;
  operations: TxOperation[];
}

export interface TxOperation {
  asset: AssetData;
  value: string;
  from: string;
  to: string;
  functionName: string;
}

export interface GasPricesResponse {
  fastWait: number;
  avgWait: number;
  blockNum: number;
  fast: number;
  fastest: number;
  fastestWait: number;
  safeLow: number;
  safeLowWait: number;
  speed: number;
  block_time: number;
  average: number;
}

export interface GasPrice {
  time: number;
  price: number;
}

export interface GasPrices {
  timestamp: number;
  slow: GasPrice;
  average: GasPrice;
  fast: GasPrice;
}

export interface MethodArgument {
  type: string;
}

export interface Method {
  signature: string;
  name: string;
  args: MethodArgument[];
}

export interface ChainRequestRender {
  label: string;
  value: string;
}

export interface ChainMetadata {
  name?: string;
  logo: string;
  rgb: string;
}

export interface NamespaceMetadata {
  [reference: string]: ChainMetadata;
}
export interface ChainNamespaces {
  [namespace: string]: {
    [reference: string]: {
      name: string;
      id: string;
      rpc: string[];
      slip44: number;
      testnet: boolean;
    };
  };
}

export interface AccountAction {
  method: string;
  callback: (account: string) => Promise<void>;
}

export interface AccountBalances {
  [account: string]: AssetData;
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/helpers/utilities.ts">
import { BigNumber, BigNumberish, providers, utils } from "ethers";
import * as encoding from "@walletconnect/encoding";
import { TypedDataUtils } from "eth-sig-util";
import * as ethUtil from "ethereumjs-util";

import { eip1271 } from "./eip1271";
import { DEFAULT_CHAINS } from "../constants";

export function capitalize(string: string): string {
  return string
    .split(" ")
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(" ");
}

export function ellipseText(text = "", maxLength = 9999): string {
  if (text.length <= maxLength) {
    return text;
  }
  const _maxLength = maxLength - 3;
  let ellipse = false;
  let currentLength = 0;
  const result =
    text
      .split(" ")
      .filter(word => {
        currentLength += word.length;
        if (ellipse || currentLength >= _maxLength) {
          ellipse = true;
          return false;
        } else {
          return true;
        }
      })
      .join(" ") + "...";
  return result;
}

export function ellipseAddress(address = "", width = 10): string {
  return `${address.slice(0, width)}...${address.slice(-width)}`;
}

export function getDataString(func: string, arrVals: any[]): string {
  let val = "";
  for (let i = 0; i < arrVals.length; i++) {
    val += encoding.padLeft(arrVals[i], 64);
  }
  const data = func + val;
  return data;
}

export function isMobile(): boolean {
  let mobile = false;

  function hasTouchEvent(): boolean {
    try {
      document.createEvent("TouchEvent");
      return true;
    } catch (e) {
      return false;
    }
  }

  function hasMobileUserAgent(): boolean {
    if (
      /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
        navigator.userAgent,
      ) ||
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
        navigator.userAgent.substr(0, 4),
      )
    ) {
      return true;
    } else if (hasTouchEvent()) {
      return true;
    }
    return false;
  }

  mobile = hasMobileUserAgent();

  return mobile;
}

export function encodePersonalMessage(msg: string): string {
  const data = encoding.utf8ToBuffer(msg);
  const buf = Buffer.concat([
    Buffer.from("\u0019Ethereum Signed Message:\n" + data.length.toString(), "utf8"),
    data,
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashPersonalMessage(msg: string): string {
  const data = encodePersonalMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function encodeTypedDataMessage(msg: string): string {
  const data = TypedDataUtils.sanitizeData(JSON.parse(msg));
  const buf = Buffer.concat([
    Buffer.from("1901", "hex"),
    TypedDataUtils.hashStruct("EIP712Domain", data.domain, data.types),
    TypedDataUtils.hashStruct(data.primaryType as string, data.message, data.types),
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashTypedDataMessage(msg: string): string {
  const data = encodeTypedDataMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function recoverAddress(sig: string, hash: string): string {
  const params = ethUtil.fromRpcSig(sig);
  const result = ethUtil.ecrecover(ethUtil.toBuffer(hash), params.v, params.r, params.s);
  const signer = ethUtil.bufferToHex(ethUtil.publicToAddress(result));
  return signer;
}

export function recoverPersonalSignature(sig: string, msg: string): string {
  const hash = hashPersonalMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export function recoverTypedMessage(sig: string, msg: string): string {
  const hash = hashTypedDataMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export async function verifySignature(
  address: string,
  sig: string,
  hash: string,
  rpcUrl: string,
): Promise<boolean> {
  const provider = new providers.JsonRpcProvider(rpcUrl);
  const bytecode = await provider.getCode(address);
  if (!bytecode || bytecode === "0x" || bytecode === "0x0" || bytecode === "0x00") {
    const signer = recoverAddress(sig, hash);
    return signer.toLowerCase() === address.toLowerCase();
  } else {
    return eip1271.isValidSignature(address, sig, hash, provider);
  }
}

export function convertHexToNumber(hex: string) {
  try {
    return encoding.hexToNumber(hex);
  } catch (e) {
    return hex;
  }
}

export function convertHexToUtf8(hex: string) {
  try {
    return encoding.hexToUtf8(hex);
  } catch (e) {
    return hex;
  }
}

export const sanitizeDecimals = (value: string, decimals = 18): string => {
  const [integer, fractional] = value.split(".");
  const _fractional = fractional
    ? fractional.substring(0, decimals).replace(/0+$/gi, "")
    : undefined;
  return _fractional ? [integer, _fractional].join(".") : integer;
};

export const toWad = (amount: string, decimals = 18): BigNumber => {
  return utils.parseUnits(sanitizeDecimals(amount, decimals), decimals);
};

export const fromWad = (wad: BigNumberish, decimals = 18): string => {
  return sanitizeDecimals(utils.formatUnits(wad, decimals), decimals);
};

export const LOCALSTORAGE_KEY_TESTNET = "TESTNET";
export const INITIAL_STATE_TESTNET_DEFAULT = true;

export function setLocaleStorageTestnetFlag(value: boolean): void {
  window.localStorage.setItem(LOCALSTORAGE_KEY_TESTNET, `${value}`);
}

export function getLocalStorageTestnetFlag(): boolean {
  let value = INITIAL_STATE_TESTNET_DEFAULT;
  const persisted = window.localStorage.getItem(LOCALSTORAGE_KEY_TESTNET);
  if (!persisted) {
    setLocaleStorageTestnetFlag(value);
  } else {
    value = persisted === "true" ? true : false;
  }
  return value;
}

export const getAllChainNamespaces = () => {
  const namespaces: string[] = [];
  DEFAULT_CHAINS.forEach(chainId => {
    const [namespace] = chainId.split(":");
    if (!namespaces.includes(namespace)) {
      namespaces.push(namespace);
    }
  });
  return namespaces;
};
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/modals/shared/index.ts">
import styled from "styled-components";

export const SModalContainer = styled.div`
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

export const SModalTitle = styled.div`
  margin: 1em 0;
  font-size: 20px;
  font-weight: 700;
`;

export const SModalParagraph = styled.p`
  margin-top: 30px;
`;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/modals/PairingModal.tsx">
import * as React from "react";

import { PairingTypes } from "@walletconnect/types";

import Button from "../components/Button";
import Pairing from "../components/Pairing";
import { STable } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";

interface PairingModalProps {
  pairings: PairingTypes.Struct[];
  connect: (pairing?: { topic: string }) => Promise<void>;
}

const PairingModal = (props: PairingModalProps) => {
  const { pairings, connect } = props;
  return (
    <SModalContainer>
      <SModalTitle>{"Select available pairing or create new one"}</SModalTitle>
      <STable>
        {pairings.map(pairing => (
          <Pairing
            key={pairing.topic}
            pairing={pairing}
            onClick={() => connect({ topic: pairing.topic })}
          />
        ))}
      </STable>
      <Button onClick={() => connect()}>{`New Pairing`}</Button>
    </SModalContainer>
  );
};

export default PairingModal;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/modals/PingModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";

interface PingModalProps {
  pending: boolean;
  result: any;
}

const PingModal = (props: PingModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending Session Ping"}</SModalTitle>
          <SContainer>
            <Loader />
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid ? "Successful Session Ping" : "Failed Session Ping"}
          </SModalTitle>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"Unknown Error with Session Ping"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default PingModal;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/modals/RequestModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer, STable, SRow, SKey, SValue } from "../components/shared";

import { SModalContainer, SModalTitle, SModalParagraph } from "./shared";

interface RequestModalProps {
  pending: boolean;
  result: any;
}

const RequestModal = (props: RequestModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending JSON-RPC Request"}</SModalTitle>
          <SContainer>
            <Loader />
            <SModalParagraph>{"Approve or reject request using your wallet"}</SModalParagraph>
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid ? "JSON-RPC Request Approved" : "JSON-RPC Request Failed"}
          </SModalTitle>
          <STable>
            {Object.keys(result).map(key => (
              <SRow key={key}>
                <SKey>{key}</SKey>
                <SValue>{result[key].toString()}</SValue>
              </SRow>
            ))}
          </STable>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"JSON-RPC Request Rejected"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default RequestModal;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/pages/_app.tsx">
import "../styles/globals.css";
import type { AppProps } from "next/app";
import { createGlobalStyle } from "styled-components";
import { ClientContextProvider } from "../contexts/ClientContext";
import Metadata from "../components/Metadata";

import { globalStyle } from "./../styles";
const GlobalStyle = createGlobalStyle`
  ${globalStyle}
`;

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Metadata />
      <GlobalStyle />
      <ClientContextProvider>
        <Component {...pageProps} />
      </ClientContextProvider>
    </>
  );
}

export default MyApp;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/pages/_error.tsx">
export default function Error() {
  return <div>An error as occured</div>;
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/pages/404.tsx">
export default function FourOhFour() {
  return <h1>404 Page Not Found</h1>;
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/pages/index.tsx">
import React, { useState } from "react";
import { RELAYER_SDK_VERSION as version } from "@walletconnect/core";
import {
  formatDirectSignDoc,
  stringifySignDocValues,
  verifyAminoSignature,
  verifyDirectSignature,
} from "cosmos-wallet";

import Banner from "./../components/Banner";
import Blockchain from "./../components/Blockchain";
import Column from "./../components/Column";
import Header from "./../components/Header";
import Modal from "./../components/Modal";
import { DEFAULT_MAIN_CHAINS } from "./../constants";
import { AccountAction } from "./../helpers";
import RequestModal from "./../modals/RequestModal";
import PingModal from "./../modals/PingModal";
import {
  SAccounts,
  SAccountsContainer,
  SButtonContainer,
  SContent,
  SLanding,
  SLayout,
} from "./../components/app";
import { useWalletConnectClient } from "./../contexts/ClientContext";

interface IFormattedRpcResponse {
  method?: string;
  address?: string;
  valid?: boolean;
  result: string;
}

interface CosmosRpcResponse {
  pub_key: {
    type: string;
    value: string;
  };
  signature: string;
}

export default function App() {
  const [isRpcRequestPending, setIsRpcRequestPending] = useState(false);
  const [rpcResult, setRpcResult] = useState<IFormattedRpcResponse | null>();

  const [modal, setModal] = useState("");

  const closeModal = () => setModal("");
  const openPingModal = () => setModal("ping");
  const openRequestModal = () => setModal("request");

  // Initialize the WalletConnect client.
  const {
    client,
    session,
    disconnect,
    chain,
    accounts,
    balances,
    chainData,
    isInitializing,
    onEnable,
    cosmosProvider,
  } = useWalletConnectClient();

  const ping = async () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect Client is not initialized");
    }

    try {
      setIsRpcRequestPending(true);
      const session = cosmosProvider?.session;
      if (!session) return;
      await cosmosProvider.client?.ping({ topic: session.topic! });
      setRpcResult({
        address: "",
        method: "ping",
        valid: true,
        result: "success",
      });
    } catch (error) {
      console.error("RPC request failed:", error);
    } finally {
      setIsRpcRequestPending(false);
    }
  };

  const onPing = async () => {
    openPingModal();
    await ping();
  };

  const testSignDirect: (account: string) => Promise<IFormattedRpcResponse> = async account => {
    if (!cosmosProvider) {
      throw new Error("cosmosProvider not connected");
    }

    // test direct sign doc inputs
    const inputs = {
      fee: [{ amount: "2000", denom: "ucosm" }],
      pubkey: "AgSEjOuOr991QlHCORRmdE5ahVKeyBrmtgoYepCpQGOW",
      gasLimit: 200000,
      accountNumber: 1,
      sequence: 1,
      bodyBytes:
        "0a90010a1c2f636f736d6f732e62616e6b2e763162657461312e4d736753656e6412700a2d636f736d6f7331706b707472653766646b6c366766727a6c65736a6a766878686c63337234676d6d6b38727336122d636f736d6f7331717970717870713971637273737a673270767871367273307a716733797963356c7a763778751a100a0575636f736d120731323334353637",
      authInfoBytes:
        "0a500a460a1f2f636f736d6f732e63727970746f2e736563703235366b312e5075624b657912230a21034f04181eeba35391b858633a765c4a0c189697b40d216354d50890d350c7029012040a020801180112130a0d0a0575636f736d12043230303010c09a0c",
    };

    // format sign doc
    const signDoc = formatDirectSignDoc(
      inputs.fee,
      inputs.pubkey,
      inputs.gasLimit,
      inputs.accountNumber,
      inputs.sequence,
      inputs.bodyBytes,
      "cosmoshub-4",
    );

    const address = account.split(":").pop();

    if (!address) {
      throw new Error(`Could not derive address from account: ${account}`);
    }

    // cosmos_signDirect params
    const params = {
      signerAddress: address,
      signDoc: stringifySignDocValues(signDoc),
    };

    const result = await cosmosProvider.request<CosmosRpcResponse>({
      method: "cosmos_signDirect",
      params,
    });

    const valid = await verifyDirectSignature(address, result.signature, signDoc);

    return {
      method: "cosmos_signDirect",
      address,
      valid,
      result: result.signature,
    };
  };

  const testSignAmino: (account: string) => Promise<IFormattedRpcResponse> = async account => {
    if (!cosmosProvider) {
      throw new Error("cosmosProvider not connected");
    }

    // test amino sign doc
    const signDoc = {
      msgs: [],
      fee: { amount: [], gas: "23" },
      chain_id: "foochain",
      memo: "hello, world",
      account_number: "7",
      sequence: "54",
    };

    const address = account.split(":").pop();

    if (!address) {
      throw new Error(`Could not derive address from account: ${account}`);
    }

    // cosmos_signAmino params
    const params = { signerAddress: address, signDoc };

    const result = await cosmosProvider.request<CosmosRpcResponse>({
      method: "cosmos_signAmino",
      params,
    });

    const valid = await verifyAminoSignature(address, result.signature, signDoc);

    return {
      method: "cosmos_signAmino",
      address,
      valid,
      result: result.signature,
    };
  };

  const getCosmosActions = (): AccountAction[] => {
    const wrapRpcRequest =
      (rpcRequest: (account: string) => Promise<IFormattedRpcResponse>) =>
      async (account: string) => {
        openRequestModal();
        try {
          setIsRpcRequestPending(true);
          const result = await rpcRequest(account);
          setRpcResult(result);
        } catch (error) {
          console.error("RPC request failed:", error);
          setRpcResult({ result: (error as Error).message as string });
        } finally {
          setIsRpcRequestPending(false);
        }
      };

    return [
      { method: "cosmos_signDirect", callback: wrapRpcRequest(testSignDirect) },
      { method: "cosmos_signAmino", callback: wrapRpcRequest(testSignAmino) },
    ];
  };

  // Renders the appropriate model for the given request that is currently in-flight.
  const renderModal = () => {
    switch (modal) {
      case "request":
        return <RequestModal pending={isRpcRequestPending} result={rpcResult} />;
      case "ping":
        return <PingModal pending={isRpcRequestPending} result={rpcResult} />;
      default:
        return null;
    }
  };

  const renderContent = () => {
    const chainOptions = DEFAULT_MAIN_CHAINS;
    return !accounts.length && !Object.keys(balances).length ? (
      <SLanding center>
        <Banner />
        <h6>
          <span>{`Using v${version}`}</span>
        </h6>
        <SButtonContainer>
          <h6>Select Cosmos chain:</h6>
          {chainOptions.map(chainId => (
            <Blockchain key={chainId} chainId={chainId} chainData={chainData} onClick={onEnable} />
          ))}
        </SButtonContainer>
      </SLanding>
    ) : (
      <SAccountsContainer>
        <h3>Account</h3>
        <SAccounts>
          {accounts.map(account => {
            return (
              <Blockchain
                key={account}
                active={true}
                chainData={chainData}
                address={account}
                chainId={chain}
                balances={balances}
                actions={getCosmosActions()}
              />
            );
          })}
        </SAccounts>
      </SAccountsContainer>
    );
  };

  return (
    <SLayout>
      <Column maxWidth={1000} spanHeight>
        <Header ping={onPing} disconnect={disconnect} session={session} />
        <SContent>{isInitializing ? "Loading..." : renderContent()}</SContent>
      </Column>
      <Modal show={!!modal} closeModal={closeModal}>
        {renderModal()}
      </Modal>
    </SLayout>
  );
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/styles/globals.css">
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
  body {
    color: white;
    background: black;
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/styles/Home.module.css">
.container {
  padding: 0 2rem;
}

.main {
  min-height: 100vh;
  padding: 4rem 0;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.footer {
  display: flex;
  flex: 1;
  padding: 2rem 0;
  border-top: 1px solid #eaeaea;
  justify-content: center;
  align-items: center;
}

.footer a {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-grow: 1;
}

.title a {
  color: #0070f3;
  text-decoration: none;
}

.title a:hover,
.title a:focus,
.title a:active {
  text-decoration: underline;
}

.title {
  margin: 0;
  line-height: 1.15;
  font-size: 4rem;
}

.title,
.description {
  text-align: center;
}

.description {
  margin: 4rem 0;
  line-height: 1.5;
  font-size: 1.5rem;
}

.code {
  background: #fafafa;
  border-radius: 5px;
  padding: 0.75rem;
  font-size: 1.1rem;
  font-family: Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono,
    Bitstream Vera Sans Mono, Courier New, monospace;
}

.grid {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  max-width: 800px;
}

.card {
  margin: 1rem;
  padding: 1.5rem;
  text-align: left;
  color: inherit;
  text-decoration: none;
  border: 1px solid #eaeaea;
  border-radius: 10px;
  transition: color 0.15s ease, border-color 0.15s ease;
  max-width: 300px;
}

.card:hover,
.card:focus,
.card:active {
  color: #0070f3;
  border-color: #0070f3;
}

.card h2 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.card p {
  margin: 0;
  font-size: 1.25rem;
  line-height: 1.5;
}

.logo {
  height: 1em;
  margin-left: 0.5rem;
}

@media (max-width: 600px) {
  .grid {
    width: 100%;
    flex-direction: column;
  }
}

@media (prefers-color-scheme: dark) {
  .card,
  .footer {
    border-color: #222;
  }
  .code {
    background: #111;
  }
  .logo img {
    filter: invert(1);
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/react-app-env.d.ts">
/// <reference types="react-scripts" />
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/src/styles.ts">
export const colors: Record<string, string> = {
  white: "255, 255, 255",
  black: "0, 0, 0",
  dark: "12, 12, 13",
  grey: "169, 169, 188",
  darkGrey: "113, 119, 138",
  lightGrey: "212, 212, 212",
  blue: "101, 127, 230",
  lightBlue: "64, 153, 255",
  yellow: "250, 188, 45",
  orange: "246, 133, 27",
  green: "84, 209, 146",
  pink: "255, 51, 102",
  red: "214, 75, 71",
  purple: "110, 107, 233",
};

export const fonts = {
  size: {
    tiny: "10px",
    small: "14px",
    medium: "16px",
    large: "18px",
    h1: "60px",
    h2: "50px",
    h3: "40px",
    h4: "32px",
    h5: "24px",
    h6: "20px",
  },
  weight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
  },
  family: {
    OpenSans: `"Open Sans", sans-serif`,
  },
};

export const transitions = {
  short: "all 0.1s ease-in-out",
  base: "all 0.2s ease-in-out",
  long: "all 0.3s ease-in-out",
  button: "all 0.15s ease-in-out",
};

export const shadows = {
  soft: "0 4px 6px 0 rgba(50, 50, 93, 0.11), 0 1px 3px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
  medium:
    "0 3px 6px 0 rgba(0, 0, 0, 0.06), 0 0 1px 0 rgba(50, 50, 93, 0.02), 0 5px 10px 0 rgba(59, 59, 92, 0.08)",
  big: "0 15px 35px 0 rgba(50, 50, 93, 0.06), 0 5px 15px 0 rgba(50, 50, 93, 0.15)",
  hover:
    "0 7px 14px 0 rgba(50, 50, 93, 0.1), 0 3px 6px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
};

export const responsive = {
  xs: {
    min: "min-width: 467px",
    max: "max-width: 468px",
  },
  sm: {
    min: "min-width: 639px",
    max: "max-width: 640px",
  },
  md: {
    min: "min-width: 959px",
    max: "max-width: 960px",
  },
  lg: {
    min: "min-width: 1023px",
    max: "max-width: 1024px",
  },
  xl: {
    min: "min-width: 1399px",
    max: "max-width: 1400px",
  },
};

export const globalStyle = `

  html, body, #root {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: ${fonts.family.OpenSans};
    font-style: normal;
    font-stretch: normal;
    font-weight: ${fonts.weight.normal};
    font-size: ${fonts.size.medium};
    background-color: rgb(${colors.white});
    color: rgb(${colors.dark});
    overflow-y:auto;
    text-rendering: optimizeLegibility;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  	-webkit-text-size-adjust: 100%;
    -webkit-overflow-scrolling: touch;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;  
  }

  button {
    border-style: none;
    line-height: 1em;
    background-image: none;
    outline: 0;
    -webkit-box-shadow: none;
            box-shadow: none;
  }

  [tabindex] {
    outline: none;
    width: 100%;
    height: 100%;
  }

  a, p, h1, h2, h3, h4, h5, h6 {
  	text-decoration: none;
  	margin: 0;
    padding: 0;
    margin: 0.7em 0;
  }

  h1 {
    font-size: ${fonts.size.h1}
  }
  h2 {
    font-size: ${fonts.size.h2}
  }
  h3 {
    font-size: ${fonts.size.h3}
  }
  h4 {
    font-size: ${fonts.size.h4}
  }
  h5 {
    font-size: ${fonts.size.h5}
  }
  h6 {
    font-size: ${fonts.size.h6}
  }

  a {
    background-color: transparent;
    -webkit-text-decoration-skip: objects;  
    text-decoration: none;
    color: inherit;
    outline: none;
  }

  b,
  strong {
    font-weight: inherit;
    font-weight: bolder;
  }

  ul, li {
  	list-style: none;
  	margin: 0;
  	padding: 0;
  }

  * {
    box-sizing: border-box !important;
  }


  input {
    -webkit-appearance: none;
  }

  article,
  aside,
  details,
  figcaption,
  figure,
  footer,
  header,
  main,
  menu,
  nav,
  section,
  summary {
    display: block;
  }
  audio,
  canvas,
  progress,
  video {
    display: inline-block;
  }

  input[type="color"],
  input[type="date"],
  input[type="datetime"],
  input[type="datetime-local"],
  input[type="email"],
  input[type="month"],
  input[type="number"],
  input[type="password"],
  input[type="search"],
  input[type="tel"],
  input[type="text"],
  input[type="time"],
  input[type="url"],
  input[type="week"],
  select:focus,
  textarea {
    font-size: 16px;
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/.env.local.example">
REACT_APP_PROJECT_ID=39bc93c...
REACT_APP_INFURA_ID=5dc0df...
REACT_APP_RELAY_URL=wss://relay.walletconnect.com
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

.eslintcache
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/.prettierrc">
{
  "tabWidth": 2,
  "useTabs": false,
  "trailingComma": "all",
  "printWidth": 100,
  "arrowParens": "avoid"
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/images.d.ts">
declare module "*.svg";
declare module "*.png";
declare module "*.jpg";
declare module "*.jpeg";
declare module "*.gif";
declare module "*.bmp";
declare module "*.tiff";
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/LICENSE">
MIT License

Copyright (c) 2021 WalletConnect, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  distDir: "build",
  webpack(config) {
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
    };

    return config;
  },
};

module.exports = nextConfig;
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/package.json">
{
  "name": "react-dapp-v2-cosmos",
  "version": "2.0.0-beta.26",
  "private": true,
  "keywords": [
    "walletconnect",
    "ethereum",
    "web3",
    "crypto"
  ],
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "license": "MIT",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prettier": "prettier --check '**/*.{js,ts,jsx,tsx}'"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/walletconnect/walletconnect-monorepo.git"
  },
  "bugs": {
    "url": "https://github.com/walletconnect/walletconnect-monorepo/issues"
  },
  "resolutions": {
    "react-error-overlay": "6.0.11"
  },
  "dependencies": {
    "@ethereumjs/tx": "^3.5.0",
    "@kadena/pactjs": "^0.4.3",
    "@noble/secp256k1": "^2.2.3",
    "@walletconnect/core": "^2.19.1",
    "@walletconnect/encoding": "^1.0.1",
    "@walletconnect/jsonrpc-utils": "^1.0.8",
    "@walletconnect/types": "2.10.0",
    "@walletconnect/universal-provider": "2.10.0",
    "@walletconnect/utils": "2.10.0",
    "@web3modal/standalone": "^2.3.7",
    "axios": "^1.0.0",
    "blockies-ts": "^1.0.0",
    "cosmos-wallet": "^1.2.0",
    "eth-sig-util": "^2.5.3",
    "ethereumjs-util": "^7.0.6",
    "ethers": "^5.3.0",
    "next": "15.2.3",
    "prop-types": "^15.7.2",
    "qr-image": "^3.2.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "^4.0.3",
    "styled-components": "^6.1.15",
    "typescript": "^4.3.2",
    "web-vitals": "^0.2.4"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.16.1",
    "@testing-library/react": "^12.1.2",
    "@testing-library/user-event": "^13.5.0",
    "@types/bn.js": "^5.1.0",
    "@types/eth-sig-util": "^2.1.1",
    "@types/jest": "^27.4.0",
    "@types/node": "^17.0.14",
    "@types/pino": "^7.0.5",
    "@types/prop-types": "^15.7.4",
    "@types/qr-image": "^3.2.5",
    "@types/react": "18.0.15",
    "@types/react-dom": "18.0.6",
    "@types/styled-components": "^5.1.34",
    "eslint-config-next": "12.2.4",
    "prettier": "^2.5.1"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "pnpm": {
    "overrides": {
      "node-forge@<1.0.0": ">=1.0.0",
      "node-forge@<1.3.0": ">=1.3.0",
      "ejs@<3.1.7": ">=3.1.7",
      "browserslist@>=4.0.0 <4.16.5": ">=4.16.5",
      "loader-utils@>=2.0.0 <2.0.3": ">=2.0.3",
      "postcss@<8.4.31": ">=8.4.31",
      "next@>=0.9.9 <13.4.20-canary.13": ">=13.4.20-canary.13",
      "loader-utils@>=2.0.0 <2.0.4": ">=2.0.4",
      "nth-check@<2.0.1": ">=2.0.1",
      "shell-quote@<=1.7.2": ">=1.7.3",
      "minimatch@<3.0.5": ">=3.0.5",
      "webpack-dev-middleware@<=5.3.3": ">=5.3.4",
      "immer@>=7.0.0 <9.0.6": ">=9.0.6",
      "protobufjs@>=6.10.0 <6.11.4": ">=6.11.4",
      "braces@<3.0.3": ">=3.0.3",
      "ejs@<3.1.10": ">=3.1.10",
      "micromatch@<4.0.8": ">=4.0.8",
      "rollup@<2.79.2": ">=2.79.2",
      "http-proxy-middleware@<2.0.7": ">=2.0.7",
      "next@>=10.0.0 <14.2.7": ">=14.2.7",
      "cross-spawn@>=7.0.0 <7.0.5": ">=7.0.5",
      "semver@>=7.0.0 <7.5.2": ">=7.5.2",
      "next@>=9.5.5 <14.2.15": ">=14.2.15",
      "ansi-html@<0.0.8": ">=0.0.8"
    }
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/README.md">
# React dApp (with v2 CosmosProvider)

> **⚠️ This provider-based example is currently reliant on the deprecated `2.0.0-beta.26` SDK. ⚠️**
>
> This example will be updated to be compatible with the latest v2 SDK (`2.0.0-beta.100+`) in due time.
> In the meantime, please use the up-to-date [standalone client example](../react-dapp-v2/).

🔗 Live dapp demo - https://react-dapp-v2-cosmos-provider.vercel.app/ <br />
🔗 Live wallet demo - https://react-wallet-v2.vercel.app <br />
📚 WalletConnect v2 Docs - https://docs.walletconnect.com/2.0

## Overview

This is an example implementation of a React dApp (generated via `create-react-app`) using the v2 [`CosmosProvider`](https://docs.walletconnect.com/2.0/quick-start/dapps/cosmos-provider) to:

- handle pairings
- manage sessions
- send JSON-RPC requests to a paired wallet

## Running locally

Install the app's dependencies:

```bash
yarn
```

Set up your local environment variables by copying the example into your own `.env.local` file:

```bash
cp .env.local.example .env.local
```

Your `.env.local` now contains the following environment variables:

- `REACT_APP_PROJECT_ID` (placeholder) - You can generate your own ProjectId at https://cloud.walletconnect.com
- `REACT_APP_RELAY_URL` (already set)

## Develop

```bash
yarn start
```

## Test

```bash
yarn test
```

## Build

```bash
yarn build
```
</file>

<file path="advanced/dapps/react-dapp-v2-cosmos-provider/tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="theme-color" content="#000000" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
    <meta name="description" content="React App for WalletConnect" />
    <style>
      @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,500,600,700,800");
    </style>
  </head>
  <body>
    <noscript> You need to enable JavaScript to run this app. </noscript>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/public/manifest.json">
{
  "short_name": "WalletConnect",
  "name": "WalletConnect React App",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": "./index.html",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/chains/cosmos.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import { NamespaceMetadata, ChainMetadata, ChainRequestRender } from "../helpers";

export const CosmosMetadata: NamespaceMetadata = {
  "cosmoshub-4": {
    logo: "/assets/" + "cosmos-cosmoshub-4.png",
    rgb: "27, 31, 53",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = CosmosMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(request: JsonRpcRequest): ChainRequestRender[] {
  let params = [{ label: "Method", value: request.method }];

  switch (request.method) {
    default:
      params = [
        ...params,
        {
          label: "params",
          value: JSON.stringify(request.params, null, "\t"),
        },
      ];
      break;
  }
  return params;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/chains/eip155.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import {
  NamespaceMetadata,
  ChainMetadata,
  ChainRequestRender,
  convertHexToNumber,
  convertHexToUtf8,
} from "../helpers";

export const EIP155Colors = {
  ethereum: "99, 125, 234",
  optimism: "233, 1, 1",
  goerli: "189, 174, 155",
  xdai: "73, 169, 166",
  polygon: "130, 71, 229",
  celo: "60, 203, 132",
  arbitrum: "44, 55, 75",
};

export const EIP155ChainData = {
  "1": {
    name: "Ethereum Mainnet",
    id: "eip155:1",
    rpc: ["https://api.mycryptoapi.com/eth"],
    slip44: 60,
    testnet: false,
  },
  "5": {
    name: "Ethereum Goerli",
    id: "eip155:5",
    rpc: ["https://rpc.goerli.mudit.blog"],
    slip44: 60,
    testnet: true,
  },
  "10": {
    name: "Optimism Mainnet",
    id: "eip155:10",
    rpc: ["https://mainnet.optimism.io"],
    slip44: 60,
    testnet: false,
  },
  "42": {
    name: "Ethereum Kovan",
    id: "eip155:42",
    rpc: ["https://kovan.poa.network"],
    slip44: 60,
    testnet: true,
  },
  "69": {
    name: "Optimism Kovan",
    id: "eip155:69",
    rpc: ["https://kovan.optimism.io"],
    slip44: 60,
    testnet: true,
  },
  "100": {
    name: "xDAI",
    id: "eip155:100",
    rpc: ["https://dai.poa.network"],
    slip44: 60,
    testnet: false,
  },
  "280": {
    name: "zkSync Era Testnet",
    id: "eip155:280",
    rpc: ["https://testnet.era.zksync.dev"],
    slip44: 60,
    testnet: true,
  },
  "324": {
    name: "zkSync Era",
    id: "eip155:324",
    rpc: ["https://mainnet.era.zksync.io"],
    slip44: 60,
    testnet: false,
  },
  "137": {
    name: "Polygon Mainnet",
    id: "eip155:137",
    rpc: ["https://rpc-mainnet.matic.network"],
    slip44: 60,
    testnet: false,
  },
  "420": {
    name: "Optimism Goerli",
    id: "eip155:420",
    rpc: ["https://goerli.optimism.io"],
    slip44: 60,
    testnet: true,
  },
  "42161": {
    name: "Arbitrum One",
    id: "eip155:42161",
    rpc: ["https://arb1.arbitrum.io/rpc"],
    slip44: 60,
    testnet: false,
  },
  "42220": {
    name: "Celo Mainnet",
    id: "eip155:42220",
    rpc: ["https://forno.celo.org"],
    slip44: 52752,
    testnet: false,
  },
  "44787": {
    name: "Celo Alfajores",
    id: "eip155:44787",
    rpc: ["https://alfajores-forno.celo-testnet.org"],
    slip44: 52752,
    testnet: true,
  },
  "80001": {
    name: "Polygon Mumbai",
    id: "eip155:80001",
    rpc: ["https://rpc-mumbai.matic.today"],
    slip44: 60,
    testnet: true,
  },
  "421611": {
    name: "Arbitrum Rinkeby",
    id: "eip155:421611",
    rpc: ["https://rinkeby.arbitrum.io/rpc"],
    slip44: 60,
    testnet: true,
  },
};

export const EIP155Metadata: NamespaceMetadata = {
  "1": {
    name: "Ethereum",
    logo: "/assets/" + "eip155-1.png",
    rgb: EIP155Colors.ethereum,
  },
  "5": {
    logo: "/assets/" + "eip155-5.png",
    rgb: EIP155Colors.goerli,
  },
  "10": {
    name: "Optimism",
    logo: "/assets/" + "eip155-10.png",
    rgb: EIP155Colors.optimism,
  },
  "42": {
    logo: "/assets/" + "eip155-42.png",
    rgb: EIP155Colors.ethereum,
  },
  "69": {
    logo: "/assets/" + "eip155-69.png",
    rgb: EIP155Colors.optimism,
  },
  "100": {
    logo: "/assets/" + "eip155-100.png",
    rgb: EIP155Colors.xdai,
  },
  "137": {
    name: "Polygon",
    logo: "/assets/" + "eip155-137.png",
    rgb: EIP155Colors.polygon,
  },
  "80001": {
    logo: "/assets/" + "eip155-80001.png",
    rgb: EIP155Colors.polygon,
  },
  "42161": {
    name: "Arbitrum",
    logo: "/assets/" + "eip155-42161.png",
    rgb: EIP155Colors.arbitrum,
  },
  "42220": {
    name: "Celo",
    logo: "/assets/" + "eip155-42220.png",
    rgb: EIP155Colors.celo,
  },
  "44787": {
    logo: "/assets/" + "eip155-44787.png",
    rgb: EIP155Colors.celo,
  },
  "421611": {
    logo: "/assets/" + "eip155-421611.png",
    rgb: EIP155Colors.arbitrum,
  },
};
export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = EIP155Metadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(request: JsonRpcRequest): ChainRequestRender[] {
  let params = [{ label: "Method", value: request.method }];

  switch (request.method) {
    case "eth_sendTransaction":
    case "eth_signTransaction":
      params = [
        ...params,
        { label: "From", value: request.params[0].from },
        { label: "To", value: request.params[0].to },
        {
          label: "Gas Limit",
          value: request.params[0].gas
            ? convertHexToNumber(request.params[0].gas)
            : request.params[0].gasLimit
            ? convertHexToNumber(request.params[0].gasLimit)
            : "",
        },
        {
          label: "Gas Price",
          value: convertHexToNumber(request.params[0].gasPrice),
        },
        {
          label: "Nonce",
          value: convertHexToNumber(request.params[0].nonce),
        },
        {
          label: "Value",
          value: request.params[0].value ? convertHexToNumber(request.params[0].value) : "",
        },
        { label: "Data", value: request.params[0].data },
      ];
      break;

    case "eth_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[0] },
        { label: "Message", value: request.params[1] },
      ];
      break;
    case "personal_sign":
      params = [
        ...params,
        { label: "Address", value: request.params[1] },
        {
          label: "Message",
          value: convertHexToUtf8(request.params[0]),
        },
      ];
      break;
    default:
      params = [
        ...params,
        {
          label: "params",
          value: JSON.stringify(request.params, null, "\t"),
        },
      ];
      break;
  }
  return params;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/chains/index.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import * as eip155 from "./eip155";
import * as cosmos from "./cosmos";
import * as polkadot from "./polkadot";

import { ChainMetadata, ChainRequestRender } from "../helpers";

export function getChainMetadata(chainId: string): ChainMetadata {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainMetadata(chainId);
    case "cosmos":
      return cosmos.getChainMetadata(chainId);
    case "polkadot":
      return polkadot.getChainMetadata(chainId);
    default:
      throw new Error(`No metadata handler for namespace ${namespace}`);
  }
}

export function getChainRequestRender(
  request: JsonRpcRequest,
  chainId: string,
): ChainRequestRender[] {
  const namespace = chainId.split(":")[0];
  switch (namespace) {
    case "eip155":
      return eip155.getChainRequestRender(request);
    case "cosmos":
      return cosmos.getChainRequestRender(request);
    case "polkadot":
      return polkadot.getChainRequestRender(request);
    default:
      throw new Error(`No render handler for namespace ${namespace}`);
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/chains/polkadot.ts">
import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";

import { NamespaceMetadata, ChainMetadata, ChainRequestRender } from "../helpers";

export const PolkadotMetadata: NamespaceMetadata = {
  // eslint-disable-next-line no-useless-computed-key
  ["91b171bb158e2d3848fa23a9f1c25182"]: {
    logo: "/assets/polkadot.svg",
    rgb: "230, 1, 122",
  },
};

export function getChainMetadata(chainId: string): ChainMetadata {
  const reference = chainId.split(":")[1];
  const metadata = PolkadotMetadata[reference];
  if (typeof metadata === "undefined") {
    throw new Error(`No chain metadata found for chainId: ${chainId}`);
  }
  return metadata;
}

export function getChainRequestRender(request: JsonRpcRequest): ChainRequestRender[] {
  let params = [{ label: "Method", value: request.method }];

  switch (request.method) {
    default:
      params = [
        ...params,
        {
          label: "params",
          value: JSON.stringify(request.params, null, "\t"),
        },
      ];
      break;
  }
  return params;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/app/index.tsx">
import styled from "styled-components";
import { fonts } from "../../styles";
import Button from "../Button";
import Column from "../Column";
import Wrapper from "../Wrapper";

export const SLayout = styled.div`
  position: relative;
  width: 100%;
  min-height: 100vh;
  text-align: center;
`;

export const SContent = styled(Wrapper as any)`
  width: 100%;
  height: 100%;
  padding: 0 16px;
`;

export const SLanding = styled(Column as any)`
  /* height: 600px; */
`;

export const SButtonContainer = styled(Column as any)`
  width: 250px;
  margin: 50px 0;
`;

export const SConnectButton = styled(Button as any)`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
`;

export const SAccountsContainer = styled(SLanding as any)`
  height: 100%;
  padding-bottom: 30px;
  & h3 {
    padding-top: 30px;
  }
`;

export const SToggleContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 10px auto;
  & > p {
    margin-right: 10px;
  }
`;

export const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

export const SAccounts = styled(SFullWidthContainer)`
  justify-content: space-between;
  & > div {
    margin: 12px 0;
    flex: 1 0 100%;
    @media (min-width: 648px) {
      flex: 0 1 48%;
    }
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/shared/index.ts">
import styled from "styled-components";

export const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

export const STable = styled(SContainer as any)`
  flex-direction: column;
  text-align: left;
`;

export const SRow = styled.div`
  width: 100%;
  display: flex;
  margin: 6px 0;
`;

export const SKey = styled.div`
  width: 30%;
  font-weight: 700;
`;

export const SValue = styled.div`
  width: 70%;
  font-family: monospace;
`;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Asset.tsx">
import * as React from "react";
import styled from "styled-components";

import Icon from "./Icon";

import { AssetData } from "../helpers";

import eth from "../assets/eth.svg";
import erc20 from "../assets/erc20.svg";
import { getChainMetadata } from "../chains";

const xdai = getChainMetadata("eip155:100").logo;
const matic = getChainMetadata("eip155:137").logo;

const SAsset = styled.div`
  width: 100%;
  padding: 20px;
  display: flex;
  justify-content: space-between;
`;
const SAssetLeft = styled.div`
  display: flex;
`;

const SAssetName = styled.div`
  display: flex;
  margin-left: 10px;
`;

const SAssetRight = styled.div`
  display: flex;
`;

const SAssetBalance = styled.div`
  display: flex;
`;

// eslint-disable-next-line
function getAssetIcon(asset: AssetData): JSX.Element {
  if (!!asset.contractAddress) {
    const src = `https://raw.githubusercontent.com/TrustWallet/tokens/master/tokens/${asset.contractAddress.toLowerCase()}.png`;
    return <Icon src={src} fallback={erc20} />;
  }
  switch (asset.symbol.toLowerCase()) {
    case "eth":
      return <Icon src={eth} />;
    case "xdai":
      return <Icon src={xdai} />;
    case "matic":
      return <Icon src={matic} />;
    default:
      return <Icon src={erc20} />;
  }
}

interface AssetProps {
  asset: { symbol: string; balance: string };
}

const Asset = (props: AssetProps) => {
  const { asset } = props;
  return (
    <SAsset {...props}>
      <SAssetLeft>
        {/* {getAssetIcon(asset)} */}
        <SAssetName>{asset.symbol}</SAssetName>
      </SAssetLeft>
      <SAssetRight>
        <SAssetBalance>{`${asset.balance}`}</SAssetBalance>
      </SAssetRight>
    </SAsset>
  );
};

export default Asset;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Banner.tsx">
import * as React from "react";
import styled from "styled-components";

const SBannerWrapper = styled.div`
  display: flex;
  align-items: center;
  position: relative;
`;

const SBanner = styled.div`
  width: 275px;
  height: 45px;
  background: url(/assets/walletconnect.png) no-repeat;
  background-size: cover;
  background-position: center;
`;

const Banner = () => (
  <SBannerWrapper>
    <SBanner />
  </SBannerWrapper>
);

export default Banner;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Blockchain.tsx">
import React, { PropsWithChildren, FC } from "react";
import { styled } from "styled-components";

import Asset from "./Asset";
import Button from "./Button";
import Column from "./Column";
import Loader from "./Loader";

import { getChainMetadata } from "../chains";
import {
  AccountAction,
  ellipseAddress,
  ChainMetadata,
  ChainNamespaces,
  AccountBalances,
} from "../helpers";
import { fonts } from "../styles";

interface AccountStyleProps {
  rgb: string;
  children?: React.ReactNode;
  onClick?: () => void;
  className?: string;
}

const SAccount = styled.div<AccountStyleProps>`
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  border-radius: 8px;
  padding: 8px;
  margin: 5px 0;
  border: ${({ rgb }) => `2px solid rgb(${rgb})`};
  &.active {
    box-shadow: ${({ rgb }) => `0 0 8px rgb(${rgb})`};
  }
`;

const SChain = styled.div`
  width: 100%;
  display: flex;
  align-items: center;
  & p {
    font-weight: 600;
  }
  & img {
    border-radius: 50%;
    width: 35px;
    height: 35px;
    margin-right: 10px;
  }
`;

const SContainer = styled.div`
  height: 100%;
  min-height: 200px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  word-break: break-word;
`;

const SFullWidthContainer = styled.div`
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
`;

interface ActionProps {
  rgb: string;
}

const SAction = styled(Button)<ActionProps>`
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  height: 44px;
  width: 100%;
  margin: 12px 0;
  background-color: ${({ rgb }) => `rgb(${rgb})`};
`;

const SBlockchainChildrenContainer = styled(SFullWidthContainer)`
  flex-direction: column;
`;

interface BlockchainProps {
  chainData: ChainNamespaces;
  fetching?: boolean;
  active?: boolean;
  chainId: string;
  address?: string;
  onClick?: (chain: string) => void;
  balances?: AccountBalances;
  actions?: AccountAction[];
}

interface BlockchainDisplayData {
  data: any;
  meta: ChainMetadata;
}

function getBlockchainDisplayData(
  chainId: string,
  chainData: ChainNamespaces,
): BlockchainDisplayData | undefined {
  const [namespace, reference] = chainId.split(":");
  let meta: ChainMetadata;
  try {
    meta = getChainMetadata(chainId);
  } catch (e) {
    return undefined;
  }
  const data = chainData[namespace][reference];
  if (typeof data === "undefined") return undefined;
  return { data, meta };
}

const Blockchain: FC<PropsWithChildren<BlockchainProps>> = (
  props: PropsWithChildren<BlockchainProps>,
) => {
  const { chainData, fetching, chainId, address, onClick, balances, active, actions } = props;

  if (!Object.keys(chainData).length) return null;

  const chain = getBlockchainDisplayData(chainId, chainData);
  if (typeof chain === "undefined") {
    return null;
  }
  const name = chain.meta.name || chain.data.name;

  return (
    <React.Fragment>
      <SAccount
        rgb={chain.meta.rgb}
        onClick={() => onClick && onClick(props.chainId)}
        className={active ? "active" : ""}
      >
        <SChain>
          <img src={chain.meta.logo} alt={name} />
          <p>{name}</p>
        </SChain>
        {!!address && <p>{ellipseAddress(address)}</p>}
        <SBlockchainChildrenContainer>
          {fetching ? (
            <Column center>
              <SContainer>
                <Loader rgb={`rgb(${chain.meta.rgb})`} />
              </SContainer>
            </Column>
          ) : (
            <>
              {!!address && !!balances && balances[address] ? (
                <SFullWidthContainer>
                  <h6>Balances</h6>
                  <Column center>
                    <Asset key={balances[address].symbol} asset={balances[address]} />
                  </Column>
                </SFullWidthContainer>
              ) : null}
              {!!actions && actions.length ? (
                <SFullWidthContainer>
                  <h6>Methods</h6>
                  {actions.map(action => (
                    <SAction
                      key={action.method}
                      left
                      rgb={chain.meta.rgb}
                      onClick={() => action.callback(chainId)}
                    >
                      {action.method}
                    </SAction>
                  ))}
                </SFullWidthContainer>
              ) : null}
            </>
          )}
        </SBlockchainChildrenContainer>
      </SAccount>
    </React.Fragment>
  );
};
export default Blockchain;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Button.tsx">
import * as React from "react";
import { styled, keyframes } from "styled-components";
import Loader from "./Loader";
import { colors, fonts, shadows, transitions } from "../styles";

interface ButtonStyleProps {
  fetching: boolean;
  outline: boolean;
  type: "button" | "submit" | "reset";
  color: string;
  disabled: boolean;
  icon: any;
  left: boolean;
}

interface ButtonProps extends ButtonStyleProps {
  children: React.ReactNode;
  onClick?: any;
}

const SIcon = styled.div`
  position: absolute;
  height: 15px;
  width: 15px;
  margin: 0 8px;
  top: calc((100% - 15px) / 2);
`;

const SHoverLayer = styled.div`
  transition: ${transitions.button};
  position: absolute;
  height: 100%;
  width: 100%;
  background-color: rgb(${colors.white}, 0.1);
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  pointer-events: none;
  opacity: 0;
  visibility: hidden;
`;

const SButton = styled.button<ButtonStyleProps>`
  transition: ${transitions.button};
  position: relative;
  border: none;
  border-style: none;
  box-sizing: border-box;
  background-color: ${({ outline, color }) => (outline ? "transparent" : `rgb(${colors[color]})`)};
  border: ${({ outline, color }) => (outline ? `1px solid rgb(${colors[color]})` : "none")};
  color: ${({ outline, color }) => (outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`)};
  box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  border-radius: 8px;
  font-size: ${fonts.size.medium};
  font-weight: ${fonts.weight.semibold};
  padding: ${({ icon, left }) =>
    icon ? (left ? "7px 12px 8px 28px" : "7px 28px 8px 12px") : "8px 12px"};
  cursor: ${({ disabled }) => (disabled ? "auto" : "pointer")};
  will-change: transform;

  &:disabled {
    opacity: 0.6;
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
  }

  @media (hover: hover) {
    &:hover {
      transform: ${({ disabled }) => (!disabled ? "translateY(-1px)" : "none")};
      box-shadow: ${({ disabled, outline }) =>
        !disabled ? (outline ? "none" : `${shadows.hover}`) : `${shadows.soft}`};
    }

    &:hover ${SHoverLayer} {
      opacity: 1;
      visibility: visible;
    }
  }

  &:active {
    transform: ${({ disabled }) => (!disabled ? "translateY(1px)" : "none")};
    box-shadow: ${({ outline }) => (outline ? "none" : `${shadows.soft}`)};
    color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgba(${colors.white}, 0.24)`};

    & ${SIcon} {
      opacity: 0.8;
    }
  }

  & ${SIcon} {
    right: ${({ left }) => (left ? "auto" : "0")};
    left: ${({ left }) => (left ? "0" : "auto")};
    display: ${({ icon }) => (icon ? "block" : "none")};
    mask: ${({ icon }) => (icon ? `url(${icon}) center no-repeat` : "none")};
    background-color: ${({ outline, color }) =>
      outline ? `rgb(${colors[color]})` : `rgb(${colors.white})`};
    transition: 0.15s ease;
  }
`;

const Button = (props: ButtonProps) => (
  <SButton
    {...props}
    type={props.type}
    outline={props.outline}
    color={props.color}
    disabled={props.disabled}
    icon={props.icon}
    left={props.left}
  >
    <SHoverLayer />
    <SIcon />
    {props.fetching ? <Loader size={20} color="white" /> : props.children}
  </SButton>
);

Button.defaultProps = {
  fetching: false,
  outline: false,
  type: "button",
  color: "lightBlue",
  disabled: false,
  icon: null,
  left: false,
};

export default Button;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Column.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled } from "styled-components";

interface ColumnStyleProps {
  spanHeight: boolean;
  maxWidth: number;
  center: boolean;
  children?: React.ReactNode;
}

interface ColumnProps extends ColumnStyleProps {
  children: React.ReactNode;
}

const SColumn = styled.div<ColumnStyleProps>`
  position: relative;
  width: 100%;
  height: ${({ spanHeight }) => (spanHeight ? "100%" : "auto")};
  max-width: ${({ maxWidth }) => `${maxWidth}px`};
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: ${({ center }) => (center ? "center" : "flex-start")};
`;

const Column = (props: ColumnProps) => {
  const { children, spanHeight, maxWidth, center } = props;
  return (
    <SColumn {...props} spanHeight={spanHeight} maxWidth={maxWidth} center={center}>
      {children}
    </SColumn>
  );
};

Column.propTypes = {
  children: PropTypes.node.isRequired,
  spanHeight: PropTypes.bool,
  maxWidth: PropTypes.number,
  center: PropTypes.bool,
};

Column.defaultProps = {
  spanHeight: false,
  maxWidth: 600,
  center: false,
};

export default Column;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Header.tsx">
import { SessionTypes } from "@walletconnect/types";
import * as React from "react";
import styled from "styled-components";

import { fonts, responsive } from "../styles";
import Button from "./Button";

const SHeader = styled.div`
  margin-top: -1px;
  margin-bottom: 1px;
  width: 100%;
  height: 100px;
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 16px;
  @media screen and (${responsive.sm.max}) {
    font-size: ${fonts.size.small};
  }
`;

const SHeaderActions = styled.div`
  display: flex;
  & > button:first-child {
    margin-right: 10px !important;
  }
`;

const SActiveAccount = styled.div`
  display: flex;
  align-items: center;
  position: relative;
  font-weight: 500;
`;

const SActiveSession = styled(SActiveAccount as any)`
  flex-direction: column;
  text-align: left;
  align-items: flex-start;
  & p {
    font-size: 0.8em;
    margin: 0;
    padding: 0;
  }
  & p:nth-child(n + 2) {
    font-weight: bold;
  }
`;

interface HeaderProps {
  ping: () => Promise<void>;
  disconnect: () => Promise<void>;
  session: SessionTypes.Struct | undefined;
}

const Header = (props: HeaderProps) => {
  const { ping, disconnect, session } = props;
  return (
    <SHeader {...props}>
      {session ? (
        <>
          <SActiveSession>
            <p>{`Connected to`}</p>
            <p>{session.peer.metadata.name}</p>
          </SActiveSession>
          <SHeaderActions>
            <Button outline color="black" onClick={ping}>
              {"Ping"}
            </Button>
            <Button outline color="red" onClick={disconnect}>
              {"Disconnect"}
            </Button>
          </SHeaderActions>
        </>
      ) : null}
    </SHeader>
  );
};

export default Header;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Icon.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

interface IconStyleProps {
  size: number;
}

const SIcon = styled.img<IconStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
`;

const Icon = (props: any) => {
  const { src, fallback, size } = props;
  return (
    <SIcon
      {...props}
      src={src}
      size={size}
      onError={(event: any) => {
        if (fallback) {
          event.target.src = fallback;
        }
      }}
    />
  );
};

Icon.propTypes = {
  src: PropTypes.string,
  fallback: PropTypes.string,
  size: PropTypes.number,
};

Icon.defaultProps = {
  src: null,
  fallback: "",
  size: 20,
};

export default Icon;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Loader.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import { styled, keyframes } from "styled-components";
import { colors } from "../styles";

const load = keyframes`
  0% {
    transform: scale(1.0);
  }
  5% {
    transform: scale(1.0);
  }
  50% {
    transform: scale(0.8);
  }
  95% {
    transform: scale(1.0);
  }
  100% {
    transform: scale(1.0);
  }
`;

interface LoaderStyleProps {
  size: number;
  children?: React.ReactNode;
  viewBox?: string;
}

interface LoaderProps extends LoaderStyleProps {
  color: string;
  rgb?: string;
}

const SLoader = styled.svg<LoaderStyleProps>`
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  animation: ${load} 1s infinite cubic-bezier(0.25, 0, 0.75, 1);
  transform: translateZ(0);
`;

const Loader = (props: LoaderProps) => {
  const { size, color } = props;
  const rgb = props.rgb || `rgb(${colors[color]})`;
  return (
    <SLoader viewBox="0 0 186 187" size={size}>
      <g stroke="none" strokeWidth="1" fill="none" fillRule="evenodd">
        <path
          d="M60,10.34375 C32.3857625,10.34375 10,32.7295125 10,60.34375 L10,126.34375 C10,153.957987 32.3857625,176.34375 60,176.34375 L126,176.34375 C153.614237,176.34375 176,153.957987 176,126.34375 L176,60.34375 C176,32.7295125 153.614237,10.34375 126,10.34375 L60,10.34375 Z M60,0.34375 L126,0.34375 C159.137085,0.34375 186,27.206665 186,60.34375 L186,126.34375 C186,159.480835 159.137085,186.34375 126,186.34375 L60,186.34375 C26.862915,186.34375 0,159.480835 0,126.34375 L0,60.34375 C0,27.206665 26.862915,0.34375 60,0.34375 Z"
          id="Rectangle-Copy"
          fill={rgb}
          fillRule="nonzero"
        />
        <rect id="Rectangle" fill={rgb} x="44" y="44.34375" width="98" height="98" rx="35" />
      </g>
    </SLoader>
  );
};

Loader.propTypes = {
  size: PropTypes.number,
  color: PropTypes.string,
};

Loader.defaultProps = {
  size: 40,
  color: "lightBlue",
};

export default Loader;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Metadata.tsx">
import Head from "next/head";
import * as React from "react";
import { DEFAULT_APP_METADATA } from "../constants";

const Metadata = () => (
  <Head>
    <title>{DEFAULT_APP_METADATA.name}</title>
    <meta name="description" content={DEFAULT_APP_METADATA.description} />
    <meta name="url" content={DEFAULT_APP_METADATA.url} />

    {DEFAULT_APP_METADATA.icons.map((icon, index) => (
      <link key={index} rel="icon" href={icon} />
    ))}
  </Head>
);

export default Metadata;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Modal.tsx">
import React, { useEffect, useRef, useState } from "react";
import { styled } from "styled-components";
import { colors, transitions } from "../styles";

interface LightboxProps {
  show: boolean;
  offset: number;
  opacity?: number;
  children?: React.ReactNode;
  ref?: React.RefObject<HTMLDivElement>;
}

const SLightbox = styled.div<LightboxProps>`
  transition: opacity 0.1s ease-in-out;
  text-align: center;
  position: absolute;
  width: 100vw;
  height: 100%;
  margin-left: -50vw;
  top: ${({ offset }) => (offset ? `-${offset}px` : 0)};
  left: 50%;
  z-index: 2;
  will-change: opacity;
  background-color: ${({ opacity }) => {
    let alpha = 0.4;
    if (typeof opacity === "number") {
      alpha = opacity;
    }
    return `rgba(0, 0, 0, ${alpha})`;
  }};
  opacity: ${({ show }) => (show ? 1 : 0)};
  visibility: ${({ show }) => (show ? "visible" : "hidden")};
  pointer-events: ${({ show }) => (show ? "auto" : "none")};
  display: flex;
  justify-content: center;
  align-items: center;
`;

const SModalContainer = styled.div`
  position: relative;
  width: 100%;
  height: 100%;
  padding: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

interface HitboxProps {
  onClick?: () => void;
}

const SHitbox = styled.div<HitboxProps>`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
`;

interface CloseButtonStyleProps {
  size: number;
  color: string;
  onClick?: any;
}

const SCloseButton = styled.div<CloseButtonStyleProps>`
  transition: ${transitions.short};
  position: absolute;
  width: ${({ size }) => `${size}px`};
  height: ${({ size }) => `${size}px`};
  right: ${({ size }) => `${size / 1.6667}px`};
  top: ${({ size }) => `${size / 1.6667}px`};
  opacity: 0.5;
  cursor: pointer;
  &:hover {
    opacity: 1;
  }
  &:before,
  &:after {
    position: absolute;
    content: " ";
    height: ${({ size }) => `${size}px`};
    width: 2px;
    background: ${({ color }) => `rgb(${colors[color]})`};
  }
  &:before {
    transform: rotate(45deg);
  }
  &:after {
    transform: rotate(-45deg);
  }
`;

const SCard = styled.div`
  position: relative;
  width: 100%;
  max-width: 500px;
  padding: 25px;
  background-color: rgb(${colors.white});
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;

const SModalContent = styled.div`
  position: relative;
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

interface IProps {
  children: React.ReactNode;
  show: boolean;
  closeModal: () => void;
  opacity?: number;
}

export default function Modal({ children, show, opacity, closeModal }: IProps) {
  const [offset, setOffset] = useState(0);
  const lightboxRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (lightboxRef.current) {
      const lightboxRect = lightboxRef.current.getBoundingClientRect();
      const nextOffset = lightboxRect.top > 0 ? lightboxRect.top : 0;

      if (nextOffset !== 0 && nextOffset !== offset) {
        setOffset(nextOffset);
      }
    }
  }, [offset]);

  return (
    <SLightbox show={show} offset={offset} opacity={opacity} ref={lightboxRef}>
      <SModalContainer>
        <SHitbox onClick={closeModal} />

        <SCard>
          <SCloseButton size={25} color={"dark"} onClick={closeModal} />
          <SModalContent>{children}</SModalContent>
        </SCard>
      </SModalContainer>
    </SLightbox>
  );
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Pairing.tsx">
import * as React from "react";
import styled from "styled-components";

import { PairingTypes } from "@walletconnect/types";

import Peer from "./Peer";

interface PairingProps {
  pairing: PairingTypes.Struct;
  onClick?: any;
}

const SPairingContainer = styled.div`
  width: 100%;
  cursor: pointer;
`;

const Pairing = (props: PairingProps) => {
  const { peerMetadata } = props.pairing;
  return (
    <SPairingContainer onClick={props.onClick}>
      <div>
        {typeof peerMetadata !== "undefined" ? (
          <Peer oneLiner metadata={peerMetadata} />
        ) : (
          <div>{`Unknown`}</div>
        )}
      </div>
    </SPairingContainer>
  );
};

export default Pairing;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Peer.tsx">
import { CoreTypes } from "@walletconnect/types";
import * as React from "react";
import styled from "styled-components";
import { colors, fonts } from "../styles";

const SPeerOneLiner = styled.div`
  display: flex;
  align-items: center;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;

  & img {
    width: 40px;
    height: 40px;
  }
  & > div {
    margin-left: 10px;
  }
`;

const SPeerCard = styled.div`
  align-items: center;
  justify-content: center;
  display: flex;
  width: 100%;
  flex-direction: column;
  border-radius: 8px;
  border: 2px solid rgb(${colors.darkGrey});
  padding: 5px;
  & > div {
    margin: 4px auto;
  }
`;

const SIcon = styled.img`
  width: 100px;
  margin: 0 auto;
`;

const SCenter = styled.div`
  text-align: center;
`;

const SUrl = styled(SCenter as any)`
  font-size: ${fonts.size.small};
  opacity: 0.8;
`;

const SName = styled(SCenter as any)`
  font-weight: bold;
`;

interface PeerProps {
  oneLiner?: boolean;
  metadata: CoreTypes.Metadata;
}

const Peer = (props: PeerProps) =>
  props.oneLiner ? (
    <SPeerOneLiner>
      <img src={props.metadata.icons[0]} alt={props.metadata.name} />
      <div>{props.metadata.name}</div>
    </SPeerOneLiner>
  ) : (
    <SPeerCard>
      <SIcon src={props.metadata.icons[0]} alt={props.metadata.name} />
      <SName>{props.metadata.name}</SName>
      <SCenter>{props.metadata.description}</SCenter>
      <SUrl>{props.metadata.url}</SUrl>
    </SPeerCard>
  );

export default Peer;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Toggle.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled from "styled-components";

import { colors, transitions } from "../styles";

interface IToggleStyleProps {
  color: string;
  active: boolean;
}

const SToggle = styled.div<IToggleStyleProps>`
  position: relative;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  transition: ${transitions.base};
  & div {
    transition: ${transitions.base};
    appearance: none;
    transition: all 0.3s ease;
    box-shadow: ${({ active, color }) =>
      active
        ? `inset 0px 0px 0px 20px rgb(${colors[color]})`
        : `inset 0px 0px 0px 1px rgb(${colors.grey})`};
    border-radius: 1rem;
    background-color: rgb(${colors.white});
    padding: 1px;
    display: inline-block;
    width: 46px;
    height: 26px;
    position: relative;
    cursor: pointer;
    margin: 0px;
    vertical-align: bottom;
    outline: none;
    border: none;
  }
  & div:after {
    transition: ${transitions.base};
    box-shadow: inset 0 1px 0 rgb(${colors.grey}), 0px 2px 2px 1px rgba(${colors.black}, 0.2);
    border-radius: 1rem;
    left: ${({ active }) => (active ? `20px` : `0`)};
    content: "";
    position: absolute;
    width: 24px;
    height: 24px;
    cursor: pointer;
    background-color: rgb(${colors.white});
  }
`;

interface IToggleProps extends IToggleStyleProps {
  onClick?: any;
}

const Toggle = (props: IToggleProps) => (
  <SToggle color={props.color} active={props.active} onClick={props.onClick}>
    <div />
  </SToggle>
);

Toggle.propTypes = {
  active: PropTypes.bool,
  color: PropTypes.string,
  onClick: PropTypes.func,
};

Toggle.defaultProps = {
  active: false,
  color: "green",
};

export default Toggle;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/components/Wrapper.tsx">
import * as React from "react";
import * as PropTypes from "prop-types";
import styled, { keyframes } from "styled-components";

const fadeIn = keyframes`
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
`;

interface WrapperStyleProps {
  center: boolean;
}

const SWrapper = styled.div<WrapperStyleProps>`
  will-change: transform, opacity;
  animation: ${fadeIn} 0.7s ease 0s normal 1;
  min-height: 200px;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: ${({ center }) => (center ? `center` : `flex-start`)};
`;

interface WrapperProps extends WrapperStyleProps {
  children: React.ReactNode;
}

const Wrapper = (props: WrapperProps) => {
  const { children, center } = props;
  return (
    <SWrapper {...props} center={center}>
      {children}
    </SWrapper>
  );
};

Wrapper.propTypes = {
  children: PropTypes.node.isRequired,
  center: PropTypes.bool,
};

Wrapper.defaultProps = {
  center: false,
};

export default Wrapper;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/constants/default.ts">
export const DEFAULT_MAIN_CHAINS = [
  // mainnets
  "eip155:1",
  "eip155:10",
  "eip155:100",
  "eip155:137",
  "eip155:42161",
  "eip155:42220",
];

export const DEFAULT_TEST_CHAINS = [
  // testnets
  "eip155:5",
  "eip155:69",
  "eip155:80001",
  "eip155:421611",
  "eip155:44787",
];

export const DEFAULT_CHAINS = [...DEFAULT_MAIN_CHAINS, ...DEFAULT_TEST_CHAINS];

export const DEFAULT_PROJECT_ID = process.env.NEXT_PUBLIC_PROJECT_ID;

export const DEFAULT_RELAY_URL = process.env.NEXT_PUBLIC_RELAY_URL;

export const DEFAULT_EIP155_METHODS = ["eth_sendTransaction", "personal_sign", "eth_signTypedData"];

export enum DEFAULT_EIP_155_EVENTS {
  ETH_CHAIN_CHANGED = "chainChanged",
  ETH_ACCOUNTS_CHANGED = "accountsChanged",
}

export const DEFAULT_LOGGER = "debug";

export const DEFAULT_APP_METADATA = {
  name: "React App with ethers",
  description: "React App for WalletConnect",
  url: "https://walletconnect.com/",
  icons: ["https://avatars.githubusercontent.com/u/37784886"],
};
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/constants/index.ts">
export * from "./default";
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/contexts/ClientContext.tsx">
import {
  createContext,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from "react";

import { Web3Modal } from "@web3modal/standalone";
import UniversalProvider from "@walletconnect/universal-provider";
import { PairingTypes, SessionTypes } from "@walletconnect/types";
import Client from "@walletconnect/sign-client";

import { DEFAULT_LOGGER, DEFAULT_PROJECT_ID, DEFAULT_RELAY_URL } from "../constants";
import { providers, utils } from "ethers";
import { AccountBalances, ChainNamespaces, getAllChainNamespaces } from "../helpers";
import { EIP155ChainData } from "../chains/eip155";
/**
 * Types
 */
interface IContext {
  client: Client | undefined;
  session: SessionTypes.Struct | undefined;
  connect: (caipChainId: string, pairing?: { topic: string }) => Promise<void>;
  disconnect: () => Promise<void>;
  isInitializing: boolean;
  chain: string;
  pairings: PairingTypes.Struct[];
  accounts: string[];
  balances: AccountBalances;
  isFetchingBalances: boolean;
  chainData: ChainNamespaces;
  web3Provider?: providers.Web3Provider;
}

/**
 * Context
 */
export const ClientContext = createContext<IContext>({} as IContext);

/**
 * Provider
 */
/**
 * Provider
 */
export function ClientContextProvider({ children }: { children: ReactNode | ReactNode[] }) {
  const [client, setClient] = useState<Client>();
  const [pairings, setPairings] = useState<PairingTypes.Struct[]>([]);
  const [session, setSession] = useState<SessionTypes.Struct>();

  const [ethereumProvider, setEthereumProvider] = useState<UniversalProvider>();
  const [web3Provider, setWeb3Provider] = useState<providers.Web3Provider>();

  const [isFetchingBalances, setIsFetchingBalances] = useState(false);
  const [isInitializing, setIsInitializing] = useState(false);
  const [hasCheckedPersistedSession, setHasCheckedPersistedSession] = useState(false);

  const [balances, setBalances] = useState<AccountBalances>({});
  const [accounts, setAccounts] = useState<string[]>([]);
  const [chainData, setChainData] = useState<ChainNamespaces>({});
  const [chain, setChain] = useState<string>("");
  const [web3Modal, setWeb3Modal] = useState<Web3Modal>();

  const resetApp = () => {
    setPairings([]);
    setSession(undefined);
    setBalances({});
    setAccounts([]);
    setChain("");
  };

  const loadChainData = async () => {
    const namespaces = getAllChainNamespaces();
    const chainData: ChainNamespaces = {};
    await Promise.all(
      namespaces.map(async namespace => {
        let chains;
        switch (namespace) {
          case "eip155":
            chains = EIP155ChainData;
            break;

          default:
            console.error("Unknown chain namespace: ", namespace);
        }

        if (typeof chains !== "undefined") {
          chainData[namespace] = chains;
        }
      }),
    );
    setChainData(chainData);
  };

  const disconnect = useCallback(async () => {
    if (typeof ethereumProvider === "undefined") {
      throw new Error("ethereumProvider is not initialized");
    }
    await ethereumProvider.disconnect();
    resetApp();
  }, [ethereumProvider]);

  const _subscribeToProviderEvents = useCallback(
    async (_client: UniversalProvider) => {
      if (typeof _client === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }

      _client.on("display_uri", async (uri: string) => {
        console.log("EVENT", "QR Code Modal open");
        web3Modal?.openModal({ uri });
      });

      // Subscribe to session ping
      _client.on("session_ping", ({ id, topic }: { id: number; topic: string }) => {
        console.log("EVENT", "session_ping");
        console.log(id, topic);
      });

      // Subscribe to session event
      _client.on("session_event", ({ event, chainId }: { event: any; chainId: string }) => {
        console.log("EVENT", "session_event");
        console.log(event, chainId);
      });

      // Subscribe to session update
      _client.on(
        "session_update",
        ({ topic, session }: { topic: string; session: SessionTypes.Struct }) => {
          console.log("EVENT", "session_updated");
          setSession(session);
        },
      );

      // Subscribe to session delete
      _client.on("session_delete", ({ id, topic }: { id: number; topic: string }) => {
        console.log("EVENT", "session_deleted");
        console.log(id, topic);
        resetApp();
      });
    },
    [web3Modal],
  );

  const createClient = useCallback(async () => {
    try {
      setIsInitializing(true);

      if (!DEFAULT_PROJECT_ID) return;

      const provider = await UniversalProvider.init({
        projectId: DEFAULT_PROJECT_ID,
        logger: DEFAULT_LOGGER,
        relayUrl: DEFAULT_RELAY_URL,
      });

      const web3Modal = new Web3Modal({
        projectId: DEFAULT_PROJECT_ID,
        walletConnectVersion: 2,
      });

      setEthereumProvider(provider);
      setClient(provider.client);
      setWeb3Modal(web3Modal);
    } catch (err) {
      throw err;
    } finally {
      setIsInitializing(false);
    }
  }, []);

  const createWeb3Provider = useCallback((ethereumProvider: UniversalProvider) => {
    const web3Provider = new providers.Web3Provider(ethereumProvider);
    setWeb3Provider(web3Provider);
  }, []);

  const connect = useCallback(
    async (caipChainId: string, pairing?: { topic: string }) => {
      if (!ethereumProvider) {
        throw new ReferenceError("WalletConnect Client is not initialized.");
      }

      const chainId = caipChainId.split(":").pop();

      console.log("Enabling EthereumProvider for chainId: ", chainId);

      const session = await ethereumProvider.connect({
        namespaces: {
          eip155: {
            methods: [
              "eth_sendTransaction",
              "eth_signTransaction",
              "eth_sign",
              "personal_sign",
              "eth_signTypedData",
            ],
            chains: [`eip155:${chainId}`],
            events: ["chainChanged", "accountsChanged"],
            rpcMap: {
              chainId: `https://rpc.walletconnect.com?chainId=eip155:${chainId}&projectId=${DEFAULT_PROJECT_ID}`,
            },
          },
        },
        pairingTopic: pairing?.topic,
      });

      createWeb3Provider(ethereumProvider);
      const _accounts = await ethereumProvider.enable();
      console.log("_accounts", _accounts);
      setAccounts(_accounts);
      setSession(session);
      setChain(caipChainId);

      web3Modal?.closeModal();
    },
    [ethereumProvider, chainData.eip155, createWeb3Provider, web3Modal],
  );

  const onSessionConnected = useCallback(
    async (_session: SessionTypes.Struct) => {
      if (!ethereumProvider) {
        throw new ReferenceError("EthereumProvider is not initialized.");
      }
      const allNamespaceAccounts = Object.values(_session.namespaces)
        .map(namespace => namespace.accounts)
        .flat();
      const allNamespaceChains = Object.keys(_session.namespaces);

      const chainData = allNamespaceAccounts[0].split(":");
      const caipChainId = `${chainData[0]}:${chainData[1]}`;
      console.log("restored caipChainId", caipChainId);
      setChain(caipChainId);
      setSession(_session);
      setAccounts(allNamespaceAccounts.map(account => account.split(":")[2]));
      console.log("RESTORED", allNamespaceChains, allNamespaceAccounts);
      createWeb3Provider(ethereumProvider);
    },
    [ethereumProvider, createWeb3Provider],
  );

  const _checkForPersistedSession = useCallback(
    async (provider: UniversalProvider) => {
      if (typeof provider === "undefined") {
        throw new Error("WalletConnect is not initialized");
      }
      const pairings = provider.client.pairing.getAll({ active: true });
      // populates existing pairings to state
      setPairings(pairings);
      console.log("RESTORED PAIRINGS: ", pairings);
      if (typeof session !== "undefined") return;
      // populates (the last) existing session to state
      if (ethereumProvider?.session) {
        const _session = ethereumProvider?.session;
        console.log("RESTORED SESSION:", _session);
        await onSessionConnected(_session);
        return _session;
      }
    },
    [session, ethereumProvider, onSessionConnected],
  );

  useEffect(() => {
    loadChainData();
  }, []);

  useEffect(() => {
    if (!client) {
      createClient();
    }
  }, [client, createClient]);

  useEffect(() => {
    if (ethereumProvider && web3Modal) _subscribeToProviderEvents(ethereumProvider);
  }, [_subscribeToProviderEvents, ethereumProvider, web3Modal]);

  useEffect(() => {
    const fetchBalances = async () => {
      if (!web3Provider || !accounts) return;

      try {
        setIsFetchingBalances(true);
        const _balances = await Promise.all(
          accounts.map(async account => {
            const balance = await web3Provider.getBalance(account);
            return {
              account,
              symbol: "ETH",
              balance: utils.formatEther(balance),
              contractAddress: "",
            };
          }),
        );

        const balancesByAccount = _balances.reduce((obj, balance) => {
          obj[balance.account] = balance;
          return obj;
        }, {} as AccountBalances);

        setBalances(balancesByAccount);
      } catch (error: any) {
        throw new Error(error);
      } finally {
        setIsFetchingBalances(false);
      }
    };

    fetchBalances();
  }, [web3Provider, accounts]);

  useEffect(() => {
    const getPersistedSession = async () => {
      if (!ethereumProvider) return;
      await _checkForPersistedSession(ethereumProvider);
      setHasCheckedPersistedSession(true);
    };

    if (ethereumProvider && chainData && !hasCheckedPersistedSession) {
      getPersistedSession();
    }
  }, [ethereumProvider, chainData, _checkForPersistedSession, hasCheckedPersistedSession]);

  const value = useMemo(
    () => ({
      pairings,
      isInitializing,
      balances,
      isFetchingBalances,
      accounts,
      chain,
      client,
      session,
      disconnect,
      connect,
      chainData,
      web3Provider,
    }),
    [
      pairings,
      isInitializing,
      balances,
      isFetchingBalances,
      accounts,
      chain,
      client,
      session,
      disconnect,
      connect,
      chainData,
      web3Provider,
    ],
  );

  return (
    <ClientContext.Provider
      value={{
        ...value,
      }}
    >
      {children}
    </ClientContext.Provider>
  );
}

export function useWalletConnectClient() {
  const context = useContext(ClientContext);
  if (context === undefined) {
    throw new Error("useWalletConnectClient must be used within a ClientContextProvider");
  }
  return context;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/helpers/api.ts">
import axios, { AxiosInstance } from "axios";

export type RpcProvidersByChainId = Record<
  number,
  {
    name: string;
    baseURL: string;
    token: {
      name: string;
      symbol: string;
    };
  }
>;

const WALLETCONNECT_RPC_BASE_URL = `https://rpc.walletconnect.com/v1?projectId=${process.env.NEXT_PUBLIC_PROJECT_ID}`;

export const rpcProvidersByChainId: RpcProvidersByChainId = {
  1: {
    name: "Ethereum Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:1",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  5: {
    name: "Ethereum Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:5",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  137: {
    name: "Polygon Mainnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:137",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  280: {
    name: "zkSync Era Testnet",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:280",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  324: {
    name: "zkSync Era",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:324",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  80001: {
    name: "Polygon Mumbai",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:80001",
    token: {
      name: "Matic",
      symbol: "MATIC",
    },
  },
  10: {
    name: "Optimism",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:10",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  420: {
    name: "Optimism Goerli",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:420",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  42161: {
    name: "Arbitrum",
    baseURL: WALLETCONNECT_RPC_BASE_URL + "&chainId=eip155:42161",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  421611: {
    name: "Arbitrum Rinkeby",
    baseURL: "https://rinkeby.arbitrum.io/rpc",
    token: {
      name: "Ether",
      symbol: "ETH",
    },
  },
  100: {
    name: "xDAI",
    baseURL: "https://xdai-archive.blockscout.com",
    token: {
      name: "xDAI",
      symbol: "xDAI",
    },
  },
  42220: {
    name: "Celo",
    baseURL: "https://rpc.walletconnect.com/v1",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
  44787: {
    name: "Celo Alfajores",
    baseURL: "https://alfajores-forno.celo-testnet.org",
    token: {
      name: "CELO",
      symbol: "CELO",
    },
  },
};

const api: AxiosInstance = axios.create({
  baseURL: "https://rpc.walletconnect.com/v1",
  timeout: 10000, // 10 secs
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json",
  },
});

export const apiGetAccountNonce = async (address: string, chainId: string): Promise<number> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_getTransactionCount",
    params: [address, "latest"],
    id: 1,
  });
  const { result } = response.data;
  const nonce = parseInt(result, 16);
  return nonce;
};

export const apiGetGasPrice = async (chainId: string): Promise<string> => {
  const ethChainId = chainId.split(":")[1];
  const { baseURL } = rpcProvidersByChainId[Number(ethChainId)];
  const response = await api.post(baseURL, {
    jsonrpc: "2.0",
    method: "eth_gasPrice",
    params: [],
    id: 1,
  });
  const { result } = response.data;
  return result;
};
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/helpers/eip1271.ts">
import { Contract, providers, utils } from "ethers";

const spec = {
  magicValue: "0x1626ba7e",
  abi: [
    {
      constant: true,
      inputs: [
        {
          name: "_hash",
          type: "bytes32",
        },
        {
          name: "_sig",
          type: "bytes",
        },
      ],
      name: "isValidSignature",
      outputs: [
        {
          name: "magicValue",
          type: "bytes4",
        },
      ],
      payable: false,
      stateMutability: "view",
      type: "function",
    },
  ],
};

async function isValidSignature(
  address: string,
  sig: string,
  data: string,
  provider: providers.Provider,
  abi = eip1271.spec.abi,
  magicValue = eip1271.spec.magicValue,
): Promise<boolean> {
  let returnValue;
  try {
    returnValue = await new Contract(address, abi, provider).isValidSignature(
      utils.arrayify(data),
      sig,
    );
  } catch (e) {
    return false;
  }
  return returnValue.toLowerCase() === magicValue.toLowerCase();
}

export const eip1271 = {
  spec,
  isValidSignature,
};
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/helpers/eip712.ts">
// From spec: https://eips.ethereum.org/EIPS/eip-712
const example = {
  types: {
    EIP712Domain: [
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
    ],
    Person: [
      { name: "name", type: "string" },
      { name: "wallet", type: "address" },
    ],
    Mail: [
      { name: "from", type: "Person" },
      { name: "to", type: "Person" },
      { name: "contents", type: "string" },
    ],
  },
  primaryType: "Mail",
  domain: {
    name: "Ether Mail",
    version: "1",
    chainId: 1,
    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
  },
  message: {
    from: { name: "Cow", wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826" },
    to: { name: "Bob", wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB" },
    contents: "Hello, Bob!",
  },
};

export const eip712 = {
  example,
};
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/helpers/index.ts">
export * from "./api";
export * from "./eip712";
export * from "./eip1271";
export * from "./tx";
export * from "./types";
export * from "./utilities";
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/helpers/tx.ts">
import * as encoding from "@walletconnect/encoding";

import { apiGetAccountNonce, apiGetGasPrice } from "./api";

export async function getGasPrice(chainId: string): Promise<string> {
  const gasPrice = await apiGetGasPrice(chainId);
  return gasPrice;
}

export async function formatTestTransaction(account: string) {
  const [namespace, reference, address] = account.split(":");
  const chainId = `${namespace}:${reference}`;
  // nonce
  const _nonce = await apiGetAccountNonce(address, chainId);

  const nonce = encoding.sanitizeHex(encoding.numberToHex(_nonce));

  // gasPrice
  const _gasPrice = await getGasPrice(chainId);
  const gasPrice = encoding.sanitizeHex(_gasPrice);

  // gasLimit
  const _gasLimit = 21000;
  const gasLimit = encoding.sanitizeHex(encoding.numberToHex(_gasLimit));

  // value
  const _value = 0;
  const value = encoding.sanitizeHex(encoding.numberToHex(_value));

  const tx = { from: address, to: address, data: "0x", nonce, gasPrice, gasLimit, value };

  return tx;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/helpers/types.ts">
export interface AssetData {
  account: string;
  symbol: string;
  balance: string;
  contractAddress?: string;
}

export interface ChainData {
  name: string;
  short_name: string;
  chain: string;
  network: string;
  chain_id: number;
  network_id: number;
  rpc_url: string;
  native_currency: AssetData;
}
export interface TxData {
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasLimit: string;
  value: string;
  data: string;
}

export interface BlockScoutTx {
  value: string;
  txreceipt_status: string;
  transactionIndex: string;
  to: string;
  timeStamp: string;
  nonce: string;
  isError: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface BlockScoutTokenTx {
  value: string;
  transactionIndex: string;
  tokenSymbol: string;
  tokenName: string;
  tokenDecimal: string;
  to: string;
  timeStamp: string;
  nonce: string;
  input: string;
  hash: string;
  gasUsed: string;
  gasPrice: string;
  gas: string;
  from: string;
  cumulativeGasUsed: string;
  contractAddress: string;
  confirmations: string;
  blockNumber: string;
  blockHash: string;
}

export interface ParsedTx {
  timestamp: string;
  hash: string;
  from: string;
  to: string;
  nonce: string;
  gasPrice: string;
  gasUsed: string;
  fee: string;
  value: string;
  input: string;
  error: boolean;
  asset: AssetData;
  operations: TxOperation[];
}

export interface TxOperation {
  asset: AssetData;
  value: string;
  from: string;
  to: string;
  functionName: string;
}

export interface GasPricesResponse {
  fastWait: number;
  avgWait: number;
  blockNum: number;
  fast: number;
  fastest: number;
  fastestWait: number;
  safeLow: number;
  safeLowWait: number;
  speed: number;
  block_time: number;
  average: number;
}

export interface GasPrice {
  time: number;
  price: number;
}

export interface GasPrices {
  timestamp: number;
  slow: GasPrice;
  average: GasPrice;
  fast: GasPrice;
}

export interface MethodArgument {
  type: string;
}

export interface Method {
  signature: string;
  name: string;
  args: MethodArgument[];
}

export interface ChainRequestRender {
  label: string;
  value: string;
}

export interface ChainMetadata {
  name?: string;
  logo: string;
  rgb: string;
}

export interface NamespaceMetadata {
  [reference: string]: ChainMetadata;
}

export interface ChainNamespaces {
  [namespace: string]: {
    [reference: string]: {
      name: string;
      id: string;
      rpc: string[];
      slip44: number;
      testnet: boolean;
    };
  };
}

export interface AccountAction {
  method: string;
  callback: (chainId: string) => Promise<void>;
}

export interface AccountBalances {
  [account: string]: AssetData;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/helpers/utilities.ts">
import { BigNumber, BigNumberish, providers, utils } from "ethers";
import * as encoding from "@walletconnect/encoding";
import { TypedDataUtils } from "eth-sig-util";
import * as ethUtil from "ethereumjs-util";

import { eip1271 } from "./eip1271";
import { DEFAULT_CHAINS } from "../constants";

export function capitalize(string: string): string {
  return string
    .split(" ")
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(" ");
}

export function ellipseText(text = "", maxLength = 9999): string {
  if (text.length <= maxLength) {
    return text;
  }
  const _maxLength = maxLength - 3;
  let ellipse = false;
  let currentLength = 0;
  const result =
    text
      .split(" ")
      .filter(word => {
        currentLength += word.length;
        if (ellipse || currentLength >= _maxLength) {
          ellipse = true;
          return false;
        } else {
          return true;
        }
      })
      .join(" ") + "...";
  return result;
}

export function ellipseAddress(address = "", width = 10): string {
  return `${address.slice(0, width)}...${address.slice(-width)}`;
}

export function getDataString(func: string, arrVals: any[]): string {
  let val = "";
  for (let i = 0; i < arrVals.length; i++) {
    val += encoding.padLeft(arrVals[i], 64);
  }
  const data = func + val;
  return data;
}

export function isMobile(): boolean {
  let mobile = false;

  function hasTouchEvent(): boolean {
    try {
      document.createEvent("TouchEvent");
      return true;
    } catch (e) {
      return false;
    }
  }

  function hasMobileUserAgent(): boolean {
    if (
      /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
        navigator.userAgent,
      ) ||
      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(
        navigator.userAgent.substr(0, 4),
      )
    ) {
      return true;
    } else if (hasTouchEvent()) {
      return true;
    }
    return false;
  }

  mobile = hasMobileUserAgent();

  return mobile;
}

export function encodePersonalMessage(msg: string): string {
  const data = encoding.utf8ToBuffer(msg);
  const buf = Buffer.concat([
    Buffer.from("\u0019Ethereum Signed Message:\n" + data.length.toString(), "utf8"),
    data,
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashPersonalMessage(msg: string): string {
  const data = encodePersonalMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function encodeTypedDataMessage(msg: string): string {
  const data = TypedDataUtils.sanitizeData(JSON.parse(msg));
  const buf = Buffer.concat([
    Buffer.from("1901", "hex"),
    TypedDataUtils.hashStruct("EIP712Domain", data.domain, data.types),
    TypedDataUtils.hashStruct(data.primaryType as string, data.message, data.types),
  ]);
  return ethUtil.bufferToHex(buf);
}

export function hashTypedDataMessage(msg: string): string {
  const data = encodeTypedDataMessage(msg);
  const buf = ethUtil.toBuffer(data);
  const hash = ethUtil.keccak256(buf);
  return ethUtil.bufferToHex(hash);
}

export function recoverAddress(sig: string, hash: string): string {
  const params = ethUtil.fromRpcSig(sig);
  const result = ethUtil.ecrecover(ethUtil.toBuffer(hash), params.v, params.r, params.s);
  const signer = ethUtil.bufferToHex(ethUtil.publicToAddress(result));
  return signer;
}

export function recoverPersonalSignature(sig: string, msg: string): string {
  const hash = hashPersonalMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export function recoverTypedMessage(sig: string, msg: string): string {
  const hash = hashTypedDataMessage(msg);
  const signer = recoverAddress(sig, hash);
  return signer;
}

export async function verifySignature(
  address: string,
  sig: string,
  hash: string,
  provider: providers.Web3Provider,
): Promise<boolean> {
  const bytecode = await provider.getCode(address);
  if (!bytecode || bytecode === "0x" || bytecode === "0x0" || bytecode === "0x00") {
    const signer = recoverAddress(sig, hash);
    return signer.toLowerCase() === address.toLowerCase();
  } else {
    return eip1271.isValidSignature(address, sig, hash, provider);
  }
}

export function convertHexToNumber(hex: string) {
  try {
    return encoding.hexToNumber(hex);
  } catch (e) {
    return hex;
  }
}

export function convertHexToUtf8(hex: string) {
  try {
    return encoding.hexToUtf8(hex);
  } catch (e) {
    return hex;
  }
}

export const sanitizeDecimals = (value: string, decimals = 18): string => {
  const [integer, fractional] = value.split(".");
  const _fractional = fractional
    ? fractional.substring(0, decimals).replace(/0+$/gi, "")
    : undefined;
  return _fractional ? [integer, _fractional].join(".") : integer;
};

export const toWad = (amount: string, decimals = 18): BigNumber => {
  return utils.parseUnits(sanitizeDecimals(amount, decimals), decimals);
};

export const fromWad = (wad: BigNumberish, decimals = 18): string => {
  return sanitizeDecimals(utils.formatUnits(wad, decimals), decimals);
};

export const LOCALSTORAGE_KEY_TESTNET = "TESTNET";
export const INITIAL_STATE_TESTNET_DEFAULT = true;

export function setLocaleStorageTestnetFlag(value: boolean): void {
  window.localStorage.setItem(LOCALSTORAGE_KEY_TESTNET, `${value}`);
}

export function getLocalStorageTestnetFlag(): boolean {
  if (typeof window === "undefined") return false;
  let value = INITIAL_STATE_TESTNET_DEFAULT;
  const persisted = window.localStorage.getItem(LOCALSTORAGE_KEY_TESTNET);
  if (!persisted) {
    setLocaleStorageTestnetFlag(value);
  } else {
    value = persisted === "true" ? true : false;
  }
  return value;
}

export const getAllChainNamespaces = () => {
  const namespaces: string[] = [];
  DEFAULT_CHAINS.forEach(chainId => {
    const [namespace] = chainId.split(":");
    if (!namespaces.includes(namespace)) {
      namespaces.push(namespace);
    }
  });
  return namespaces;
};
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/modals/shared/index.ts">
import styled from "styled-components";

export const SModalContainer = styled.div`
  width: 100%;
  position: relative;
  word-wrap: break-word;
`;

export const SModalTitle = styled.div`
  margin: 1em 0;
  font-size: 20px;
  font-weight: 700;
`;

export const SModalParagraph = styled.p`
  margin-top: 30px;
`;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/modals/PairingModal.tsx">
import * as React from "react";

import { PairingTypes } from "@walletconnect/types";

import Button from "../components/Button";
import Pairing from "../components/Pairing";
import { STable } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";

interface PairingModalProps {
  pairings: PairingTypes.Struct[];
  connect: (pairing?: { topic: string }) => Promise<void>;
}

const PairingModal = (props: PairingModalProps) => {
  const { pairings, connect } = props;
  return (
    <SModalContainer>
      <SModalTitle>{"Select available pairing or create new one"}</SModalTitle>
      <STable>
        {pairings.map(pairing => (
          <Pairing
            key={pairing.topic}
            pairing={pairing}
            onClick={() => connect({ topic: pairing.topic })}
          />
        ))}
      </STable>
      <Button onClick={() => connect()}>{`New Pairing`}</Button>
    </SModalContainer>
  );
};

export default PairingModal;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/modals/PingModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer } from "../components/shared";

import { SModalContainer, SModalTitle } from "./shared";

interface PingModalProps {
  pending: boolean;
  result: any;
}

const PingModal = (props: PingModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending Session Ping"}</SModalTitle>
          <SContainer>
            <Loader />
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid ? "Successful Session Ping" : "Failed Session Ping"}
          </SModalTitle>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"Unknown Error with Session Ping"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default PingModal;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/modals/RequestModal.tsx">
import * as React from "react";

import Loader from "../components/Loader";
import { SContainer, STable, SRow, SKey, SValue } from "../components/shared";

import { SModalContainer, SModalTitle, SModalParagraph } from "./shared";

interface RequestModalProps {
  pending: boolean;
  result: any;
}

const RequestModal = (props: RequestModalProps) => {
  const { pending, result } = props;
  return (
    <>
      {pending ? (
        <SModalContainer>
          <SModalTitle>{"Pending JSON-RPC Request"}</SModalTitle>
          <SContainer>
            <Loader />
            <SModalParagraph>{"Approve or reject request using your wallet"}</SModalParagraph>
          </SContainer>
        </SModalContainer>
      ) : result ? (
        <SModalContainer>
          <SModalTitle>
            {result.valid ? "JSON-RPC Request Approved" : "JSON-RPC Request Failed"}
          </SModalTitle>
          <STable>
            {Object.keys(result).map(key => (
              <SRow key={key}>
                <SKey>{key}</SKey>
                <SValue>{result[key].toString()}</SValue>
              </SRow>
            ))}
          </STable>
        </SModalContainer>
      ) : (
        <SModalContainer>
          <SModalTitle>{"JSON-RPC Request Rejected"}</SModalTitle>
        </SModalContainer>
      )}
    </>
  );
};

export default RequestModal;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/pages/_app.tsx">
import type { AppProps } from "next/app";
import { createGlobalStyle } from "styled-components";
import Metadata from "../components/Metadata";

import { ClientContextProvider } from "../contexts/ClientContext";

import { globalStyle } from "../styles";
const GlobalStyle = createGlobalStyle`
  ${globalStyle}
`;

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <Metadata />
      <GlobalStyle />
      <ClientContextProvider>
        <Component {...pageProps} />
      </ClientContextProvider>
    </>
  );
}

export default MyApp;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/pages/_error.tsx">
export default function Error() {
  return <div>An error as occured</div>;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/pages/404.tsx">
export default function FourOhFour() {
  return <h1>404 Page Not Found</h1>;
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/pages/index.tsx">
import type { NextPage } from "next";
import React, { useState } from "react";
import * as encoding from "@walletconnect/encoding";
import { BigNumber, utils } from "ethers";
import { TypedDataField } from "@ethersproject/abstract-signer";
import { Transaction } from "@ethereumjs/tx";

import Banner from "./../components/Banner";
import Blockchain from "./../components/Blockchain";
import Column from "./../components/Column";
import Header from "./../components/Header";
import Modal from "./../components/Modal";
import { DEFAULT_MAIN_CHAINS, DEFAULT_TEST_CHAINS } from "./../constants";
import {
  AccountAction,
  eip712,
  formatTestTransaction,
  getLocalStorageTestnetFlag,
  hashPersonalMessage,
  hashTypedDataMessage,
  setLocaleStorageTestnetFlag,
  verifySignature,
} from "./../helpers";
import Toggle from "./../components/Toggle";
import RequestModal from "./../modals/RequestModal";
import PingModal from "./../modals/PingModal";
import {
  SAccounts,
  SAccountsContainer,
  SButtonContainer,
  SContent,
  SLanding,
  SLayout,
  SToggleContainer,
} from "./../components/app";
import { useWalletConnectClient } from "./../contexts/ClientContext";
import { RELAYER_SDK_VERSION as version } from "@walletconnect/core";

interface IFormattedRpcResponse {
  method: string;
  address: string;
  valid: boolean;
  result: string;
}

const Home: NextPage = () => {
  const [isTestnet, setIsTestnet] = useState(getLocalStorageTestnetFlag());
  const [isRpcRequestPending, setIsRpcRequestPending] = useState(false);
  const [rpcResult, setRpcResult] = useState<IFormattedRpcResponse | null>();

  const [modal, setModal] = useState("");

  const closeModal = () => setModal("");
  const openPingModal = () => setModal("ping");
  const openRequestModal = () => setModal("request");

  // Initialize the WalletConnect client.
  const {
    client,
    session,
    disconnect,
    chain,
    accounts,
    balances,
    chainData,
    isFetchingBalances,
    isInitializing,
    connect,
    web3Provider,
  } = useWalletConnectClient();

  const verifyEip155MessageSignature = (message: string, signature: string, address: string) =>
    utils.verifyMessage(message, signature).toLowerCase() === address.toLowerCase();

  const ping = async () => {
    if (typeof client === "undefined") {
      throw new Error("WalletConnect Client is not initialized");
    }

    if (typeof session === "undefined") {
      throw new Error("Session is not connected");
    }

    try {
      setIsRpcRequestPending(true);
      await client.ping({ topic: session.topic });
      setRpcResult({
        address: "",
        method: "ping",
        valid: true,
        result: "success",
      });
    } catch (error) {
      console.error("RPC request failed:", error);
    } finally {
      setIsRpcRequestPending(false);
    }
  };

  const onPing = async () => {
    openPingModal();
    await ping();
  };

  const testSendTransaction: () => Promise<IFormattedRpcResponse> = async () => {
    if (!web3Provider) {
      throw new Error("web3Provider not connected");
    }

    const { chainId } = await web3Provider.getNetwork();
    const [address] = await web3Provider.listAccounts();
    const balance = await web3Provider.getBalance(address);

    const tx = await formatTestTransaction("eip155:" + chainId + ":" + address);

    if (balance.lt(BigNumber.from(tx.gasPrice).mul(tx.gasLimit))) {
      return {
        method: "eth_sendTransaction",
        address,
        valid: false,
        result: "Insufficient funds for intrinsic transaction cost",
      };
    }

    const txHash = await web3Provider.send("eth_sendTransaction", [tx]);

    return {
      method: "eth_sendTransaction",
      address,
      valid: true,
      result: txHash,
    };
  };

  const testSignTransaction: () => Promise<IFormattedRpcResponse> = async () => {
    if (!web3Provider) {
      throw new Error("web3Provider not connected");
    }

    const { chainId } = await web3Provider.getNetwork();
    const [address] = await web3Provider.listAccounts();

    const tx = await formatTestTransaction("eip155:" + chainId + ":" + address);
    const signedTx = await web3Provider.send("eth_signTransaction", [tx]);
    const valid = Transaction.fromSerializedTx(signedTx as any).verifySignature();

    return {
      method: "eth_signTransaction",
      address,
      valid,
      result: signedTx,
    };
  };

  const testSignMessage: () => Promise<IFormattedRpcResponse> = async () => {
    if (!web3Provider) {
      throw new Error("web3Provider not connected");
    }

    const msg = "hello world";
    const hexMsg = encoding.utf8ToHex(msg, true);
    const [address] = await web3Provider.listAccounts();
    const signature = await web3Provider.send("personal_sign", [hexMsg, address]);
    const hashMsg = hashPersonalMessage(msg)
    const valid = await verifySignature(address, signature, hashMsg, web3Provider);
    return {
      method: "personal_sign",
      address,
      valid,
      result: signature,
    };
  };

  const testEthSign: () => Promise<IFormattedRpcResponse> = async () => {
    if (!web3Provider) {
      throw new Error("web3Provider not connected");
    }
    const msg = "hello world";
    const hexMsg = encoding.utf8ToHex(msg, true);
    const [address] = await web3Provider.listAccounts();
    const signature = await web3Provider.send("eth_sign", [address, hexMsg]);
    const valid = verifyEip155MessageSignature(msg, signature, address);
    return {
      method: "eth_sign (standard)",
      address,
      valid,
      result: signature,
    };
  };

  const testSignTypedData: () => Promise<IFormattedRpcResponse> = async () => {
    if (!web3Provider) {
      throw new Error("web3Provider not connected");
    }

    const message = JSON.stringify(eip712.example);

    const [address] = await web3Provider.listAccounts();

    // eth_signTypedData params
    const params = [address, message];

    // send message
    const signature = await web3Provider.send("eth_signTypedData", params);

    const hashedTypedData = hashTypedDataMessage(message);
    const valid = await verifySignature(
          address,
          signature,
          hashedTypedData,
          web3Provider
        );
    return {
      method: "eth_signTypedData",
      address,
      valid,
      result: signature,
    };
  };

  const getEthereumActions = (): AccountAction[] => {
    const wrapRpcRequest = (rpcRequest: () => Promise<IFormattedRpcResponse>) => async () => {
      openRequestModal();
      try {
        setIsRpcRequestPending(true);
        const result = await rpcRequest();
        setRpcResult(result);
      } catch (error) {
        console.error("RPC request failed:", error);
        setRpcResult(null);
      } finally {
        setIsRpcRequestPending(false);
      }
    };

    return [
      { method: "eth_sendTransaction", callback: wrapRpcRequest(testSendTransaction) },
      { method: "eth_signTransaction", callback: wrapRpcRequest(testSignTransaction) },
      { method: "personal_sign", callback: wrapRpcRequest(testSignMessage) },
      { method: "eth_sign (standard)", callback: wrapRpcRequest(testEthSign) },
      { method: "eth_signTypedData", callback: wrapRpcRequest(testSignTypedData) },
    ];
  };

  const getBlockchainActions = (chainId: string) => {
    const [namespace] = chainId.split(":");
    switch (namespace) {
      case "eip155":
        return getEthereumActions();
      case "cosmos":
        return [];
      default:
        break;
    }
  };

  // Toggle between displaying testnet or mainnet chains as selection options.
  const toggleTestnets = () => {
    const nextIsTestnetState = !isTestnet;
    setIsTestnet(nextIsTestnetState);
    setLocaleStorageTestnetFlag(nextIsTestnetState);
  };

  // Renders the appropriate model for the given request that is currently in-flight.
  const renderModal = () => {
    switch (modal) {
      case "request":
        return <RequestModal pending={isRpcRequestPending} result={rpcResult} />;
      case "ping":
        return <PingModal pending={isRpcRequestPending} result={rpcResult} />;
      default:
        return null;
    }
  };

  const renderContent = () => {
    const chainOptions = isTestnet ? DEFAULT_TEST_CHAINS : DEFAULT_MAIN_CHAINS;
    return !accounts.length && !Object.keys(balances).length ? (
      <SLanding center>
        <Banner />
        <h6>
          <span>{`Using v${version || "2.0.0-beta"}`}</span>
        </h6>
        <SButtonContainer>
          <h6>Select an Ethereum chain:</h6>
          <SToggleContainer>
            <p>Testnets Only?</p>
            <Toggle active={isTestnet} onClick={toggleTestnets} />
          </SToggleContainer>
          {chainOptions.map(chainId => (
            <Blockchain key={chainId} chainId={chainId} chainData={chainData} onClick={connect} />
          ))}
        </SButtonContainer>
      </SLanding>
    ) : (
      <SAccountsContainer>
        <h3>Account</h3>
        <SAccounts>
          {accounts.map(account => {
            return (
              <Blockchain
                key={account}
                active={true}
                chainData={chainData}
                fetching={isFetchingBalances}
                address={account}
                chainId={chain}
                balances={balances}
                actions={getBlockchainActions(chain)}
              />
            );
          })}
        </SAccounts>
      </SAccountsContainer>
    );
  };

  return (
    <SLayout>
      <Column maxWidth={1000} spanHeight>
        <Header ping={onPing} disconnect={disconnect} session={session} />
        <SContent>{isInitializing ? "Loading..." : renderContent()}</SContent>
      </Column>
      <Modal show={!!modal} closeModal={closeModal}>
        {renderModal()}
      </Modal>
    </SLayout>
  );
};

export default Home;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/react-app-env.d.ts">
/// <reference types="react-scripts" />
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/src/styles.ts">
export const colors: Record<string, string> = {
  white: "255, 255, 255",
  black: "0, 0, 0",
  dark: "12, 12, 13",
  grey: "169, 169, 188",
  darkGrey: "113, 119, 138",
  lightGrey: "212, 212, 212",
  blue: "101, 127, 230",
  lightBlue: "64, 153, 255",
  yellow: "250, 188, 45",
  orange: "246, 133, 27",
  green: "84, 209, 146",
  pink: "255, 51, 102",
  red: "214, 75, 71",
  purple: "110, 107, 233",
};

export const fonts = {
  size: {
    tiny: "10px",
    small: "14px",
    medium: "16px",
    large: "18px",
    h1: "60px",
    h2: "50px",
    h3: "40px",
    h4: "32px",
    h5: "24px",
    h6: "20px",
  },
  weight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
  },
  family: {
    OpenSans: `"Open Sans", sans-serif`,
  },
};

export const transitions = {
  short: "all 0.1s ease-in-out",
  base: "all 0.2s ease-in-out",
  long: "all 0.3s ease-in-out",
  button: "all 0.15s ease-in-out",
};

export const shadows = {
  soft: "0 4px 6px 0 rgba(50, 50, 93, 0.11), 0 1px 3px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
  medium:
    "0 3px 6px 0 rgba(0, 0, 0, 0.06), 0 0 1px 0 rgba(50, 50, 93, 0.02), 0 5px 10px 0 rgba(59, 59, 92, 0.08)",
  big: "0 15px 35px 0 rgba(50, 50, 93, 0.06), 0 5px 15px 0 rgba(50, 50, 93, 0.15)",
  hover:
    "0 7px 14px 0 rgba(50, 50, 93, 0.1), 0 3px 6px 0 rgba(0, 0, 0, 0.08), inset 0 0 1px 0 rgba(0, 0, 0, 0.06)",
};

export const responsive = {
  xs: {
    min: "min-width: 467px",
    max: "max-width: 468px",
  },
  sm: {
    min: "min-width: 639px",
    max: "max-width: 640px",
  },
  md: {
    min: "min-width: 959px",
    max: "max-width: 960px",
  },
  lg: {
    min: "min-width: 1023px",
    max: "max-width: 1024px",
  },
  xl: {
    min: "min-width: 1399px",
    max: "max-width: 1400px",
  },
};

export const globalStyle = `

  html, body, #root {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: ${fonts.family.OpenSans};
    font-style: normal;
    font-stretch: normal;
    font-weight: ${fonts.weight.normal};
    font-size: ${fonts.size.medium};
    background-color: rgb(${colors.white});
    color: rgb(${colors.dark});
    overflow-y:auto;
    text-rendering: optimizeLegibility;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  	-webkit-text-size-adjust: 100%;
    -webkit-overflow-scrolling: touch;
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;  
  }

  button {
    border-style: none;
    line-height: 1em;
    background-image: none;
    outline: 0;
    -webkit-box-shadow: none;
            box-shadow: none;
  }

  [tabindex] {
    outline: none;
    width: 100%;
    height: 100%;
  }

  a, p, h1, h2, h3, h4, h5, h6 {
  	text-decoration: none;
  	margin: 0;
    padding: 0;
    margin: 0.7em 0;
  }

  h1 {
    font-size: ${fonts.size.h1}
  }
  h2 {
    font-size: ${fonts.size.h2}
  }
  h3 {
    font-size: ${fonts.size.h3}
  }
  h4 {
    font-size: ${fonts.size.h4}
  }
  h5 {
    font-size: ${fonts.size.h5}
  }
  h6 {
    font-size: ${fonts.size.h6}
  }

  a {
    background-color: transparent;
    -webkit-text-decoration-skip: objects;  
    text-decoration: none;
    color: inherit;
    outline: none;
  }

  b,
  strong {
    font-weight: inherit;
    font-weight: bolder;
  }

  ul, li {
  	list-style: none;
  	margin: 0;
  	padding: 0;
  }

  * {
    box-sizing: border-box !important;
  }


  input {
    -webkit-appearance: none;
  }

  article,
  aside,
  details,
  figcaption,
  figure,
  footer,
  header,
  main,
  menu,
  nav,
  section,
  summary {
    display: block;
  }
  audio,
  canvas,
  progress,
  video {
    display: inline-block;
  }

  input[type="color"],
  input[type="date"],
  input[type="datetime"],
  input[type="datetime-local"],
  input[type="email"],
  input[type="month"],
  input[type="number"],
  input[type="password"],
  input[type="search"],
  input[type="tel"],
  input[type="text"],
  input[type="time"],
  input[type="url"],
  input[type="week"],
  select:focus,
  textarea {
    font-size: 16px;
  }
`;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/.env.local.example">
NEXT_PUBLIC_PROJECT_ID=39bc93c...
NEXT_PUBLIC_RELAY_URL=wss://relay.walletconnect.com
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

.eslintcache
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/.prettierrc">
{
  "tabWidth": 2,
  "useTabs": false,
  "trailingComma": "all",
  "printWidth": 100,
  "arrowParens": "avoid"
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/images.d.ts">
declare module "*.svg";
declare module "*.png";
declare module "*.jpg";
declare module "*.jpeg";
declare module "*.gif";
declare module "*.bmp";
declare module "*.tiff";
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/LICENSE">
MIT License

Copyright (c) 2021 WalletConnect, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  distDir: "build",
  webpack(config) {
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false,
    };

    return config;
  },
};

module.exports = nextConfig;
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/package.json">
{
  "name": "react-dapp-v2-with-ethers",
  "version": "2.0.0-beta.26",
  "private": true,
  "keywords": [
    "walletconnect",
    "ethereum",
    "web3",
    "crypto"
  ],
  "author": "WalletConnect, Inc. <walletconnect.com>",
  "license": "MIT",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prettier": "prettier --check '**/*.{js,ts,jsx,tsx}'"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/walletconnect/walletconnect-monorepo.git"
  },
  "bugs": {
    "url": "https://github.com/walletconnect/walletconnect-monorepo/issues"
  },
  "resolutions": {
    "react-error-overlay": "6.0.11"
  },
  "dependencies": {
    "@ethereumjs/tx": "^3.5.0",
    "@ethersproject/abstract-signer": "^5.8.0",
    "@noble/secp256k1": "^2.2.3",
    "@walletconnect/core": "^2.19.1",
    "@walletconnect/encoding": "^1.0.2",
    "@walletconnect/jsonrpc-utils": "^1.0.8",
    "@walletconnect/sign-client": "^2.19.1",
    "@walletconnect/types": "^2.7.6",
    "@walletconnect/universal-provider": "^2.7.6",
    "@walletconnect/utils": "^2.7.6",
    "@web3modal/standalone": "^2.3.7",
    "axios": "^1.8.2",
    "blockies-ts": "^1.0.0",
    "cosmos-wallet": "^1.1.0",
    "eth-sig-util": "^2.5.3",
    "ethereumjs-util": "^7.0.6",
    "ethers": "5.7.2",
    "next": "14.2.25",
    "prop-types": "^15.7.2",
    "qr-image": "^3.2.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "^4.0.3",
    "styled-components": "^6.1.15",
    "typescript": "^4.3.2",
    "web-vitals": "^0.2.4"
  },
  "devDependencies": {
    "@babel/preset-env": "^7.19.4",
    "@testing-library/jest-dom": "^5.16.1",
    "@testing-library/react": "^12.1.2",
    "@testing-library/user-event": "^13.5.0",
    "@types/bn.js": "^5.1.0",
    "@types/eth-sig-util": "^2.1.1",
    "@types/jest": "^27.4.0",
    "@types/node": "^17.0.14",
    "@types/pino": "^7.0.5",
    "@types/prop-types": "^15.7.4",
    "@types/qr-image": "^3.2.5",
    "@types/react": "18.0.15",
    "@types/react-dom": "18.0.6",
    "@types/styled-components": "^5.1.34",
    "prettier": "^2.5.1",
    "eslint-config-next": "14.2.25"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": [
    ">0.2%",
    "not dead",
    "not op_mini all"
  ],
  "pnpm": {
    "overrides": {
      "node-forge@<1.0.0": ">=1.0.0",
      "node-forge@<1.3.0": ">=1.3.0",
      "ejs@<3.1.7": ">=3.1.7",
      "browserslist@>=4.0.0 <4.16.5": ">=4.16.5",
      "loader-utils@>=2.0.0 <2.0.3": ">=2.0.3",
      "postcss@<8.4.31": ">=8.4.31",
      "next@>=0.9.9 <13.4.20-canary.13": ">=13.4.20-canary.13",
      "loader-utils@>=2.0.0 <2.0.4": ">=2.0.4",
      "nth-check@<2.0.1": ">=2.0.1",
      "shell-quote@<=1.7.2": ">=1.7.3",
      "minimatch@<3.0.5": ">=3.0.5",
      "webpack-dev-middleware@<=5.3.3": ">=5.3.4",
      "immer@>=7.0.0 <9.0.6": ">=9.0.6",
      "protobufjs@>=6.10.0 <6.11.4": ">=6.11.4",
      "braces@<3.0.3": ">=3.0.3",
      "ejs@<3.1.10": ">=3.1.10",
      "ws@>=7.0.0 <7.5.10": ">=7.5.10",
      "elliptic@>=4.0.0 <=6.5.6": ">=6.5.7",
      "elliptic@>=2.0.0 <=6.5.6": ">=6.5.7",
      "elliptic@>=5.2.1 <=6.5.6": ">=6.5.7",
      "micromatch@<4.0.8": ">=4.0.8",
      "rollup@<2.79.2": ">=2.79.2",
      "http-proxy-middleware@<2.0.7": ">=2.0.7",
      "next@>=10.0.0 <14.2.7": ">=14.2.7",
      "cross-spawn@>=7.0.0 <7.0.5": ">=7.0.5",
      "semver@>=7.0.0 <7.5.2": ">=7.5.2",
      "next@>=9.5.5 <14.2.15": ">=14.2.15",
      "elliptic@<6.6.0": ">=6.6.0",
      "elliptic@<6.5.6": ">=6.5.6",
      "ansi-html@<0.0.8": ">=0.0.8",
      "elliptic@<=6.6.0": ">=6.6.1"
    }
  }
}
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/README.md">
# React dApp (with v2 UniversalProvider + Ethers.js)

🔗 Live dapp demo - https://react-dapp-v2-with-ethers.vercel.app <br />
🔗 Live wallet demo - https://react-wallet.walletconnect.com/ <br />
📚 WalletConnect v2 Docs - https://docs.walletconnect.com/2.0

## Overview

This is an example implementation of a React dApp (generated via `create-react-app`) using the v2 [`UniversalProvider`](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/providers/universal-provider) together with [`Ethers.js`](https://docs.ethers.io/v5/) to:

- handle pairings
- manage sessions
- send JSON-RPC requests to a paired wallet

## Running locally

Install the app's dependencies:

```bash
yarn
```

Set up your local environment variables by copying the example into your own `.env.local` file:

```bash
cp .env.local.example .env.local
```

Your `.env.local` now contains the following environment variables:

- `NEXT_PUBLIC_PROJECT_ID` (placeholder) - You can generate your own ProjectId at https://cloud.walletconnect.com
- `NEXT_PUBLIC_RELAY_URL` (already set)

## Develop

```bash
yarn dev
```

## Test

```bash
yarn test
```

## Build

```bash
yarn build
```
</file>

<file path="advanced/dapps/react-dapp-v2-with-ethers/tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
</file>

<file path="advanced/dapps/smart-sessions-demo/public/.well-known/walletconnect.txt">
036e2dea-947e-4ab5-b5a6-cc007ba52c13=cd9cfc50fcb49c77b511f53fcdd336589c05f1ec6e6cc5d4fbf4ebe7f8b9cb07
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/api/dca/execute/route.ts">
import {
  abi as donutContractAbi,
  address as donutContractAddress,
} from "@/utils/DonutContract";
import { executeActionsWithECDSAKey } from "@/utils/ERC7715PermissionsAsyncUtils";
import { NextResponse } from "next/server";
import { encodeFunctionData, parseEther } from "viem";
import { DCAFormSchemaType } from "@/schema/DCAFormSchema";
import { SmartSessionGrantPermissionsResponse } from "@reown/appkit-experimental/smart-session";
import { getChain } from "@/utils/ChainsUtil";

// Helper function to validate request inputs
const validateRequestInputs = (
  strategy: DCAFormSchemaType,
  permissions: SmartSessionGrantPermissionsResponse,
  privateKey: string | undefined,
) => {
  if (!privateKey) throw new Error("No application signer");
  if (!strategy) throw new Error("No strategy provided");
  if (!permissions || !permissions.context || !permissions.address)
    throw new Error("No permissions provided");
};

// Helper function to validate chain ID and get chain object
const getValidatedChain = (chainIdHex: string) => {
  const chainId = parseInt(chainIdHex, 16);
  if (!chainId)
    throw new Error("Chain ID not available in granted permissions");

  const chain = getChain(chainId);
  if (!chain) throw new Error("Unknown chainId");
  return chain;
};

// Helper function to construct purchase call data
const getPurchaseDonutCallData = () =>
  encodeFunctionData({
    abi: donutContractAbi,
    functionName: "purchase",
    args: [1],
  });

// Main handler function for POST request
export async function POST(request: Request) {
  try {
    const {
      strategy,
      permissions,
    }: {
      strategy: DCAFormSchemaType;
      permissions: SmartSessionGrantPermissionsResponse;
    } = await request.json();
    const APPLICATION_PRIVATE_KEY = process.env
      .APPLICATION_PRIVATE_KEY as `0x${string}`;
    // Validate inputs and get chain
    validateRequestInputs(strategy, permissions, APPLICATION_PRIVATE_KEY);

    const chain = getValidatedChain(permissions.chainId);

    // Create purchase call data
    const purchaseDonutCallData = getPurchaseDonutCallData();
    const purchaseDonutCallDataExecution = [
      {
        to: donutContractAddress as `0x${string}`,
        value: parseEther("0.0001"),
        data: purchaseDonutCallData,
      },
    ];
    // Execute the actions using ECDSA key
    await executeActionsWithECDSAKey({
      ecdsaPrivateKey: APPLICATION_PRIVATE_KEY,
      actions: purchaseDonutCallDataExecution,
      chain,
      accountAddress: permissions.address,
      permissionsContext: permissions.context,
    });

    return NextResponse.json(
      { message: "Asset successfully purchased." },
      { status: 200 },
    );
  } catch (error) {
    return handleError(error);
  }
}

// Helper function to handle and log errors
const handleError = (error: unknown) => {
  const errorMessage = getErrorMessage(error);
  console.error("Error interacting with contract:", errorMessage);
  return NextResponse.json(
    { message: errorMessage, error: errorMessage },
    { status: 500 },
  );
};

// Helper function to extract error message
const getErrorMessage = (error: unknown): string => {
  if (error instanceof Error) return error.message;
  if (typeof error === "string") return error;
  try {
    return JSON.stringify(error, null, 2);
  } catch {
    return Object.prototype.toString.call(error);
  }
};
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/api/signer/route.ts">
import { NextResponse } from "next/server";
import { privateKeyToAccount } from "viem/accounts";

export function GET() {
  try {
    const APPLICATION_PRIVATE_KEY = process.env
      .APPLICATION_PRIVATE_KEY as `0x${string}`;
    const account = privateKeyToAccount(APPLICATION_PRIVATE_KEY);

    return NextResponse.json({ key: account.publicKey });
  } catch (e) {
    console.warn("Error getting signer:", e);

    return NextResponse.json(
      { message: "Error getting application signer" },
      { status: 500 },
    );
  }
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/api/tictactoe/create/route.ts">
import { createGame } from "@/utils/TicTacToeUtils";
import { SmartSessionGrantPermissionsResponse } from "@reown/appkit-experimental/smart-session";
import { NextResponse } from "next/server";
import { isAddress } from "viem";

export async function POST(request: Request) {
  try {
    const APPLICATION_PRIVATE_KEY = process.env.APPLICATION_PRIVATE_KEY;
    if (!APPLICATION_PRIVATE_KEY) {
      return NextResponse.json(
        { message: "Missing required environment variables" },
        { status: 400 },
      );
    }
    const { permissions } = await request.json();

    if (!permissions) {
      return NextResponse.json(
        { message: "No permissions provided" },
        { status: 400 },
      );
    }

    const playerOAddress = (permissions as SmartSessionGrantPermissionsResponse)
      .address;

    if (!playerOAddress || !isAddress(playerOAddress))
      throw new Error("Invalid playerO address");

    const txHash = await createGame(APPLICATION_PRIVATE_KEY, playerOAddress);

    return NextResponse.json({ transactionHash: txHash });
  } catch (e) {
    console.error("Error:", e);
    return NextResponse.json(
      { message: "An error occurred", error: (e as Error).message },
      { status: 500 },
    );
  }
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/api/tictactoe/make-move/system/route.ts">
import {
  findRandomEmptyPosition,
  getBoardState,
  makeComputerMove,
} from "@/utils/TicTacToeUtils";
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  try {
    const { gameId } = await request.json();

    if (typeof gameId !== "string") {
      return NextResponse.json({ message: "Invalid game ID" }, { status: 400 });
    }
    const board = await getBoardState(gameId);
    const computerPosition = findRandomEmptyPosition(board);
    if (computerPosition === null) {
      return NextResponse.json({ message: "Game is over" }, { status: 400 });
    }
    const APPLICATION_PRIVATE_KEY = process.env.APPLICATION_PRIVATE_KEY;
    if (!APPLICATION_PRIVATE_KEY) {
      return NextResponse.json(
        { message: "Missing required environment variables" },
        { status: 400 },
      );
    }
    const systemMoveTxHash = await makeComputerMove(
      APPLICATION_PRIVATE_KEY,
      gameId,
      computerPosition,
    );

    return NextResponse.json({ transactionHash: systemMoveTxHash });
  } catch (e) {
    console.error("Error:", e);
    const errorMessage = (e as Error)?.message || "Error making move";
    return NextResponse.json(
      { message: "Error making move", error: errorMessage },
      { status: 500 },
    );
  }
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/api/tictactoe/make-move/user/route.ts">
import { makeUserMove } from "@/utils/TicTacToeUtils";
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  try {
    const { gameId, position, permissions } = await request.json();

    if (typeof gameId !== "string") {
      return NextResponse.json({ message: "Invalid game ID" }, { status: 400 });
    }
    if (typeof position !== "number" || position < 0 || position > 8) {
      return NextResponse.json(
        { message: "Invalid position" },
        { status: 400 },
      );
    }
    const APPLICATION_PRIVATE_KEY = process.env.APPLICATION_PRIVATE_KEY;
    if (!APPLICATION_PRIVATE_KEY) {
      return NextResponse.json(
        { message: "Missing required environment variables" },
        { status: 400 },
      );
    }

    const userTxHash = await makeUserMove(
      APPLICATION_PRIVATE_KEY,
      gameId,
      position,
      permissions,
    );
    return NextResponse.json({ userOpIdentifier: userTxHash });
  } catch (e) {
    console.error("Error:", e);
    const errorMessage = (e as Error)?.message || "Error making move";
    return NextResponse.json(
      { message: "Error making move", error: errorMessage },
      { status: 500 },
    );
  }
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/demo/dca/page.tsx">
"use client";
import React from "react";
import { createAppKit } from "@reown/appkit/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import { baseSepolia, type AppKitNetwork } from "@reown/appkit/networks";
import { WagmiAdapter } from "@reown/appkit-adapter-wagmi";
import { DcaApplicationContextProvider } from "@/context/DcaApplicationContextProvider";
import { Toaster } from "@/components/ui/sonner";
import DCA from "@/components/DcaComponents/DCA";
import { ConstantsUtil } from "@/utils/ConstantsUtil";

const queryClient = new QueryClient();

const networks = [baseSepolia] as [AppKitNetwork, ...AppKitNetwork[]];

const wagmiAdapter = new WagmiAdapter({
  ssr: true,
  networks,
  projectId: ConstantsUtil.ProjectId,
});

createAppKit({
  adapters: [wagmiAdapter],
  networks,
  defaultNetwork: baseSepolia,
  projectId: ConstantsUtil.ProjectId,
  features: {
    analytics: true,
    email: true,
    socials: [],
    emailShowWallets: false,
  },
  themeMode: "light",
  termsConditionsUrl: "https://reown.com/terms-of-service",
  privacyPolicyUrl: "https://reown.com/privacy-policy",
});

export default function DCAPage() {
  return (
    <WagmiProvider config={wagmiAdapter.wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        <DcaApplicationContextProvider>
          <DCA />
          <Toaster expand={true} />
        </DcaApplicationContextProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/demo/tictactoe/page.tsx">
"use client";
import React from "react";
import { createAppKit } from "@reown/appkit/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import { baseSepolia, type AppKitNetwork } from "@reown/appkit/networks";
import { WagmiAdapter } from "@reown/appkit-adapter-wagmi";
import { Toaster } from "@/components/ui/sonner";
import { ConstantsUtil } from "@/utils/ConstantsUtil";
import TicTacToe from "@/components/TicTacToeComponents/TicTacToe";
import { TicTacToeContextProvider } from "@/context/TicTacToeContextProvider";

const queryClient = new QueryClient();

const networks = [baseSepolia] as [AppKitNetwork, ...AppKitNetwork[]];

const wagmiAdapter = new WagmiAdapter({
  ssr: true,
  networks,
  projectId: ConstantsUtil.ProjectId,
});

createAppKit({
  adapters: [wagmiAdapter],
  networks,
  defaultNetwork: baseSepolia,
  projectId: ConstantsUtil.ProjectId,
  features: {
    email: true,
    socials: [],
    emailShowWallets: false,
    analytics: true,
  },
  allWallets: "HIDE",
  themeMode: "light",
  termsConditionsUrl: "https://reown.com/terms-of-service",
  privacyPolicyUrl: "https://reown.com/privacy-policy",
});

export default function TicTacToePage() {
  return (
    <WagmiProvider config={wagmiAdapter.wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        <TicTacToeContextProvider>
          <TicTacToe />
          <Toaster expand={true} />
        </TicTacToeContextProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }

  /* Custom class to remove number input arrows */
  .no-arrows::-webkit-inner-spin-button,
  .no-arrows::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .no-arrows {
    -moz-appearance: textfield;
    appearance: textfield;
  }
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/HomePage.tsx">
import React from "react";
import DemoApplicationList from "@/components/DemoApplicationList";
import { smartSessionsDemoAppMetadata } from "@/utils/DataUtil";
import { Separator } from "@/components/ui/separator";

export default function HomePage() {
  return (
    <div className="min-h-screen">
      <header className="sticky top-0 z-50 w-full border-b">
        <div className="container mx-auto px-4 h-14 flex items-center">
          <a className="flex items-center space-x-2" href="/">
            <span className="font-bold text-lg">Smart Session Demos</span>
          </a>
        </div>
      </header>
      <Separator />
      <main className="container mx-auto px-4 py-6">
        <DemoApplicationList demoAppsMetadata={smartSessionsDemoAppMetadata} />
      </main>
    </div>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import React from "react";

// eslint-disable-next-line new-cap
const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Smart Sessions Demo",
  description: "Smart Sessions Demo",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/app/page.tsx">
"use client";
import React from "react";

import HomePage from "./HomePage";

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col  p-8 bg-gray-100 dark:bg-gray-900">
      <HomePage />
    </main>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/AddressDisplay.tsx">
import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Copy, Check } from "lucide-react";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface AddressDisplayProps {
  address: string;
}

export default function AddressDisplay({ address }: AddressDisplayProps) {
  const [copied, setCopied] = useState(false);

  function shortenAddress(address: string) {
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  }

  function copyToClipboard() {
    navigator.clipboard.writeText(address).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000); // Reset after 2 seconds
    });
  }

  return (
    <div className="flex justify-between items-center border-b pb-2">
      <p className="font-semibold">Address</p>
      <div className="flex items-center space-x-2">
        <p className="text-sm">{shortenAddress(address)}</p>
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="outline" size="icon" onClick={copyToClipboard}>
                {copied ? (
                  <Check className="h-4 w-4" />
                ) : (
                  <Copy className="h-4 w-4" />
                )}
              </Button>
            </TooltipTrigger>
            <TooltipContent>
              <p>{copied ? "Copied!" : "Copy"}</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      </div>
    </div>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/AssetAllocationField.tsx">
import React from "react";
import { Controller } from "react-hook-form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { assetsToAllocate } from "@/utils/DCAUtils";
import { FieldProps } from "./DCAForm";

const ForwardedSelect = React.forwardRef<
  never, // Select does not accept ref prop
  React.ComponentPropsWithoutRef<typeof Select>
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
>((props, _ref) => <Select {...props} />);
ForwardedSelect.displayName = "ForwardedSelect";

const ForwardedInput = React.forwardRef<
  HTMLInputElement,
  React.ComponentPropsWithoutRef<typeof Input>
>((props, ref) => <Input {...props} ref={ref} />);
ForwardedInput.displayName = "ForwardedInput";

export default function AssetAllocationField({ control, errors }: FieldProps) {
  return (
    <div className="grid w-full max-w-sm gap-1.5">
      <div
        className={`grid max-w-sm items-center gap-1.5 rounded-lg p-4 bg-blue-200 focus-within:ring-2 focus-within:border-blue-500 ${
          errors.assetToAllocate ? "border-2 border-red-500" : ""
        }`}
      >
        <Label className="flex" htmlFor="assetToAllocate">
          I Want To Allocate
        </Label>
        <div className="flex w-full max-w-sm items-center space-x-2">
          <Controller
            name="assetToAllocate"
            control={control}
            render={({ field }) => (
              <ForwardedSelect
                {...field}
                onValueChange={field.onChange}
                value={field.value}
              >
                <SelectTrigger
                  className={`w-[180px] text-lg border-none bg-blue-200 focus:outline-none focus:ring-0 focus:ring-offset-0 ${
                    errors.assetToAllocate ? "border-2 border-red-500" : ""
                  }`}
                >
                  <SelectValue>
                    {assetsToAllocate.find(
                      (option) => option.value === field.value,
                    )?.label || "Select asset"}
                  </SelectValue>
                </SelectTrigger>
                <SelectContent>
                  <SelectGroup>
                    {assetsToAllocate.map((option) => (
                      <SelectItem
                        key={option.value}
                        value={option.value}
                        disabled={!option.supported}
                      >
                        {option.label}
                      </SelectItem>
                    ))}
                  </SelectGroup>
                </SelectContent>
              </ForwardedSelect>
            )}
          />
          <Controller
            name="allocationAmount"
            control={control}
            render={({ field }) => (
              <ForwardedInput
                {...field}
                type="number"
                placeholder="0.00"
                className={`border-none text-lg no-arrows bg-transparent text-right focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-offset-0 ${
                  errors.allocationAmount ? "border-2 border-red-500" : ""
                }`}
              />
            )}
          />
        </div>
      </div>
      {errors.allocationAmount && (
        <div className="w-full text-left">
          <p className="text-red-500 text-sm">
            {errors.allocationAmount.message}
          </p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/AssetBalance.tsx">
import React from "react";
import { Button } from "../ui/button";
import { RefreshCcw } from "lucide-react";

interface AssetBalanceProps {
  assetName: string;
  balance: string | undefined;
  isLoading: boolean;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  refetch: Function;
}

export default function AssetBalance({
  assetName,
  balance,
  isLoading,
  refetch,
}: AssetBalanceProps) {
  return (
    <>
      <div className="flex justify-between border-b pb-2">
        <p className="font-semibold">Asset</p>
        <p className="font-semibold">Balance</p>
      </div>
      <div className="flex justify-between items-center">
        <p>{assetName}</p>
        {isLoading ? (
          <p>...</p>
        ) : (
          <p>
            {balance}
            <Button
              className="ml-2"
              variant="outline"
              size="icon"
              onClick={() => refetch()}
            >
              <RefreshCcw className="h-4 w-4" />
            </Button>
          </p>
        )}
      </div>
    </>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/AssetToBuyField.tsx">
import React from "react";
import { Controller } from "react-hook-form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { assetsToBuy } from "@/utils/DCAUtils";
import { FieldProps } from "./DCAForm";

const ForwardedSelect = React.forwardRef<
  never, // Select does not accept ref prop
  React.ComponentPropsWithoutRef<typeof Select>
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
>((props, _ref) => <Select {...props} />);
ForwardedSelect.displayName = "ForwardedSelect";

// Forward ref correctly for Input, since it accepts ref prop
const ForwardedInput = React.forwardRef<
  HTMLInputElement,
  React.ComponentPropsWithoutRef<typeof Input>
>((props, ref) => <Input {...props} ref={ref} />);
ForwardedInput.displayName = "ForwardedInput";

export default function AssetToBuyField({ control, errors }: FieldProps) {
  return (
    <div className="grid w-full max-w-sm gap-1.5">
      <div
        className={`grid max-w-sm items-center gap-1.5 rounded-lg p-4 bg-blue-200 focus-within:ring-2 focus-within:border-blue-500 ${
          errors.assetToBuy ? "border-2 border-red-500" : ""
        }`}
      >
        <Label className="flex" htmlFor="assetToBuy">
          To Buy
        </Label>
        <Controller
          name="assetToBuy"
          control={control}
          render={({ field }) => (
            <ForwardedSelect
              {...field}
              onValueChange={field.onChange}
              value={field.value}
            >
              <SelectTrigger
                className={`w-full text-lg border-none bg-transparent focus:outline-none focus:ring-0 focus:ring-offset-0 ${
                  errors.assetToBuy ? "border-2 border-red-500" : ""
                }`}
              >
                <SelectValue>
                  {assetsToBuy.find((option) => option.value === field.value)
                    ?.label || "Select asset"}
                </SelectValue>
              </SelectTrigger>
              <SelectContent>
                <SelectGroup>
                  {assetsToBuy.map((option) => (
                    <SelectItem
                      key={option.value}
                      value={option.value}
                      disabled={!option.supported}
                    >
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectGroup>
              </SelectContent>
            </ForwardedSelect>
          )}
        />
      </div>
      {errors.assetToBuy && (
        <div className="w-full text-left">
          <p className="text-red-500 text-sm">{errors.assetToBuy.message}</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/Dashboard.tsx">
import React from "react";
import { useDcaApplicationContext } from "@/context/DcaApplicationContextProvider";
import {
  abi as donutAbi,
  address as donutAddress,
} from "@/utils/DonutContract";
import { useReadContract } from "wagmi";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import AddressDisplay from "./AddressDisplay";
import AssetBalance from "./AssetBalance";
import { useAppKitAccount } from "@reown/appkit/react";

export default function Dashboard() {
  const { smartSession } = useDcaApplicationContext();
  const { address: connectedAddress } = useAppKitAccount();
  const lastAddress = smartSession?.grantedPermissions
    ? smartSession?.grantedPermissions.address
    : connectedAddress;

  return (
    <Card className="max-w-md mx-auto mt-8">
      <CardHeader>
        <CardTitle className="text-center">Dashboard</CardTitle>
      </CardHeader>
      <CardContent>
        {lastAddress ? (
          <DashboardContent address={lastAddress} />
        ) : (
          <EmptyDashboardContent />
        )}
      </CardContent>
    </Card>
  );
}

function DashboardContent({ address }: { address: string }) {
  const {
    data: donutsOwned,
    isLoading: donutsQueryLoading,
    isRefetching: donutsQueryRefetching,
    refetch,
  } = useReadContract({
    abi: donutAbi,
    address: donutAddress,
    functionName: "getBalance",
    args: [address],
    query: {
      refetchOnWindowFocus: false,
    },
  });

  return (
    <div className="flex flex-col space-y-4">
      <AddressDisplay address={address} />
      <AssetBalance
        assetName="Donut"
        balance={donutsOwned?.toString()}
        isLoading={donutsQueryLoading || donutsQueryRefetching}
        refetch={refetch}
      />
    </div>
  );
}

function EmptyDashboardContent() {
  return <p className="text-center">No address found</p>;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/DCA.tsx">
"use client";
import React, { useEffect, useState } from "react";
import DCAForm from "@/components/DcaComponents/DCAForm";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import Dashboard from "@/components/DcaComponents/Dashboard";
import { useAppKitAccount } from "@reown/appkit/react";
import { isSmartSessionSupported } from "@reown/appkit-experimental/smart-session";
import { useDcaApplicationContext } from "@/context/DcaApplicationContextProvider";
import NotConnectedScreen from "./NotConnectedScreen";
import { useBalance } from "wagmi";
import { parseUnits } from "viem";

export default function DCA() {
  // Account and session state
  const { status, address, embeddedWalletInfo } = useAppKitAccount();
  const { smartSession } = useDcaApplicationContext();
  const grantedPermissions = smartSession?.grantedPermissions;
  const { accountType, user } = embeddedWalletInfo ?? {};

  // Derived state checks
  const isWalletConnected = status === "connected" || address !== undefined;
  const isSmartAccount = accountType === "smartAccount";
  const isEmailAllowed = Boolean(user?.email?.includes("+smart-sessions@"));
  const isPermissionExpired = grantedPermissions?.expiry
    ? grantedPermissions.expiry < Date.now() / 1000
    : true;
  const hasValidPermissions = grantedPermissions && !isPermissionExpired;

  // Feature support check
  const isSupported =
    hasValidPermissions ||
    (isSmartSessionSupported() &&
      isWalletConnected &&
      isSmartAccount &&
      isEmailAllowed);

  // Use effective address from either wallet or permissions
  const effectiveAddress =
    address ||
    (hasValidPermissions
      ? (grantedPermissions.address as `0x${string}`)
      : undefined);

  // Balance check
  const balance = useBalance({
    address: effectiveAddress as `0x${string}`,
  });
  const hasInsufficientEth =
    !balance.data || balance.data.value < parseUnits("0.0005", 18);

  // Client-side rendering guard
  const [readyToRender, setReadyToRender] = useState(false);
  useEffect(() => {
    setReadyToRender(true);
  }, []);

  // Generate status messages as an array
  const getStatusMessages = () => {
    const messages = [];

    if (!isEmailAllowed && !hasValidPermissions && isWalletConnected) {
      messages.push({
        id: "email-format",
        content: (
          <>
            Account not connected with required email format:{" "}
            <span className="font-bold text-red-700 dark:text-red-400 whitespace-nowrap">
              youremail+smart-sessions@domain.com
            </span>
          </>
        ),
      });
    }

    if (isEmailAllowed && !isSmartAccount && isWalletConnected) {
      messages.push({
        id: "smart-account",
        content: (
          <>
            Switch to a <span className="font-bold">Smart Account</span> to use
            this feature.
          </>
        ),
      });
    }

    if (isEmailAllowed && isSmartAccount && hasInsufficientEth) {
      messages.push({
        id: "eth-balance",
        content: (
          <>
            Insufficient ETH, need at least{" "}
            <span className="font-bold">0.0005 ETH</span>
          </>
        ),
      });
    }

    return messages;
  };

  const statusMessages = getStatusMessages();

  // Main content for connected users or valid permissions
  const mainContent = (
    <main className="flex min-h-screen flex-col items-center justify-center p-8 bg-gray-100 dark:bg-gray-900">
      <div className="w-full max-w-sm text-center mb-12">
        <h1 className="text-3xl font-bold mb-4 text-gray-800 dark:text-gray-200">
          Dollar Cost Average
        </h1>

        {/* Wallet connection button for connected users */}
        {isWalletConnected && (
          <div className="flex w-full items-center justify-center mb-4">
            <w3m-button />
          </div>
        )}

        {/* Status messages as a list */}
        {statusMessages.length > 0 && (
          <div className="flex w-full items-center mb-4">
            <ul className="text-sm text-red-700 dark:text-gray-300 list-disc list-inside text-left">
              {statusMessages.map((message) => (
                <li key={message.id}>{message.content}</li>
              ))}
            </ul>
          </div>
        )}

        {/* Tabs for DCA and Dashboard */}
        <Tabs defaultValue="dca" className="w-[400px]">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="dca">DCA</TabsTrigger>
            <TabsTrigger value="dashboard">Dashboard</TabsTrigger>
          </TabsList>
          <TabsContent value="dca">
            <DCAForm
              isSupported={isSupported}
              hasInsufficientEth={hasInsufficientEth}
            />
          </TabsContent>
          <TabsContent value="dashboard">
            <Dashboard />
          </TabsContent>
        </Tabs>
      </div>
    </main>
  );

  // Rendering logic
  if (!readyToRender) {
    return null; // Wait until client-side rendering is ready
  }

  // Show if wallet is connected OR has valid permissions
  if (isWalletConnected || hasValidPermissions) {
    return mainContent;
  }

  // If no wallet connection and no permissions, show the connection screen
  return <NotConnectedScreen />;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/DCAExecutionProgress.tsx">
"use client";

import * as React from "react";
import { Progress } from "@/components/ui/progress";
import { DCAFormSchemaType } from "@/schema/DCAFormSchema";
import { useDcaApplicationContext } from "@/context/DcaApplicationContextProvider";
import { calculateInterval } from "@/utils/DCAUtils";
import { toast } from "sonner";

interface DCAExecutionProgressProps {
  strategy: DCAFormSchemaType;
  toastId?: string | number;
}

export function DCAExecutionProgress({
  strategy,
  toastId,
}: DCAExecutionProgressProps) {
  const [progress, setProgress] = React.useState(0);
  const { smartSession, clearSmartSession } = useDcaApplicationContext();
  const totalOrders = strategy.numberOfOrders;
  const intervalInMilliseconds = calculateInterval(
    strategy.investmentInterval,
    strategy.intervalUnit,
  );

  // Initialize nextExecutionTime to the current time plus the interval
  const [nextExecutionTime, setNextExecutionTime] = React.useState<number>(
    Date.now() + intervalInMilliseconds,
  );

  // Force re-render every second
  const [, setTick] = React.useState(0);

  // Flag to track if all orders have been processed
  const [allOrdersCompleted, setAllOrdersCompleted] = React.useState(false);

  // Calculate remaining orders based on progress
  const getRemainingOrders = React.useCallback(() => {
    const completedOrders = Math.floor((progress / 100) * totalOrders);
    return totalOrders - completedOrders;
  }, [progress, totalOrders]);

  // Format time remaining until next execution
  function formatTimeRemaining(time: number) {
    // Prevent negative times
    if (time <= 0) {
      return "executing now...";
    }

    const seconds = Math.floor((time / 1000) % 60);
    const minutes = Math.floor((time / 1000 / 60) % 60);
    return `${minutes}m ${seconds}s`;
  }

  React.useEffect(() => {
    async function executeDCA() {
      // If smartSession is undefined, close the component and dismiss toast
      if (!smartSession) {
        setAllOrdersCompleted(true);
        setShouldClose(true);

        return;
      }

      try {
        // Set status to executing
        setNextExecutionTime(0); // This will show "executing now..."

        fetch("/api/dca/execute", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            strategy,
            permissions: smartSession?.grantedPermissions,
          }),
        });

        // Increment progress after API call completes
        setProgress((prev) => {
          const newProgress = Math.min(prev + 100 / totalOrders, 100);

          // Check if we've reached 100% progress
          if (newProgress >= 100) {
            setAllOrdersCompleted(true);
          }

          return newProgress;
        });

        // Reset next execution time
        if (getRemainingOrders() > 1) {
          // -1 to account for the order we just executed
          setNextExecutionTime(Date.now() + intervalInMilliseconds);
        }
      } catch (error) {
        console.error("Error executing DCA:", error);
      }
    }

    const executionIntervalId = setInterval(() => {
      if (progress < 100 && getRemainingOrders() > 0) {
        executeDCA();
      } else {
        clearInterval(executionIntervalId);
      }
    }, intervalInMilliseconds);

    return () => {
      clearInterval(executionIntervalId);
    };
  }, [
    progress,
    strategy,
    smartSession?.grantedPermissions,
    intervalInMilliseconds,
    totalOrders,
    getRemainingOrders,
  ]);

  // Check if smartSession is undefined when the component mounts
  React.useEffect(() => {
    if (!smartSession) {
     // Also dismiss the toast when the session disappears
      if (toastId) {
        toast.dismiss(toastId);
      }
      setShouldClose(true);
    }
  }, [smartSession]);

  // Track if component should close itself
  const [shouldClose, setShouldClose] = React.useState(false);

  // Clear smart session when all orders are completed
  React.useEffect(() => {
    if (allOrdersCompleted && clearSmartSession) {
      // Add a small delay to ensure the last order has been processed
      const clearTimer = setTimeout(() => {
        clearSmartSession();
        console.log("Smart session cleared after all DCA orders completed");

        // Signal that the component should close after a brief display period
        const closeTimer = setTimeout(() => {
          // Explicitly dismiss the toast using its ID
          if (toastId) {
            toast.dismiss(toastId);
          }
          setShouldClose(true);
        }, 2000); // Show success message for 2 seconds before closing

        return () => clearTimeout(closeTimer);
      }, 1000);

      return () => clearTimeout(clearTimer);
    }
  }, [allOrdersCompleted, clearSmartSession]);

  React.useEffect(() => {
    const countdownIntervalId = setInterval(() => {
      setTick((tick) => tick + 1); // Force re-render every second
    }, 1000);

    return () => clearInterval(countdownIntervalId);
  }, []);

  // If shouldClose is true, return null to close the component
  if (shouldClose) {
    return null;
  }

  return (
    <div className="flex flex-col w-full">
      <h3 className="text-lg font-semibold mb-2">Executing the Strategy...</h3>
      <p className="text-gray-700 mb-4">
        Orders Remaining:{" "}
        <span className="font-bold">{getRemainingOrders()}</span>
      </p>
      <Progress value={progress} className="w-full h-4 bg-blue-200" />
      {nextExecutionTime > 0 && getRemainingOrders() > 0 ? (
        <p className="mt-2 text-sm text-gray-500">
          Executing in {formatTimeRemaining(nextExecutionTime - Date.now())}
        </p>
      ) : getRemainingOrders() > 0 ? (
        <p className="mt-2 text-sm text-gray-500">Executing order now...</p>
      ) : null}
      {allOrdersCompleted && (
        <p className="mt-2 text-sm text-green-500 font-medium">
          All orders completed successfully! Closing...
        </p>
      )}
    </div>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/DCAForm.tsx">
import React from "react";
import { useForm, Control, FieldErrors } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { dcaFormSchema, DCAFormSchemaType } from "@/schema/DCAFormSchema";
import { useDCA } from "@/hooks/useDCA";
import { toast } from "sonner";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { DCAExecutionProgress } from "@/components/DcaComponents/DCAExecutionProgress";
import { ArrowUpDown, Loader2, RefreshCw } from "lucide-react";
import AssetAllocationField from "./AssetAllocationField";
import AssetToBuyField from "./AssetToBuyField";
import InvestmentIntervalField from "./InvestmentIntervalField";
import NumberOfOrdersField from "./NumberOfOrdersField";
import { useDcaApplicationContext } from "@/context/DcaApplicationContextProvider";

export interface FieldProps {
  control: Control<DCAFormSchemaType>;
  errors: FieldErrors<DCAFormSchemaType>;
}

interface DCAFormProps {
  isSupported: boolean;
  hasInsufficientEth?: boolean;
}

function DCAForm({ isSupported, hasInsufficientEth }: DCAFormProps) {
  const {
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<DCAFormSchemaType>({
    resolver: zodResolver(dcaFormSchema),
    defaultValues: {
      assetToAllocate: "eth",
      assetToBuy: "donut",
      intervalUnit: "minute",
      allocationAmount: 0,
      investmentInterval: 0,
      numberOfOrders: 0,
    },
  });

  const { createNewDCAStrategy } = useDCA();
  const [isLoading, setLoading] = React.useState(false);
  const { smartSession, clearSmartSession } = useDcaApplicationContext();

  // Check if there's an active strategy running
  const hasActiveStrategy = !!smartSession;

  // Store active toast IDs
  const [activeToastIds, setActiveToastIds] = React.useState<
    (string | number)[]
  >([]);

  // Effect to clean up toasts and reset loading state if smartSession becomes undefined
  React.useEffect(() => {
    if (!smartSession) {
      // Reset loading state to ensure button text updates
      setLoading(false);

      // Dismiss all active DCA execution toasts
      if (activeToastIds.length > 0) {
        activeToastIds.forEach((id) => {
          toast.dismiss(id);
        });
        // Clear the list
        setActiveToastIds([]);
      }
    }
  }, [smartSession, activeToastIds]);

  async function onSubmit(data: DCAFormSchemaType) {
    try {
      setLoading(true);
      const strategyWithTimestamp = {
        ...data,
        createdTimestamp: Date.now() + 500,
      };

      await createNewDCAStrategy(strategyWithTimestamp);

      // Generate a unique ID for this toast before creating it
      const uniqueToastId = `dca-toast-${Date.now()}`;

      // Create toast with the predetermined ID
      toast(
        <DCAExecutionProgress
          strategy={strategyWithTimestamp}
          toastId={uniqueToastId}
          key={Date.now()}
        />,
        {
          id: uniqueToastId,
          duration: Infinity,
        },
      );

      // Store the toast ID
      setActiveToastIds((prev) => [...prev, uniqueToastId]);
    } catch (e) {
      toast("Error", {
        description: (e as Error)?.message || "Error creating DCA strategy",
      });
    } finally {
      setLoading(false);
    }
  }

  // Handle clearing the smart session
  const handleClearStrategy = () => {
    if (clearSmartSession) {
      // Set loading to false to update button state immediately
      setLoading(false);
      clearSmartSession();
      toast.success("Strategy cleared successfully");
    }
  };

  // Check if the Create button should be shown
  const canCreateStrategy =
    isSupported && !hasInsufficientEth && !hasActiveStrategy;

  return (
    <Card>
      <CardHeader>
        <CardDescription>Set DCA Strategy</CardDescription>
      </CardHeader>
      <form onSubmit={handleSubmit(onSubmit)}>
        <CardContent className="space-y-4">
          <AssetAllocationField control={control} errors={errors} />
          <Button variant="outline" size="icon" disabled>
            <ArrowUpDown className="h-4 w-4" />
          </Button>
          <AssetToBuyField control={control} errors={errors} />
          <InvestmentIntervalField control={control} errors={errors} />
          <NumberOfOrdersField control={control} errors={errors} />
        </CardContent>
        <CardFooter className="flex flex-col gap-2">
          {/* Always show Create button, but disable it when conditions aren't met */}
          <Button
            type="submit"
            className="w-full bg-blue-500 hover:bg-blue-700"
            disabled={!canCreateStrategy || isLoading}
          >
            {isLoading ? (
              <>
                Creating Strategy
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
              </>
            ) : !isSupported ? (
              "Unsupported Wallet"
            ) : hasInsufficientEth ? (
              "Insufficient ETH"
            ) : hasActiveStrategy ? (
              "Executing Strategy..."
            ) : (
              "Create"
            )}
          </Button>

          {/* Clear strategy button - always visible but conditionally enabled */}
          <Button
            type="button"
            variant="outline"
            className="w-full flex items-center justify-center gap-2"
            onClick={handleClearStrategy}
            disabled={!hasActiveStrategy}
          >
            <RefreshCw className="h-4 w-4" />
            Clear Strategy
          </Button>
        </CardFooter>
      </form>
    </Card>
  );
}

export default DCAForm;
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/InvestmentIntervalField.tsx">
import React from "react";
import { Controller } from "react-hook-form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { intervalOptions } from "@/utils/DCAUtils";
import { FieldProps } from "./DCAForm";

const ForwardedSelect = React.forwardRef<
  never, // Select does not accept ref prop
  React.ComponentPropsWithoutRef<typeof Select>
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
>((props, _ref) => <Select {...props} />);
ForwardedSelect.displayName = "ForwardedSelect";

// Forward ref correctly for Input, since it accepts ref prop
const ForwardedInput = React.forwardRef<
  HTMLInputElement,
  React.ComponentPropsWithoutRef<typeof Input>
>((props, ref) => <Input {...props} ref={ref} />);
ForwardedInput.displayName = "ForwardedInput";

export default function InvestmentIntervalField({
  control,
  errors,
}: FieldProps) {
  return (
    <div className="grid w-full max-w-sm items-center gap-1.5">
      <Label className="flex" htmlFor="investmentInterval">
        Every
      </Label>
      <div className="flex w-full max-w-sm items-center align-center space-x-2">
        <div className="flex flex-col w-full">
          <div className="flex w-full items-center align-center space-x-2">
            <Controller
              name="investmentInterval"
              control={control}
              render={({ field }) => (
                <ForwardedInput
                  {...field}
                  type="number"
                  placeholder="0"
                  className={`border-none bg-blue-200 text-lg no-arrows text-left focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-offset-0 ${
                    errors.investmentInterval ? "border-2 border-red-500" : ""
                  }`}
                />
              )}
            />
            <Controller
              name="intervalUnit"
              control={control}
              render={({ field }) => (
                <ForwardedSelect
                  {...field}
                  onValueChange={field.onChange}
                  value={field.value}
                >
                  <SelectTrigger
                    className={`w-[180px] text-lg border-none bg-blue-200 focus:outline-none focus:ring-0 focus:ring-offset-0 ${
                      errors.intervalUnit ? "border-2 border-red-500" : ""
                    }`}
                  >
                    <SelectValue>
                      {intervalOptions.find(
                        (option) => option.value === field.value,
                      )?.label || "Select interval"}
                    </SelectValue>
                  </SelectTrigger>
                  <SelectContent>
                    <SelectGroup>
                      {intervalOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectGroup>
                  </SelectContent>
                </ForwardedSelect>
              )}
            />
          </div>
          {errors.investmentInterval && (
            <p className="text-red-500 text-sm">
              {errors.investmentInterval.message}
            </p>
          )}
          {errors.intervalUnit && (
            <p className="text-red-500 text-sm">
              {errors.intervalUnit.message}
            </p>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/NotConnectedScreen.tsx">
import React from "react";
import { useAppKit, useAppKitAccount } from "@reown/appkit/react";
import { Button } from "@/components/ui/button";

export default function NotConnectedScreen() {
  const { open } = useAppKit();
  const { status } = useAppKitAccount();
  const isWalletConnecting =
    status === "connecting" || status === "reconnecting";
  const [hasMounted, setHasMounted] = React.useState(false);

  React.useEffect(() => {
    setHasMounted(true);
  }, []);

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-8 bg-gray-100 dark:bg-gray-900">
      <div className="w-full max-w-md text-center mb-12">
        <h1 className="text-3xl font-bold mb-4 text-gray-800 dark:text-gray-200">
          Dollar Cost Average
        </h1>

        <div className="bg-gray-50 dark:bg-gray-700 p-3 rounded-md border border-gray-200 dark:border-gray-600 mb-3">
          <p className="text-sm text-gray-700 dark:text-gray-300 mb-2 font-medium">
            Please connect your wallet in order to create a DCA strategy.
          </p>
          <p className="text-sm text-gray-700 dark:text-gray-300 mb-2">
            When connecting, be sure to use Email Wallet with:
          </p>
          <p className="font-mono text-sm bg-white dark:bg-gray-800 p-2 rounded border border-gray-200 dark:border-gray-600">
            youremail
            <span className="text-blue-500 dark:text-blue-400">
              +smart-sessions
            </span>
            @domain.com
          </p>
          <p className="text-xs text-gray-500 dark:text-gray-400 mt-2">
            Example: john
            <span className="text-blue-500 dark:text-blue-400">
              +smart-sessions
            </span>
            @doe.com
          </p>
        </div>
        {hasMounted && !isWalletConnecting ? (
          <Button
            onClick={() => open({ view: "Connect" })}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Connect Wallet
          </Button>
        ) : (
          <Button className="bg-blue-500 hover:bg-blue-600 text-white" disabled>
            Connecting...
          </Button>
        )}
      </div>
    </main>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DcaComponents/NumberOfOrdersField.tsx">
import React from "react";
import { Controller } from "react-hook-form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { FieldProps } from "./DCAForm";

// Forward ref correctly for Input, since it accepts ref prop
const ForwardedInput = React.forwardRef<
  HTMLInputElement,
  React.ComponentPropsWithoutRef<typeof Input>
>((props, ref) => <Input {...props} ref={ref} />);
ForwardedInput.displayName = "ForwardedInput";

export default function NumberOfOrdersField({ control, errors }: FieldProps) {
  return (
    <div className="grid w-full max-w-sm items-center gap-1.5">
      <Label className="flex" htmlFor="numberOfOrders">
        Over
      </Label>
      <div
        className={`flex w-full max-w-sm items-center rounded-lg justify-between space-x-2 bg-blue-200 ${
          errors.numberOfOrders ? "border-2 border-red-500" : ""
        }`}
      >
        <Controller
          name="numberOfOrders"
          control={control}
          render={({ field }) => (
            <ForwardedInput
              {...field}
              type="number"
              placeholder="0"
              className={`border-none bg-transparent text-lg no-arrows text-left focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-offset-0 ${
                errors.numberOfOrders ? "border-2 border-red-500" : ""
              }`}
            />
          )}
        />
        <Label className="flex pr-2" htmlFor="orders">
          orders
        </Label>
      </div>
      {errors.numberOfOrders && (
        <p className="text-red-500 text-sm">{errors.numberOfOrders.message}</p>
      )}
    </div>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/TicTacToeComponents/DisplayPlayerScore.tsx">
import React from "react";

function DisplayPlayerScore({
  icon,
  label,
  score,
  color,
}: {
  icon: React.ReactNode;
  label: string;
  score: number;
  color: string;
}) {
  return (
    <div className="flex items-center flex-col justify-center">
      <div className="flex items-center">
        <div
          className={`w-20 h-20 ${color} flex items-center justify-center transform rotate-30`}
          style={{
            clipPath:
              "polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)",
          }}
        >
          {icon}
        </div>
      </div>
      <div className="flex items-center mt-2">
        <p className="text-gray-700 font-semibold text-center">{label}:</p>
        <span className="text-gray-900 font-bold text-lg sm:text-xl ml-2 text-center">
          {score}
        </span>
      </div>
    </div>
  );
}

export default DisplayPlayerScore;
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/TicTacToeComponents/PositionSquare.tsx">
import React from "react";
import { CircleIcon, Cross1Icon } from "@radix-ui/react-icons";
import { GameState } from "@/context/TicTacToeContextProvider";

function PositionSquare({
  gameState,
  index,
  handleMove,
  loading,
  isAvailable,
}: {
  gameState: GameState;
  index: number;
  handleMove: (gameId: string, position: number) => void;
  loading: boolean;
  isSystemThinking?: boolean;
  isAvailable?: boolean;
}) {
  const isWinningSquare = gameState.winningLine?.includes(index);
  const isDisabled =
    loading ||
    !!gameState.board[index] ||
    !!gameState.winner ||
    !gameState.isXNext; // Disable when it's not player's turn

  const baseClasses = `
    
    text-lg
    font-medium
    flex items-center justify-center 
    rounded-lg
    transition-all duration-200
    relative
    ${isWinningSquare ? "bg-yellow-50" : "bg-gray-50"}
    ${!isDisabled && !gameState.board[index] ? "hover:bg-gray-100 cursor-pointer" : "cursor-not-allowed"}
    ${isAvailable ? "bg-blue-50" : ""}
    border border-gray-200
    ${isDisabled && !gameState.board[index] ? "text-gray-300" : "text-gray-400"}
  `;

  return (
    <button
      className={baseClasses}
      onClick={() => handleMove(gameState.gameId!, index)}
      disabled={isDisabled}
      aria-label={`Square ${index + 1}`}
    >
      {!gameState.board[index] ? (
        <span className="text-inherit">{index + 1}</span>
      ) : gameState.board[index] === "X" ? (
        <Cross1Icon width={32} height={32} className="text-green-500" />
      ) : (
        <CircleIcon width={32} height={32} className="text-red-500" />
      )}
    </button>
  );
}

export default React.memo(PositionSquare, (prevProps, nextProps) => {
  return (
    prevProps.gameState.board[prevProps.index] ===
      nextProps.gameState.board[nextProps.index] &&
    prevProps.loading === nextProps.loading &&
    prevProps.isSystemThinking === nextProps.isSystemThinking &&
    prevProps.isAvailable === nextProps.isAvailable &&
    prevProps.gameState.isXNext === nextProps.gameState.isXNext && // Add isXNext to comparison
    (prevProps.gameState.winningLine?.includes(prevProps.index) ?? false) ===
      (nextProps.gameState.winningLine?.includes(nextProps.index) ?? false)
  );
});
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/TicTacToeComponents/StartGameButton.tsx">
import React from "react";
import { Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

const StartGameButton = ({
  isWalletConnected,
  loading,
  startGame,
}: {
  isWalletConnected: boolean;
  loading: boolean;
  startGame: () => void;
}) => {
  const button = (
    <Button
      className=" bg-blue-700 hover:bg-blue-500"
      size="lg"
      variant="default"
      disabled={!isWalletConnected || loading}
      onClick={startGame}
    >
      {loading ? <Loader2 className="ml-2 h-4 w-4 animate-spin" /> : "New Game"}
    </Button>
  );

  return isWalletConnected ? (
    button
  ) : (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent>
          <p>Connect your wallet</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
};

export default StartGameButton;
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/TicTacToeComponents/TicTacToe.tsx">
"use client";
import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import { ConnectWalletButton } from "@/components/ConnectWalletButton";
import TicTacToeBoard from "./TicTacToeBoard";
import { useTicTacToeContext } from "@/context/TicTacToeContextProvider";
import { useTicTacToeActions } from "@/hooks/useTicTacToeActions";
import { useAppKitAccount } from "@reown/appkit/react";
import { useBalance } from "wagmi";
import { parseUnits } from "viem";
// This component contains all your hooks and JSX.
function TicTacToeInner() {
  const [isLoading, setIsLoading] = useState(false);
  const { smartSession, clearSmartSession } = useTicTacToeContext();
  const { startGame } = useTicTacToeActions();
  const { status, address, embeddedWalletInfo } = useAppKitAccount();
  const balance = useBalance({ address: address as `0x${string}` });
  const { accountType, user } = embeddedWalletInfo ?? {};
  const isSmartAccount = accountType === "smartAccount";
  const isDisabled =
    !balance.data || balance.data.value < parseUnits("0.0005", 18);
  const isEmailAllowed = user?.email?.includes("+smart-sessions@");

  const isWalletConnected = status === "connected" || address !== undefined;
  const isWalletConnecting = status
    ? ["connecting", "reconnecting"].includes(status)
    : false;
  const grantedPermissions = smartSession?.grantedPermissions;
  const gameStarted = smartSession?.gameInfo?.gameStarted;

  const resetGame = () => {
    clearSmartSession();
  };

  async function onStartGame() {
    setIsLoading(true);
    try {
      await startGame();
    } catch (e) {
      const errorMessage = (e as Error)?.message || "Error starting game";
      toast.error("Error", { description: errorMessage });
    } finally {
      setIsLoading(false);
    }
  }

  // Subcomponent: Loading screen shown during wallet connection
  const LoadingScreen = () => (
    <main className="flex min-h-screen flex-col items-center justify-center p-8 bg-gradient-to-b from-blue-100 to-purple-100">
      <div className="w-full max-w-sm text-center mb-12">
        <h1 className="text-3xl font-bold mb-4 text-gray-800 dark:text-gray-200">
          TicTacToe Game
        </h1>
        <div className="flex items-center justify-center space-x-2">
          <Loader2 className="animate-spin h-8 w-8 text-gray-600 dark:text-gray-400" />
          <p className="text-lg font-bold text-gray-600 dark:text-gray-400">
            Loading...
          </p>
        </div>
      </div>
    </main>
  );

  const NotConnectedScreen = () => (
    <main className="flex min-h-screen flex-col items-center justify-center p-8 bg-gradient-to-b from-blue-100 to-purple-100">
      <div className="w-full max-w-md text-center mb-12">
        <h1 className="text-3xl font-bold mb-4 text-gray-800 dark:text-gray-200">
          TicTacToe Game
        </h1>
        <Card className="w-full bg-gradient-to-br from-purple-100 to-indigo-100 shadow-lg mb-4">
          <CardHeader className="pb-0">
            <CardTitle className="text-lg text-indigo-800">
              Connect Your Wallet
            </CardTitle>
          </CardHeader>
          <CardContent className="p-4">
            <div className="bg-indigo-50/70 p-3 rounded-md border border-indigo-100 mb-3">
              <p className="text-sm text-gray-700 mb-2 font-medium">
                Please use your email wallet with:
              </p>
              <p className="font-mono text-sm bg-white p-2 rounded border border-gray-200">
                youremail
                <span className="text-blue-500 dark:text-blue-400">
                  +smart-sessions
                </span>
                @domain.com
              </p>
              <p className="text-xs text-gray-500 mt-2">
                Example: john
                <span className="text-blue-500 dark:text-blue-400">
                  +smart-sessions
                </span>
                @doe.com
              </p>
            </div>
          </CardContent>
          <CardFooter className="p-4 justify-center">
            <ConnectWalletButton />
          </CardFooter>
        </Card>
      </div>
    </main>
  );

  const GameIntroCard = () => (
    <div className="w-full max-w-md mx-auto mb-12">
      <div className="flex w-full mb-4 items-center justify-center">
        <w3m-button />
      </div>
      <Card className="w-full bg-gradient-to-br from-purple-100 to-indigo-100 shadow-lg">
        <CardHeader className="p-4">
          <CardTitle className="text-center text-xl sm:text-2xl md:text-3xl font-bold text-indigo-800">
            Let&apos;s Play TicTacToe
          </CardTitle>
        </CardHeader>
        <CardContent className="p-4 space-y-4">
          {/* Show requirements that need to be fulfilled */}
          {(!isEmailAllowed || !isSmartAccount || isDisabled) && (
            <div className="p-3 bg-amber-50 border border-amber-200 rounded-md space-y-2">
              {!isEmailAllowed && (
                <p className="text-amber-700 font-medium">
                  Not connected with the proper email wallet:{" "}
                  <span className="font-mono text-amber-600">
                    youremail+smart-sessions@domain.com
                  </span>
                </p>
              )}

              {isEmailAllowed && !isSmartAccount && (
                <p className="text-amber-700 font-medium">
                  Please use a smart account to get started.
                </p>
              )}

              {isEmailAllowed && isSmartAccount && isDisabled && (
                <p className="text-red-600 font-medium">
                  Insufficient balance. Need at least 0.0005 ETH to get started.
                </p>
              )}
            </div>
          )}

          <div className="bg-white/50 p-4 rounded-md border border-indigo-100">
            <h3 className="font-semibold text-indigo-800 mb-2">Game Rules</h3>
            <p className="text-base text-gray-700 leading-relaxed">
              Players take turns placing their marks in empty squares. The first
              to align three marks in a row—vertically, horizontally, or
              diagonally—wins. If all squares are filled and no one has three in
              a row, the game ends in a tie.
            </p>
          </div>
        </CardContent>
        <CardFooter className="p-4 justify-center">
          <div className="flex items-center justify-center">
            <Button
              onClick={onStartGame}
              disabled={
                isLoading || !isSmartAccount || isDisabled || !isEmailAllowed
              }
              className="w-full max-w-xs bg-indigo-700 hover:bg-indigo-600 text-white transition-all"
            >
              {isLoading ? (
                <div className="flex items-center justify-center space-x-2">
                  <Loader2 className="animate-spin h-4 w-4" />
                  <span>Starting...</span>
                </div>
              ) : !isEmailAllowed ? (
                "Email Format Required"
              ) : !isSmartAccount ? (
                "Smart Account Required"
              ) : isDisabled ? (
                "Insufficient ETH"
              ) : (
                "Start New Game"
              )}
            </Button>
          </div>
        </CardFooter>
      </Card>
    </div>
  );

  const GameBoard = () => (
    <div className="w-full max-w-md mx-auto mb-12">
      <div className="flex flex-col items-center gap-4 mb-4">
        <Button
          variant="destructive"
          className="w-full max-w-xs"
          onClick={resetGame}
        >
          End Game
        </Button>
        <TicTacToeBoard />
      </div>
    </div>
  );

  if (isWalletConnecting) {
    return <LoadingScreen />;
  }

  if (!isWalletConnected) {
    return <NotConnectedScreen />;
  }

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-8 bg-gradient-to-b from-blue-100 to-purple-100">
      {grantedPermissions && gameStarted ? <GameBoard /> : <GameIntroCard />}
    </main>
  );
}

// The outer component only handles the mounting check.
export default function TicTacToe() {
  const [hasMounted, setHasMounted] = useState(false);
  useEffect(() => {
    setHasMounted(true);
  }, []);

  if (!hasMounted) return null;
  return <TicTacToeInner />;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/TicTacToeComponents/TicTacToeBoard.tsx">
"use client";

import React, { useCallback, useState, memo } from "react";
import { useTicTacToeContext } from "@/context/TicTacToeContextProvider";
import { useTicTacToeActions } from "@/hooks/useTicTacToeActions";
import { CircleIcon, Cross1Icon } from "@radix-ui/react-icons";
import { toast } from "sonner";
import {
  checkWinner,
  getBoardState,
  transformBoard,
} from "@/utils/TicTacToeUtils";
import { getCallsStatus } from "@/utils/UserOpBuilderServiceUtils";
import PositionSquare from "./PositionSquare";

// Memoized PlayerCard component with animated turn indicator
const PlayerCard = memo(
  ({
    icon,
    label,
    score,
    isActive,
    color,
  }: {
    icon: React.ReactNode;
    label: string;
    score: number;
    isActive: boolean;
    color: string;
  }) => (
    <div
      className={`
    relative p-4 rounded-xl bg-white/95
    transition-all duration-300 shadow-sm
    ${isActive ? "scale-105" : ""}
  `}
    >
      {isActive && (
        <div className="absolute -top-2 left-1/2 transform -translate-x-1/2">
          <div className="w-3 h-3 bg-blue-500 rotate-45" />
        </div>
      )}
      <div className="flex flex-col items-center gap-1">
        <div
          className={`
        w-14 h-14 ${color} rounded-lg
        flex items-center justify-center
      `}
        >
          {icon}
        </div>
        <p className="font-medium text-gray-800 text-sm">{label}</p>
        <p className="text-3xl font-bold text-gray-900">{score}</p>
      </div>
    </div>
  ),
);

PlayerCard.displayName = "PlayerCard";

// Memoized GameStatus banner with animations
const GameStatus = memo(
  ({
    gameId,
    isXNext,
    winner,
    isGameCompleted, // NEW Prop added
  }: {
    gameId: string;
    isXNext: boolean;
    winner: string | null;
    isGameCompleted: boolean;
  }) => {
    let message: React.ReactNode;
    if (winner) {
      message = (
        <span className="text-green-600">
          {winner === "X" ? "You Won! 🎉" : "System Won! 🤖"}
        </span>
      );
    } else if (isGameCompleted) {
      // NEW branch
      message = (
        <span className="font-semibold text-xl text-gray-600">
          Game Completed
        </span>
      );
    } else {
      message = (
        <span
          className={`font-semibold text-xl ${isXNext ? "text-green-600" : "text-red-500"}`}
        >
          {isXNext ? "Your Turn" : "System's Turn"}
        </span>
      );
    }

    return (
      <div className="flex flex-col items-center">
        {/* Fixed size container for status message to prevent layout shift */}
        <div className="w-40 h-10 flex items-center justify-center bg-gray-100 rounded-lg shadow-sm">
          {message}
        </div>
        <div className="text-sm text-gray-500 mt-2">Game ID: {gameId}</div>
      </div>
    );
  },
);

GameStatus.displayName = "GameStatus";

// Main TicTacToeBoard component
const TicTacToeBoard = () => {
  const { smartSession, setSmartSession } = useTicTacToeContext();
  const { handleSystemMove, handleUserMove } = useTicTacToeActions();
  const [isLoading, setIsLoading] = useState(false);
  const gameState = smartSession?.gameInfo?.gameState;

  if (!gameState?.gameId) {
    return (
      <div className="flex items-center justify-center h-48">
        <p className="text-red-500 font-semibold bg-red-50 px-4 py-2 rounded-lg">
          Error: Game ID not found. Please try again.
        </p>
      </div>
    );
  }

  // Calculate the score counts and check if the board is full.
  const xCount = gameState.board.filter((cell) => cell === "X").length;
  const oCount = gameState.board.filter((cell) => cell === "O").length;
  const isBoardFull = gameState.board.every(
    (cell) => cell === "X" || cell === "O",
  );
  const isGameCompleted = isBoardFull && !gameState.winner;

  const onMove = useCallback(
    async (gameId: string, position: number) => {
      // Early exit if the game is already completed
      if (
        gameState.winner ||
        gameState.board.every((cell) => cell === "X" || cell === "O")
      ) {
        return;
      }

      setIsLoading(true);
      try {
        const data = await handleUserMove(gameId, position);
        const { userOpIdentifier } = data;
        await getCallsStatus(userOpIdentifier);

        const updatedBoard = await getBoardState(gameId);
        // Note: Ensure the empty cell representation is consistent.
        const movesCount = updatedBoard.filter((cell) => cell !== 0).length;
        const winnerInfo =
          movesCount >= 5
            ? checkWinner([...updatedBoard])
            : { winner: null, winningLine: null };

        const newGameState = {
          board: transformBoard([...updatedBoard]),
          isXNext: false,
          winner: winnerInfo.winner,
          winningLine: winnerInfo.winningLine,
          gameId,
        };

        setSmartSession((prev) => ({
          ...prev!,
          gameInfo: {
            gameState: newGameState,
            gameStarted: prev?.gameInfo?.gameStarted || false,
          },
        }));

        // If no winner and moves remain, let the system move.
        if (!winnerInfo.winner && movesCount < 9) {
          await handleSystemMove(gameId);
        }
      } catch (e) {
        console.warn("Error:", e);
        toast.error("Error", {
          description: (e as Error)?.message || "Error making move",
        });
      } finally {
        setIsLoading(false);
      }
    },
    [gameState, handleSystemMove, handleUserMove, setSmartSession],
  );

  return (
    <div className="flex flex-col items-center gap-6 p-4 ">
      <div className="w-full max-w-xl flex flex-col items-center gap-6">
        <div className="flex max-w-xl justify-between items-center w-full gap-4">
          <PlayerCard
            icon={<Cross1Icon width={24} height={24} color="white" />}
            label="You"
            score={xCount}
            isActive={gameState.isXNext && !gameState.winner}
            color="bg-green-500"
          />
          <GameStatus
            gameId={gameState.gameId}
            isXNext={gameState.isXNext}
            winner={gameState.winner}
            isGameCompleted={isGameCompleted} // NEW prop passed here
          />
          <PlayerCard
            icon={<CircleIcon width={24} height={24} color="white" />}
            label="System"
            score={oCount}
            isActive={!gameState.isXNext && !gameState.winner}
            color="bg-red-500"
          />
        </div>

        <div className="relative flex justify-center w-full">
          <div className="grid grid-cols-3 gap-3 bg-white/95 p-6 rounded-xl shadow-sm w-96 h-96 mx-auto">
            {Array(9)
              .fill(null)
              .map((_, index) => (
                <PositionSquare
                  key={index}
                  gameState={gameState}
                  index={index}
                  handleMove={onMove}
                  loading={isLoading}
                  isAvailable={!gameState.board[index]}
                />
              ))}
          </div>

          {/* Overlays */}
          {isGameCompleted ? (
            <div className="absolute inset-0 bg-gray-200/50 rounded-xl pointer-events-none flex items-center justify-center">
              <div className="bg-white text-gray-800 px-4 py-2 rounded-lg font-medium shadow-sm w-40 text-center">
                Game Completed
              </div>
            </div>
          ) : !gameState.isXNext && !gameState.winner ? (
            <div className="absolute inset-0 bg-blue-50/30 rounded-xl pointer-events-none flex items-center justify-center">
              <div className="bg-white text-blue-600 px-4 py-2 rounded-lg font-medium shadow-sm w-40 text-center">
                System&apos;s Turn
              </div>
            </div>
          ) : (
            isLoading &&
            gameState.isXNext && (
              <div className="absolute inset-0 bg-green-50/30 rounded-xl pointer-events-none flex items-center justify-center">
                <div className="bg-white text-green-600 px-4 py-2 rounded-lg font-medium shadow-sm w-40 text-center">
                  Processing Your Move...
                </div>
              </div>
            )
          )}
        </div>
      </div>
    </div>
  );
};

export default memo(TicTacToeBoard);
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/form.tsx">
/* eslint-disable @typescript-eslint/no-useless-template-literals */
/* eslint-disable no-implicit-coercion */
/* eslint-disable no-negated-condition */
/* eslint-disable arrow-body-style */
/* eslint-disable func-style */
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form";

import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/progress.tsx">
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className,
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/select.tsx">
"use client";

import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/separator.tsx">
"use client";

import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref,
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className,
      )}
      {...props}
    />
  ),
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/sonner.tsx">
"use client";
import React from "react";
import { useTheme } from "next-themes";
import { Toaster as Sonner } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/tabs.tsx">
"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ui/tooltip.tsx">
"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/ConnectWalletButton.tsx">
import React from "react";
import { useAppKit } from "@reown/appkit/react";
import { Button } from "./ui/button";

export function ConnectWalletButton() {
  const { open } = useAppKit();

  return (
    <Button
      type="button"
      className="w-full bg-blue-500 hover:bg-blue-700"
      size="lg"
      onClick={() => open({ view: "Connect" })}
    >
      Connect Wallet
    </Button>
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/components/DemoApplicationList.tsx">
import React from "react";
import Link from "next/link";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "./ui/card";
import { Button } from "./ui/button";
import { DemoAppMetadata } from "@/utils/DataUtil";
import { ArrowRightIcon } from "lucide-react";

interface DemoApplicationsProps {
  demoAppsMetadata: DemoAppMetadata[];
}

export default function DemoApplicationList({
  demoAppsMetadata,
}: DemoApplicationsProps) {
  return (
    <div>
      <h2 className="text-2xl font-bold mb-6">Applications</h2>
      <div className="flex flex-col space-y-4">
        {demoAppsMetadata.map((appMetadata) => (
          <DemoApplication key={appMetadata.title} {...appMetadata} />
        ))}
      </div>
    </div>
  );
}

const DemoApplication: React.FC<DemoAppMetadata> = React.memo(
  function DemoApplication({ title, link, description }: DemoAppMetadata) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle className="text-xl font-semibold">{title}</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-between gap-4">
            <CardDescription className="flex-grow text-sm text-muted-foreground">
              {description}
            </CardDescription>
            <Link href={link}>
              <Button
                size="sm"
                variant="outline"
                className="flex-shrink-0"
                aria-label={`Go to ${title}`}
              >
                Go
                <ArrowRightIcon className="ml-2 h-4 w-4" />
              </Button>
            </Link>
          </div>
        </CardContent>
      </Card>
    );
  },
);
</file>

<file path="advanced/dapps/smart-sessions-demo/src/context/DcaApplicationContextProvider.tsx">
"use client";
import React, { createContext, useContext, ReactNode } from "react";
import { DCA_APP_DATA, removeItem } from "../utils/LocalStorage";
import { useLocalStorageState } from "../hooks/useLocalStorageState";
import { DCAFormSchemaType } from "@/schema/DCAFormSchema";
import { SmartSessionGrantPermissionsResponse } from "@reown/appkit-experimental/smart-session";

interface DcaApplicationContextType {
  projectId: string;
  smartSession:
    | {
        grantedPermissions: SmartSessionGrantPermissionsResponse;
        dcaStrategy: DCAFormSchemaType;
      }
    | undefined;
  setSmartSession: React.Dispatch<
    React.SetStateAction<
      | {
          grantedPermissions: SmartSessionGrantPermissionsResponse;
          dcaStrategy: DCAFormSchemaType;
        }
      | undefined
    >
  >;
  clearSmartSession: () => void;
}

const DcaApplicationContext = createContext<
  DcaApplicationContextType | undefined
>(undefined);

export function DcaApplicationContextProvider({
  children,
}: {
  children: ReactNode;
}) {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }

  const [smartSession, setSmartSession] = useLocalStorageState<
    | {
        grantedPermissions: SmartSessionGrantPermissionsResponse;
        dcaStrategy: DCAFormSchemaType;
      }
    | undefined
  >(DCA_APP_DATA, undefined);

  function clearSmartSession() {
    removeItem(DCA_APP_DATA);
    setSmartSession(undefined);
  }

  return (
    <DcaApplicationContext.Provider
      value={{
        projectId,
        smartSession,
        clearSmartSession,
        setSmartSession,
      }}
    >
      {children}
    </DcaApplicationContext.Provider>
  );
}

export function useDcaApplicationContext() {
  const context = useContext(DcaApplicationContext);
  if (!context) {
    throw new Error(
      "useDcaApplicationContext must be used within a DcaApplicationContextProvider",
    );
  }

  return context;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/context/TicTacToeContextProvider.tsx">
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";
import { TICTACTOE_APP_DATA, removeItem } from "../utils/LocalStorage";
import { useLocalStorageState } from "../hooks/useLocalStorageState";
import { SmartSessionGrantPermissionsResponse } from "@reown/appkit-experimental/smart-session";

export interface GameState {
  board: (string | null)[];
  isXNext: boolean;
  winner: string | null;
  winningLine: number[] | null;
  gameId: string | null;
}

interface TicTacToeContextType {
  projectId: string;
  smartSession:
    | {
        grantedPermissions: SmartSessionGrantPermissionsResponse;
        gameInfo:
          | {
              gameState: GameState;
              gameStarted: boolean;
            }
          | undefined;
      }
    | undefined;
  setSmartSession: React.Dispatch<
    React.SetStateAction<
      | {
          grantedPermissions: SmartSessionGrantPermissionsResponse;
          gameInfo:
            | {
                gameState: GameState;
                gameStarted: boolean;
              }
            | undefined;
        }
      | undefined
    >
  >;
  clearSmartSession: () => void;
  loading: boolean;
  setLoading: React.Dispatch<React.SetStateAction<boolean>>;
  error: string | null;
  setError: React.Dispatch<React.SetStateAction<string | null>>;
}

const TicTacToeContext = createContext<TicTacToeContextType | undefined>(
  undefined,
);

export function TicTacToeContextProvider({
  children,
}: {
  children: ReactNode;
}) {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }

  const [smartSession, setSmartSession] = useLocalStorageState<
    | {
        grantedPermissions: SmartSessionGrantPermissionsResponse;
        gameInfo:
          | {
              gameState: GameState;
              gameStarted: boolean;
            }
          | undefined;
      }
    | undefined
  >(TICTACTOE_APP_DATA, undefined);

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  function clearSmartSession() {
    removeItem(TICTACTOE_APP_DATA);
    setSmartSession(undefined);
  }

  return (
    <TicTacToeContext.Provider
      value={{
        projectId,
        smartSession,
        setSmartSession,
        clearSmartSession,
        loading,
        setLoading,
        error,
        setError,
      }}
    >
      {children}
    </TicTacToeContext.Provider>
  );
}

export function useTicTacToeContext() {
  const context = useContext(TicTacToeContext);
  if (!context) {
    throw new Error(
      "useTicTacToeContext must be used within a TicTacToeContextProvider",
    );
  }

  return context;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/hooks/useDCA.ts">
import { toHex } from "viem";
import { useDcaApplicationContext } from "../context/DcaApplicationContextProvider";
import { DCAFormSchemaType } from "@/schema/DCAFormSchema";
import { getSampleAsyncDCAPermissions } from "@/utils/DCAUtils";
import {
  grantPermissions,
  SmartSessionGrantPermissionsRequest,
} from "@reown/appkit-experimental/smart-session";
import { useAppKitAccount, useAppKitNetwork } from "@reown/appkit/react";

export function useDCA() {
  const { setSmartSession } = useDcaApplicationContext();
  const { address } = useAppKitAccount();
  const { chainId } = useAppKitNetwork();

  async function createNewDCAStrategy(data: DCAFormSchemaType) {
    if (!chainId || !address) {
      throw new Error("Wallet not connected");
    }

    const getDappKeyResponse = await fetch("/api/signer", {
      method: "GET",
    });
    const dappSignerData = await getDappKeyResponse.json();
    const dAppECDSAPublicKey = dappSignerData.key;
    const sampleDCAPermissions = getSampleAsyncDCAPermissions(data);
    const grantDCAPermissions: SmartSessionGrantPermissionsRequest = {
      // Adding 24 hours to the current time
      expiry: Math.floor(Date.now() / 1000) + 24 * 60 * 60,
      chainId: toHex(chainId),
      address: address as `0x${string}`,
      signer: {
        type: "keys",
        data: {
          keys: [
            {
              type: "secp256k1",
              publicKey: dAppECDSAPublicKey,
            },
          ],
        },
      },
      permissions: sampleDCAPermissions["permissions"],
      policies: sampleDCAPermissions["policies"] || [],
    };
    const approvedPermissions = await grantPermissions(grantDCAPermissions);

    setSmartSession({
      grantedPermissions: approvedPermissions,
      dcaStrategy: data,
    });
  }

  return {
    createNewDCAStrategy,
  };
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/hooks/useLocalStorageState.ts">
import { useEffect, useState } from "react";
import { getItem, removeItem, setItem } from "../utils/LocalStorage";

/**
 * Custom hook that manages state in local storage.
 *
 * @template T - The type of the state value.
 * @param {string} key - The key used to store the state value in local storage.
 * @param {T} initialValue - The initial value of the state.
 * @returns {[T, React.Dispatch<React.SetStateAction<T>>]} - An array containing the current state value and a function to update the state.
 */
function useLocalStorageState<T>(
  key: string,
  initialValue: T,
): [T, React.Dispatch<React.SetStateAction<T>>] {
  const [state, setState] = useState<T>(initialValue);

  useEffect(() => {
    const storedValue = getItem(key);
    if (storedValue && storedValue !== "undefined" && storedValue !== "null") {
      try {
        setState(JSON.parse(storedValue) as T);
      } catch {
        setState(storedValue as T);
      }
    }
  }, [key]);

  useEffect(() => {
    if (state === undefined || state === null) {
      removeItem(key);
    } else {
      setItem(key, JSON.stringify(state));
    }
  }, [key, state]);

  return [state, setState];
}

export { useLocalStorageState };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/hooks/useTicTacToeActions.ts">
import { useTicTacToeContext } from "@/context/TicTacToeContextProvider";
import { toHex } from "viem";
import {
  checkWinner,
  getBoardState,
  getGameIdFromReceipt,
  getSampleAsynTicTacToePermissions,
  transformBoard,
  waitForTransaction,
} from "@/utils/TicTacToeUtils";
import { toast } from "sonner";
import {
  grantPermissions,
  SmartSessionGrantPermissionsRequest,
} from "@reown/appkit-experimental/smart-session";
import { useAppKitAccount, useAppKitNetwork } from "@reown/appkit/react";

export function useTicTacToeActions() {
  const { setLoading, smartSession, setSmartSession } = useTicTacToeContext();
  const { address } = useAppKitAccount();
  const { chainId } = useAppKitNetwork();

  async function handleUserMove(gameId: string, index: number) {
    if (!smartSession) {
      throw new Error("Smart Session not found");
    }
    const { grantedPermissions, gameInfo } = smartSession;
    if (!gameInfo) {
      throw new Error("Game info not found");
    }

    const { gameState, gameStarted } = gameInfo;
    if (!gameStarted) {
      throw new Error("Game not started");
    }

    if (!gameState || gameState.board[index] || gameState.winner) {
      throw new Error("Invalid move");
    }
    if (!grantedPermissions) {
      throw new Error("No permissions found");
    }
    try {
      const response = await fetch("/api/tictactoe/make-move/user", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          gameId,
          position: index,
          permissions: grantedPermissions,
        }),
      });

      const data = await response.json();
      if (!response.ok) {
        const errorMessage = data?.message || "Error making your move";
        throw new Error(errorMessage);
      }
      return data;
    } catch (e) {
      console.warn("Error making user move:", e);
      throw Error("Error making user move");
    } finally {
      setLoading(false);
    }
  }

  async function handleSystemMove(gameId: string) {
    if (!smartSession) {
      throw new Error("Smart Session not found");
    }
    const { grantedPermissions, gameInfo } = smartSession;
    if (!gameInfo) {
      throw new Error("Game info not found");
    }

    const { gameState, gameStarted } = gameInfo;
    if (!gameStarted) {
      throw new Error("Game not started");
    }

    if (!gameState || gameState.winner) {
      throw new Error("Invalid move");
    }
    if (!grantedPermissions) {
      throw new Error("No permissions found");
    }
    try {
      const systemMoveResponse = await fetch(
        "/api/tictactoe/make-move/system",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ gameId }),
        },
      );

      const systemMoveResponseData = await systemMoveResponse.json();
      if (!systemMoveResponse.ok) {
        const errorMessage =
          systemMoveResponseData?.message || "Error making system move";
        throw new Error(errorMessage);
      }
      const { transactionHash } = systemMoveResponseData;
      await waitForTransaction(transactionHash);
      console.log("System move made successfully");
      // After the system's move, read the updated board state
      const updatedBoardAfterSystemMove = await getBoardState(gameId);
      console.log(
        "Updated board after system move:",
        updatedBoardAfterSystemMove,
      );

      // Check for a winner after the system's move
      const winnerInfoAfterSystemMove = checkWinner([
        ...updatedBoardAfterSystemMove,
      ]);

      const gameState = {
        board: transformBoard([...updatedBoardAfterSystemMove]),
        isXNext: true,
        winner: winnerInfoAfterSystemMove.winner,
        winningLine: winnerInfoAfterSystemMove.winningLine,
        gameId,
      };
      setSmartSession((prev) =>
        prev
          ? {
              ...prev,
              gameInfo: {
                ...prev.gameInfo,
                gameState,
                gameStarted: prev.gameInfo?.gameStarted ?? false,
              },
            }
          : prev,
      );
    } catch (e) {
      console.warn("Error making move:", e);
      throw Error("Error making system move");
    } finally {
      setLoading(false);
    }
  }

  async function startGame() {
    if (!chainId || !address) {
      throw new Error("Wallet not connected");
    }

    const getDappKeyResponse = await fetch("/api/signer", {
      method: "GET",
    });
    const dappSignerData = await getDappKeyResponse.json();
    const dAppECDSAPublicKey = dappSignerData.key;
    const sampleTictacToePermissions = getSampleAsynTicTacToePermissions();
    const grantTicTacToePermissions: SmartSessionGrantPermissionsRequest = {
      // Adding 24 hours to the current time
      expiry: Math.floor(Date.now() / 1000) + 24 * 60 * 60,
      chainId: toHex(chainId),
      address: address as `0x${string}`,
      signer: {
        type: "keys",
        data: {
          keys: [
            {
              type: "secp256k1",
              publicKey: dAppECDSAPublicKey,
            },
          ],
        },
      },
      permissions: sampleTictacToePermissions["permissions"],
      policies: sampleTictacToePermissions["policies"] || [],
    };
    const approvedPermissions = await grantPermissions(
      grantTicTacToePermissions,
    );

    const response = await fetch("/api/tictactoe/create", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        permissions: approvedPermissions,
      }),
    });
    const data = await response.json();
    if (!response.ok) {
      throw new Error("Error creating game");
    }
    const { transactionHash } = data;
    const gameId = await getGameIdFromReceipt(transactionHash);
    const initialGameState = {
      board: Array(9).fill(null),
      isXNext: true,
      winner: null,
      winningLine: null,
      gameId,
      transactionHash: transactionHash,
    };

    setSmartSession({
      grantedPermissions: approvedPermissions,
      gameInfo: {
        gameState: initialGameState,
        gameStarted: true,
      },
    });

    toast.success("Game ready to play");
  }

  return {
    handleUserMove,
    handleSystemMove,
    startGame,
  };
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/schema/DCAFormSchema.ts">
import { z } from "zod";

export const dcaFormSchema = z.object({
  assetToAllocate: z
    .string({
      required_error: "Asset required",
    })
    .min(1, { message: "Select an asset." }),

  allocationAmount: z
    .string({
      required_error: "Amount required",
      invalid_type_error: "Must be a number",
    })
    .transform((val) => parseFloat(val))
    .refine((val) => !isNaN(val) && val > 0, {
      message: "Must be greater than 0.",
    }),

  assetToBuy: z
    .string({
      required_error: "Asset required",
    })
    .min(1, { message: "Select an asset." }),

  investmentInterval: z
    .string({
      required_error: "Interval required",
      invalid_type_error: "Must be a number",
    })
    .transform((val) => parseInt(val, 10))
    .refine((val) => !isNaN(val) && val >= 1, {
      message: "Must be at least 1.",
    }),

  intervalUnit: z.enum(["second", "minute", "hour", "day", "week"], {
    required_error: "Unit required",
  }),

  numberOfOrders: z
    .string({
      required_error: "Orders required",
      invalid_type_error: "Must be a number",
    })
    .transform((val) => parseInt(val, 10))
    .refine((val) => !isNaN(val) && val >= 1, {
      message: "Must be at least 1.",
    }),

  createdTimestamp: z.number().optional(),
});

// Export the inferred type based on the schema
export type DCAFormSchemaType = z.infer<typeof dcaFormSchema>;
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/ChainsUtil.ts">
import * as viemChains from "viem/chains";

if (!process.env["NEXT_PUBLIC_PROJECT_ID"]) {
  throw new Error("NEXT_PUBLIC_PROJECT_ID is required");
}

export function getBlockchainApiRpcUrl(chainId: number) {
  return `https://rpc.walletconnect.org/v1/?chainId=eip155:${chainId}&projectId=${process.env["NEXT_PUBLIC_PROJECT_ID"]}`;
}

export const baseSepolia = {
  chainId: 84532,
  name: "Base Sepolia",
  currency: "BASE",
  explorerUrl: "https://sepolia.basescan.org",
  rpcUrl: getBlockchainApiRpcUrl(84532),
};

export function getChain(id: number) {
  const chains = Object.values(viemChains) as viemChains.Chain[];

  return chains.find((x) => x.id === id);
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/CommonUtils.ts">
export function parseJSON(str: string) {
  try {
    return JSON.parse(str);
  } catch (error) {
    return { error: `Invalid JSON: ${error}` };
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function bigIntReplacer(_key: string, value: any) {
  if (typeof value === "bigint") {
    return `0x${value.toString(16)}`;
  }

  return value;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/ConstantsUtil.ts">
const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
if (!projectId) {
  throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
}
export const WALLET_URL =
  process.env["WALLET_URL"] || "https://react-wallet.walletconnect.com/";
export function getPublicUrl() {
  const vercelUrl = process.env["NEXT_PUBLIC_VERCEL_URL"];
  if (vercelUrl) {
    return `https://${vercelUrl}`;
  }

  return "https://lab.web3modal.com";
}

export const CUSTOM_WALLET = "wc:custom_wallet";
export const USEROP_BUILDER_SERVICE_BASE_URL =
  "https://rpc.walletconnect.org/v1/wallet";

let storedCustomWallet;
if (typeof window !== "undefined") {
  storedCustomWallet = localStorage.getItem(CUSTOM_WALLET);
}

const customWallet = storedCustomWallet ? [JSON.parse(storedCustomWallet)] : [];

export const ConstantsUtil = {
  SigningSucceededToastTitle: "Signing Succeeded",
  SigningFailedToastTitle: "Signing Failed",
  TestIdSiweAuthenticationStatus: "w3m-authentication-status",
  Metadata: {
    name: "AppKit Lab",
    description: "Laboratory environment for AppKit testing",
    url: getPublicUrl(),
    icons: [`${getPublicUrl()}/metadata-icon.svg`],
    verifyUrl: "",
  },
  CustomWallets: [
    ...customWallet,
    {
      id: "react-wallet-v2",
      name: "React Sample Wallet",
      homepage: WALLET_URL,
      mobile_link: WALLET_URL,
      desktop_link: WALLET_URL,
      webapp_link: WALLET_URL,
      image_url: "/sample-wallets/react.svg",
    },
    {
      id: "kotlin-web3wallet",
      name: "Kotlin Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "kotlin-web3wallet://",
      image_url: "/sample-wallets/kotlin.svg",
    },
    {
      id: "swift-web3wallet",
      name: "Swift Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "walletapp://",
      image_url: "/sample-wallets/swift.svg",
    },
    {
      id: "flutter-web3wallet",
      name: "Flutter Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "wcflutterwallet://",
      image_url: "/sample-wallets/flutter.svg",
    },
    {
      id: "rn-web3wallet",
      name: "React Native Sample Wallet",
      homepage: "https://walletconnect.com",
      mobile_link: "rn-web3wallet://",
      image_url: "/sample-wallets/react-native.svg",
    },
  ],
  ProjectId: projectId,
};

export function getBundlerUrl(): string {
  const localBundlerUrl = process.env["NEXT_PUBLIC_LOCAL_BUNDLER_URL"];
  if (localBundlerUrl) {
    return localBundlerUrl;
  }
  const apiKey = process.env["NEXT_PUBLIC_PIMLICO_KEY"];
  if (!apiKey) {
    throw new Error("env NEXT_PUBLIC_PIMLICO_KEY missing.");
  }

  return `https://api.pimlico.io/v2/base-sepolia/rpc?apikey=${apiKey}`;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/DataUtil.ts">
export type DemoAppMetadata = {
  title: string;
  link: string;
  description: string;
  randomLinks?: string[];
};

export const smartSessionsDemoAppMetadata: DemoAppMetadata[] = [
  {
    title: "DCA",
    link: "/demo/dca",
    description: "Dollar Cost Averaging Dapp Demo",
  },
  {
    title: "TicTacToe",
    link: "/demo/tictactoe",
    description: "Play TicTacToe",
  },
  {
    title: "Chat Agent",
    link: "https://ai-agent-demo.reown.com/",
    description: "Demo Chat Agent using smart-sessions and ai-agent ",
  },
];
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/DCAUtils.ts">
import { DCAFormSchemaType } from "@/schema/DCAFormSchema";
import { SmartSessionGrantPermissionsRequest } from "@reown/appkit-experimental/smart-session";
import {
  abi as donutContractAbi,
  address as donutContractAddress,
} from "./DonutContract";

export const assetsToAllocate = [
  { value: "eth", label: "ETH", supported: true },
  { value: "usdc", label: "USDC", supported: false },
  { value: "arb", label: "ARB", supported: false },
  { value: "op", label: "OP", supported: false },
];
export const assetsToBuy = [
  { value: "donut", label: "DONUT", supported: true },
  { value: "usdc", label: "USDC", supported: false },
];

export const intervalOptions = [
  { value: "second", label: "Second" },
  { value: "minute", label: "Minute" },
  { value: "hour", label: "Hour" },
  { value: "day", label: "Day" },
  { value: "week", label: "Week" },
];

export function getSampleAsyncDCAPermissions(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  data: DCAFormSchemaType,
): Omit<
  SmartSessionGrantPermissionsRequest,
  "signer" | "chainId" | "address" | "expiry"
> {
  return {
    permissions: [
      {
        type: "contract-call",
        data: {
          address: donutContractAddress,
          abi: donutContractAbi,
          functions: [
            {
              functionName: "purchase",
            },
          ],
        },
      },
    ],
    policies: [],
  };
}

// Helper function to calculate interval in milliseconds
export function calculateInterval(
  investmentInterval: number,
  intervalUnit: string,
): number {
  const unitToMilliseconds: Record<string, number> = {
    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000,
    week: 7 * 24 * 60 * 60 * 1000,
  };

  return investmentInterval * (unitToMilliseconds[intervalUnit] || 0);
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/DonutContract.ts">
export const abi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "purchase",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "donutBalances",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "check",
        type: "address",
      },
    ],
    name: "getBalance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];

export const address = "0x2E65BAfA07238666c3b239E94F32DaD3cDD6498D";
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/EncodingUtils.ts">
import bs58 from "bs58";

const PUBLIC_KEY_PREFIX = 0x04;
const PUBLIC_KEY_LENGTH = 65;

export function encodePublicKeyToDID(
  publicKey: string,
  keyType: string,
): string {
  // Define the key type to DID prefix mapping
  const keyTypeToDIDPrefix: Record<string, string> = {
    secp256k1: "did:key:zQ3s",
    secp256r1: "did:key:zDn",
  };

  // Check if the key type is supported
  if (!(keyType in keyTypeToDIDPrefix)) {
    throw new Error("Unsupported key type.");
  }

  // Remove '0x' prefix if present
  const modifiedPublicKey = publicKey.startsWith("0x")
    ? publicKey.slice(2)
    : publicKey;

  // Convert publicKey to Buffer
  const publicKeyBuffer = Buffer.from(modifiedPublicKey, "hex");

  // Base58 encode the public key
  const encodedPublicKey = bs58.encode(publicKeyBuffer);

  // Get the DID prefix for the key type
  const didPrefix = keyTypeToDIDPrefix[keyType];

  // Construct the did:key
  return `${didPrefix}${encodedPublicKey}`;
}

export function decodeUncompressedPublicKey(
  uncompressedPublicKey: string,
): `0x${string}` {
  const uncompressedPublicKeyBuffer = Buffer.from(
    uncompressedPublicKey,
    "base64",
  );

  if (uncompressedPublicKeyBuffer.length !== PUBLIC_KEY_LENGTH) {
    throw new Error("Invalid uncompressed public key length");
  }

  const header = uncompressedPublicKeyBuffer[0];
  if (header !== PUBLIC_KEY_PREFIX) {
    throw new Error("Invalid uncompressed public key header");
  }

  const publicKey = uncompressedPublicKeyBuffer.toString("hex");

  return `0x${publicKey}`;
}

export function hexStringToBase64(hexString: string): string {
  // Remove the `0x` prefix if it exists
  const cleanedHexString = hexString.replace(/^0x/, "");

  // Convert the hex string to a Buffer
  const buffer = Buffer.from(cleanedHexString, "hex");

  // Convert the Buffer to a base64 string
  return buffer.toString("base64");
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/ERC7715PermissionsAsyncUtils.ts">
import { signMessage } from "viem/accounts";
import { toHex, type Chain } from "viem";
import {
  Call,
  prepareCalls,
  sendPreparedCalls,
} from "./UserOpBuilderServiceUtils";

export type MultikeySigner = {
  type: "keys";
  data: {
    ids: string[];
  };
};

export async function executeActionsWithECDSAKey(args: {
  actions: Call[];
  ecdsaPrivateKey: `0x${string}`;
  chain: Chain;
  accountAddress: `0x${string}`;
  permissionsContext: string;
}): Promise<string> {
  const {
    ecdsaPrivateKey,
    actions,
    chain,
    accountAddress,
    permissionsContext,
  } = args;
  if (!permissionsContext) {
    throw new Error("No permissions available");
  }
  if (!accountAddress) {
    throw new Error("No account Address available");
  }

  const prepareCallsResponse = await prepareCalls({
    from: accountAddress,
    chainId: toHex(chain.id),
    calls: actions.map((call) => ({
      to: call.to,
      data: call.data,
      value: toHex(call.value),
    })),
    capabilities: {
      permissions: { context: permissionsContext },
    },
  });
  if (prepareCallsResponse.length !== 1 && prepareCallsResponse[0]) {
    throw new Error("Invalid response type");
  }
  const response = prepareCallsResponse[0];
  if (!response || response.preparedCalls.type !== "user-operation-v07") {
    throw new Error("Invalid response type");
  }
  const signatureRequest = response.signatureRequest;
  const dappSignature = await signMessage({
    privateKey: ecdsaPrivateKey,
    message: { raw: signatureRequest.hash },
  });

  const sendPreparedCallsResponse = await sendPreparedCalls({
    context: response.context,
    preparedCalls: response.preparedCalls,
    signature: dappSignature,
  });

  const userOpIdentifier = sendPreparedCallsResponse[0];

  return userOpIdentifier;
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/LocalStorage.ts">
"use client";
import { bigIntReplacer } from "./CommonUtils";

export const LAST_USED_ADDRESS_KEY = "lastUsedAddress";
export const DCA_APP_DATA = "dca";
export const TICTACTOE_APP_DATA = "tictactoe";

/**
 * Sets an item in the local storage.
 * @param key - The key to set the item with.
 * @param value - The value to be stored. It will be converted to a string using JSON.stringify.
 * @template T - The type of the value being stored.
 */
function setItem<T>(key: string, value: T) {
  // To prevent silly mistakes with double stringifying
  if (typeof value === "string") {
    localStorage.setItem(key, value);
  } else {
    localStorage?.setItem(key, JSON.stringify(value, bigIntReplacer));
  }
}

/**
 * Retrieves the value associated with the specified key from the local storage.
 *
 * @param key - The key of the item to retrieve.
 * @returns The value associated with the key, or null if the key does not exist.
 */
function getItem(key: string): string | null {
  return localStorage.getItem(key);
}

function removeItem(key: string) {
  localStorage.removeItem(key);
}

export type PasskeyLocalStorageFormat = {
  rawId: string;
  pubkeyCoordinates: {
    x: string;
    y: string;
  };
};
export { setItem, getItem, removeItem };
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/TicTacToeAbi.ts">
export const ticTacToeAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_playerO",
        type: "address",
      },
    ],
    name: "createGame",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "gameId",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "playerX",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "playerO",
        type: "address",
      },
    ],
    name: "GameCreated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "gameId",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "winner",
        type: "address",
      },
    ],
    name: "GameEnded",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "gameId",
        type: "uint256",
      },
      {
        internalType: "uint8",
        name: "position",
        type: "uint8",
      },
    ],
    name: "makeMove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "gameId",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "player",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "position",
        type: "uint8",
      },
    ],
    name: "MoveMade",
    type: "event",
  },
  {
    inputs: [],
    name: "gameCounter",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "games",
    outputs: [
      {
        internalType: "address",
        name: "playerX",
        type: "address",
      },
      {
        internalType: "address",
        name: "playerO",
        type: "address",
      },
      {
        internalType: "address",
        name: "currentPlayer",
        type: "address",
      },
      {
        internalType: "address",
        name: "winner",
        type: "address",
      },
      {
        internalType: "bool",
        name: "gameStarted",
        type: "bool",
      },
      {
        internalType: "uint8",
        name: "movesCount",
        type: "uint8",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "gameId",
        type: "uint256",
      },
    ],
    name: "getBoard",
    outputs: [
      {
        internalType: "uint8[9]",
        name: "",
        type: "uint8[9]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const;
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/TicTacToeUtils.ts">
import { encodeFunctionData, parseEther } from "viem";
import { ticTacToeAbi } from "./TicTacToeAbi";
import {
  createPublicClient,
  createWalletClient,
  decodeEventLog,
  http,
} from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { baseSepolia } from "viem/chains";
import { getBlockchainApiRpcUrl, getChain } from "./ChainsUtil";
import { executeActionsWithECDSAKey } from "./ERC7715PermissionsAsyncUtils";
import {
  SmartSessionGrantPermissionsRequest,
  SmartSessionGrantPermissionsResponse,
} from "@reown/appkit-experimental/smart-session";

export const ticTacToeAddress =
  "0x6Fd3d86C43BD571F40a3eF2b6BB58B257eC2F392" as `0x${string}`;
const PROJECT_ID = process.env.NEXT_PUBLIC_PROJECT_ID;

if (!PROJECT_ID) {
  throw new Error("Missing required environment variables");
}

const publicClient = createPublicClient({
  chain: baseSepolia,
  transport: http(getBlockchainApiRpcUrl(baseSepolia.id), { timeout: 300000 }),
});

type Board = number[];

export function getSampleAsynTicTacToePermissions(): Omit<
  SmartSessionGrantPermissionsRequest,
  "signer" | "chainId" | "address" | "expiry"
> {
  return {
    permissions: [
      {
        type: "contract-call",
        data: {
          address: ticTacToeAddress,
          abi: ticTacToeAbi as unknown as Record<string, unknown>[],
          functions: [
            {
              functionName: "makeMove",
            },
          ],
        },
      },
    ],
    policies: [],
  };
}

export async function createGame(
  applicationPrivateKey: string,
  playerOAddress: `0x${string}`,
) {
  const account = privateKeyToAccount(applicationPrivateKey as `0x${string}`);
  const walletClient = createWalletClient({
    account,
    chain: baseSepolia,
    transport: http(),
  });
  const txHash = await walletClient.writeContract({
    address: ticTacToeAddress,
    abi: ticTacToeAbi,
    functionName: "createGame",
    args: [playerOAddress],
  });

  return txHash;
}

export async function getGameIdFromReceipt(txHash: `0x${string}`) {
  const receipt = await publicClient.waitForTransactionReceipt({
    hash: txHash,
  });
  const gameCreatedEvent = receipt.logs[0];

  if (!gameCreatedEvent) {
    throw new Error("Failed to retrieve game ID from event");
  }

  const decodedGameId = decodeEventLog({
    abi: ticTacToeAbi,
    eventName: "GameCreated",
    topics: gameCreatedEvent.topics,
  }).args.gameId;

  return decodedGameId.toString();
}

export async function getBoardState(gameId: string): Promise<Board> {
  return Array.from(
    await publicClient.readContract({
      address: ticTacToeAddress,
      abi: ticTacToeAbi,
      functionName: "getBoard",
      args: [BigInt(gameId)],
    }),
  ) as Board;
}

export function checkWinner(board: number[]): {
  winner: string | null;
  winningLine: number[] | null;
} {
  const winningPositions = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];

  for (const positions of winningPositions) {
    const [a, b, c] = positions;
    if (board[a] !== 0 && board[a] === board[b] && board[a] === board[c]) {
      return { winner: board[a] === 1 ? "X" : "O", winningLine: positions };
    }
  }

  return { winner: null, winningLine: null };
}

export function transformBoard(board: number[]): string[] {
  return board.map((cell) => {
    if (cell === 1) {
      return "X";
    }
    if (cell === 2) {
      return "O";
    }

    return "";
  });
}
// Helper function to validate chain ID and get chain object
const getValidatedChain = (chainIdHex: string) => {
  const chainId = parseInt(chainIdHex, 16);
  if (!chainId)
    throw new Error("Chain ID not available in granted permissions");

  const chain = getChain(chainId);
  if (!chain) throw new Error("Unknown chainId");
  return chain;
};
export async function makeUserMove(
  applicationPrivateKey: string,
  gameId: string,
  position: number,
  permissions: SmartSessionGrantPermissionsResponse,
) {
  const chain = getValidatedChain(permissions.chainId);
  const gameIdBigInt = BigInt(gameId);
  const makeMoveCallData = encodeFunctionData({
    abi: ticTacToeAbi,
    functionName: "makeMove",
    args: [gameIdBigInt, position],
  });
  const makeMoveCallDataExecution = [
    {
      to: ticTacToeAddress,
      value: parseEther("0"),
      data: makeMoveCallData,
    },
  ];

  return await executeActionsWithECDSAKey({
    ecdsaPrivateKey: applicationPrivateKey as `0x${string}`,
    permissionsContext: permissions.context,
    accountAddress: permissions.address,
    chain: chain,
    actions: makeMoveCallDataExecution,
  });
}

export async function makeComputerMove(
  applicationPrivateKey: string,
  gameId: string,
  position: number,
) {
  const account = privateKeyToAccount(applicationPrivateKey as `0x${string}`);
  const walletClient = createWalletClient({
    account,
    chain: baseSepolia,
    transport: http(),
  });

  return await walletClient.writeContract({
    address: ticTacToeAddress,
    abi: ticTacToeAbi,
    functionName: "makeMove",
    args: [BigInt(gameId), position],
  });
}

export function findRandomEmptyPosition(board: number[]): number | null {
  // Create an array of empty positions
  const emptyPositions = board
    .map((cell, index) => (cell === 0 ? index : null)) // 0 indicates an empty cell
    .filter((index) => index !== null) as number[]; // Filter out null values

  // If there are no empty positions, return null
  if (emptyPositions.length === 0) return null;

  // Select a random index from the empty positions
  const randomIndex = Math.floor(Math.random() * emptyPositions.length);
  return emptyPositions[randomIndex]; // Return the random empty position
}

export async function waitForTransaction(txHash: `0x${string}`) {
  await publicClient.waitForTransactionReceipt({ hash: txHash });
}
</file>

<file path="advanced/dapps/smart-sessions-demo/src/utils/UserOpBuilderServiceUtils.ts">
import { bigIntReplacer } from "../utils/CommonUtils";
import type { Address, Hex } from "viem";
import { USEROP_BUILDER_SERVICE_BASE_URL } from "./ConstantsUtil";

export type Call = { to: Address; value: bigint; data: Hex };

export type UserOperationWithBigIntAsHex = {
  sender: Address;
  nonce: Hex;
  factory: Address | undefined;
  factoryData: Hex | undefined;
  callData: Hex;
  callGasLimit: Hex;
  verificationGasLimit: Hex;
  preVerificationGas: Hex;
  maxFeePerGas: Hex;
  maxPriorityFeePerGas: Hex;
  paymaster: Address | undefined;
  paymasterVerificationGasLimit: Hex | undefined;
  paymasterPostOpGasLimit: Hex | undefined;
  paymasterData: Hex | undefined;
  signature: Hex;
  initCode?: never;
  paymasterAndData?: never;
};

/**
 * UserOperation v0.7
 */
export type UserOperation = {
  sender: Address;
  nonce: bigint;
  factory?: Address;
  factoryData?: Hex;
  callData: Hex;
  callGasLimit: bigint;
  verificationGasLimit: bigint;
  preVerificationGas: bigint;
  maxFeePerGas: bigint;
  maxPriorityFeePerGas: bigint;
  paymaster?: Address;
  paymasterVerificationGasLimit?: bigint;
  paymasterPostOpGasLimit?: bigint;
  paymasterData?: Hex;
  signature: Hex;
  initCode?: never;
  paymasterAndData?: never;
};

export type ErrorResponse = {
  message: string;
  error: string;
};

export type PrepareCallsParams = {
  from: `0x${string}`;
  chainId: `0x${string}`;
  calls: {
    to: `0x${string}`;
    data: `0x${string}`;
    value: `0x${string}`;
  }[];
  capabilities: Record<string, unknown>;
};

export type PrepareCallsReturnValue = {
  preparedCalls: {
    type: string;
    data: unknown;
    chainId: `0x${string}`;
  };
  signatureRequest: {
    hash: `0x${string}`;
  };
  context: string;
};

export type SendPreparedCallsParams = {
  preparedCalls: {
    type: string;
    data: unknown;
    chainId: `0x${string}`;
  };
  signature: `0x${string}`;
  context: string;
};

export type SendPreparedCallsReturnValue = string;
export type GetCallsStatusParams = string;
export type GetCallsStatusReturnValue = {
  status: "PENDING" | "CONFIRMED";
  receipts?: {
    logs: {
      address: `0x${string}`;
      data: `0x${string}`;
      topics: `0x${string}`[];
    }[];
    status: `0x${string}`; // Hex 1 or 0 for success or failure, respectively
    blockHash: `0x${string}`;
    blockNumber: `0x${string}`;
    gasUsed: `0x${string}`;
    transactionHash: `0x${string}`;
  }[];
};

// Define a custom error type
export class UserOpBuilderApiError extends Error {
  constructor(
    public status: number,
    message: string,
  ) {
    super(message);
    this.name = "UserOpBuilderApiError";
  }
}

async function jsonRpcRequest<TParams, TResult>(
  method: string,
  params: TParams,
  url: string,
): Promise<TResult> {
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(
      {
        jsonrpc: "2.0",
        id: "1",
        method,
        params,
      },
      bigIntReplacer,
    ),
  });

  if (!response.ok) {
    throw new UserOpBuilderApiError(response.status, await response.text());
  }

  const data = await response.json();

  if ("error" in data) {
    throw new UserOpBuilderApiError(500, JSON.stringify(data.error));
  }

  return data.result; // Return the result if successful
}

export async function prepareCalls(
  args: PrepareCallsParams,
): Promise<PrepareCallsReturnValue[]> {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }
  const url = `${USEROP_BUILDER_SERVICE_BASE_URL}?projectId=${projectId}`;

  return jsonRpcRequest<PrepareCallsParams[], PrepareCallsReturnValue[]>(
    "wallet_prepareCalls",
    [args],
    url,
  );
}

export async function sendPreparedCalls(
  args: SendPreparedCallsParams,
): Promise<SendPreparedCallsReturnValue[]> {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }
  const url = `${USEROP_BUILDER_SERVICE_BASE_URL}?projectId=${projectId}`;

  return jsonRpcRequest<
    SendPreparedCallsParams[],
    SendPreparedCallsReturnValue[]
  >("wallet_sendPreparedCalls", [args], url);
}

export async function getCallsStatus(
  args: GetCallsStatusParams,
  options: { timeout?: number; interval?: number } = {},
): Promise<GetCallsStatusReturnValue> {
  const projectId = process.env["NEXT_PUBLIC_PROJECT_ID"];
  if (!projectId) {
    throw new Error("NEXT_PUBLIC_PROJECT_ID is not set");
  }

  const url = `${USEROP_BUILDER_SERVICE_BASE_URL}?projectId=${projectId}`;

  const { timeout = 30000, interval = 3000 } = options; // Default timeout to 30 seconds and interval to 2 second
  const endTime = Date.now() + timeout;
  while (Date.now() < endTime) {
    const response = await jsonRpcRequest<
      GetCallsStatusParams[],
      GetCallsStatusReturnValue
    >("wallet_getCallsStatus", [args], url);

    // Check if the response is valid (not null)
    if (response.status === "CONFIRMED") {
      return response;
    }

    // Wait for the specified interval before polling again
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  throw new Error(
    "Timeout: No valid response received from wallet_getCallsStatus",
  );
}
</file>

<file path="advanced/dapps/smart-sessions-demo/.env.example">
NEXT_PUBLIC_PROJECT_ID=
NEXT_PUBLIC_RELAY_URL=wss://relay.walletconnect.org
NEXT_PUBLIC_SECURE_SITE_SDK_URL=
APPLICATION_PRIVATE_KEY=
</file>

<file path="advanced/dapps/smart-sessions-demo/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="advanced/dapps/smart-sessions-demo/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
</file>

<file path="advanced/dapps/smart-sessions-demo/eslint.config.mjs">
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
import pluginReact from "eslint-plugin-react";


export default [
  {files: ["**/*.{js,mjs,cjs,ts,jsx,tsx}"]},
  {languageOptions: { globals: globals.browser }},
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
  pluginReact.configs.flat.recommended,
];
</file>

<file path="advanced/dapps/smart-sessions-demo/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;
</file>

<file path="advanced/dapps/smart-sessions-demo/package.json">
{
  "name": "smart-sessions-demo",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,css,md}\""
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.1",
    "@radix-ui/react-tooltip": "^1.1.2",
    "@reown/appkit": "1.6.8",
    "@reown/appkit-adapter-wagmi": "1.6.8",
    "@reown/appkit-experimental": "1.6.8",
    "@shadcn/ui": "^0.0.4",
    "@tanstack/react-query": "5.24.8",
    "@wagmi/connectors": "5.1.9",
    "@wagmi/core": "2.13.4",
    "autoprefixer": "10.4.18",
    "axios": "1.8.2",
    "bs58": "^6.0.0",
    "class-variance-authority": "^0.7.0",
    "clsx": "2.1.0",
    "lucide-react": "^0.427.0",
    "next": "14.2.25",
    "next-themes": "^0.3.0",
    "permissionless": "0.1.31",
    "pino-pretty": "^11.2.2",
    "react": "^18",
    "react-dom": "^18",
    "react-hook-form": "^7.52.2",
    "sonner": "1.4.3",
    "tailwind-merge": "2.2.1",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "0.9.0",
    "viem": "2.17.8",
    "wagmi": "2.12.2",
    "zod": "3.22.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^9.9.0",
    "eslint-config-next": "14.2.25",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react": "^7.35.0",
    "globals": "^15.9.0",
    "postcss": "^8",
    "prettier": "^3.3.3",
    "tailwindcss": "^3.4.1",
    "typescript": "^5",
    "typescript-eslint": "^8.2.0"
  },
  "pnpm": {
    "overrides": {
      "elliptic@>=4.0.0 <=6.5.6": ">=6.5.7",
      "elliptic@>=2.0.0 <=6.5.6": ">=6.5.7",
      "elliptic@>=5.2.1 <=6.5.6": ">=6.5.7",
      "elliptic@<6.6.0": ">=6.6.0",
      "elliptic@<6.5.6": ">=6.5.6",
      "@coinbase/wallet-sdk@>=4.0 <4.3.0": ">=4.3.0",
      "elliptic@<=6.6.0": ">=6.6.1",
      "@babel/runtime@<7.26.10": ">=7.26.10"
    }
  }
}
</file>

<file path="advanced/dapps/smart-sessions-demo/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="advanced/dapps/smart-sessions-demo/README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="advanced/dapps/smart-sessions-demo/tailwind.config.ts">
import type { Config } from "tailwindcss";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        fadeIn: {
          from: { opacity: "0", transform: "translateY(-10px)" },
          to: { opacity: "1", transform: "translateY(0)" },
        },
        bounce: {
          "0%, 100%": { transform: "translateY(0)" },
          "50%": { transform: "translateY(-10px)" },
        },
        fadeInDown: {
          from: { opacity: "0", transform: "translateY(-10px)" },
          to: { opacity: "1", transform: "translateY(0)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        dynamicPulse: "dynamicPulse 2s ease-in-out infinite",
      },
    },
  },
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

export default config;
</file>

<file path="advanced/dapps/smart-sessions-demo/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "src/app/**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="advanced/wallets/react-wallet-v2/public/main.css">
* {
  box-sizing: border-box;
  -ms-overflow-style: none; 
  scrollbar-width: none; 
}

::-webkit-scrollbar {
  display: none;
}

.routeTransition {
  display: flex;
  flex: 1;
  flex-direction: column;
  overflow: hidden;
}

.container {
  width: 100%;
  height: calc(100% - 220px);
  display: flex;
  flex: 1;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.qrVideoMask {
  width: 100%;
  border-radius: 15px;
  overflow: hidden !important;
  position: relative;
}

.qrPlaceholder {
  border: 2px rgba(139, 139, 139, 0.4) dashed;
  width: 100%;
  border-radius: 15px;
  padding: 50px;
}

.qrIcon {
  opacity: 0.3;
}

.codeBlock code {
  flex: 1;
}

.codeBlock span {
  background-color: transparent !important;
  overflow: scroll;
}

.navLink {
  transition: ease-in-out .2s opacity;
}

.navLink:hover {
  opacity: 0.6;
}

select {
  background-color: rgba(139, 139, 139, 0.2);
  background-image: url(/icons/arrow-down-icon.svg);
  background-size: 15px 15px;
  background-position: right 10px center;
  background-repeat: no-repeat;
  padding: 5px 30px 6px 10px;
  border-radius: 10px;
  cursor: pointer;
  border: none;
  appearance: none;
  transition: .2s ease-in-out background-color;
  font-family: var(--nextui-fonts-sans);
  font-weight: var(--nextui-fontWeights-light);
  border: 1px solid rgba(139, 139, 139, 0.25);
}

select:hover {
  background-color: rgba(139, 139, 139, 0.35);
}

i {
  margin-top: -5px !important;
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/visual/BadgeAlertIcon.tsx">
import React from "react";

const BadgeAlertIcon = ({ color = "red", size = 24 }) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z" />
      <line x1="12" x2="12" y1="8" y2="12" />
      <line x1="12" x2="12.01" y1="16" y2="16" />
    </svg>
  );
};

export default BadgeAlertIcon;
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/visual/BadgeCheckIcon.tsx">
import React from "react";

const BadgeCheckIcon = ({ color = "green", size = 24 }) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width={size}
      height={size}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z" />
      <path d="m9 12 2 2 4-4" />
    </svg>
  );
};

export default BadgeCheckIcon;
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/visual/GiftIcon.tsx">
import React from 'react'

/**
 * Gift icon
 */
export const GiftIcon: React.FC = () => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="11" height="9" fill="none">
      <path
        d="M10.375 3c0-.035-.005-.07-.014-.103L9.688.544C9.643.388 9.549.25 9.419.152S9.131.001 8.969 0H2.031c-.163.001-.32.054-.45.152s-.224.235-.269.391L.64 2.897A.37.37 0 0 0 .625 3v.75c0 .291.068.578.198.839s.319.487.552.661v3.375c0 .099.04.195.11.265s.166.11.265.11h7.5c.099 0 .195-.04.265-.11s.11-.166.11-.265V5.25c.233-.175.422-.401.552-.661s.198-.547.198-.839V3zM2.031.75h6.938l.535 1.875H1.497L2.031.75zm2.344 2.625h2.25v.375c0 .298-.119.585-.33.795s-.497.33-.795.33-.585-.119-.795-.33-.33-.497-.33-.795v-.375zm-.75 0v.375c0 .193-.05.384-.145.552s-.232.31-.397.41-.354.156-.547.162-.385-.038-.556-.127a.37.37 0 0 0-.085-.05c-.159-.102-.29-.242-.38-.407s-.138-.351-.138-.54v-.375h2.25zm5.25 4.875h-6.75V5.588a1.9 1.9 0 0 0 .375.037c.291 0 .578-.068.839-.198s.487-.319.661-.552c.175.233.401.422.661.552s.547.198.839.198.578-.068.839-.198.487-.319.661-.552c.175.233.401.422.661.552s.547.198.839.198a1.9 1.9 0 0 0 .375-.037V8.25zm.231-3.553a.38.38 0 0 0-.084.049c-.171.09-.363.134-.556.128s-.382-.062-.548-.162-.302-.241-.398-.41-.145-.359-.145-.552v-.375h2.25v.375c0 .189-.048.374-.138.54s-.222.305-.38.407z"
        fill="#9a9a9a"
      />
    </svg>
  )
}

export default GiftIcon
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/visual/OrderDetailIcon.tsx">
import React from 'react'

/**
 * Gift icon
 */
export const OrderDetailIcon: React.FC = () => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="11" fill="none">
      <path
        d="M2.719 3.969c0-.174.069-.341.192-.464s.29-.192.464-.192h5.25c.174 0 .341.069.464.192s.192.29.192.464-.069.341-.192.464-.29.192-.464.192h-5.25c-.174 0-.341-.069-.464-.192s-.192-.29-.192-.464zm.656 2.844h5.25c.174 0 .341-.069.464-.192s.192-.29.192-.464-.069-.341-.192-.464-.29-.192-.464-.192h-5.25c-.174 0-.341.069-.464.192s-.192.29-.192.464.069.341.192.464.29.192.464.192zm8.531-5.25v8.313c0 .112-.029.222-.083.32s-.133.18-.228.239-.204.092-.316.097-.223-.019-.323-.069L9.5 9.734l-1.456.728c-.091.046-.192.069-.294.069s-.202-.024-.294-.069L6 9.734l-1.456.728c-.091.046-.192.069-.294.069s-.202-.024-.294-.069L2.5 9.734l-1.456.728c-.1.05-.211.074-.323.069s-.22-.038-.316-.097-.174-.141-.228-.239-.083-.208-.083-.32V1.563c0-.29.115-.568.32-.773s.483-.32.773-.32h9.625c.29 0 .568.115.773.32s.32.483.32.773zm-1.312.219H1.406v7.032l.8-.4c.091-.046.192-.069.294-.069s.203.024.294.069l1.456.728 1.456-.728c.091-.046.192-.069.294-.069s.202.024.294.069l1.456.728 1.456-.728c.091-.046.192-.069.294-.069s.203.024.294.069l.8.4V1.781z"
        fill="#9a9a9a"
      />
    </svg>
  )
}

export default OrderDetailIcon
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/visual/WalletIcon.tsx">
import React from 'react'

/**
 * Wallet icon
 */
export const WalletIcon: React.FC<{ width?: number; height?: number }> = ({
  width = 10,
  height = 9
}) => {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width={width} height={height} fill="none">
      <path
        d="M8.625 1.5h-7.5c-.099 0-.195-.04-.265-.11s-.11-.166-.11-.265S.79.93.86.86s.166-.11.265-.11H7.5c.099 0 .195-.04.265-.11s.11-.166.11-.265-.04-.195-.11-.265S7.599 0 7.5 0H1.125C.827 0 .54.119.33.33S0 .827 0 1.125v6c0 .298.119.585.33.795s.497.33.795.33h7.5a.75.75 0 0 0 .75-.75V2.25a.75.75 0 0 0-.75-.75zm0 6h-7.5c-.099 0-.195-.04-.265-.11s-.11-.166-.11-.265V2.186c.12.043.247.064.375.064h7.5V7.5zm-2.25-2.812a.56.56 0 0 1 .095-.313c.062-.093.15-.165.252-.207a.56.56 0 0 1 .325-.032c.109.022.209.075.288.154s.132.179.154.288a.56.56 0 0 1-.032.325c-.043.103-.115.191-.207.252a.56.56 0 0 1-.313.095c-.149 0-.292-.059-.398-.165s-.165-.249-.165-.398z"
        fill="#9a9a9a"
      />
    </svg>
  )
}

export default WalletIcon
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/GenericDropdown.tsx">
import { useEffect, useRef, useState } from 'react'
import { Text, Card } from '@nextui-org/react'

// Simple hook to detect clicks outside an element
const useClickAway = (onClickAway: () => void) => {
  const ref = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (ref.current && !ref.current.contains(event.target as Node)) {
        onClickAway()
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [onClickAway])

  return ref
}
// Style variables
const styles = {
  dropdownContainer: {
    position: 'relative' as const
  },
  dropdownButton: {
    padding: '8px 16px',
    background: '$accents0',
    cursor: 'pointer'
  },
  cardBody: {
    overflow: 'visible' as const,
    display: 'flex' as const,
    justifyContent: 'space-between' as const,
    alignItems: 'center' as const,
    padding: '4px 0'
  },
  contentWrapper: {
    display: 'flex' as const,
    alignItems: 'center' as const,
    width: '100%'
  },
  chevronContainer: {
    marginLeft: 'auto'
  },
  dropdownMenu: {
    position: 'absolute' as const,
    top: 'calc(100% + 8px)',
    left: 0,
    right: 0,
    zIndex: 1000,
    padding: '4px 8px',
    boxShadow: '0 4px 14px 0 rgba(0, 0, 0, 0.3)',
    maxHeight: '300px',
    overflow: 'auto' as const,
    backgroundColor: '#2a2a2a'
  },
  checkmark: {
    position: 'absolute' as const,
    right: '10px',
    top: '50%',
    transform: 'translateY(-50%)',
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    backgroundColor: '#17c964',
    display: 'flex' as const,
    alignItems: 'center' as const,
    justifyContent: 'center' as const,
    color: 'white',
    boxShadow: '0 2px 8px rgba(23, 201, 100, 0.5)'
  }
}

// Generic dropdown component
export default function GenericDropdown({
  items,
  selectedIndex,
  setSelectedIndex,
  renderItem,
  placeholder = 'Select an option',
  emptyMessage = 'No options available'
}: {
  items: any[]
  selectedIndex: number
  setSelectedIndex: (index: number) => void
  renderItem: (item: any) => React.ReactNode
  placeholder?: string
  emptyMessage?: string
}) {
  const [isOpen, setIsOpen] = useState(false)

  // Reference to detect clicks outside dropdown
  const dropdownRef = useClickAway(() => {
    setIsOpen(false)
  })

  const handleSelect = (index: number) => {
    setSelectedIndex(index)
    setIsOpen(false)
  }

  // Get style for dropdown item
  const getDropdownItemStyle = (isSelected: boolean, isLast: boolean) => ({
    cursor: 'pointer' as const,
    padding: '8px 4px',
    borderRadius: '8px',
    backgroundColor: isSelected ? 'rgba(23, 201, 100, 0.2)' : 'transparent',
    position: 'relative' as const,
    marginBottom: 0,
    borderBottom: isLast ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
    paddingBottom: '8px',
    marginTop: '8px',
    transition: 'all 0.2s ease'
  })

  // Handle hover effects
  const handleMouseOver = (e: React.MouseEvent<HTMLDivElement>, isSelected: boolean) => {
    if (!isSelected) {
      e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.1)'
    }
  }

  const handleMouseOut = (e: React.MouseEvent<HTMLDivElement>, isSelected: boolean) => {
    if (!isSelected) {
      e.currentTarget.style.backgroundColor = 'transparent'
    }
  }

  // Render chevron icon
  const renderChevron = () => (
    <svg
      width="16"
      height="16"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
      style={{
        transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)',
        transition: 'transform 0.2s ease'
      }}
    >
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  )

  // Render checkmark icon
  const renderCheckmark = () => (
    <div style={styles.checkmark}>
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="14"
        height="14"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="3"
        strokeLinecap="round"
        strokeLinejoin="round"
      >
        <polyline points="20 6 9 17 4 12"></polyline>
      </svg>
    </div>
  )

  return (
    <div ref={dropdownRef} style={styles.dropdownContainer}>
      {/* Dropdown Button */}
      <Card onClick={() => setIsOpen(!isOpen)} css={styles.dropdownButton}>
        <Card.Body css={styles.cardBody}>
          <div style={styles.contentWrapper}>
            {items.length > 0 && selectedIndex >= 0 ? (
              renderItem(items[selectedIndex])
            ) : (
              <Text size={14} css={{ color: '#aaaaaa' }}>
                {placeholder}
              </Text>
            )}
            <div style={styles.chevronContainer}>{renderChevron()}</div>
          </div>
        </Card.Body>
      </Card>

      {/* Dropdown Menu */}
      {isOpen && (
        <Card css={styles.dropdownMenu}>
          {items.length > 0 ? (
            items.map((item, idx) => {
              const isSelected = selectedIndex === idx
              const isLastItem = idx === items.length - 1

              return (
                <div
                  key={idx}
                  onClick={() => handleSelect(idx)}
                  style={getDropdownItemStyle(isSelected, isLastItem)}
                  onMouseOver={e => handleMouseOver(e, isSelected)}
                  onMouseOut={e => handleMouseOut(e, isSelected)}
                >
                  {renderItem(item)}
                  {isSelected && renderCheckmark()}
                </div>
              )
            })
          ) : (
            <Text css={{ color: '$accents7', padding: '8px 4px' }}>{emptyMessage}</Text>
          )}
        </Card>
      )}
    </div>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/NetworkDropdown.tsx">
import { Text, Row, Grid } from '@nextui-org/react'
import Image from 'next/image'
import GenericDropdown from './GenericDropdown'

// Style variables
const styles = {
  avatarWrapper: {
    position: 'relative' as const,
    marginRight: '12px'
  },
  chainImage: {
    objectFit: 'cover' as const,
    borderRadius: '50%'
  }
}

interface NetworkWithTokens {
  chainId: string
  chainName: string
  chainNamespace: string
  chainIcon: string
  tokens: string[]
}

// Network Dropdown Component
interface NetworkDropdownProps {
  allNetworks: NetworkWithTokens[]
  filteredNetworks: NetworkWithTokens[]
  selectedNetworkIndex: number
  onSelectNetwork: (index: number) => void
}

export default function NetworkDropdown({
  allNetworks,
  filteredNetworks,
  selectedNetworkIndex,
  onSelectNetwork
}: NetworkDropdownProps) {
  const renderNetwork = (network: NetworkWithTokens) => (
    <Row align="center" css={{ width: '100%' }}>
      {network.chainIcon && (
        <div style={{ ...styles.avatarWrapper, marginRight: '12px' }}>
          <Image
            src={network.chainIcon}
            width={24}
            height={24}
            style={styles.chainImage}
            alt={network.chainName}
          />
        </div>
      )}

      <Grid.Container direction="column" css={{ margin: 0, padding: 0 }}>
        <Text b size={14} css={{ lineHeight: 1.2, color: 'white' }}>
          {network.chainName}
        </Text>
      </Grid.Container>
    </Row>
  )

  return (
    <div style={{ width: '100%' }}>
      <GenericDropdown
        items={filteredNetworks}
        selectedIndex={selectedNetworkIndex}
        setSelectedIndex={onSelectNetwork}
        renderItem={renderNetwork}
        placeholder="Select network"
        emptyMessage="No networks available"
      />
    </div>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/SelectedPaymentDetails.tsx">
import { useState, useEffect, useRef, useCallback } from 'react'
import { Text, Row, Container, Col, Card, Divider, Spacer } from '@nextui-org/react'
import { DetailedPaymentOption } from '@/types/wallet_checkout'
import Image from 'next/image'
import { formatUnits } from 'viem'
import { GiftIcon } from './visual/GiftIcon'
import WalletIcon from './visual/WalletIcon'

// Selected Payment Details Component
interface SelectedPaymentDetailsProps {
  selectedPayment: DetailedPaymentOption | null
}

const SelectedPaymentDetails = ({ selectedPayment }: SelectedPaymentDetailsProps) => {
  if (!selectedPayment) {
    return null
  }
  const styles = {
    iconWrapper: {
      width: '40px',
      height: '40px',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    },
    circleIconBg: {
      display: 'flex',
      backgroundColor: '#333',
      height: '32px',
      width: '32px',
      borderRadius: '50%',
      alignItems: 'center',
      justifyContent: 'center'
    }
  }

  const formattedBalance = formatUnits(
    selectedPayment.assetMetadata.assetBalance,
    selectedPayment.assetMetadata.assetDecimals
  )

  return (
    <Card
      css={{
        backgroundColor: '#222',
        borderRadius: '24px',
        padding: '12px',
        marginTop: '16px'
      }}
    >
      <Card.Body css={{ padding: '12px 0' }}>
        <Row align="center" css={{ marginBottom: '12px' }}>
          <Row align="center" css={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <div style={styles.iconWrapper}>
              <div style={styles.circleIconBg}>
                <WalletIcon />
              </div>
            </div>
            <Text css={{ color: '#aaa', fontSize: '14px' }}>Balance</Text>
          </Row>
          <Col span={8} css={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
            <Text css={{ color: '#fff', fontSize: '14px', justifyContent: 'flex-end' }}>
              {formattedBalance.length > 4
                ? parseFloat(formattedBalance).toFixed(3)
                : formattedBalance}{' '}
              {selectedPayment.assetMetadata.assetSymbol}
            </Text>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <Text css={{ color: '#aaa', fontSize: '14px', whiteSpace: 'nowrap' }}>
                on {selectedPayment.chainMetadata.chainName}
              </Text>
              <div style={{ alignItems: 'center', display: 'flex', width: '16px', height: '16px' }}>
                <Image
                  src={selectedPayment.chainMetadata.chainIcon}
                  width={16}
                  height={16}
                  alt={selectedPayment.chainMetadata.chainName}
                  style={{ borderRadius: '50%', marginLeft: '4px' }}
                />
              </div>
            </div>
          </Col>
        </Row>

        <Row align="center" justify="space-between" css={{ marginBottom: '12px' }}>
          <Row align="center" css={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <div style={styles.iconWrapper}>
              <div style={styles.circleIconBg}>
                <GiftIcon />
              </div>
            </div>
            <Text css={{ color: '#aaa', fontSize: '14px' }}>Send</Text>
          </Row>
          <Col span={8} css={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
            <Text css={{ color: '#fff', fontSize: '14px', justifyContent: 'flex-end' }}>
              {formatUnits(
                BigInt(selectedPayment.amount),
                selectedPayment.assetMetadata.assetDecimals
              ).toString()}{' '}
              {selectedPayment.assetMetadata.assetSymbol}
            </Text>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <Text css={{ color: '#aaa', fontSize: '14px', whiteSpace: 'nowrap' }}>
                on {selectedPayment.chainMetadata.chainName}
              </Text>
              <div style={{ alignItems: 'center', display: 'flex', width: '16px', height: '16px' }}>
                <Image
                  src={selectedPayment.chainMetadata.chainIcon}
                  width={16}
                  height={16}
                  alt={selectedPayment.chainMetadata.chainName}
                  style={{ borderRadius: '50%', marginLeft: '4px' }}
                />
              </div>
            </div>
          </Col>
        </Row>
      </Card.Body>
    </Card>
  )
}

export default SelectedPaymentDetails
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentCheckout/TokenDropdown.tsx">
import { Text, Row, Avatar, Grid } from '@nextui-org/react'
import GenericDropdown from './GenericDropdown'

// Style variables
const styles = {
  avatarWrapper: {
    position: 'relative' as const,
    marginRight: '12px'
  }
}

// Define types for the enhanced token and network data
interface TokenWithNetworks {
  assetSymbol: string
  assetIcon: string
  assetName: string
  assetDecimals: number
  assetNamespace: string
  networks: string[]
}

// Token Dropdown Component
interface TokenDropdownProps {
  allTokens: TokenWithNetworks[]
  filteredTokens: TokenWithNetworks[]
  selectedTokenIndex: number
  onSelectToken: (index: number) => void
}

export default function TokenDropdown({
  allTokens,
  filteredTokens,
  selectedTokenIndex,
  onSelectToken
}: TokenDropdownProps) {
  const renderToken = (token: TokenWithNetworks) => (
    <Row align="center" css={{ width: '100%' }}>
      <div style={styles.avatarWrapper}>
        {token.assetIcon ? (
          <Avatar
            src={token.assetIcon}
            bordered={false}
            color="primary"
            css={{ zIndex: 1 }}
            text={token.assetSymbol.charAt(0)}
            size="sm"
          />
        ) : (
          <Avatar
            bordered={false}
            color="primary"
            css={{ zIndex: 1 }}
            text={token.assetSymbol.charAt(0)}
            size="sm"
          />
        )}
      </div>

      <Grid.Container direction="column" css={{ margin: 0, padding: 0 }}>
        <Text b size={14} css={{ lineHeight: 1.2, color: 'white' }}>
          {token.assetSymbol}
        </Text>
      </Grid.Container>
    </Row>
  )

  return (
    <div style={{ width: '100%' }}>
      <GenericDropdown
        items={filteredTokens}
        selectedIndex={selectedTokenIndex}
        setSelectedIndex={onSelectToken}
        renderItem={renderToken}
        placeholder="Select token"
        emptyMessage="No tokens available"
      />
    </div>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/AccountCard.tsx">
import ChainCard from '@/components/ChainCard'
import SettingsStore from '@/store/SettingsStore'
import { eip155Addresses } from '@/utils/EIP155WalletUtil'
import { truncate } from '@/utils/HelperUtil'
import { updateSignClientChainId } from '@/utils/WalletConnectUtil'
import { Avatar, Button, Text, Tooltip } from '@nextui-org/react'
import Image from 'next/image'
import { useState } from 'react'
import { useSnapshot } from 'valtio'

interface Props {
  name: string
  logo: string
  rgb: string
  address: string
  chainId: string
}

export default function AccountCard({ name, logo, rgb, address = '', chainId }: Props) {
  const [copied, setCopied] = useState(false)
  const { activeChainId, account } = useSnapshot(SettingsStore.state)
  function onCopy() {
    navigator?.clipboard?.writeText(address)
    setCopied(true)
    setTimeout(() => setCopied(false), 1500)
  }

  async function onChainChanged(chainId: string, address: string) {
    SettingsStore.setActiveChainId(chainId)
    await updateSignClientChainId(chainId.toString(), address)
  }

  return (
    <ChainCard rgb={rgb} flexDirection="row" alignItems="center">
      <Avatar src={logo} />
      <div style={{ flex: 1 }}>
        <Text h5 css={{ marginLeft: '$9' }}>
          {name}
        </Text>
        <Text weight="light" size={13} css={{ marginLeft: '$9' }}>
          {address ? truncate(address, 19) : '<no address available>'}
        </Text>
      </div>

      <Tooltip content={copied ? 'Copied!' : 'Copy'} placement="left">
        <Button
          size="sm"
          css={{ minWidth: 'auto', backgroundColor: 'rgba(255, 255, 255, 0.15)' }}
          data-testid={'chain-copy-button' + chainId}
          onClick={e => {
            e.stopPropagation()
            onCopy()
          }}
        >
          <Image
            src={copied ? '/icons/checkmark-icon.svg' : '/icons/copy-icon.svg'}
            width={15}
            height={15}
            alt="copy icon"
          />
        </Button>
      </Tooltip>
      <Button
        size="sm"
        css={{
          minWidth: 'auto',
          backgroundColor: 'rgba(255, 255, 255, 0.15)',
          marginLeft: '$5'
        }}
        data-testid={'chain-switch-button' + chainId}
        onClick={e => {
          e.stopPropagation()
          onChainChanged(chainId, address)
        }}
      >
        {activeChainId === chainId ? `✅` : `🔄`}
      </Button>
    </ChainCard>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/AccountPicker.tsx">
import SettingsStore from '@/store/SettingsStore'
import { cosmosAddresses } from '@/utils/CosmosWalletUtil'
import { eip155Addresses } from '@/utils/EIP155WalletUtil'
import { nearAddresses } from '@/utils/NearWalletUtil'
import { solanaAddresses } from '@/utils/SolanaWalletUtil'
import { multiversxAddresses } from '@/utils/MultiversxWalletUtil'
import { tronAddresses } from '@/utils/TronWalletUtil'
import { tezosAddresses } from '@/utils/TezosWalletUtil'
import { kadenaAddresses } from '@/utils/KadenaWalletUtil'
import { useSnapshot } from 'valtio'

export default function AccountPicker() {
  const { account } = useSnapshot(SettingsStore.state)

  function onSelect(value: string) {
    const account = Number(value)
    console.log('account', account)
    SettingsStore.setAccount(account)
    SettingsStore.setEIP155Address(eip155Addresses[account])
    SettingsStore.setCosmosAddress(cosmosAddresses[account])
    SettingsStore.setSolanaAddress(solanaAddresses[account])
    SettingsStore.setNearAddress(nearAddresses[account])
    SettingsStore.setMultiversxAddress(multiversxAddresses[account])
    SettingsStore.setTronAddress(tronAddresses[account])
    SettingsStore.setTezosAddress(tezosAddresses[account])
    SettingsStore.setKadenaAddress(kadenaAddresses[account])
  }

  return (
    <select
      value={account}
      onChange={e => onSelect(e.currentTarget.value)}
      aria-label="addresses"
      data-testid="account-picker"
    >
      <option value={0}>Account 1</option>
      <option value={1}>Account 2</option>
    </select>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/AccountSelectCard.tsx">
import { truncate } from '@/utils/HelperUtil'
import { Card, Checkbox, Row, Text } from '@nextui-org/react'

/**
 * Types
 */
interface IProps {
  address: string
  index: number
  selected: boolean
  onSelect: () => void
  isRequired: boolean
}

/**
 * Component
 */
export default function AccountSelectCard({
  address,
  selected,
  index,
  onSelect,
  isRequired
}: IProps) {
  return (
    <Card
      onClick={onSelect}
      clickable
      key={address}
      css={{
        marginTop: '$5',
        backgroundColor: selected ? 'rgba(23, 200, 100, 0.2)' : '$accents2'
      }}
      data-testid={`account-select-card-${isRequired ? 'req' : 'opt'}-${index + 1}`}
    >
      <Row justify="space-between" align="center">
        <Checkbox size="lg" color="success" checked={selected} />

        <Text data-testid={`account-select-text-${index + 1}`}>
          {`${truncate(address, 14)} - Account ${index + 1}`}
        </Text>
      </Row>
    </Card>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ChainAbstractionBalanceCard.tsx">
import SettingsStore from '@/store/SettingsStore'
import { getChainById } from '@/utils/ChainUtil'
import {
  getErc20TokenBalance,
  supportedAssets as multibridgeSupportedAssets
} from '@/utils/MultibridgeUtil'
import { Collapse, Loading, Text } from '@nextui-org/react'
import { useEffect, useState } from 'react'
import { useSnapshot } from 'valtio'
import { Hex } from 'viem'

export default function ChainAbstractionBalanceCard() {
  const { eip155Address } = useSnapshot(SettingsStore.state)
  const [balances, setBalances] = useState<Record<string, Record<string, number>>>({})
  const [totalBalance, setTotalBalance] = useState<Record<string, number>>({})
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    const fetchAllBalances = async () => {
      setLoading(true)

      const fetchedBalances: Record<string, any> = {}
      for (const asset of Object.keys(multibridgeSupportedAssets)) {
        const assetBalances: Record<string, number> = {}
        for (const chainId of Object.keys(multibridgeSupportedAssets[asset])) {
          const tokenAddress = multibridgeSupportedAssets[asset][Number(chainId)]
          const balance = await getErc20TokenBalance(
            tokenAddress as Hex,
            Number(chainId),
            eip155Address as Hex
          )
          assetBalances[chainId] = balance
        }
        fetchedBalances[asset] = assetBalances
      }
      setBalances(fetchedBalances)
      setLoading(false)
    }
    fetchAllBalances()
  }, [eip155Address])

  useEffect(() => {
    const totalBalances: Record<string, number> = {}
    for (const asset of Object.keys(balances)) {
      let total = 0
      for (const chainBalance of Object.values(balances[asset])) {
        total += chainBalance
      }
      totalBalances[asset] = total
    }
    setTotalBalance(totalBalances)
  }, [balances])

  return (
    <>
      <Text h4 css={{ marginBottom: '$5' }}>
        Token Assets (CA)
      </Text>
      {loading ? (
        <Loading />
      ) : (
        <Collapse.Group accordion={false}>
          {Object.keys(balances).map(asset => {
            return (
              <Collapse
                title={
                  <Text weight="semibold">
                    {asset} - {totalBalance[asset]}
                  </Text>
                }
                key={asset}
              >
                {Object.keys(balances[asset]).map(chainId => {
                  const chain = getChainById(Number(chainId))
                  return (
                    <Text key={asset + '-' + chainId}>
                      {chain.name} - {balances[asset][chainId]}
                    </Text>
                  )
                })}
              </Collapse>
            )
          })}
        </Collapse.Group>
      )}
    </>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ChainAddressMini.tsx">
import { Row } from '@nextui-org/react'

interface Props {
  address?: string
}

export default function ChainAddressMini({ address }: Props) {
  if (!address || address === 'N/A') return <></>
  return (
    <>
      <Row>
        <span style={{ marginLeft: '5px' }}>
          {address.substring(0, 6)}...{address.substring(address.length - 6)}
        </span>
      </Row>
    </>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ChainCard.tsx">
import { Card } from '@nextui-org/react'
import { ReactNode } from 'react'

interface Props {
  children: ReactNode | ReactNode[]
  rgb: string
  flexDirection: 'row' | 'col'
  alignItems: 'center' | 'flex-start'
  flexWrap?: 'wrap' | 'nowrap'
}

export default function ChainCard({ rgb, children, flexDirection, alignItems, flexWrap }: Props) {
  return (
    <Card
      bordered
      borderWeight="light"
      css={{
        borderColor: `rgba(${rgb}, 0.4)`,
        boxShadow: `0 0 10px 0 rgba(${rgb}, 0.15)`,
        backgroundColor: `rgba(${rgb}, 0.25)`,
        marginBottom: '$6',
        minHeight: '70px'
      }}
    >
      <Card.Body
        css={{
          flexWrap,
          flexDirection,
          alignItems,
          justifyContent: 'space-between',
          overflow: 'hidden'
        }}
      >
        {children}
      </Card.Body>
    </Card>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ChainDataMini.tsx">
import { getChainData } from '@/data/chainsUtil'
import { Row, Avatar } from '@nextui-org/react'
import { useMemo } from 'react'

interface Props {
  chainId?: string // namespace + ":" + reference
}

// const StyledLogo = styled(Image, {})

export default function ChainDataMini({ chainId }: Props) {
  const chainData = useMemo(() => getChainData(chainId), [chainId])
  console.log(chainData)

  if (!chainData) return <></>
  return (
    <>
      <Row>
        <Avatar size={'xs'} src={chainData.logo} />
        <span style={{ marginLeft: '5px' }}>{chainData.name}</span>
      </Row>
    </>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ChainSmartAddressMini.tsx">
import ChainAddressMini from './ChainAddressMini'
import { Button, Col, Row, Spinner, Text, Tooltip } from '@nextui-org/react'
import InfoIcon from '@mui/icons-material/Info'

type SmartAccount = {
  address: string
  type: string
}

interface Props {
  account: SmartAccount
}

export default function ChainSmartAddressMini({ account }: Props) {
  if (!account) return <Spinner />
  return (
    <Row>
      <Col>
        <Text style={{ marginLeft: '5px' }}>({account.type})</Text>
        <ChainAddressMini address={account.address} />
      </Col>
    </Row>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/Layout.tsx">
import Navigation from '@/components/Navigation'
import RouteTransition from '@/components/RouteTransition'
import { Card, Container, Loading } from '@nextui-org/react'
import { Fragment, ReactNode } from 'react'

/**
 * Types
 */
interface Props {
  initialized: boolean
  children: ReactNode | ReactNode[]
}

/**
 * Container
 */
export default function Layout({ children, initialized }: Props) {
  return (
    <Container
      display="flex"
      justify="center"
      alignItems="center"
      css={{
        width: '100vw',
        height: '100vh',
        paddingLeft: 0,
        paddingRight: 0
      }}
    >
      <Card
        bordered={{ '@initial': false, '@xs': true }}
        borderWeight={{ '@initial': 'light', '@xs': 'light' }}
        css={{
          height: '100%',
          width: '100%',
          justifyContent: initialized ? 'normal' : 'center',
          alignItems: initialized ? 'normal' : 'center',
          borderRadius: 0,
          paddingBottom: 5,
          '@xs': {
            borderRadius: '$lg',
            height: '95vh',
            maxWidth: '450px'
          }
        }}
      >
        {initialized ? (
          <Fragment>
            <RouteTransition>
              <Card.Body
                css={{
                  display: 'block',
                  paddingLeft: 2,
                  paddingRight: 2,
                  paddingBottom: '40px',
                  '@xs': {
                    padding: '20px',
                    paddingBottom: '40px'
                  }
                }}
              >
                {children}
              </Card.Body>
            </RouteTransition>

            <Card.Footer
              css={{
                height: '85px',
                minHeight: '85px',
                position: 'sticky',
                justifyContent: 'flex-end',
                alignItems: 'flex-end',
                boxShadow: '0 -30px 20px #111111',
                backgroundColor: '#111111',
                zIndex: 200,
                bottom: 0,
                left: 0
              }}
            >
              <Navigation />
            </Card.Footer>
          </Fragment>
        ) : (
          <Loading />
        )}
      </Card>
    </Container>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/Modal.tsx">
import ModalStore from '@/store/ModalStore'
import SessionProposalModal from '@/views/SessionProposalModal'
import SessionSendTransactionModal from '@/views/SessionSendTransactionModal'
import SessionSignCosmosModal from '@/views/SessionSignCosmosModal'
import SessionRequestModal from '@/views/SessionSignModal'
import SessionSignNearModal from '@/views/SessionSignNearModal'
import SessionSignPolkadotModal from '@/views/SessionSignPolkadotModal'
import SessionSignSolanaModal from '@/views/SessionSignSolanaModal'
import SessionSignMultiversxModal from '@/views/SessionSignMultiversxModal'
import SessionSignTronModal from '@/views/SessionSignTronModal'
import SessionSignTezosModal from '@/views/SessionSignTezosModal'
import SessionSignKadenaModal from '@/views/SessionSignKadenaModal'
import SessionSignTypedDataModal from '@/views/SessionSignTypedDataModal'
import SessionUnsuportedMethodModal from '@/views/SessionUnsuportedMethodModal'
import SessionSendCallsModal from '@/views/SessionSendCallsModal'
import SessionCheckoutModal from '@/views/SessionCheckoutModal'
import { Modal as NextModal } from '@nextui-org/react'
import { useSnapshot } from 'valtio'
import { useCallback, useMemo } from 'react'
import LoadingModal from '@/views/LoadingModal'
import SessionAuthenticateModal from '@/views/SessionAuthenticateModal'
import SessionSignBip122Modal from '@/views/SessionSignBip122Modal'
import SessionSendTransactionBip122Modal from '@/views/SessionSendTransactionBip122Modal'
import SessionGrantPermissionsModal from '@/views/SessionGrantPermissionsModal'
import SessionGetBip122AddressesModal from '@/views/SessionGetBip122AddressesModal'

export default function Modal() {
  const { open, view } = useSnapshot(ModalStore.state)
  // handle the modal being closed by click outside
  const onClose = useCallback(() => {
    if (open) {
      ModalStore.close()
    }
  }, [open])

  const componentView = useMemo(() => {
    switch (view) {
      case 'SessionProposalModal':
        return <SessionProposalModal />
      case 'SessionSignModal':
        return <SessionRequestModal />
      case 'SessionSignTypedDataModal':
        return <SessionSignTypedDataModal />
      case 'SessionSendTransactionModal':
        return <SessionSendTransactionModal />
      case 'SessionGrantPermissionsModal':
        return <SessionGrantPermissionsModal />
      case 'SessionSendCallsModal':
        return <SessionSendCallsModal />
      case 'SessionUnsuportedMethodModal':
        return <SessionUnsuportedMethodModal />
      case 'SessionSignCosmosModal':
        return <SessionSignCosmosModal />
      case 'SessionSignSolanaModal':
        return <SessionSignSolanaModal />
      case 'SessionSignPolkadotModal':
        return <SessionSignPolkadotModal />
      case 'SessionSignNearModal':
        return <SessionSignNearModal />
      case 'SessionSignMultiversxModal':
        return <SessionSignMultiversxModal />
      case 'SessionSignTronModal':
        return <SessionSignTronModal />
      case 'SessionSignTezosModal':
        return <SessionSignTezosModal />
      case 'SessionSignKadenaModal':
        return <SessionSignKadenaModal />
      case 'LoadingModal':
        return <LoadingModal />
      case 'SessionAuthenticateModal':
        return <SessionAuthenticateModal />
      case 'SessionSignBip122Modal':
        return <SessionSignBip122Modal />
      case 'SessionGetBip122AddressesModal':
        return <SessionGetBip122AddressesModal />
      case 'SessionSendTransactionBip122Modal':
        return <SessionSendTransactionBip122Modal />
      case 'SessionCheckoutModal':
        return <SessionCheckoutModal />
      default:
        return null
    }
  }, [view])

  return (
    <NextModal
      blur
      onClose={onClose}
      open={open}
      style={{ border: '1px solid rgba(139, 139, 139, 0.4)' }}
    >
      {componentView}
    </NextModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ModalFooter.tsx">
import SettingsStore from '@/store/SettingsStore'
import { Button, Modal, Row, Loading } from '@nextui-org/react'
import { useMemo } from 'react'
import { useSnapshot } from 'valtio'
export interface LoaderProps {
  color?: 'default' | 'primary' | 'secondary' | 'success' | 'warning' | 'error' | 'white'
  active?: boolean
}
interface Props {
  onApprove: () => void
  onReject: () => void
  infoBoxCondition?: boolean
  infoBoxText?: string
  approveLoader?: LoaderProps
  rejectLoader?: LoaderProps
  disableApprove?: boolean
  disableReject?: boolean
}

export default function ModalFooter({
  onApprove,
  approveLoader,
  onReject,
  rejectLoader,
  infoBoxCondition,
  infoBoxText,
  disableApprove,
  disableReject
}: Props) {
  const { currentRequestVerifyContext } = useSnapshot(SettingsStore.state)
  const validation = currentRequestVerifyContext?.verified.validation

  const approveButtonColor: any = useMemo(() => {
    switch (validation) {
      case 'INVALID':
        return 'error'
      case 'UNKNOWN':
        return 'warning'
      default:
        return 'success'
    }
  }, [validation])

  return (
    <Modal.Footer>
      {infoBoxCondition && (
        <Row style={{ textAlign: 'initial' }}>
          <span>{infoBoxText || ''}</span>
        </Row>
      )}
      <Row justify="space-between" align="center">
        <Button
          auto
          flat
          style={{ color: 'white', backgroundColor: 'grey' }}
          onPress={onReject}
          data-testid="session-reject-button"
          disabled={disableReject || rejectLoader?.active}
        >
          {rejectLoader && rejectLoader.active ? (
            <Loading size="md" type="points" color={rejectLoader.color || 'white'} />
          ) : (
            'Reject'
          )}
        </Button>
        <Button
          auto
          flat
          color={approveButtonColor}
          disabled={disableApprove || approveLoader?.active}
          onPress={onApprove}
          data-testid="session-approve-button"
        >
          {approveLoader && approveLoader.active ? (
            <Loading size="md" type="points" color={approveLoader.color || approveButtonColor} />
          ) : (
            'Approve'
          )}
        </Button>
      </Row>
    </Modal.Footer>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ModuleActions.tsx">
import { Fragment, useMemo } from 'react'
import OwnableValidatorActions from '@/views/OwnableValidatorActions'
import { ModuleView } from '@/data/ERC7579ModuleData'
import { Module } from '@rhinestone/module-sdk'

export default function ModuleActions({
  accountAddress,
  chainId,
  view
}: {
  accountAddress: string
  chainId: string
  view?: ModuleView
}) {
  const componentView = useMemo(() => {
    switch (view) {
      case 'OwnableValidatorActions':
        return <OwnableValidatorActions accountAddress={accountAddress} chainId={chainId} />
      default:
        return null
    }
  }, [accountAddress, chainId, view])

  return <Fragment>{componentView}</Fragment>
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/MultibridgeRequestModal.tsx">
import { useCallback, useState } from 'react'
import { Avatar, Col, Divider, Row, Text } from '@nextui-org/react'
import { LoaderProps } from '@/components/ModalFooter'
import RequestMethodCard from '@/components/RequestMethodCard'
import RequestModal from './RequestModal'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { approveEIP155Request } from '@/utils/EIP155RequestHandlerUtil'
import {
  convertTokenBalance,
  decodeErc20Transaction,
  getAssetByContractAddress
} from '@/utils/MultibridgeUtil'
import { getWallet } from '@/utils/EIP155WalletUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import { EIP155_CHAINS, TEIP155Chain } from '@/data/EIP155Data'
import { ChainAbstractionService, Transaction } from '@/utils/ChainAbstractionService'
import { providers } from 'ethers'
import { formatJsonRpcError } from '@json-rpc-tools/utils'

interface IProps {
  onReject: () => void
  transactions?: Transaction[]
  orchestrationId: string
  rejectLoader?: LoaderProps
}

export default function MultibridgeRequestModal({
  transactions,
  orchestrationId,
  onReject,
  rejectLoader
}: IProps) {
  const [isLoadingApprove, setIsLoadingApprove] = useState<boolean>(false)

  const bridgingTransactions = transactions?.slice(0, transactions.length - 1) || []
  const initialTransaction = transactions?.[transactions.length - 1]

  const eip155ChainsFundsSourcedFrom = transactions
    ? new Set(bridgingTransactions.map(transaction => transaction.chainId))
    : new Set<TEIP155Chain>()

  const eip155ChainFundsDestination = initialTransaction?.chainId

  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession

  const topic = requestEvent?.topic
  const params = requestEvent?.params

  const chainId = params?.chainId
  const request = params?.request
  const caService = new ChainAbstractionService()

  const bridgeFunds = useCallback(async (): Promise<void> => {
    if (!bridgingTransactions) {
      throw new Error('bridgingTransactions are unavailable')
    }

    const wallet = await getWallet(params)
    console.log(
      'Bridge funds from',
      eip155ChainsFundsSourcedFrom,
      'to',
      eip155ChainFundsDestination
    )

    for (const transaction of bridgingTransactions) {
      console.log('Bridging transaction', transaction)
      const chainId = transaction.chainId
      const chainProvider = new providers.JsonRpcProvider(
        EIP155_CHAINS[chainId as TEIP155Chain].rpc
      )
      const chainConnectedWallet = await wallet.connect(chainProvider)
      const walletAddress = wallet.getAddress()

      const txResponse = await chainConnectedWallet.sendTransaction({
        from: walletAddress,
        to: transaction.to,
        value: transaction.value,
        data: transaction.data,
        nonce: transaction.nonce,
        gasPrice: transaction.gasPrice,
        gasLimit: transaction.gas
      })
      const txHash = typeof txResponse === 'string' ? txResponse : txResponse?.hash
      const txReceipt = await txResponse.wait()
      const txStatus = txReceipt.status
      console.log(
        `Transaction broadcasted on chain ${chainId} , ${{ txHash }}, status: ${txStatus}`
      )
    }
    await pollOrchestrationStatus(orchestrationId)
  }, [bridgingTransactions, orchestrationId, onReject, params])

  async function pollOrchestrationStatus(
    orchestrationId: string,
    maxAttempts = 100,
    interval = 1500
  ): Promise<void> {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const { status } = await caService.getOrchestrationStatus(orchestrationId)
      console.log(attempt, '- Orchestration status:', status)
      if (status === 'completed') {
        console.log('Bridging completed')
        return
      }
      await new Promise(resolve => setTimeout(resolve, interval))
    }
    console.log('Max attempts reached. Orchestration not completed.')
    throw new Error('Max attempts reached. Orchestration not completed.')
  }

  const onApprove = useCallback(async (): Promise<void> => {
    if (requestEvent && topic) {
      setIsLoadingApprove(true)
      try {
        performance.mark('startInititalTransactionSend')
        await bridgeFunds()
        const response = await approveEIP155Request(requestEvent)
        performance.mark('endInititalTransactionSend')
        console.log(
          `Initial transaction send: ${
            performance.measure(
              'initial-tx-send',
              'startInititalTransactionSend',
              'endInititalTransactionSend'
            ).duration
          } ms`
        )

        await walletkit.respondSessionRequest({ topic, response })
      } catch (e) {
        const { id } = requestEvent
        const errorMessage = (e as Error).message || 'Error bridging funds'
        const response = formatJsonRpcError(id, errorMessage)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
        styledToast((e as Error).message, 'error')
        console.error(e)
      } finally {
        setIsLoadingApprove(false)
      }
      ModalStore.close()
    }
  }, [bridgeFunds, requestEvent, topic])

  if (!request || !requestSession || !bridgingTransactions || bridgingTransactions.length === 0) {
    return <Text>Request not found</Text>
  }

  const transfer = decodeErc20Transaction(request.params[0])
  if (!transfer) {
    return <Text>Invalid transfer request</Text>
  }

  const asset = getAssetByContractAddress(transfer.contract)
  const amount = convertTokenBalance(asset, transfer.amount)
  const destination = transfer.to
  const sourceChain = EIP155_CHAINS[Array.from(eip155ChainsFundsSourcedFrom)[0] as TEIP155Chain]
  const targetChain = EIP155_CHAINS[eip155ChainFundsDestination as TEIP155Chain]

  return (
    <RequestModal
      intention="Multibridge"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={rejectLoader}
      disableThreatDetection={true}
    >
      <Row>
        <Col>
          <Text h5>Transaction details</Text>
          <Text
            color=""
            data-testid="request-details-chain"
            css={{ paddingTop: '$6', paddingBottom: '$6' }}
          >
            Sending {amount} {asset} to:
          </Text>
          <Text color="$gray400" data-testid="request-details-chain" size="sm">
            {destination}
          </Text>
        </Col>
      </Row>
      <Divider y={1} />
      <Row>
        <Col>
          <Text h5>Chain details</Text>
          <Text color="">Target chain:</Text>
          <Row align="center" css={{ marginTop: '$6' }}>
            <Col>
              <Avatar src={targetChain.logo} />
            </Col>
            <Col>{targetChain.name}</Col>
          </Row>

          <Text color="">Sourcing funds from:</Text>
          <Row align="center" css={{ marginTop: '$6' }}>
            <Col>
              <Avatar src={sourceChain.logo} />
            </Col>
            <Col>{sourceChain.name}</Col>
          </Row>
        </Col>
      </Row>
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/Navigation.tsx">
import { Avatar, Row } from '@nextui-org/react'
import Image from 'next/image'
import Link from 'next/link'

export default function Navigation() {
  return (
    <Row justify="space-between" align="center">
      <Link href="/" passHref>
        <a className="navLink" data-testid="accounts">
          <Image alt="accounts icon" src="/icons/accounts-icon.svg" width={27} height={27} />
        </a>
      </Link>

      <Link href="/sessions" passHref>
        <a className="navLink" data-testid="sessions">
          <Image alt="sessions icon" src="/icons/sessions-icon.svg" width={27} height={27} />
        </a>
      </Link>

      <Link href="/walletconnect" passHref>
        <a className="navLink" data-testid="wc-connect">
          <Avatar
            size="lg"
            css={{ cursor: 'pointer' }}
            color="gradient"
            icon={
              <Image
                alt="wallet connect icon"
                src="/wallet-connect-logo.svg"
                width={30}
                height={30}
              />
            }
          />
        </a>
      </Link>

      <Link href="/pairings" passHref>
        <a className="navLink" data-testid="pairings">
          <Image alt="pairings icon" src="/icons/pairings-icon.svg" width={25} height={25} />
        </a>
      </Link>

      <Link href="/settings" passHref>
        <a className="navLink" data-testid="settings">
          <Image alt="settings icon" src="/icons/settings-icon.svg" width={27} height={27} />
        </a>
      </Link>
    </Row>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/OrderInfoCard.tsx">
import { DetailedPaymentOption } from '@/types/wallet_checkout'
import { Avatar, Col, Link, Row, styled, StyledLink, Text } from '@nextui-org/react'
import { useEffect, useState } from 'react'
import { CoreTypes } from '@walletconnect/types'
import OrderDetailIcon from './PaymentCheckout/visual/OrderDetailIcon'
import WalletCheckoutUtil from '@/utils/WalletCheckoutUtil'
import { formatUnits } from 'viem'
import { useSnapshot } from 'valtio'
import SettingsStore from '@/store/SettingsStore'
import BadgeCheckIcon from './PaymentCheckout/visual/BadgeCheckIcon'
import BadgeAlertIcon from './PaymentCheckout/visual/BadgeAlertIcon'

/**
 * Types
 */
interface IProps {
  selectedPayment: DetailedPaymentOption | null
  orderId: string
  metadata: CoreTypes.Metadata
  expiry?: number
}

/**
 * Helper function to calculate time remaining for countdown
 */
const calculateTimeRemaining = (expiryTimestamp?: number) => {
  if (!expiryTimestamp) return null

  const expiryTime = expiryTimestamp * 1000 // Convert to milliseconds
  const now = Date.now()

  // Check if already expired
  if (now >= expiryTime) {
    return { hours: 0, minutes: 0, seconds: 0, isExpired: true }
  }

  // Calculate remaining time
  const timeRemaining = expiryTime - now

  const hours = Math.floor(timeRemaining / (1000 * 60 * 60))
  const minutes = Math.floor((timeRemaining % (1000 * 60 * 60)) / (1000 * 60))
  const seconds = Math.floor((timeRemaining % (1000 * 60)) / 1000)

  return { hours, minutes, seconds, isExpired: false }
}

export default function OrderInfoCard({ orderId, expiry, selectedPayment, metadata }: IProps) {
  const styles = {
    iconWrapper: {
      width: '40px',
      height: '40px',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    },
    circleIconBg: {
      display: 'flex',
      backgroundColor: '#333',
      height: '32px',
      width: '32px',
      borderRadius: '50%',
      alignItems: 'center',
      justifyContent: 'center'
    }
  }
  const [timeRemaining, setTimeRemaining] = useState(calculateTimeRemaining(expiry))
  const { currentRequestVerifyContext } = useSnapshot(SettingsStore.state)
  const validation = currentRequestVerifyContext?.verified.validation
  const { icons, name, url } = metadata
  const isVerified = validation == 'VALID'
  // Update countdown every second
  useEffect(() => {
    if (!expiry) return

    const interval = setInterval(() => {
      setTimeRemaining(calculateTimeRemaining(expiry))
    }, 1000)

    // Clean up on unmount
    return () => clearInterval(interval)
  }, [expiry])

  // Format the countdown display
  const formatCountdown = () => {
    if (!timeRemaining) return 'No expiry set'
    if (timeRemaining.isExpired) return 'Expired'

    const { hours, minutes, seconds } = timeRemaining

    // Create a readable time format
    const parts = []

    if (hours > 0) {
      parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`)
    }

    if (minutes > 0 || hours > 0) {
      parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`)
    }

    // Always show seconds if less than 1 hour remains
    if (seconds > 0 || parts.length === 0) {
      parts.push(`${seconds} ${seconds === 1 ? 'second' : 'seconds'}`)
    }

    // If we're under 1 minute, just show seconds
    if (hours === 0 && minutes === 0) {
      return parts.join(' ')
    }

    // If we're under 1 hour, show minutes and seconds
    if (hours === 0) {
      return parts.join(' ')
    }

    // If more than 1 hour, show hours and minutes
    return parts.join(' ')
  }

  return (
    <Col css={{ display: 'flex', flexDirection: 'column', gap: '12px', marginTop: '12px' }}>
      <div style={styles.iconWrapper}>
        <div style={styles.circleIconBg}>
          <OrderDetailIcon />
        </div>
      </div>
      <Col css={{ display: 'flex', flexDirection: 'column', gap: '12px', paddingLeft: '4px' }}>
      <Row align="center" justify="space-between">
        <Text color="$gray400">Merchant</Text>
        <Text css={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
          {isVerified ? (
            <BadgeCheckIcon color="green" size={16} />
          ) : (
            <BadgeAlertIcon color="#F5A623" size={16} />
          )}
          {name || 'Unknown'}
        </Text>
      </Row>
      
        {selectedPayment && selectedPayment.recipient && (
          <Row align="center" justify="space-between">
            <Text color="$gray400">Address</Text>
            <Text>{WalletCheckoutUtil.formatRecipient(selectedPayment.recipient)}</Text>
          </Row>
        )}
        {selectedPayment && selectedPayment.fee && (
          <Row align="center" justify="space-between">
            <Text color="$gray400">Estimated Gas Fee</Text>
            <Text>
              ~
              {Number(
                formatUnits(BigInt(selectedPayment.fee.gasFee), selectedPayment.fee.decimals)
              ).toFixed(6)}{' '}
              {selectedPayment.fee.feeSymbol}
            </Text>
          </Row>
        )}
        <Row align="center" justify="space-between">
          <Text color="$gray400">Order ID</Text>
          <Text size={'small'}>{orderId}</Text>
        </Row>
        {timeRemaining ? (
          <Row align="center" justify="space-between">
            <Text color={timeRemaining.isExpired ? '$error' : '$gray400'}>
              {timeRemaining.isExpired ? 'Expired' : 'Expires in: '}
            </Text>
            {!timeRemaining.isExpired && (
              <Text
                css={{
                  fontWeight: 'bold',
                  padding: '2px 0',
                  color: timeRemaining.hours < 1 ? '$warning' : '$gray800'
                }}
                size={'small'}
              >
                {formatCountdown()}
              </Text>
            )}
          </Row>
        ) : (
          <Text color="$gray400" size={'small'}>
            No expiry set
          </Text>
        )}
      </Col>
    </Col>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PageHeader.tsx">
import { Col, Divider, Row, Text } from '@nextui-org/react'
import { Fragment, ReactNode } from 'react'

/**
 * Types
 */
interface Props {
  children?: ReactNode | ReactNode[]
  title: string
}

/**
 * Component
 */
export default function PageHeader({ title, children }: Props) {
  return (
    <Fragment>
      <Row css={{ marginBottom: '$5', width: '100%' }} justify="space-between" align="center">
        <Col>
          <Text
            h3
            weight="bold"
            css={{
              textGradient: '90deg, $secondary, $primary 30%'
            }}
          >
            {title}
          </Text>
        </Col>
        {children ? <Col css={{ flex: 1 }}>{children}</Col> : null}
      </Row>

      <Divider css={{ marginBottom: '$10' }} />
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PairingCard.tsx">
import { truncate } from '@/utils/HelperUtil'
import { Avatar, Button, Card, Link, Text, Tooltip } from '@nextui-org/react'
import Image from 'next/image'

/**
 * Types
 */
interface IProps {
  logo?: string
  name?: string
  url?: string
  topic?: string
  onDelete: () => Promise<void>
}

/**
 * Component
 */
export default function PairingCard({ logo, name, url, topic, onDelete }: IProps) {
  return (
    <Card
      bordered
      borderWeight="light"
      css={{
        position: 'relative',
        marginBottom: '$6',
        minHeight: '70px'
      }}
    >
      <Card.Body
        css={{
          flexDirection: 'row',
          alignItems: 'center',
          justifyContent: 'space-between',
          overflow: 'hidden'
        }}
      >
        <Avatar src={logo} />
        <div style={{ flex: 1 }}>
          <Text h5 css={{ marginLeft: '$9' }} data-testid={'pairing-text-' + topic}>
            {name}
          </Text>
          <Link href={url} css={{ marginLeft: '$9' }}>
            <a data-testid={'pairing-text-' + topic}>
              {truncate(url?.split('https://')[1] ?? 'Unknown', 23)}
            </a>
          </Link>
        </div>
        <Tooltip content="Delete" placement="left">
          <Button
            size="sm"
            color="error"
            flat
            onClick={onDelete}
            css={{ minWidth: 'auto' }}
            data-testid={'pairing-delete-' + topic}
          >
            <Image src={'/icons/delete-icon.svg'} width={15} height={15} alt="delete icon" />
          </Button>
        </Tooltip>
      </Card.Body>
    </Card>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PaymentOptions.tsx">
import { useState, useEffect, useRef, useCallback } from 'react'
import { Text, Row, Container, Col, Card, Divider, Spacer } from '@nextui-org/react'
import { DetailedPaymentOption } from '@/types/wallet_checkout'
import TokenDropdown from './PaymentCheckout/TokenDropdown'
import NetworkDropdown from './PaymentCheckout/NetworkDropdown'
import SelectedPaymentDetails from './PaymentCheckout/SelectedPaymentDetails'

interface PayWithProps {
  payments: DetailedPaymentOption[]
  onSelectPayment?: (payment: DetailedPaymentOption) => void
}

// Define types for the enhanced token and network data
interface TokenWithNetworks {
  assetSymbol: string
  assetIcon: string
  assetName: string
  assetDecimals: number
  assetNamespace: string
  networks: string[]
}

interface NetworkWithTokens {
  chainId: string
  chainName: string
  chainNamespace: string
  chainIcon: string
  tokens: string[]
}

// Modified to extract tokens with network info
const extractTokensWithNetworks = (payments: DetailedPaymentOption[]): TokenWithNetworks[] => {
  const tokenMap = new Map()

  payments.forEach(payment => {
    const tokenKey = payment.assetMetadata.assetSymbol
    if (!tokenMap.has(tokenKey)) {
      tokenMap.set(tokenKey, {
        assetSymbol: payment.assetMetadata.assetSymbol,
        assetIcon: payment.assetMetadata.assetIcon,
        assetName: payment.assetMetadata.assetName,
        assetDecimals: payment.assetMetadata.assetDecimals,
        assetNamespace: payment.assetMetadata.assetNamespace,
        networks: new Set([payment.chainMetadata.chainId])
      })
    } else {
      // Add network to existing token's networks
      tokenMap.get(tokenKey).networks.add(payment.chainMetadata.chainId)
    }
  })

  // Convert sets to arrays for easier handling
  return Array.from(tokenMap.values()).map(token => ({
    ...token,
    networks: Array.from(token.networks)
  }))
}

// Modified to extract networks with token info
const extractNetworksWithTokens = (payments: DetailedPaymentOption[]): NetworkWithTokens[] => {
  const networkMap = new Map()

  payments.forEach(payment => {
    const networkKey = payment.chainMetadata.chainId
    if (!networkMap.has(networkKey)) {
      networkMap.set(networkKey, {
        chainId: payment.chainMetadata.chainId,
        chainName: payment.chainMetadata.chainName,
        chainNamespace: payment.chainMetadata.chainNamespace,
        chainIcon: payment.chainMetadata.chainIcon,
        tokens: new Set([payment.assetMetadata.assetSymbol])
      })
    } else {
      // Add token to existing network's tokens
      networkMap.get(networkKey).tokens.add(payment.assetMetadata.assetSymbol)
    }
  })

  // Convert sets to arrays for easier handling
  return Array.from(networkMap.values()).map(network => ({
    ...network,
    tokens: Array.from(network.tokens)
  }))
}

// Get filtered tokens based on selected network
const getFilteredTokens = (
  tokensWithNetworks: TokenWithNetworks[],
  selectedNetworkId?: string
): TokenWithNetworks[] => {
  if (!selectedNetworkId) return tokensWithNetworks
  return tokensWithNetworks.filter(token => token.networks.includes(selectedNetworkId))
}

// Get filtered networks based on selected token
const getFilteredNetworks = (
  networksWithTokens: NetworkWithTokens[],
  selectedTokenSymbol?: string
): NetworkWithTokens[] => {
  if (!selectedTokenSymbol) return networksWithTokens
  return networksWithTokens.filter(network => network.tokens.includes(selectedTokenSymbol))
}

export default function PayWith({ payments, onSelectPayment }: PayWithProps) {
  const allTokensWithNetworks = extractTokensWithNetworks(payments)
  const allNetworksWithTokens = extractNetworksWithTokens(payments)

  const initializedRef = useRef(false)

  const [selectedTokenIndex, setSelectedTokenIndex] = useState<number>(0)
  const [selectedNetworkIndex, setSelectedNetworkIndex] = useState<number>(0)

  const [selectedToken, setSelectedToken] = useState<TokenWithNetworks | null>(
    allTokensWithNetworks.length > 0 ? allTokensWithNetworks[0] : null
  )
  const [selectedNetwork, setSelectedNetwork] = useState<NetworkWithTokens | null>(
    allNetworksWithTokens.length > 0 ? allNetworksWithTokens[0] : null
  )

  const [filteredTokens, setFilteredTokens] = useState<TokenWithNetworks[]>(allTokensWithNetworks)
  const [filteredNetworks, setFilteredNetworks] =
    useState<NetworkWithTokens[]>(allNetworksWithTokens)

  const [lastChanged, setLastChanged] = useState<'token' | 'network' | null>(null)

  const [selectedPayment, setSelectedPayment] = useState<DetailedPaymentOption | null>(null)

  const getFilteredTokensForNetwork = useCallback(
    (networkId: string | undefined) => {
      return getFilteredTokens(allTokensWithNetworks, networkId)
    },
    [allTokensWithNetworks]
  )

  const getFilteredNetworksForToken = useCallback(
    (tokenSymbol: string | undefined) => {
      return getFilteredNetworks(allNetworksWithTokens, tokenSymbol)
    },
    [allNetworksWithTokens]
  )

  useEffect(() => {
    if (lastChanged === 'network' && selectedNetwork) {
      const newFilteredTokens = getFilteredTokensForNetwork(selectedNetwork.chainId)

      // Only update if the filtered tokens actually changed
      if (JSON.stringify(newFilteredTokens) !== JSON.stringify(filteredTokens)) {
        setFilteredTokens(newFilteredTokens)

        // If current token is not available in this network, select the first available
        if (newFilteredTokens.length > 0) {
          const currentTokenIsValid =
            selectedToken &&
            newFilteredTokens.some(t => t.assetSymbol === selectedToken.assetSymbol)

          if (!currentTokenIsValid) {
            setSelectedToken(newFilteredTokens[0])
            setSelectedTokenIndex(0)
          } else if (selectedToken) {
            // Update the token index to match the new filtered list
            const newIndex = newFilteredTokens.findIndex(
              t => t.assetSymbol === selectedToken.assetSymbol
            )
            if (newIndex !== -1 && newIndex !== selectedTokenIndex) {
              setSelectedTokenIndex(newIndex)
            }
          }
        }
      }
    }
  }, [
    selectedNetwork,
    lastChanged,
    selectedToken,
    getFilteredTokensForNetwork,
    filteredTokens,
    selectedTokenIndex
  ])

  useEffect(() => {
    if (lastChanged === 'token' && selectedToken) {
      const newFilteredNetworks = getFilteredNetworksForToken(selectedToken.assetSymbol)

      // Only update if the filtered networks actually changed
      if (JSON.stringify(newFilteredNetworks) !== JSON.stringify(filteredNetworks)) {
        setFilteredNetworks(newFilteredNetworks)

        // If current network is not available for this token, select the first available
        if (newFilteredNetworks.length > 0) {
          const currentNetworkIsValid =
            selectedNetwork && newFilteredNetworks.some(n => n.chainId === selectedNetwork.chainId)

          if (!currentNetworkIsValid) {
            setSelectedNetwork(newFilteredNetworks[0])
            setSelectedNetworkIndex(0)
          } else if (selectedNetwork) {
            // Update the network index to match the new filtered list
            const newIndex = newFilteredNetworks.findIndex(
              n => n.chainId === selectedNetwork.chainId
            )
            if (newIndex !== -1 && newIndex !== selectedNetworkIndex) {
              setSelectedNetworkIndex(newIndex)
            }
          }
        }
      }
    }
  }, [
    selectedToken,
    lastChanged,
    selectedNetwork,
    getFilteredNetworksForToken,
    filteredNetworks,
    selectedNetworkIndex
  ])

  const handleSelectToken = (index: number) => {
    setSelectedTokenIndex(index)
    setSelectedToken(filteredTokens[index])
    setLastChanged('token')
  }

  const handleSelectNetwork = (index: number) => {
    setSelectedNetworkIndex(index)
    setSelectedNetwork(filteredNetworks[index])
    setLastChanged('network')
  }

  useEffect(() => {
    if (selectedToken && selectedNetwork && onSelectPayment) {
      const payment = payments.find(
        payment =>
          payment.assetMetadata.assetSymbol === selectedToken.assetSymbol &&
          payment.chainMetadata.chainId === selectedNetwork.chainId
      )

      if (payment) {
        setSelectedPayment(payment)
        onSelectPayment(payment)
      }
    }
  }, [selectedToken, selectedNetwork, onSelectPayment, payments])

  useEffect(() => {
    if (
      !initializedRef.current &&
      allTokensWithNetworks.length > 0 &&
      allNetworksWithTokens.length > 0
    ) {
      initializedRef.current = true

      const initialToken = allTokensWithNetworks[0]
      const initialNetwork = allNetworksWithTokens[0]

      setSelectedToken(initialToken)
      setSelectedNetwork(initialNetwork)
      setFilteredTokens(allTokensWithNetworks)
      setFilteredNetworks(allNetworksWithTokens)

      if (payments.length > 0) {
        const initialPayment = payments.find(
          payment =>
            payment.assetMetadata.assetSymbol === initialToken.assetSymbol &&
            payment.chainMetadata.chainId === initialNetwork.chainId
        )

        if (initialPayment) {
          setSelectedPayment(initialPayment)
          if (onSelectPayment) {
            onSelectPayment(initialPayment)
          }
        } else if (payments[0]) {
          setSelectedPayment(payments[0])
          if (onSelectPayment) {
            onSelectPayment(payments[0])
          }
        }
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  return (
    <>
      <Container css={{ borderRadius: '32px', padding: '16px', backgroundColor: 'var(--nextui-colors-accents1)' }}>
        <Col css={{ marginBottom: '16px' }}>
          <Text css={{ color: '$text', fontWeight: '600', fontSize: '14px', marginBottom: '8px' }}>
            Pay with
          </Text>
          <Row justify="space-between" align="center" css={{ width: '100%' }}>
            <TokenDropdown
              allTokens={allTokensWithNetworks}
              filteredTokens={filteredTokens}
              selectedTokenIndex={selectedTokenIndex}
              onSelectToken={handleSelectToken}
            />
          </Row>
        </Col>
        <Col>
          <Text css={{ color: '$text', fontWeight: '600', fontSize: '14px', marginBottom: '8px' }}>
            Network
          </Text>
          <Row justify="space-between" align="center" css={{ width: '100%' }}>
            <NetworkDropdown
              allNetworks={allNetworksWithTokens}
              filteredNetworks={filteredNetworks}
              selectedNetworkIndex={selectedNetworkIndex}
              onSelectNetwork={handleSelectNetwork}
            />
          </Row>
        </Col>

        <Spacer y={1} />

        {/* Display Selected Payment Option Details */}
        <SelectedPaymentDetails selectedPayment={selectedPayment} />
      </Container>
    </>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/PermissionDetailsCard.tsx">
import { Col, Row, Text } from '@nextui-org/react'

type PermissionAction = {
  description: string
}

interface IProps {
  scope: PermissionAction[]
}

export default function PermissionDetailsCard({ scope }: IProps) {
  return (
    <Row>
      <Col>
        <Text h5>Dapp is requesting following permissions</Text>
        {scope.map((action, index) => {
          return (
            <Text color="$gray400" key={index}>
              {action.description}
            </Text>
          )
        })}
      </Col>
    </Row>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/Products.tsx">
import { Fragment } from 'react'
import { Card, Col, Row, Image, Text } from '@nextui-org/react'

interface ProductMetadata {
  name: string
  description?: string
  imageUrl?: string
  price?: string
}

interface ProductCardProps {
  product: ProductMetadata
}

function ProductCard({ product }: ProductCardProps) {
  return (
    <Card style={{ marginBottom: '16px', backgroundColor: '#2A2A2A' }}>
      <Card.Body style={{ padding: '8px' }}>
        <Row style={{ alignItems: 'center', height: '72px' }}>
          {product.imageUrl && (
            <Col style={{ width: 'auto' }}>
              <Image
                src={product.imageUrl}
                alt={product.name}
                width={64}
                height={64}
                objectFit="cover"
              />
            </Col>
          )}
          <Col style={{ paddingLeft: product.imageUrl ? '16px' : 0 }}>
            <Text style={{ fontSize: '18px' }}>{product.name}</Text>
            <Row justify="space-between">
              {product.price && (
                <Row>
                  <Text b style={{ color: '#8c8c8c', fontSize: '14px' }}>
                    {'Price '}
                  </Text>
                  <span style={{ fontSize: '14px' }}>{product.price}</span>
                </Row>
              )}
            </Row>
          </Col>
        </Row>
      </Card.Body>
    </Card>
  )
}

interface ProductsProps {
  products?: ProductMetadata[]
}

export default function Products({ products }: ProductsProps) {
  if (!products || products.length === 0) {
    return null
  }

  return (
    <Fragment>
      {products.map((product, idx) => (
        <ProductCard key={idx} product={product} />
      ))}
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ProjectInfoCard.tsx">
import { useMemo } from 'react'
import { useSnapshot } from 'valtio'
import SettingsStore from '@/store/SettingsStore'
import ReportIcon from '@mui/icons-material/Report'
import ReportProblemIcon from '@mui/icons-material/ReportProblem'
import NewReleasesIcon from '@mui/icons-material/NewReleases'
import { Avatar, Col, Link, Row, Text, styled } from '@nextui-org/react'
import { SignClientTypes } from '@walletconnect/types'

/**
 * Types
 */
interface IProps {
  metadata: SignClientTypes.Metadata
  intention?: string
}

const StyledLink = styled('span', {
  color: '#697177'
} as any)

const StyledVerifiedIcon = styled('img', {
  verticalAlign: 'middle',
  marginRight: '5px'
} as any)

const StyledUnknownRow = styled(Row, {
  color: '$warning'
  // marginTop: '10px'
} as any)

const StyledUnknownContainer = styled('div', {
  padding: '7px'
} as any)

const StyledInvalidRow = styled(Row, {
  color: '$error'
  // marginTop: '10px'
} as any)

const StyledInvalidContainer = styled('div', {
  padding: '7px'
} as any)

/**
 * Components
 */
export default function ProjectInfoCard({ metadata, intention }: IProps) {
  const { currentRequestVerifyContext } = useSnapshot(SettingsStore.state)
  const validation = currentRequestVerifyContext?.verified.validation
  const { icons, name, url } = metadata

  return (
    <div style={{ textAlign: 'center' }}>
      <Row>
        <Col>
          <Avatar style={{ margin: 'auto' }} src={icons[0]} size={'xl'} />
        </Col>
      </Row>
      <Row align="center">
        <Col>
          <Text h3 data-testid="session-info-card-text">
            <span>{name}</span> <br />
            <Text h4> wants to {intention ? intention : 'connect'}</Text>
          </Text>
        </Col>
      </Row>
      <Row align="center">
        <Col>
          {validation == 'VALID' ? (
            <StyledVerifiedIcon
              src="/icons/verified-domain.svg"
              data-testid="session-info-verified"
            />
          ) : null}
          <Link style={{ verticalAlign: 'middle' }} href={url} data-testid="session-info-card-url">
            <StyledLink>{url}</StyledLink>
          </Link>
        </Col>
      </Row>
      {currentRequestVerifyContext?.verified.isScam ? (
        <StyledInvalidRow>
          <Col style={{ margin: 'auto' }}>
            <StyledInvalidContainer>
              <NewReleasesIcon style={{ verticalAlign: 'bottom' }} />
              Potential threat
            </StyledInvalidContainer>
          </Col>
        </StyledInvalidRow>
      ) : validation == 'UNKNOWN' ? (
        <StyledUnknownRow>
          <Col style={{ margin: 'auto' }}>
            <StyledUnknownContainer>
              <ReportIcon style={{ verticalAlign: 'bottom' }} />
              Cannot Verify
            </StyledUnknownContainer>
          </Col>
        </StyledUnknownRow>
      ) : validation == 'INVALID' ? (
        <StyledInvalidRow>
          <Col style={{ margin: 'auto' }}>
            <StyledInvalidContainer>
              <ReportProblemIcon style={{ verticalAlign: 'bottom', marginRight: '2px' }} />
              Invalid Domain
            </StyledInvalidContainer>
          </Col>
        </StyledInvalidRow>
      ) : null}
    </div>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/ProposalSelectSection.tsx">
import AccountSelectCard from '@/components/AccountSelectCard'
import { Col, Row, Text } from '@nextui-org/react'

/**
 * Types
 */
interface IProps {
  chain: string
  addresses: string[]
  selectedAddresses: string[] | undefined
  onSelect: (chain: string, address: string) => void
  isRequired: boolean
}

/**
 * Component
 */
export default function ProposalSelectSection({
  addresses,
  selectedAddresses,
  chain,
  onSelect,
  isRequired
}: IProps) {
  return (
    <Row>
      <Col>
        <Text h4 css={{ marginTop: '$5' }}>{`Choose ${chain} accounts`}</Text>
        {addresses.map((address, index) => (
          <AccountSelectCard
            key={address}
            address={address}
            index={index}
            onSelect={() => onSelect(chain, address)}
            selected={selectedAddresses?.includes(address) ?? false}
            isRequired={isRequired}
          />
        ))}
      </Col>
    </Row>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/QrReader.tsx">
import { Button, Loading } from '@nextui-org/react'
import dynamic from 'next/dynamic'
import Image from 'next/image'
import { Fragment, useState } from 'react'

/**
 * You can use normal import if you are not within next / ssr environment
 * @info https://nextjs.org/docs/advanced-features/dynamic-import
 */
const ReactQrReader = dynamic(() => import('react-qr-reader-es6'), { ssr: false })

/**
 * Types
 */
interface IProps {
  onConnect: (uri: string) => Promise<void>
}

/**
 * Component
 */
export default function QrReader({ onConnect }: IProps) {
  const [show, setShow] = useState(false)
  const [loading, setLoading] = useState(false)

  function onError() {
    setShow(false)
  }

  async function onScan(data: string | null) {
    if (data) {
      await onConnect(data)
      setShow(false)
    }
  }

  function onShowScanner() {
    setLoading(true)
    setShow(true)
  }

  return (
    <div className="container">
      {show ? (
        <Fragment>
          {loading && <Loading css={{ position: 'absolute' }} />}
          <div className="qrVideoMask">
            <ReactQrReader
              onLoad={() => setLoading(false)}
              showViewFinder={false}
              onError={onError}
              onScan={onScan}
              style={{ width: '100%' }}
            />
          </div>
        </Fragment>
      ) : (
        <div className="container qrPlaceholder">
          <Image
            src="/icons/qr-icon.svg"
            width={100}
            height={100}
            alt="qr code icon"
            className="qrIcon"
          />
          <Button
            color="gradient"
            css={{ marginTop: '$10', width: '100%' }}
            onClick={onShowScanner}
            data-testid="qrcode-button"
          >
            Scan QR code
          </Button>
        </div>
      )}
    </div>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/RelayRegionPicker.tsx">
import { REGIONALIZED_RELAYER_ENDPOINTS } from '@/data/RelayerRegions'
import SettingsStore from '@/store/SettingsStore'
import { useSnapshot } from 'valtio'

export default function AccountPicker() {
  const { relayerRegionURL } = useSnapshot(SettingsStore.state)

  function onSelect(value: string) {
    SettingsStore.setRelayerRegionURL(value)
  }

  return (
    <select
      value={relayerRegionURL}
      onChange={e => onSelect(e.currentTarget.value)}
      aria-label="relayerRegions"
      data-testid="setting-region-select"
    >
      {REGIONALIZED_RELAYER_ENDPOINTS.map((endpoint, index) => {
        return (
          <option key={index} value={endpoint.value}>
            {endpoint.label}
          </option>
        )
      })}
    </select>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/RequestDataCard.tsx">
import { Col, Row, Text } from '@nextui-org/react'
import { CodeBlock, codepen } from 'react-code-blocks'

/**
 * Types
 */
interface IProps {
  data: Record<string, unknown>
}

/**
 * Component
 */
export default function RequestDataCard({ data }: IProps) {
  return (
    <Row>
      <Col>
        <Text h5>Data</Text>
        <CodeBlock
          showLineNumbers={false}
          text={JSON.stringify(data, null, 2)}
          theme={codepen}
          language="json"
        />
      </Col>
    </Row>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/RequestDetalilsCard.tsx">
import { COSMOS_MAINNET_CHAINS, TCosmosChain } from '@/data/COSMOSData'
import { EIP155_CHAINS, TEIP155Chain } from '@/data/EIP155Data'
import { KADENA_CHAINS, TKadenaChain } from '@/data/KadenaData'
import { NEAR_TEST_CHAINS, TNearChain } from '@/data/NEARData'
import { SOLANA_CHAINS, TSolanaChain } from '@/data/SolanaData'
import { MULTIVERSX_CHAINS, TMultiversxChain } from '@/data/MultiversxData'
import { TRON_CHAINS, TTronChain } from '@/data/TronData'
import { Col, Divider, Row, Text } from '@nextui-org/react'
import { Fragment } from 'react'

/**
 * Types
 */
interface IProps {
  chains: string[]
  protocol: string
}

/**
 * Component
 */
export default function RequestDetailsCard({ chains, protocol }: IProps) {
  return (
    <Fragment>
      <Row>
        <Col>
          <Text h5>Blockchain(s)</Text>
          <Text color="$gray400" data-testid="request-details-chain">
            {chains
              .map(
                chain =>
                  EIP155_CHAINS[chain as TEIP155Chain]?.name ??
                  COSMOS_MAINNET_CHAINS[chain as TCosmosChain]?.name ??
                  SOLANA_CHAINS[chain as TSolanaChain]?.name ??
                  NEAR_TEST_CHAINS[chain as TNearChain]?.name ??
                  MULTIVERSX_CHAINS[chain as TMultiversxChain]?.name ??
                  TRON_CHAINS[chain as TTronChain]?.name ??
                  KADENA_CHAINS[chain as TKadenaChain]?.name ??
                  chain
              )
              .join(', ')}
          </Text>
        </Col>
      </Row>

      <Divider y={2} />

      <Row>
        <Col>
          <Text h5>Relay Protocol</Text>
          <Text color="$gray400" data-testid="request-detauls-realy-protocol">
            {protocol}
          </Text>
        </Col>
      </Row>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/RequestMethodCard.tsx">
import { Col, Row, Text } from '@nextui-org/react'

/**
 * Types
 */
interface IProps {
  methods: string[]
}

/**
 * Component
 */
export default function RequestMethodCard({ methods }: IProps) {
  return (
    <Row>
      <Col>
        <Text h5>Methods</Text>
        <Text color="$gray400" data-testid="request-methods">
          {methods.map(method => method).join(', ')}
        </Text>
      </Col>
    </Row>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/RequestModal.tsx">
import { Fragment, ReactNode, useEffect, useMemo, useState } from 'react'
import { Divider } from '@nextui-org/react'
import { CoreTypes } from '@walletconnect/types'
import ModalFooter, { LoaderProps } from '@/components/ModalFooter'
import ProjectInfoCard from '@/components/ProjectInfoCard'
import RequestModalContainer from '@/components/RequestModalContainer'
import VerifyInfobox from '@/components/VerifyInfobox'
import { useSnapshot } from 'valtio'
import SettingsStore from '@/store/SettingsStore'
import ThreatPrompt from '../views/TheatPrompt'

interface IProps {
  children: ReactNode
  metadata: CoreTypes.Metadata
  onApprove: () => void
  onReject: () => void
  intention?: string
  infoBoxCondition?: boolean
  infoBoxText?: string
  approveLoader?: LoaderProps
  rejectLoader?: LoaderProps
  disableApprove?: boolean
  disableReject?: boolean
  disableThreatDetection?: boolean
}
export default function RequestModal({
  children,
  metadata,
  onApprove,
  onReject,
  approveLoader,
  rejectLoader,
  intention,
  infoBoxCondition,
  infoBoxText,
  disableApprove,
  disableReject,
  disableThreatDetection
}: IProps) {
  const { currentRequestVerifyContext } = useSnapshot(SettingsStore.state)
  const isScam = currentRequestVerifyContext?.verified.isScam
  const [threatAcknowledged, setThreatAcknowledged] = useState(false)

  const threatPromptContent = useMemo(() => {
    return (
      <ThreatPrompt
        metadata={metadata}
        onApprove={() => setThreatAcknowledged(true)}
        onReject={onReject}
      />
    )
  }, [metadata, onReject])

  const modalContent = useMemo(() => {
    return (
      <>
        <RequestModalContainer title="">
          <ProjectInfoCard metadata={metadata} intention={intention} />
          <Divider y={1} />
          {children}
          <Divider y={1} />
          {disableThreatDetection === undefined ? <VerifyInfobox metadata={metadata} /> : null}
        </RequestModalContainer>
        <ModalFooter
          onApprove={onApprove}
          onReject={onReject}
          approveLoader={approveLoader}
          rejectLoader={rejectLoader}
          infoBoxCondition={infoBoxCondition}
          infoBoxText={infoBoxText}
          disableApprove={disableApprove}
          disableReject={disableReject}
        />
      </>
    )
  }, [
    approveLoader,
    children,
    infoBoxCondition,
    infoBoxText,
    intention,
    metadata,
    onApprove,
    onReject,
    rejectLoader,
    disableApprove,
    disableReject
  ])
  return <Fragment>{isScam && !threatAcknowledged ? threatPromptContent : modalContent}</Fragment>
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/RequestModalContainer.tsx">
import { Container, Modal, Text } from '@nextui-org/react'
import { Fragment, ReactNode } from 'react'

/**
 * Types
 */
interface IProps {
  title?: string
  children: ReactNode | ReactNode[]
}

/**
 * Component
 */
export default function RequestModalContainer({ children, title }: IProps) {
  return (
    <Fragment>
      {title ? (
        <Modal.Header>
          <Text h3>{title}</Text>
        </Modal.Header>
      ) : null}
      <Modal.Body>
        <Container css={{ padding: 0 }}>{children}</Container>
      </Modal.Body>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/RouteTransition.tsx">
import { AnimatePresence, motion } from 'framer-motion'
import { useRouter } from 'next/router'
import { ReactNode } from 'react'

/**
 * Types
 */
interface IProps {
  children: ReactNode | ReactNode[]
}

/**
 * Components
 */
export default function RouteTransition({ children }: IProps) {
  const { pathname } = useRouter()

  return (
    <AnimatePresence exitBeforeEnter>
      <motion.div
        className="routeTransition"
        key={pathname}
        initial={{ opacity: 0, translateY: 7 }}
        animate={{ opacity: 1, translateY: 0 }}
        exit={{ opacity: 0, translateY: 7 }}
        transition={{ duration: 0.18 }}
      >
        {children}
      </motion.div>
    </AnimatePresence>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/SessionCard.tsx">
import { truncate } from '@/utils/HelperUtil'
import { Avatar, Card, Link, Text } from '@nextui-org/react'
import Image from 'next/image'
import NextLink from 'next/link'

/**
 * Types
 */
interface IProps {
  topic?: string
  logo?: string
  name?: string
  url?: string
}

/**
 * Component
 */
export default function SessionCard({ logo, name, url, topic }: IProps) {
  return (
    <NextLink href={topic ? `/session?topic=${topic}` : '#'} passHref>
      <Card
        clickable
        bordered
        borderWeight="light"
        css={{
          position: 'relative',
          marginBottom: '$6',
          minHeight: '70px'
        }}
        data-testid={`session-card`}
      >
        <Card.Body
          css={{
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'space-between',
            overflow: 'hidden'
          }}
        >
          <Avatar src={logo} />
          <div style={{ flex: 1 }}>
            <Text h5 css={{ marginLeft: '$9' }} data-testid={`session-text`}>
              {name}
            </Text>
            <Link href={url} css={{ marginLeft: '$9' }}>
              <a data-testid={`session-link`}>
                {truncate(url?.split('https://')[1] ?? 'Unknown', 23)}
              </a>
            </Link>
          </div>

          <Image
            src={'/icons/arrow-right-icon.svg'}
            width={20}
            height={20}
            alt="session icon"
            data-testid={`session-icon`}
          />
        </Card.Body>
      </Card>
    </NextLink>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/SessionChainCard.tsx">
import ChainCard from '@/components/ChainCard'
import { COSMOS_MAINNET_CHAINS } from '@/data/COSMOSData'
import { EIP155_MAINNET_CHAINS, EIP155_TEST_CHAINS } from '@/data/EIP155Data'
import { NEAR_TEST_CHAINS } from '@/data/NEARData'
import { SOLANA_MAINNET_CHAINS, SOLANA_TEST_CHAINS } from '@/data/SolanaData'
import { MULTIVERSX_MAINNET_CHAINS, MULTIVERSX_TEST_CHAINS } from '@/data/MultiversxData'
import { TRON_MAINNET_CHAINS, TRON_TEST_CHAINS } from '@/data/TronData'
import { formatChainName } from '@/utils/HelperUtil'
import { Col, Row, Text } from '@nextui-org/react'
import { SessionTypes } from '@walletconnect/types'
import { Fragment } from 'react'

/**
 * Utilities
 */
const CHAIN_METADATA = {
  ...COSMOS_MAINNET_CHAINS,
  ...SOLANA_MAINNET_CHAINS,
  ...MULTIVERSX_MAINNET_CHAINS,
  ...TRON_MAINNET_CHAINS,
  ...EIP155_MAINNET_CHAINS,
  ...EIP155_TEST_CHAINS,
  ...SOLANA_TEST_CHAINS,
  ...NEAR_TEST_CHAINS,
  ...MULTIVERSX_TEST_CHAINS,
  ...TRON_TEST_CHAINS
}

/**
 * Types
 */
interface IProps {
  namespace: SessionTypes.Namespace
}

/**
 * Component
 */
export default function SessionChainCard({ namespace }: IProps) {
  const chains: string[] = []

  // WIP

  namespace.accounts.forEach(account => {
    const [type, chain] = account.split(':')
    const chainId = `${type}:${chain}`
    if (!chains.includes(chainId)) {
      chains.push(chainId)
    }
  })

  return (
    <Fragment>
      {chains.map(chainId => {
        // @ts-expect-error
        const rgb = CHAIN_METADATA[chainId]?.rgb

        return (
          <ChainCard key={chainId} rgb={rgb ?? ''} flexDirection="col" alignItems="flex-start">
            <Text h5 css={{ marginBottom: '$5' }}>
              {formatChainName(chainId)}
            </Text>
            <Row>
              <Col>
                <Text h6>Methods</Text>
                <Text color="$gray300">
                  {namespace.methods.length ? namespace.methods.join(', ') : '-'}
                </Text>
              </Col>
            </Row>
            <Row css={{ marginTop: '$5' }}>
              <Col>
                <Text h6>Events</Text>
                <Text color="$gray300">
                  {namespace.events.length ? namespace.events.join(', ') : '-'}
                </Text>
              </Col>
            </Row>
          </ChainCard>
        )
      })}
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/SessionProposalChainCard.tsx">
import ChainCard from '@/components/ChainCard'
import { COSMOS_MAINNET_CHAINS } from '@/data/COSMOSData'
import { EIP155_MAINNET_CHAINS, EIP155_TEST_CHAINS } from '@/data/EIP155Data'
import { NEAR_TEST_CHAINS } from '@/data/NEARData'
import { SOLANA_MAINNET_CHAINS, SOLANA_TEST_CHAINS } from '@/data/SolanaData'
import { MULTIVERSX_MAINNET_CHAINS, MULTIVERSX_TEST_CHAINS } from '@/data/MultiversxData'
import { TRON_MAINNET_CHAINS, TRON_TEST_CHAINS } from '@/data/TronData'
import { formatChainName } from '@/utils/HelperUtil'
import { Col, Row, Text } from '@nextui-org/react'
import { ProposalTypes } from '@walletconnect/types'
import { Fragment } from 'react'

/**
 * Utilities
 */
const CHAIN_METADATA = {
  ...COSMOS_MAINNET_CHAINS,
  ...SOLANA_MAINNET_CHAINS,
  ...MULTIVERSX_MAINNET_CHAINS,
  ...TRON_MAINNET_CHAINS,
  ...EIP155_MAINNET_CHAINS,
  ...EIP155_TEST_CHAINS,
  ...SOLANA_TEST_CHAINS,
  ...NEAR_TEST_CHAINS,
  ...MULTIVERSX_TEST_CHAINS,
  ...TRON_TEST_CHAINS
}

/**
 * Types
 */
interface IProps {
  requiredNamespace: ProposalTypes.RequiredNamespace
}

/**
 * Component
 */
export default function SessionProposalChainCard({ requiredNamespace }: IProps) {
  return (
    <Fragment>
      {requiredNamespace.chains?.map(chainId => {
        // @ts-expect-error
        const rgb = CHAIN_METADATA[chainId]?.rgb

        return (
          <ChainCard key={chainId} rgb={rgb ?? ''} flexDirection="col" alignItems="flex-start">
            <Text h5 css={{ marginBottom: '$5' }}>
              {formatChainName(chainId)}
            </Text>
            <Row>
              <Col>
                <Text h6>Methods</Text>
                <Text color="$gray300">
                  {requiredNamespace.methods.length ? requiredNamespace.methods.join(', ') : '-'}
                </Text>
              </Col>
            </Row>
            <Row css={{ marginTop: '$5' }}>
              <Col>
                <Text h6>Events</Text>
                <Text color="$gray300">
                  {requiredNamespace.events.length ? requiredNamespace.events.join(', ') : '-'}
                </Text>
              </Col>
            </Row>
          </ChainCard>
        )
      })}
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/components/VerifyInfobox.tsx">
import { useMemo } from 'react'
import { useSnapshot } from 'valtio'
import { Image, StyledText } from '@nextui-org/react'
import SettingsStore from '@/store/SettingsStore'
import ReportIcon from '@mui/icons-material/Report'
import ReportProblemIcon from '@mui/icons-material/ReportProblem'
import NewReleasesIcon from '@mui/icons-material/NewReleases'
import { Avatar, Col, Link, Row, Text, styled } from '@nextui-org/react'
import { SignClientTypes } from '@walletconnect/types'

/**
 * Types
 */
interface IProps {
  metadata: SignClientTypes.Metadata
}

const StyledContainer = styled(Row, {
  padding: '7px',
  borderRadius: '30px',
  marginTop: '10px',
  marginBottom: '10px'
} as any)

const StyledUnknownRow = styled(StyledContainer, {
  color: '$warning',
  border: '0.5px solid $warning'
} as any)

const StyledUnknownContainer = styled('div', {
  textAlign: 'initial'
} as any)

const StyledInvalidRow = styled(StyledContainer, {
  color: '$error',
  border: '0.5px solid $error'
} as any)

const StyledInvalidContainer = styled('div', {
  textAlign: 'initial'
} as any)

const StyledDescription = styled(Text, {
  lineHeight: '20px',
  fontSize: '15px'
} as any)
/**
 * Components
 */
export default function VerifyInfobox({ metadata }: IProps) {
  const { currentRequestVerifyContext } = useSnapshot(SettingsStore.state)
  const validation = currentRequestVerifyContext?.verified.validation
  return (
    <div style={{ textAlign: 'center' }}>
      {currentRequestVerifyContext?.verified.isScam ? (
        <StyledInvalidRow>
          <Col style={{ margin: 'auto' }} span={2}>
            <NewReleasesIcon style={{ verticalAlign: 'bottom' }} />
          </Col>
          <Col style={{ margin: 'auto' }}>
            <Row>Known secury risk</Row>
            <Row>
              <StyledInvalidContainer>
                <StyledDescription>
                  This website is flagged as unsafe by multiple security reports. Leave immediately
                  to protect your assets.
                </StyledDescription>
              </StyledInvalidContainer>
            </Row>
          </Col>
        </StyledInvalidRow>
      ) : validation == 'UNKNOWN' ? (
        <StyledUnknownRow>
          <Col style={{ margin: 'auto' }} span={2}>
            <ReportIcon style={{ verticalAlign: 'bottom' }} />
          </Col>
          <Col style={{ margin: 'auto' }}>
            <Row>
              <StyledUnknownContainer>Unknown domain</StyledUnknownContainer>
            </Row>
            <Row>
              <StyledUnknownContainer>
                <StyledDescription>
                  This domain cannot be verified. Please check the request carefully before
                  approving.
                </StyledDescription>
              </StyledUnknownContainer>
            </Row>
          </Col>
        </StyledUnknownRow>
      ) : validation == 'INVALID' ? (
        <StyledInvalidRow>
          <Col style={{ margin: 'auto' }} span={2}>
            <ReportProblemIcon style={{ verticalAlign: 'bottom' }} />
          </Col>
          <Col style={{ margin: 'auto' }}>
            <Row>
              <>Domain mismatch</>
            </Row>
            <Row>
              <StyledInvalidContainer>
                <StyledDescription>
                  This website has a domain that does not match the sender of this request.
                  Approving may lead to loss of funds.
                </StyledDescription>
              </StyledInvalidContainer>
            </Row>
          </Col>
        </StyledInvalidRow>
      ) : null}
    </div>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/consts/smartAccounts.ts">
import { KernelSmartAccountLib } from '@/lib/smart-accounts/KernelSmartAccountLib'
import { SafeSmartAccountLib } from '@/lib/smart-accounts/SafeSmartAccountLib'
import { getAddress } from 'viem'
import { baseSepolia, goerli, polygonMumbai, sepolia } from 'viem/chains'

// Types
export const allowedChains = [sepolia, polygonMumbai, goerli, baseSepolia]
// build chains so I can access them by id
export const chains = allowedChains.reduce((acc, chain) => {
  acc[chain.id] = chain
  return acc
}, {} as Record<Chain['id'], Chain>)
export type Chain = typeof allowedChains[number]

export const availableSmartAccounts = {
  safe: SafeSmartAccountLib,
  kernel: KernelSmartAccountLib
}

export const SAFE_FALLBACK_HANDLER_STORAGE_SLOT =
  '0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5'

export const SAFE_4337_MODULE_ADDRESSES = [
  getAddress('0xa581c4A4DB7175302464fF3C06380BC3270b4037'),
  getAddress('0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226'),
  getAddress('0x3Fdb5BC686e861480ef99A6E3FaAe03c0b9F32e2')
]
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/Bip122Data.ts">
/**
 * Chains
 */
export const BIP122_NAMESPACE = 'bip122'

export const BIP122_MAINNET_ID = '000000000019d6689c085ae165831e93'
export const BIP122_TESTNET_ID = '000000000933ea01ad0ee984209779ba'
export const BIP122_MAINNET_CAIP2 = `${BIP122_NAMESPACE}:${BIP122_MAINNET_ID}`
export const BIP122_TESTNET_CAIP2 = `${BIP122_NAMESPACE}:${BIP122_TESTNET_ID}`

export type IBip122ChainId = typeof BIP122_MAINNET_CAIP2 | typeof BIP122_TESTNET_CAIP2

export const BITCOIN_MAINNET = {
  [BIP122_MAINNET_CAIP2]: {
    chainId: BIP122_MAINNET_ID,
    name: 'BTC Mainnet',
    logo: '/chain-logos/btc-testnet.png',
    rgb: '107, 111, 147',
    rpc: '',
    coinType: '0',
    caip2: BIP122_MAINNET_CAIP2 as IBip122ChainId,
    namespace: BIP122_NAMESPACE
  }
}
export const BITCOIN_TESTNET = {
  [BIP122_TESTNET_CAIP2]: {
    chainId: BIP122_TESTNET_ID,
    name: 'BTC Testnet',
    logo: '/chain-logos/btc-testnet.png',
    rgb: '247, 147, 25',
    rpc: '',
    coinType: '1',
    caip2: BIP122_TESTNET_CAIP2 as IBip122ChainId,
    namespace: BIP122_NAMESPACE
  }
}

export const BIP122_CHAINS = { ...BITCOIN_MAINNET, ...BITCOIN_TESTNET } as Record<
  IBip122ChainId,
  typeof BITCOIN_MAINNET[typeof BIP122_MAINNET_CAIP2] &
    typeof BITCOIN_TESTNET[typeof BIP122_TESTNET_CAIP2]
>

/**
 * Methods
 */
export const BIP122_SIGNING_METHODS = {
  BIP122_SIGN_MESSAGE: 'signMessage',
  BIP122_GET_ACCOUNT_ADDRESSES: 'getAccountAddresses',
  BIP122_SEND_TRANSACTION: 'sendTransfer',
  BIP122_SIGN_PSBT: 'signPsbt'
}

/**
 * Events
 */

export const BIP122_EVENTS = {
  BIP122_ADDRESSES_CHANGED: 'bip122_addressesChanged'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/chainsUtil.ts">
import { BIP122_CHAINS } from './Bip122Data'
import * as viemChains from 'viem/chains'
import { COSMOS_MAINNET_CHAINS } from './COSMOSData'
import { EIP155_CHAINS } from './EIP155Data'
import { KADENA_CHAINS } from './KadenaData'
import { MULTIVERSX_CHAINS } from './MultiversxData'
import { NEAR_CHAINS } from './NEARData'
import { POLKADOT_CHAINS } from './PolkadotData'
import { SOLANA_CHAINS } from './SolanaData'
import { TEZOS_CHAINS } from './TezosData'
import { TRON_CHAINS } from './TronData'

export const ALL_CHAINS = {
  ...EIP155_CHAINS,
  ...COSMOS_MAINNET_CHAINS,
  ...KADENA_CHAINS,
  ...MULTIVERSX_CHAINS,
  ...NEAR_CHAINS,
  ...POLKADOT_CHAINS,
  ...SOLANA_CHAINS,
  ...TEZOS_CHAINS,
  ...TRON_CHAINS,
  ...BIP122_CHAINS
}

export function getChainData(chainId?: string) {
  if (!chainId) return
  const [namespace, reference] = chainId.toString().split(':')
  return Object.values(ALL_CHAINS).find(
    chain => chain.chainId == reference && chain.namespace === namespace
  )
}

export function getViemChain(id: number) {
  const chains = Object.values(viemChains) as viemChains.Chain[]

  return chains.find(x => x.id === id)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/COSMOSData.ts">
/**
 * Types
 */
export type TCosmosChain = keyof typeof COSMOS_MAINNET_CHAINS

/**
 * Chains
 */
export const COSMOS_MAINNET_CHAINS = {
  'cosmos:cosmoshub-4': {
    chainId: 'cosmoshub-4',
    name: 'Cosmos Hub',
    logo: '/chain-logos/cosmos-cosmoshub-4.png',
    rgb: '107, 111, 147',
    rpc: '',
    namespace: 'cosmos'
  }
}

/**
 * Methods
 */
export const COSMOS_SIGNING_METHODS = {
  COSMOS_SIGN_DIRECT: 'cosmos_signDirect',
  COSMOS_SIGN_AMINO: 'cosmos_signAmino'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/EIP155Data.ts">
/**
 * @desc Refference list of eip155 chains
 * @url https://chainlist.org
 */

/**
 * Types
 */
export type TEIP155Chain = keyof typeof EIP155_CHAINS

export type EIP155Chain = {
  chainId: number
  name: string
  logo: string
  rgb: string
  rpc: string
  namespace: string
  smartAccountEnabled?: boolean
}
export const blockchainApiRpc = (chainId: number) => {
  return `https://rpc.walletconnect.org/v1?chainId=eip155:${chainId}&projectId=${process.env.NEXT_PUBLIC_PROJECT_ID}`
}
/**
 * Chains
 */
export const EIP155_MAINNET_CHAINS: Record<string, EIP155Chain> = {
  'eip155:1': {
    chainId: 1,
    name: 'Ethereum',
    logo: '/chain-logos/eip155-1.png',
    rgb: '99, 125, 234',
    rpc: blockchainApiRpc(1),
    namespace: 'eip155'
  },
  'eip155:43114': {
    chainId: 43114,
    name: 'Avalanche C-Chain',
    logo: '/chain-logos/eip155-43113.png',
    rgb: '232, 65, 66',
    rpc: blockchainApiRpc(43114),
    namespace: 'eip155'
  },
  'eip155:137': {
    chainId: 137,
    name: 'Polygon',
    logo: '/chain-logos/eip155-137.png',
    rgb: '130, 71, 229',
    rpc: blockchainApiRpc(137),
    namespace: 'eip155'
  },
  'eip155:10': {
    chainId: 10,
    name: 'Optimism',
    logo: '/chain-logos/eip155-10.png',
    rgb: '235, 0, 25',
    rpc: blockchainApiRpc(10),
    namespace: 'eip155'
  },
  'eip155:324': {
    chainId: 324,
    name: 'zkSync Era',
    logo: '/chain-logos/eip155-324.svg',
    rgb: '242, 242, 242',
    rpc: blockchainApiRpc(324),
    namespace: 'eip155'
  },
  'eip155:8453': {
    chainId: 8453,
    name: 'Base',
    logo: '/chain-logos/base.webp',
    rgb: '22, 83, 241',
    rpc: blockchainApiRpc(8453),
    namespace: 'eip155'
  },
  'eip155:42161': {
    chainId: 42161,
    name: 'Arbitrum',
    logo: '/chain-logos/arbitrum.webp',
    rgb: '27, 74, 220',
    rpc: blockchainApiRpc(42161),
    namespace: 'eip155'
  }
}

export const EIP155_TEST_CHAINS: Record<string, EIP155Chain> = {
  'eip155:5': {
    chainId: 5,
    name: 'Ethereum Goerli',
    logo: '/chain-logos/eip155-1.png',
    rgb: '99, 125, 234',
    rpc: blockchainApiRpc(5),
    namespace: 'eip155',
    smartAccountEnabled: true
  },
  'eip155:11155111': {
    chainId: 11155111,
    name: 'Ethereum Sepolia',
    logo: '/chain-logos/eip155-1.png',
    rgb: '99, 125, 234',
    rpc: blockchainApiRpc(11155111),
    namespace: 'eip155',
    smartAccountEnabled: true
  },
  'eip155:43113': {
    chainId: 43113,
    name: 'Avalanche Fuji',
    logo: '/chain-logos/eip155-43113.png',
    rgb: '232, 65, 66',
    rpc: blockchainApiRpc(43113),
    namespace: 'eip155'
  },
  'eip155:80001': {
    chainId: 80001,
    name: 'Polygon Mumbai',
    logo: '/chain-logos/eip155-137.png',
    rgb: '130, 71, 229',
    rpc: blockchainApiRpc(80001),
    namespace: 'eip155',
    smartAccountEnabled: true
  },
  'eip155:420': {
    chainId: 420,
    name: 'Optimism Goerli',
    logo: '/chain-logos/eip155-10.png',
    rgb: '235, 0, 25',
    rpc: blockchainApiRpc(420),
    namespace: 'eip155'
  },
  'eip155:11155420': {
    chainId: 11155420,
    name: 'Optimism Sepolia',
    logo: '/chain-logos/eip155-10.png',
    rgb: '235, 0, 25',
    rpc: blockchainApiRpc(11155420),
    namespace: 'eip155'
  },
  'eip155:280': {
    chainId: 280,
    name: 'zkSync Era Testnet',
    logo: '/chain-logos/eip155-324.svg',
    rgb: '242, 242, 242',
    rpc: blockchainApiRpc(280),
    namespace: 'eip155'
  },
  'eip155:84532': {
    chainId: 84532,
    name: 'Base Sepolia',
    logo: '/chain-logos/base.webp',
    rgb: '22, 83, 241',
    rpc: blockchainApiRpc(84532),
    namespace: 'eip155',
    smartAccountEnabled: true
  }
}

export const EIP155_CHAINS = { ...EIP155_MAINNET_CHAINS, ...EIP155_TEST_CHAINS }

/**
 * Methods
 */
export const EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: 'personal_sign',
  ETH_SIGN: 'eth_sign',
  ETH_SIGN_TRANSACTION: 'eth_signTransaction',
  ETH_SIGN_TYPED_DATA: 'eth_signTypedData',
  ETH_SIGN_TYPED_DATA_V3: 'eth_signTypedData_v3',
  ETH_SIGN_TYPED_DATA_V4: 'eth_signTypedData_v4',
  ETH_SEND_RAW_TRANSACTION: 'eth_sendRawTransaction',
  ETH_SEND_TRANSACTION: 'eth_sendTransaction',
  WALLET_CHECKOUT: 'wallet_checkout'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/EIP5792Data.ts">
/**
 * EIP5792Methods
 */
export const EIP5792_METHODS = {
  WALLET_GET_CAPABILITIES: 'wallet_getCapabilities',
  WALLET_SEND_CALLS: 'wallet_sendCalls',
  WALLET_SHOW_CALLS_STATUS: 'wallet_showCallsStatus',
  WALLET_GET_CALLS_STATUS: 'wallet_getCallsStatus'
}

// capability names as string literals
export type CapabilityName = 'atomicBatch' | 'paymasterService' | 'permissions'
// Capability type where each key is a capability name and value has `supported` field
export type Capabilities = {
  [K in CapabilityName]?: {
    supported: boolean
    [key: string]: any
  }
}
// GetCapabilitiesResult type using mapped types
export type GetCapabilitiesResult = Record<string, Capabilities>

export type GetCallsParams = string
export type ShowCallsParams = string

export type SendCallsParams = {
  version: string
  chainId: `0x${string}` // Hex chain id
  from: `0x${string}`
  calls: {
    to: `0x${string}`
    data?: `0x${string}` | undefined
    value?: `0x${string}` | undefined // Hex value
  }[]
  capabilities?: Record<string, any> | undefined
}
export type SendCallsPaymasterServiceCapabilityParam = {
  url: string
  context: Record<string, any> | undefined
}

export type GetCallsResult = {
  status: 'PENDING' | 'CONFIRMED'
  receipts?: {
    logs: {
      address: `0x${string}`
      data: `0x${string}`
      topics: `0x${string}`[]
    }[]
    status: `0x${string}` // Hex 1 or 0 for success or failure, respectively
    blockHash: `0x${string}`
    blockNumber: `0x${string}`
    gasUsed: `0x${string}`
    transactionHash: `0x${string}`
  }[]
}

// supportedEIP5792Capabilities object
export const supportedEIP5792CapabilitiesForEOA: GetCapabilitiesResult = {
  // Not supporting any capabilities for now on EOA account
}
// supportedEIP5792Capabilities object
export const supportedEIP5792CapabilitiesForSCA: GetCapabilitiesResult = {
  //Ethereum Sepolia
  '0xaa36a7': {
    paymasterService: {
      supported: true
    },
    permissions: {
      supported: true,
      signerTypes: ['keys'],
      permissionTypes: ['contract-call'],
      policyTypes: []
    },
    atomicBatch: {
      supported: true
    }
  },
  '0x14a34': {
    paymasterService: {
      supported: true
    },
    permissions: {
      supported: true,
      signerTypes: ['keys'],
      permissionTypes: [
        'contract-call',
        'native-token-recurring-allowance',
        'erc20-recurring-allowance'
      ],
      policyTypes: []
    },
    atomicBatch: {
      supported: true
    }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/EIP7715Data.ts">
/**
 * EIP7715Method
 */
export const EIP7715_METHOD = {
  WALLET_GRANT_PERMISSIONS: 'wallet_grantPermissions'
}
// The types of keys that are supported for the following `key` and `keys` signer types.
export enum SignerKeyType {
  SECP256K1 = 0, // EOA - k1
  SECP256R1 = 1 // Passkey - r1
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/EIP7811Data.ts">
import { getChainById } from '@/utils/ChainUtil'
import { createPublicClient, erc20Abi, getContract, http, isAddress, toHex } from 'viem'

// Types and Interfaces
type Hex = `0x${string}`
type ChainId = number

interface TokenMetadata {
  name: string
  symbol: string
  decimals: number
}

interface TokenBalance {
  balance: bigint
  decimals: number
}

interface Asset {
  address: Hex | 'native'
  balance: Hex
  type: string
  metadata: TokenMetadata
}

interface AggregatedBalance {
  totalBalance: bigint
  tokenDecimals: number
}

interface TokenConfig {
  chainAddresses: Record<ChainId, Hex>
  metadata: TokenMetadata
}

export interface WalletGetAssetsRequest {
  account: Hex
  assetFilter?: Record<Hex, (string | 'native')[]>
  assetTypeFilter?: string[]
  chainFilter?: Hex[]
}

export type WalletGetAssetsResponse = Record<Hex, Asset[]>

// Constants
export const EIP7811_METHODS = 'wallet_getAssets'

// Chain configurations
const SUPPORTED_CHAINS = {
  ARBITRUM: 42161,
  OPTIMISM: 10,
  BASE: 8453
} as const

// Token configurations including supported chains and metadata
const AGGREGATED_TOKEN_CONFIG: Record<string, TokenConfig> = {
  USDC: {
    chainAddresses: {
      [SUPPORTED_CHAINS.ARBITRUM]: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',
      [SUPPORTED_CHAINS.OPTIMISM]: '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',
      [SUPPORTED_CHAINS.BASE]: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'
    },
    metadata: {
      name: 'USD Coin',
      symbol: 'USDC',
      decimals: 6
    }
  },
  USDT: {
    chainAddresses: {
      [SUPPORTED_CHAINS.ARBITRUM]: '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9',
      [SUPPORTED_CHAINS.OPTIMISM]: '0x94b008aA00579c1307B0EF2c499aD98a8ce58e58'
    },
    metadata: {
      name: 'Tether USD',
      symbol: 'USDT',
      decimals: 6
    }
  }
}

// Native token configuration
const NATIVE_TOKEN_CONFIG: Record<ChainId, TokenMetadata> = {
  [SUPPORTED_CHAINS.ARBITRUM]: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
  [SUPPORTED_CHAINS.OPTIMISM]: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
  [SUPPORTED_CHAINS.BASE]: { name: 'Ethereum', symbol: 'ETH', decimals: 18 }
}

const CHAINS_FOR_NATIVE_AGGREGATION = [
  SUPPORTED_CHAINS.ARBITRUM,
  SUPPORTED_CHAINS.OPTIMISM,
  SUPPORTED_CHAINS.BASE
]

async function fetchNativeBalance(chainId: ChainId, accountAddress: Hex): Promise<bigint> {
  const publicClient = createPublicClient({
    chain: getChainById(chainId),
    transport: http()
  })

  return await publicClient.getBalance({ address: accountAddress })
}

async function fetchERC20Balance(
  chainId: ChainId,
  tokenAddress: Hex,
  accountAddress: Hex
): Promise<TokenBalance> {
  const publicClient = createPublicClient({
    chain: getChainById(chainId),
    transport: http()
  })
  const contract = getContract({
    address: tokenAddress,
    abi: erc20Abi,
    client: publicClient
  })

  const [balance, decimals] = await Promise.all([
    contract.read.balanceOf([accountAddress]),
    contract.read.decimals()
  ])

  return { balance, decimals }
}

async function aggregateNativeBalances(
  chainIds: ChainId[],
  accountAddress: Hex
): Promise<AggregatedBalance> {
  const balancePromises = chainIds.map(chainId => fetchNativeBalance(chainId, accountAddress))
  const balances = await Promise.all(balancePromises)

  return {
    totalBalance: balances.reduce((sum, balance) => sum + balance, BigInt(0)),
    tokenDecimals: NATIVE_TOKEN_CONFIG[chainIds[0]].decimals
  }
}

async function aggregateERC20Balances(
  tokenConfig: TokenConfig,
  accountAddress: Hex
): Promise<AggregatedBalance> {
  const supportedChainIds = Object.keys(tokenConfig.chainAddresses).map(Number)
  const balancePromises = supportedChainIds.map(chainId =>
    fetchERC20Balance(chainId, tokenConfig.chainAddresses[chainId], accountAddress)
  )

  const balances = await Promise.all(balancePromises)

  return {
    totalBalance: balances.reduce((sum, { balance }) => sum + balance, BigInt(0)),
    tokenDecimals: tokenConfig.metadata.decimals
  }
}

function createAssetResponse(
  address: Hex | 'native',
  balance: bigint,
  metadata: TokenMetadata
): Asset {
  return {
    address,
    balance: toHex(balance),
    type: address === 'native' ? 'NATIVE' : 'ERC20',
    metadata
  }
}

async function processAggregatedToken(
  tokenSymbol: string,
  tokenAddress: Hex,
  accountAddress: Hex
): Promise<Asset> {
  const tokenConfig = AGGREGATED_TOKEN_CONFIG[tokenSymbol]
  const { totalBalance } = await aggregateERC20Balances(tokenConfig, accountAddress)

  return createAssetResponse(tokenAddress, totalBalance, tokenConfig.metadata)
}

async function processUnknownToken(
  chainId: ChainId,
  tokenAddress: Hex,
  accountAddress: Hex
): Promise<Asset> {
  const { balance, decimals } = await fetchERC20Balance(chainId, tokenAddress, accountAddress)
  return createAssetResponse(tokenAddress, balance, {
    name: 'Unknown Token',
    symbol: 'UNK',
    decimals
  })
}

async function processNativeToken(
  chainId: ChainId,
  accountAddress: Hex,
  shouldAggregate: boolean
): Promise<Asset> {
  if (shouldAggregate) {
    const { totalBalance } = await aggregateNativeBalances(
      CHAINS_FOR_NATIVE_AGGREGATION,
      accountAddress
    )
    return createAssetResponse('native', totalBalance, NATIVE_TOKEN_CONFIG[chainId])
  }

  const balance = await fetchNativeBalance(chainId, accountAddress)
  return createAssetResponse('native', balance, NATIVE_TOKEN_CONFIG[chainId])
}

async function processChainAssets(
  chainId: ChainId,
  chainIdHex: Hex,
  requestedAssets: (string | 'native')[],
  accountAddress: Hex
): Promise<Asset[]> {
  const assetPromises = requestedAssets.map(async assetAddress => {
    try {
      // Handle native token
      if (assetAddress === 'native') {
        const shouldAggregateNative = CHAINS_FOR_NATIVE_AGGREGATION.includes(
          chainId as typeof SUPPORTED_CHAINS[keyof typeof SUPPORTED_CHAINS]
        )
        return processNativeToken(chainId, accountAddress, shouldAggregateNative)
      }

      if (!isAddress(assetAddress)) {
        return null
      }

      // Find if it's a supported aggregated token
      const tokenSymbol = Object.entries(AGGREGATED_TOKEN_CONFIG).find(
        ([_, config]) => config.chainAddresses[chainId] === assetAddress
      )?.[0]

      if (tokenSymbol) {
        return processAggregatedToken(tokenSymbol, assetAddress as Hex, accountAddress)
      }

      // Handle unknown ERC20 token
      return processUnknownToken(chainId, assetAddress as Hex, accountAddress)
    } catch (error) {
      console.error(`Error processing asset ${assetAddress} on chain ${chainId}:`, error)
      return null
    }
  })

  const assets = await Promise.all(assetPromises)
  return assets.filter((asset): asset is Asset => asset !== null)
}

export async function handleGetAssets(
  projectId: string,
  params: WalletGetAssetsRequest[]
): Promise<WalletGetAssetsResponse> {
  const [data] = params
  const response: WalletGetAssetsResponse = {}

  if (!data.assetFilter) {
    return response
  }

  const chainProcessingPromises = Object.entries(data.assetFilter).map(
    async ([chainIdHex, requestedAssets]) => {
      const chainId = parseInt(chainIdHex.slice(2), 16)
      const assets = await processChainAssets(
        chainId,
        chainIdHex as Hex,
        requestedAssets,
        data.account
      )

      return { chainIdHex, assets }
    }
  )

  const results = await Promise.all(chainProcessingPromises)

  results.forEach(({ chainIdHex, assets }) => {
    response[chainIdHex as Hex] = assets
  })

  return response
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/ERC7579ModuleData.ts">
import { ModuleType } from '@rhinestone/module-sdk'
//Note: ES6 syntax dont work for this package
const {
  SMART_SESSIONS_ADDRESS,
  MULTI_FACTOR_VALIDATOR_ADDRESS,
  OWNABLE_VALIDATOR_ADDRESS,
  WEBAUTHN_VALIDATOR_ADDRESS,
  SCHEDULED_ORDERS_EXECUTOR_ADDRESS,
  SCHEDULED_TRANSFERS_EXECUTOR_ADDRESS
} = require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')

export type ModuleView =
  | 'PermissionValidatorActions'
  | 'OwnableValidatorActions'
  | 'MFAValidatorActions'
  | 'WebAuthnValidatorActions'
  | 'ScheduleOrdersExecutorActions'
  | 'ScheduleTransfersExecutorActions'

export type Module = {
  name: string
  type: ModuleType
  url: string
  description: string
  moduleAddress: string
  moduleData: string
  view?: ModuleView
}
export const supportedModules: Module[] = [
  {
    name: 'Permission Validator',
    type: 'validator',
    url: '/permission-validator',
    moduleAddress: SMART_SESSIONS_ADDRESS,
    description: `The Permission Validator module is a module that allows DApp to request permissions from a wallet in order to execute transactions on users's behalf that is scoped with permissions`,
    moduleData: '0x'
  },
  {
    name: 'Ownable Validator',
    type: 'validator',
    url: '/ownable-validator',
    moduleAddress: OWNABLE_VALIDATOR_ADDRESS,
    description: `The Ownable Validator module is a module that allows you to add multiple ECDSA owners to an account.
     The owners can then be used to sign transactions to be executed on the account.`,
    moduleData: '',
    view: 'OwnableValidatorActions'
  },
  {
    name: `Muti-factor Validator`,
    type: 'validator',
    url: '/mfa-validator',
    moduleAddress: MULTI_FACTOR_VALIDATOR_ADDRESS,
    description: `The MFA Validator module is a module that allows you to add multi-factor validation to an account. The MFA Validator module is used to validate transactions and other executions on the account.`,
    moduleData: ''
  },
  {
    name: 'WebAuthn Validator',
    type: 'validator',
    url: '/webauthn-validator',
    moduleAddress: WEBAUTHN_VALIDATOR_ADDRESS,
    description: 'Coming Soon',
    moduleData: ''
  },
  {
    name: 'Schedule Orders Executor',
    type: 'executor',
    url: 'schedule-orders-executor',
    moduleAddress: SCHEDULED_ORDERS_EXECUTOR_ADDRESS,
    description: `The Scheduled Orders module allows users to schedule swaps to be executed at a later time, with an optional recurring schedule. This module is an executor that is installed on an account and can be triggered by an automation service at the pre-specified time(s).`,
    moduleData: ''
  },
  {
    name: 'Schedule Transfers Executor',
    type: 'executor',
    url: '/schedule-transfers-executor',
    moduleAddress: SCHEDULED_TRANSFERS_EXECUTOR_ADDRESS,
    description: `The Scheduled Transfers module allows users to schedule token transfers to occur at a future time, with an optional recurring schedule. It is an executor that is installed on an account and can be triggered by an automation service at the pre-specified time(s).`,
    moduleData: ''
  }
]
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/KadenaData.ts">
/**
 * Types
 */
export type TKadenaChain = keyof typeof KADENA_MAINNET_CHAINS

/**
 * Chains
 */
export const KADENA_MAINNET_CHAINS = {
  'kadena:mainnet01': {
    chainId: 'mainnet01',
    name: 'Kadena',
    logo: '/chain-logos/kadena.png',
    rgb: '237, 9, 143',
    namespace: 'kadena'
  }
}

export const KADENA_TEST_CHAINS = {
  'kadena:testnet04': {
    chainId: 'testnet04',
    name: 'Kadena Testnet',
    logo: '/chain-logos/kadena.png',
    rgb: '237, 9, 143',
    namespace: 'kadena'
  }
}

export const KADENA_CHAINS = { ...KADENA_MAINNET_CHAINS, ...KADENA_TEST_CHAINS }

/**
 * Methods
 */
export const KADENA_SIGNING_METHODS = {
  KADENA_GET_ACCOUNTS: 'kadena_getAccounts_v1',
  KADENA_SIGN: 'kadena_sign_v1',
  KADENA_QUICKSIGN: 'kadena_quicksign_v1'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/MultiversxData.ts">
/**
 * Types
 */
export type TMultiversxChain = keyof typeof MULTIVERSX_MAINNET_CHAINS

/**
 * Chains
 */
export const MULTIVERSX_MAINNET_CHAINS = {
  'mvx:1': {
    chainId: '1',
    name: 'MultiversX',
    logo: '/chain-logos/multiversx-1.svg',
    rgb: '43, 45, 46',
    rpc: '',
    namespace: 'mvx'
  }
}

export const MULTIVERSX_TEST_CHAINS = {
  'mvx:D': {
    chainId: 'D',
    name: 'MultiversX Devnet',
    logo: '/chain-logos/multiversx-1.svg',
    rgb: '43, 45, 46',
    rpc: '',
    namespace: 'mvx'
  }
  // Keep only one Test Chain visible
  // 'mvx:T': {
  //   chainId: 'T',
  //   name: 'MultiversX Testnet',
  //   logo: '/chain-logos/multiversx-1.svg',
  //   rgb: '43, 45, 46',
  //   rpc: '',
  //   namespace: 'mvx'
  // }
}

export const MULTIVERSX_CHAINS = { ...MULTIVERSX_MAINNET_CHAINS, ...MULTIVERSX_TEST_CHAINS }

/**
 * Methods
 */
export const MULTIVERSX_SIGNING_METHODS = {
  MULTIVERSX_SIGN_TRANSACTION: 'mvx_signTransaction',
  MULTIVERSX_SIGN_TRANSACTIONS: 'mvx_signTransactions',
  MULTIVERSX_SIGN_MESSAGE: 'mvx_signMessage',
  MULTIVERSX_SIGN_LOGIN_TOKEN: 'mvx_signLoginToken',
  MULTIVERSX_SIGN_NATIVE_AUTH_TOKEN: 'mvx_signNativeAuthToken',
  MULTIVERSX_CANCEL_ACTION: 'mvx_cancelAction'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/NEARData.ts">
/**
 * @desc Reference list of NEAR chains
 * @url https://chainlist.org
 */

/**
 * Types
 */
export type TNearChain = keyof typeof NEAR_TEST_CHAINS

/**
 * Chains
 */
export const NEAR_MAINNET_CHAINS = {
  // TODO: Dev account creation isn't supported on NEAR Mainnet.
}

interface NearTestChains {
  [key: string]: ChainMetadata
}

type ChainMetadata = {
  chainId: string
  name: string
  logo: string
  rgb: string
  rpc: string
  namespace: string
}

export const NEAR_TEST_CHAINS: NearTestChains = {
  'near:testnet': {
    chainId: 'testnet',
    name: 'NEAR Testnet',
    logo: '/chain-logos/near.png',
    rgb: '99, 125, 234',
    rpc: 'https://rpc.testnet.near.org',
    namespace: 'near'
  }
}

export const NEAR_CHAINS = { ...NEAR_MAINNET_CHAINS, ...NEAR_TEST_CHAINS }

/**
 * Methods
 */
export const NEAR_SIGNING_METHODS = {
  NEAR_SIGN_IN: 'near_signIn',
  NEAR_SIGN_OUT: 'near_signOut',
  NEAR_GET_ACCOUNTS: 'near_getAccounts',
  NEAR_SIGN_TRANSACTION: 'near_signTransaction',
  NEAR_SIGN_AND_SEND_TRANSACTION: 'near_signAndSendTransaction',
  NEAR_SIGN_TRANSACTIONS: 'near_signTransactions',
  NEAR_SIGN_AND_SEND_TRANSACTIONS: 'near_signAndSendTransactions',
  NEAR_VERIFY_OWNER: 'near_verifyOwner',
  NEAR_SIGN_MESSAGE: 'near_signMessage'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/PolkadotData.ts">
/**
 * Types
 */
export type TPolkadotChain = keyof typeof POLKADOT_MAINNET_CHAINS

/**
 * Chains
 */
export const POLKADOT_MAINNET_CHAINS = {
  'polkadot:91b171bb158e2d3848fa23a9f1c25182': {
    chainId: '91b171bb158e2d3848fa23a9f1c25182',
    name: 'Polkadot',
    logo: '/chain-logos/polkadot.svg',
    rgb: '230, 1, 122',
    rpc: '',
    namespace: 'polkadot'
  }
}

export const POLKADOT_TEST_CHAINS = {
  'polkadot:e143f23803ac50e8f6f8e62695d1ce9e': {
    chainId: 'e143f23803ac50e8f6f8e62695d1ce9e',
    name: 'Polkadot Westend',
    logo: '/chain-logos/westend.svg',
    rgb: '218, 104, 167',
    rpc: '',
    namespace: 'polkadot'
  }
}

export const POLKADOT_CHAINS = { ...POLKADOT_MAINNET_CHAINS, ...POLKADOT_TEST_CHAINS }
/**
 * Methods
 */
export const POLKADOT_SIGNING_METHODS = {
  POLKADOT_SIGN_TRANSACTION: 'polkadot_signTransaction',
  POLKADOT_SIGN_MESSAGE: 'polkadot_signMessage'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/RelayerRegions.ts">
/**
 * Types
 */

type RelayerType = {
  value: string
  label: string
}

/**
 * Relayer Regions
 */
export const REGIONALIZED_RELAYER_ENDPOINTS: RelayerType[] = [
  {
    value: 'wss://relay.walletconnect.com',
    label: 'Default'
  },

  {
    value: 'wss://us-east-1.relay.walletconnect.com',
    label: 'US'
  },
  {
    value: 'wss://eu-central-1.relay.walletconnect.com',
    label: 'EU'
  },
  {
    value: 'wss://ap-southeast-1.relay.walletconnect.com',
    label: 'Asia Pacific'
  }
]
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/SolanaData.ts">
/**
 * Types
 */
export type TSolanaChain = keyof typeof SOLANA_MAINNET_CHAINS

/**
 * Chains
 */
export const SOLANA_MAINNET_CHAINS = {
  // This chainId is deprecated and should not be used. Preserved for backwards compatibility.
  'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ': {
    chainId: '4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ',
    name: 'Solana (Legacy)',
    logo: '/chain-logos/solana-5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp.png',
    rgb: '30, 240, 166',
    rpc: '',
    namespace: 'solana'
  },
  'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': {
    chainId: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
    name: 'Solana',
    logo: '/chain-logos/solana-5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp.png',
    rgb: '30, 240, 166',
    rpc: 'https://api.mainnet-beta.solana.com',
    namespace: 'solana'
  }
}

export const SOLANA_TEST_CHAINS = {
  // This chainId is deprecated and should not be used. Preserved for backwards compatibility.
  'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K': {
    chainId: '8E9rvCKLFQia2Y35HXjjpWzj8weVo44K',
    name: 'Solana Devnet (Legacy)',
    logo: '/chain-logos/solana-5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp.png',
    rgb: '30, 240, 166',
    rpc: '',
    namespace: 'solana'
  },
  'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1': {
    chainId: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',
    name: 'Solana Devnet',
    logo: '/chain-logos/solana-5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp.png',
    rgb: '30, 240, 166',
    rpc: 'https://api.devnet.solana.com',
    namespace: 'solana'
  },
  'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z': {
    chainId: '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',
    name: 'Solana Testnet',
    logo: '/chain-logos/solana-5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp.png',
    rgb: '30, 240, 166',
    rpc: 'https://api.testnet.solana.com',
    namespace: 'solana'
  }
}

export const SOLANA_CHAINS = { ...SOLANA_MAINNET_CHAINS, ...SOLANA_TEST_CHAINS }

/**
 * Methods
 */
export const SOLANA_SIGNING_METHODS = {
  SOLANA_SIGN_TRANSACTION: 'solana_signTransaction',
  SOLANA_SIGN_MESSAGE: 'solana_signMessage',
  SOLANA_SIGN_AND_SEND_TRANSACTION: 'solana_signAndSendTransaction',
  SOLANA_SIGN_ALL_TRANSACTIONS: 'solana_signAllTransactions',
  SOLANA_WALLET_CHECKOUT: 'wallet_checkout'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/TezosData.ts">
type ChainMetadata = {
  chainId: string
  name: string
  logo: string
  rgb: string
  rpc: string
  namespace: string
}

/**
 * Types
 */
export type TTezosChain = keyof typeof TEZOS_MAINNET_CHAINS

/**
 * Chains
 */
export const TEZOS_MAINNET_CHAINS: Record<string, ChainMetadata> = {
  'tezos:mainnet': {
    chainId: 'mainnet',
    name: 'Tezos',
    logo: '/chain-logos/tezos.svg',
    rgb: '44, 125, 247',
    rpc: 'https://mainnet.api.tez.ie',
    namespace: 'tezos'
  }
}

export const TEZOS_TEST_CHAINS: Record<string, ChainMetadata> = {
  'tezos:testnet': {
    chainId: 'testnet',
    name: 'Tezos Testnet',
    logo: '/chain-logos/tezos.svg',
    rgb: '44, 125, 247',
    rpc: 'https://ghostnet.ecadinfra.com',
    namespace: 'tezos'
  }
}

export const TEZOS_CHAINS = { ...TEZOS_MAINNET_CHAINS, ...TEZOS_TEST_CHAINS }

/**
 * Methods
 */
export const TEZOS_SIGNING_METHODS = {
  TEZOS_GET_ACCOUNTS: 'tezos_getAccounts',
  TEZOS_SEND: 'tezos_send',
  TEZOS_SIGN: 'tezos_sign'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/tokenUtil.ts">
export type EIP155Token = {
  name: string
  icon: string
  assetAddress?: string
  symbol: string
  decimals: number
}

const ALL_TOKENS: EIP155Token[] = [
  {
    name: 'USDC',
    icon: '/token-logos/USDC.png',
    symbol: 'USDC',
    decimals: 6
  },
  {
    name: 'USDT',
    icon: '/token-logos/USDT.png',
    symbol: 'USDT',
    decimals: 6
  },
  {
    name: 'ETH',
    icon: '/token-logos/ETH.png',
    symbol: 'ETH',
    decimals: 18
  },
  {
    name: 'SOL',
    icon: '/token-logos/SOL.png',
    symbol: 'SOL',
    decimals: 9
  }
]

export function getTokenData(tokenSymbol: string) {
  return Object.values(ALL_TOKENS).find(token => token.symbol === tokenSymbol)
}

const SOLANA_KNOWN_TOKENS = [
  {
    name: 'USDC',
    icon: '/token-logos/USDC.png',
    symbol: 'USDC',
    decimals: 6,
    assetAddress: [
      'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1/token:4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU'
    ]
  }
]

export function getSolanaTokenData(caip19AssetAddress: string) {
  return SOLANA_KNOWN_TOKENS.find(token => token.assetAddress.includes(caip19AssetAddress))
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/data/TronData.ts">
/**
 * Types
 */
export type TTronChain = keyof typeof TRON_MAINNET_CHAINS

interface TRONChains {
  [key: string]: ChainMetadata
}

type ChainMetadata = {
  chainId: string
  name: string
  logo: string
  rgb: string
  fullNode: string
  namespace: string
}

/**
 * Chains
 */
export const TRON_MAINNET_CHAINS: TRONChains = {
  'tron:0x2b6653dc': {
    chainId: '0x2b6653dc',
    name: 'Tron',
    logo: 'https://tronscan.io/static/media/TRON.4a760cebd163969b2ee874abf2415e9a.svg',
    rgb: '183, 62, 49',
    fullNode: 'https://api.trongrid.io',
    namespace: 'tron'
  }
}

export const TRON_TEST_CHAINS: TRONChains = {
  'tron:0xcd8690dc': {
    chainId: '0xcd8690dc',
    name: 'Tron Testnet',
    logo: 'https://tronscan.io/static/media/TRON.4a760cebd163969b2ee874abf2415e9a.svg',
    rgb: '183, 62, 49',
    fullNode: 'https://nile.trongrid.io/',
    namespace: 'tron'
  }
}

export const TRON_CHAINS = { ...TRON_MAINNET_CHAINS, ...TRON_TEST_CHAINS }

/**
 * Methods
 */
export const TRON_SIGNING_METHODS = {
  TRON_SIGN_TRANSACTION: 'tron_signTransaction',
  TRON_SIGN_MESSAGE: 'tron_signMessage'
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/hooks/useInitialization.ts">
import SettingsStore from '@/store/SettingsStore'
import { createOrRestoreCosmosWallet } from '@/utils/CosmosWalletUtil'
import { createOrRestoreEIP155Wallet } from '@/utils/EIP155WalletUtil'
import { createOrRestoreSolanaWallet } from '@/utils/SolanaWalletUtil'
import { createOrRestorePolkadotWallet } from '@/utils/PolkadotWalletUtil'
import { createOrRestoreNearWallet } from '@/utils/NearWalletUtil'
import { createOrRestoreMultiversxWallet } from '@/utils/MultiversxWalletUtil'
import { createOrRestoreTronWallet } from '@/utils/TronWalletUtil'
import { createOrRestoreTezosWallet } from '@/utils/TezosWalletUtil'
import { createWalletKit, walletkit } from '@/utils/WalletConnectUtil'
import { createOrRestoreKadenaWallet } from '@/utils/KadenaWalletUtil'
import { useCallback, useEffect, useRef, useState } from 'react'
import { useSnapshot } from 'valtio'
import useSmartAccounts from './useSmartAccounts'
import { createOrRestoreBip122Wallet } from '@/utils/Bip122WalletUtil'

export default function useInitialization() {
  const [initialized, setInitialized] = useState(false)
  const prevRelayerURLValue = useRef<string>('')

  const { relayerRegionURL } = useSnapshot(SettingsStore.state)
  const { initializeSmartAccounts } = useSmartAccounts()

  const onInitialize = useCallback(async () => {
    try {
      const { eip155Addresses, eip155Wallets } = createOrRestoreEIP155Wallet()
      const { cosmosAddresses } = await createOrRestoreCosmosWallet()
      const { solanaAddresses } = await createOrRestoreSolanaWallet()
      const { polkadotAddresses } = await createOrRestorePolkadotWallet()
      const { nearAddresses } = await createOrRestoreNearWallet()
      const { multiversxAddresses } = await createOrRestoreMultiversxWallet()
      const { tronAddresses } = await createOrRestoreTronWallet()
      const { tezosAddresses } = await createOrRestoreTezosWallet()
      const { kadenaAddresses } = await createOrRestoreKadenaWallet()
      const { bip122Addresses } = await createOrRestoreBip122Wallet()
      await initializeSmartAccounts(eip155Wallets[eip155Addresses[0]].getPrivateKey())

      SettingsStore.setEIP155Address(eip155Addresses[0])
      SettingsStore.setCosmosAddress(cosmosAddresses[0])
      SettingsStore.setSolanaAddress(solanaAddresses[0])
      SettingsStore.setPolkadotAddress(polkadotAddresses[0])
      SettingsStore.setNearAddress(nearAddresses[0])
      SettingsStore.setMultiversxAddress(multiversxAddresses[0])
      SettingsStore.setTronAddress(tronAddresses[0])
      SettingsStore.setTezosAddress(tezosAddresses[0])
      SettingsStore.setKadenaAddress(kadenaAddresses[0])
      SettingsStore.setbip122Address(bip122Addresses[0])
      await createWalletKit(relayerRegionURL)
      setInitialized(true)
    } catch (err: unknown) {
      console.error('Initialization failed', err)
      alert(err)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [relayerRegionURL])

  // restart transport if relayer region changes
  const onRelayerRegionChange = useCallback(() => {
    try {
      walletkit?.core?.relayer.restartTransport(relayerRegionURL)
      prevRelayerURLValue.current = relayerRegionURL
    } catch (err: unknown) {
      alert(err)
    }
  }, [relayerRegionURL])

  useEffect(() => {
    if (!initialized) {
      onInitialize()
    }
    if (prevRelayerURLValue.current !== relayerRegionURL) {
      onRelayerRegionChange()
    }
  }, [initialized, onInitialize, relayerRegionURL, onRelayerRegionChange])

  return initialized
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/hooks/usePriorityAccounts.ts">
import SettingsStore from '@/store/SettingsStore'
import {
  biconomyAllowedChains,
  kernelAllowedChains,
  safeAllowedChains,
  supportedAddressPriority
} from '@/utils/SmartAccountUtil'
import { SessionTypes } from '@walletconnect/types'
import { useSnapshot } from 'valtio'

interface IProps {
  namespaces?: SessionTypes.Namespaces
}

export default function usePriorityAccounts({ namespaces }: IProps) {
  const {
    smartAccountEnabled,
    kernelSmartAccountAddress,
    kernelSmartAccountEnabled,
    safeSmartAccountAddress,
    safeSmartAccountEnabled,
    biconomySmartAccountAddress,
    biconomySmartAccountEnabled
  } = useSnapshot(SettingsStore.state)
  if (!namespaces) return []

  if (smartAccountEnabled) {
    if (safeSmartAccountEnabled) {
      return supportedAddressPriority(namespaces, safeSmartAccountAddress, safeAllowedChains)
    }
    if (kernelSmartAccountEnabled) {
      return supportedAddressPriority(namespaces, kernelSmartAccountAddress, kernelAllowedChains)
    }
    if (biconomySmartAccountEnabled) {
      return supportedAddressPriority(
        namespaces,
        biconomySmartAccountAddress,
        biconomyAllowedChains
      )
    }
  }
  return []
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/hooks/useSmartAccounts.ts">
import { EIP155Chain } from '@/data/EIP155Data'
import SettingsStore from '@/store/SettingsStore'
import {
  createOrRestoreBiconomySmartAccount,
  createOrRestoreKernelSmartAccount,
  createOrRestoreSafeSmartAccount,
  smartAccountWallets
} from '@/utils/SmartAccountUtil'

import { useSnapshot } from 'valtio'

export default function useSmartAccounts() {
  const {
    smartAccountEnabled,
    kernelSmartAccountEnabled,
    safeSmartAccountEnabled,
    biconomySmartAccountEnabled
  } = useSnapshot(SettingsStore.state)

  const initializeSmartAccounts = async (privateKey: string) => {
    if (smartAccountEnabled) {
      if (kernelSmartAccountEnabled) {
        const { kernelSmartAccountAddress } = await createOrRestoreKernelSmartAccount(privateKey)
        SettingsStore.setKernelSmartAccountAddress(kernelSmartAccountAddress)
      }
      if (safeSmartAccountEnabled) {
        const { safeSmartAccountAddress } = await createOrRestoreSafeSmartAccount(privateKey)
        SettingsStore.setSafeSmartAccountAddress(safeSmartAccountAddress)
      }
      if (biconomySmartAccountEnabled) {
        const { biconomySmartAccountAddress } = await createOrRestoreBiconomySmartAccount(
          privateKey
        )
        SettingsStore.setBiconomySmartAccountAddress(biconomySmartAccountAddress)
      }
    }
  }

  const getAvailableSmartAccounts = () => {
    if (!smartAccountEnabled) {
      return []
    }
    const accounts = []
    for (const [key, lib] of Object.entries(smartAccountWallets)) {
      accounts.push({
        address: key.split(':')[1],
        type: lib.type,
        chain: lib.chain
      })
    }

    return accounts
  }

  const getAvailableSmartAccountsOnNamespaceChains = (chains: string[] | undefined) => {
    if (!smartAccountEnabled || chains === undefined) {
      return []
    }
    const accounts = []
    for (const [key, lib] of Object.entries(smartAccountWallets)) {
      accounts.push({
        address: key.split(':')[1],
        type: lib.type,
        chain: lib.chain
      })
    }

    const filteredAccounts = accounts.filter(account =>
      chains.some(chain => chain && parseInt(chain.split(':')[1]) === account.chain.id)
    )
    return filteredAccounts
  }

  return {
    initializeSmartAccounts,
    getAvailableSmartAccounts,
    getAvailableSmartAccountsOnNamespaceChains
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/hooks/useWalletConnectEventsManager.ts">
import { COSMOS_SIGNING_METHODS } from '@/data/COSMOSData'
import { EIP155_SIGNING_METHODS } from '@/data/EIP155Data'
import { EIP5792_METHODS } from '@/data/EIP5792Data'
import { SOLANA_SIGNING_METHODS } from '@/data/SolanaData'
import { POLKADOT_SIGNING_METHODS } from '@/data/PolkadotData'
import { MULTIVERSX_SIGNING_METHODS } from '@/data/MultiversxData'
import { TRON_SIGNING_METHODS } from '@/data/TronData'
import ModalStore from '@/store/ModalStore'
import SettingsStore from '@/store/SettingsStore'
import { walletkit } from '@/utils/WalletConnectUtil'
import { SignClientTypes } from '@walletconnect/types'
import { useCallback, useEffect, useMemo } from 'react'
import { NEAR_SIGNING_METHODS } from '@/data/NEARData'
import { approveNearRequest } from '@/utils/NearRequestHandlerUtil'
import { TEZOS_SIGNING_METHODS } from '@/data/TezosData'
import { KADENA_SIGNING_METHODS } from '@/data/KadenaData'
import { formatJsonRpcError } from '@json-rpc-tools/utils'
import { approveEIP5792Request } from '@/utils/EIP5792RequestHandlerUtils'
import EIP155Lib from '@/lib/EIP155Lib'
import { getWallet } from '@/utils/EIP155WalletUtil'
import { BIP122_SIGNING_METHODS } from '@/data/Bip122Data'
import { EIP7715_METHOD } from '@/data/EIP7715Data'
import { refreshSessionsList } from '@/pages/wc'
import WalletCheckoutUtil from '@/utils/WalletCheckoutUtil'
import WalletCheckoutCtrl from '@/store/WalletCheckoutCtrl'
import { CheckoutErrorCode } from '@/types/wallet_checkout'
import { createCheckoutError } from '@/types/wallet_checkout'

export default function useWalletConnectEventsManager(initialized: boolean) {
  /******************************************************************************
   * 1. Open session proposal modal for confirmation / rejection
   *****************************************************************************/
  const onSessionProposal = useCallback(
    (proposal: SignClientTypes.EventArguments['session_proposal']) => {
      console.log('session_proposal', proposal)
      // set the verify context so it can be displayed in the projectInfoCard
      SettingsStore.setCurrentRequestVerifyContext(proposal.verifyContext)
      ModalStore.open('SessionProposalModal', { proposal })
    },
    []
  )

  /******************************************************************************
   * 3. Open request handling modal based on method that was used
   *****************************************************************************/
  const onSessionRequest = useCallback(
    async (requestEvent: SignClientTypes.EventArguments['session_request']) => {
      const { topic, params, verifyContext, id } = requestEvent
      const { request } = params
      const requestSession = walletkit.engine.signClient.session.get(topic)
      // set the verify context so it can be displayed in the projectInfoCard
      SettingsStore.setCurrentRequestVerifyContext(verifyContext)
      switch (request.method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          return ModalStore.open('SessionSignModal', { requestEvent, requestSession })

        case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
          return ModalStore.open('SessionSignTypedDataModal', { requestEvent, requestSession })

        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          return ModalStore.open('SessionSendTransactionModal', { requestEvent, requestSession })

        case EIP7715_METHOD.WALLET_GRANT_PERMISSIONS: {
          return ModalStore.open('SessionGrantPermissionsModal', { requestEvent, requestSession })
        }

        case EIP5792_METHODS.WALLET_GET_CAPABILITIES:
        case EIP5792_METHODS.WALLET_GET_CALLS_STATUS:
          return await walletkit.respondSessionRequest({
            topic,
            response: await approveEIP5792Request(requestEvent)
          })

        case EIP5792_METHODS.WALLET_SHOW_CALLS_STATUS:
          return await walletkit.respondSessionRequest({
            topic,
            response: formatJsonRpcError(id, "Wallet currently don't show call status.")
          })

        case EIP5792_METHODS.WALLET_SEND_CALLS: {
          const wallet = await getWallet(params)
          if (wallet instanceof EIP155Lib) {
            /**
             * Not Supporting for batch calls on EOA for now.
             * if EOA, we can submit call one by one, but need to have a data structure
             * to return bundle id, for all the calls,
             */
            return await walletkit.respondSessionRequest({
              topic,
              response: formatJsonRpcError(id, "Wallet currently don't support batch call for EOA")
            })
          }
          return ModalStore.open('SessionSendCallsModal', { requestEvent, requestSession })
        }

        case EIP155_SIGNING_METHODS.WALLET_CHECKOUT:
          try {
            await WalletCheckoutCtrl.actions.prepareFeasiblePayments(request.params[0])
          } catch (error) {
            // If it's not a CheckoutError, create one
            if (!(error && typeof error === 'object' && 'code' in error)) {
              error = createCheckoutError(
                CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
                `Unexpected error: ${error instanceof Error ? error.message : String(error)}`
              )
            }

            return await walletkit.respondSessionRequest({
              topic,
              response: WalletCheckoutUtil.formatCheckoutErrorResponse(id, error)
            })
          }
          return ModalStore.open('SessionCheckoutModal', { requestEvent, requestSession })

        case COSMOS_SIGNING_METHODS.COSMOS_SIGN_DIRECT:
        case COSMOS_SIGNING_METHODS.COSMOS_SIGN_AMINO:
          return ModalStore.open('SessionSignCosmosModal', { requestEvent, requestSession })

        case SOLANA_SIGNING_METHODS.SOLANA_SIGN_MESSAGE:
        case SOLANA_SIGNING_METHODS.SOLANA_SIGN_TRANSACTION:
        case SOLANA_SIGNING_METHODS.SOLANA_SIGN_AND_SEND_TRANSACTION:
        case SOLANA_SIGNING_METHODS.SOLANA_SIGN_ALL_TRANSACTIONS:
          return ModalStore.open('SessionSignSolanaModal', { requestEvent, requestSession })

        case POLKADOT_SIGNING_METHODS.POLKADOT_SIGN_MESSAGE:
        case POLKADOT_SIGNING_METHODS.POLKADOT_SIGN_TRANSACTION:
          return ModalStore.open('SessionSignPolkadotModal', { requestEvent, requestSession })

        case NEAR_SIGNING_METHODS.NEAR_SIGN_IN:
        case NEAR_SIGNING_METHODS.NEAR_SIGN_OUT:
        case NEAR_SIGNING_METHODS.NEAR_SIGN_TRANSACTION:
        case NEAR_SIGNING_METHODS.NEAR_SIGN_AND_SEND_TRANSACTION:
        case NEAR_SIGNING_METHODS.NEAR_SIGN_TRANSACTIONS:
        case NEAR_SIGNING_METHODS.NEAR_SIGN_AND_SEND_TRANSACTIONS:
        case NEAR_SIGNING_METHODS.NEAR_VERIFY_OWNER:
        case NEAR_SIGNING_METHODS.NEAR_SIGN_MESSAGE:
          return ModalStore.open('SessionSignNearModal', { requestEvent, requestSession })

        case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_MESSAGE:
        case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_TRANSACTION:
        case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_TRANSACTIONS:
        case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_LOGIN_TOKEN:
        case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_NATIVE_AUTH_TOKEN:
          return ModalStore.open('SessionSignMultiversxModal', { requestEvent, requestSession })

        case NEAR_SIGNING_METHODS.NEAR_GET_ACCOUNTS:
          return walletkit.respondSessionRequest({
            topic,
            response: await approveNearRequest(requestEvent)
          })

        case TRON_SIGNING_METHODS.TRON_SIGN_MESSAGE:
        case TRON_SIGNING_METHODS.TRON_SIGN_TRANSACTION:
          return ModalStore.open('SessionSignTronModal', { requestEvent, requestSession })
        case TEZOS_SIGNING_METHODS.TEZOS_GET_ACCOUNTS:
        case TEZOS_SIGNING_METHODS.TEZOS_SEND:
        case TEZOS_SIGNING_METHODS.TEZOS_SIGN:
          return ModalStore.open('SessionSignTezosModal', { requestEvent, requestSession })
        case KADENA_SIGNING_METHODS.KADENA_GET_ACCOUNTS:
        case KADENA_SIGNING_METHODS.KADENA_SIGN:
        case KADENA_SIGNING_METHODS.KADENA_QUICKSIGN:
          return ModalStore.open('SessionSignKadenaModal', { requestEvent, requestSession })
        case BIP122_SIGNING_METHODS.BIP122_SIGN_MESSAGE:
          return ModalStore.open('SessionSignBip122Modal', { requestEvent, requestSession })
        case BIP122_SIGNING_METHODS.BIP122_GET_ACCOUNT_ADDRESSES:
          return ModalStore.open('SessionGetBip122AddressesModal', { requestEvent, requestSession })
        case BIP122_SIGNING_METHODS.BIP122_SIGN_PSBT:
        case BIP122_SIGNING_METHODS.BIP122_SEND_TRANSACTION:
          return ModalStore.open('SessionSendTransactionBip122Modal', {
            requestEvent,
            requestSession
          })
        default:
          return ModalStore.open('SessionUnsuportedMethodModal', { requestEvent, requestSession })
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  )

  const onSessionAuthenticate = useCallback(
    (authRequest: SignClientTypes.EventArguments['session_authenticate']) => {
      ModalStore.open('SessionAuthenticateModal', { authRequest })
    },
    []
  )

  /******************************************************************************
   * Set up WalletConnect event listeners
   *****************************************************************************/
  useEffect(() => {
    if (initialized && walletkit) {
      //sign
      walletkit.on('session_proposal', onSessionProposal)
      walletkit.on('session_request', onSessionRequest)
      // TODOs
      walletkit.engine.signClient.events.on('session_ping', data => console.log('ping', data))
      walletkit.on('session_delete', data => {
        console.log('session_delete event received', data)
        refreshSessionsList()
      })
      walletkit.on('session_authenticate', onSessionAuthenticate)
      // load sessions on init
      refreshSessionsList()
    }
  }, [initialized, onSessionAuthenticate, onSessionProposal, onSessionRequest])
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/builders/ContextBuilderUtil.ts">
import {
  MOCK_POLICY,
  MULTIKEY_SIGNER_ADDRESSES,
  TIME_FRAME_POLICY_ADDRESSES
} from './SmartSessionUtil'
import type { Session, ChainSession, Account, ActionData, PolicyData } from '@rhinestone/module-sdk'
const {
  SMART_SESSIONS_ADDRESS,
  SmartSessionMode,
  encode1271Hash,
  getPermissionId,
  getSessionDigest,
  getSessionNonce,
  encodeSmartSessionSignature,
  hashChainSessions
} = require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')
import {
  type Hex,
  PublicClient,
  type WalletClient,
  concat,
  encodeAbiParameters,
  encodePacked,
  getAbiItem,
  toBytes,
  toFunctionSelector,
  toHex
} from 'viem'
import { publicKeyToAddress } from 'viem/accounts'
import { parsePublicKey as parsePasskeyPublicKey } from 'webauthn-p256'
import {
  MultiKeySigner,
  Permission,
  Signer,
  SmartSessionGrantPermissionsRequest,
  ContractCallPermission,
  NativeTokenRecurringAllowancePermission,
  ERC20RecurringAllowancePermission
} from '@reown/appkit-experimental/smart-session'
import { SignerKeyType } from '@/data/EIP7715Data'

// Constants for error messages
const ERROR_MESSAGES = {
  CHAIN_UNDEFINED: 'getContext: chain is undefined',
  MISMATCHED_CHAIN_ID: 'getContext: chain mismatch',
  ACCOUNT_UNDEFINED: 'getContext: Wallet account is undefined',
  CONTRACT_ADDRESS_UNDEFINED: 'Contract address is undefined',
  FUNCTIONS_UNDEFINED: 'Functions is undefined',
  UNSUPPORTED_SIGNER_TYPE: 'Unsupported signer type',
  INVALID_SIGNATURE: 'Invalid signature',
  FUNCTION_ABI_NOT_FOUND: (functionName: string) =>
    `Function ABI not found for function: ${functionName}`,
  UNSUPPORTED_KEY_TYPE: (keyType: string) => `Unsupported key type: ${keyType}`,
  UNSUPPORTED_PERMISSION_TYPE: (permissionType: string) =>
    `Unsupported permission type: ${permissionType}. Only 'contract-call' is allowed.`
}
// 32 byte salt for the session
const SESSION_SALT = toHex(toBytes('1', { size: 32 }))

// Build a ChainSession from given parameters
function buildChainSession(
  chainId: number,
  session: Session,
  accountAddress: Hex,
  sessionNonce: bigint
): ChainSession {
  return {
    chainId: BigInt(chainId),
    session: {
      ...session,
      account: accountAddress,
      smartSession: SMART_SESSIONS_ADDRESS,
      mode: parseInt(SmartSessionMode.ENABLE, 16),
      nonce: sessionNonce
    }
  }
}

// Fetch session data using the WalletClient
async function fetchSessionData(
  publicClient: PublicClient,
  account: Account,
  session: Session
): Promise<{ sessionNonce: bigint; sessionDigest: Hex; permissionId: Hex }> {
  const permissionId = (await getPermissionId({ session })) as Hex
  const sessionNonce = await getSessionNonce({ client: publicClient, account, permissionId })
  const sessionDigest = await getSessionDigest({
    client: publicClient,
    account,
    session,
    mode: SmartSessionMode.ENABLE,
    permissionId
  })

  return { sessionNonce, sessionDigest, permissionId }
}

/**
 *  1. Check if walletClient account is defined,
 *   Note - currently walletClient account is the smartAccountSigner address not smartAccount
 *  2. Check if walletClient chain is same as permissions request chain
 *
 * @param walletClient
 * @param param
 * @returns
 */
export async function getContext(
  publicClient: PublicClient,
  walletClient: WalletClient,
  {
    account,
    grantPermissionsRequest
  }: { account: Account; grantPermissionsRequest: SmartSessionGrantPermissionsRequest }
): Promise<Hex> {
  if (!walletClient.account) throw new Error(ERROR_MESSAGES.ACCOUNT_UNDEFINED)

  const { chainId: hexChainId } = grantPermissionsRequest
  if (!walletClient.chain || !publicClient.chain || !hexChainId)
    throw new Error(ERROR_MESSAGES.CHAIN_UNDEFINED)
  if (toHex(walletClient.chain.id) !== hexChainId || toHex(publicClient.chain.id) !== hexChainId)
    throw new Error(ERROR_MESSAGES.MISMATCHED_CHAIN_ID)

  const session: Session = getSmartSession(grantPermissionsRequest)

  // Fetch session data
  const { sessionNonce, sessionDigest, permissionId } = await fetchSessionData(
    publicClient,
    account,
    session
  )

  // Build chain session and hash it
  const chainSession = buildChainSession(
    walletClient.chain.id,
    session,
    account.address,
    sessionNonce
  )
  const chainSessionHash = hashChainSessions([chainSession])

  // Encode chain session hash
  const encodedChainSessionHash = encode1271Hash({
    account,
    chainId: walletClient.chain.id,
    validator: account.address,
    hash: chainSessionHash
  })

  // Validate wallet account
  if (!walletClient.account) throw new Error(ERROR_MESSAGES.ACCOUNT_UNDEFINED)

  // Sign the message
  const encodedChainSessionSignature = await walletClient.signMessage({
    account: walletClient.account,
    message: { raw: toBytes(encodedChainSessionHash) }
  })

  // Adjust the signature
  const permissionEnableSignature = adjustVInSignature('eth_sign', encodedChainSessionSignature)
  const encodedSmartSessionSignature = encodeSmartSessionSignature({
    mode: SmartSessionMode.ENABLE,
    permissionId,
    signature: '0x',
    enableSessionData: {
      enableSession: {
        chainDigestIndex: 0,
        hashesAndChainIds: [{ chainId: BigInt(walletClient.chain.id), sessionDigest }],
        sessionToEnable: session,
        permissionEnableSig: permissionEnableSignature
      },
      validator: account.address,
      accountType: account.type
    }
  })

  // Return the encoded packed data - this is the permission context which will be used for preparing the calls
  return encodePacked(['address', 'bytes'], [SMART_SESSIONS_ADDRESS, encodedSmartSessionSignature])
}

// Adjust the V value in the signature
const adjustVInSignature = (
  signingMethod: 'eth_sign' | 'eth_signTypedData',
  signature: string
): Hex => {
  const ETHEREUM_V_VALUES = [0, 1, 27, 28]
  const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27

  let signatureV = Number.parseInt(signature.slice(-2), 16)

  // Validate V value
  if (!ETHEREUM_V_VALUES.includes(signatureV)) throw new Error(ERROR_MESSAGES.INVALID_SIGNATURE)

  // Adjust the signature based on the signing method
  if (signingMethod === 'eth_sign') {
    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA
    }
    signatureV += 4
  } else if (signingMethod === 'eth_signTypedData') {
    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA
    }
  }

  // Return the adjusted signature
  return (signature.slice(0, -2) + signatureV.toString(16)) as Hex
}

/**
 * This method transforms the SmartSessionGrantPermissionsRequest into a Session object
 * The Session object includes permittied actions and policies.
 * It also includes the Session Validator Address(MultiKeySigner module) and Init Data needed for setting up the module.
 * @param SmartSessionGrantPermissionsRequest
 * @returns
 */
function getSmartSession({
  chainId,
  expiry,
  permissions,
  signer
}: SmartSessionGrantPermissionsRequest): Session {
  const chainIdNumber = parseInt(chainId, 16)
  const actions = getActionsFromPermissions(permissions, chainIdNumber, expiry)
  const sessionValidator = getSessionValidatorAddress(signer, chainIdNumber)
  const sessionValidatorInitData = getSessionValidatorInitData(signer)

  return {
    chainId: BigInt(chainId),
    sessionValidator,
    sessionValidatorInitData,
    salt: SESSION_SALT,
    userOpPolicies: [],
    actions,
    erc7739Policies: {
      allowedERC7739Content: [],
      erc1271Policies: []
    }
  }
}

// Type Guard for MultiKey Signer
function isMultiKeySigner(signer: Signer): signer is MultiKeySigner {
  return signer.type === 'keys'
}

/**
 *  This method processes the MultiKeySigner object from the permissions request and returns an array of SignerKeyType and data
 * @param signer
 * @returns
 */
function processMultiKeySigner(signer: MultiKeySigner): { type: SignerKeyType; data: string }[] {
  return signer.data.keys.map(key => {
    switch (key.type) {
      case 'secp256k1':
        return {
          type: SignerKeyType.SECP256K1,
          data: publicKeyToAddress(key.publicKey)
        }
      case 'secp256r1':
        const { x, y } = parsePasskeyPublicKey(key.publicKey as Hex)
        return {
          type: SignerKeyType.SECP256R1,
          data: encodeAbiParameters([{ type: 'uint256' }, { type: 'uint256' }], [x, y])
        }
      default:
        throw new Error(ERROR_MESSAGES.UNSUPPORTED_KEY_TYPE(key.type))
    }
  })
}

/**
 *  Get the Session Validator Address, based on signer type in permissions request
 *  Note - Currently only MultiKeySigner is supported
 */
function getSessionValidatorAddress(signer: Signer, chainId: number): Hex {
  if (isMultiKeySigner(signer)) {
    return MULTIKEY_SIGNER_ADDRESSES[chainId]
  }
  throw new Error(ERROR_MESSAGES.UNSUPPORTED_SIGNER_TYPE)
}

/**
 *  Get the Session Validator Init Data, based on signer type in permissions request
 *  Note - Currently only MultiKeySigner is supported
 *  This method return the init data in a format which can be used to initialize the MultiKeySigner module
 * @param signer
 * @returns
 */
function getSessionValidatorInitData(signer: Signer): Hex {
  if (isMultiKeySigner(signer)) {
    const processedSigners = processMultiKeySigner(signer)
    return encodeMultiKeySignersInitData(processedSigners)
  }
  throw new Error(ERROR_MESSAGES.UNSUPPORTED_SIGNER_TYPE)
}

/**
 * This method encodes the signers array into a format which can be used to initialize the MultiKeySigner module
 * @param signers
 * @returns
 */
function encodeMultiKeySignersInitData(signers: { type: SignerKeyType; data: string }[]): Hex {
  return signers.reduce(
    (encoded, signer) =>
      concat([encoded, encodePacked(['uint8', 'bytes'], [signer.type, signer.data as Hex])]),
    encodePacked(['uint8'], [signers.length]) as Hex
  )
}

// Type Guard for Contract Call Permissions
function isContractCallPermission(permission: Permission): permission is ContractCallPermission {
  return permission.type === 'contract-call'
}

function isNativeTokenRecurringAllowancePermission(
  permission: Permission
): permission is NativeTokenRecurringAllowancePermission {
  return permission.type === 'native-token-recurring-allowance'
}

function isERC20RecurringAllowancePermission(
  permission: Permission
): permission is ERC20RecurringAllowancePermission {
  return permission.type === 'erc20-recurring-allowance'
}

/**
 *  This method processes the permissions array from the permissions request and returns the actions array
 *  Note - For each permission, it creates an action data
 *       - It also adds the TIME_FRAME_POLICY for each action as the actionPolicy
 *        - The expiry time indicated in the permissions request is used as the expiry time for the actions
 * @param permissions - Permissions array from the permissions request
 * @param chainId - Chain ID on which the actions are to be performed
 * @param expiry - Expiry time for the actions
 * @returns
 */
function getActionsFromPermissions(
  permissions: Permission[],
  chainId: number,
  expiry: number
): ActionData[] {
  return permissions.reduce((actions: ActionData[], permission) => {
    switch (true) {
      case isContractCallPermission(permission):
        actions.push(
          ...createActionForContractCall(permission as ContractCallPermission, chainId, expiry)
        )
        break

      case isNativeTokenRecurringAllowancePermission(permission):
      case isERC20RecurringAllowancePermission(permission):
        actions.push(...createFallbackActionData(permission, chainId, expiry))
        break

      default:
        throw new Error(ERROR_MESSAGES.UNSUPPORTED_PERMISSION_TYPE(JSON.stringify(permission)))
    }

    return actions
  }, [])
}

// Create Action for Contract Call Permission
function createActionForContractCall(
  permission: ContractCallPermission,
  chainId: number,
  expiry: number
): ActionData[] {
  if (!permission.data.address) throw new Error(ERROR_MESSAGES.CONTRACT_ADDRESS_UNDEFINED)
  if (!permission.data.functions || permission.data.functions.length === 0)
    throw new Error(ERROR_MESSAGES.FUNCTIONS_UNDEFINED)

  return permission.data.functions.map(functionPermission => {
    const functionName = functionPermission.functionName
    const abi = permission.data.abi
    const functionAbi = getAbiItem({ abi, name: functionName })

    if (!functionAbi || functionAbi.type !== 'function') {
      throw new Error(ERROR_MESSAGES.FUNCTION_ABI_NOT_FOUND(functionName))
    }

    const functionSelector = toFunctionSelector(functionAbi)

    return {
      actionTarget: permission.data.address,
      actionTargetSelector: functionSelector,
      // Need atleast 1 actionPolicy, so hardcoding the TIME_FRAME_POLICY for now
      actionPolicies: [
        {
          policy: TIME_FRAME_POLICY_ADDRESSES[chainId],
          initData: encodePacked(['uint128', 'uint128'], [BigInt(expiry), BigInt(0)])
        }
      ]
    }
  })
}

/**
 * This is a fallback action data which will be used to skip the functionSelector and address check.
 * */
function createFallbackActionData(
  permission: Permission,
  chainId: number,
  expiry: number
): ActionData[] {
  const fallbackActionSelector = '0x00000001'
  const fallbackActionAddress = '0x0000000000000000000000000000000000000001'

  return [
    {
      actionTarget: fallbackActionAddress,
      actionTargetSelector: fallbackActionSelector,
      // Need atleast 1 actionPolicy, so hardcoding the TIME_FRAME_POLICY for now
      actionPolicies: [
        {
          policy: TIME_FRAME_POLICY_ADDRESSES[chainId],
          initData: encodePacked(['uint128', 'uint128'], [BigInt(expiry), BigInt(0)])
        }
      ]
    }
  ]
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/builders/CosignerService.ts">
import axios, { Method, AxiosError } from 'axios'
import { UserOperationWithBigIntAsHex } from './UserOpBuilder'
import { bigIntReplacer } from '@/utils/HelperUtil'
import { COSIGNER_BASE_URL } from '@/utils/ConstantsUtil'
import { SmartSessionGrantPermissionsRequest } from '@reown/appkit-experimental/smart-session'

//--Cosigner Types----------------------------------------------------------------------- //
export type AddPermissionRequest = SmartSessionGrantPermissionsRequest

export type AddPermissionResponse = {
  pci: string
  key: {
    type: KeyType
    publicKey: `0x${string}`
  }
}

export type ActivatePermissionsRequest = {
  pci: string
  context: `0x${string}`
} & AddPermissionRequest

type RevokePermissionRequest = {
  pci: string
  signature: string
}

type CoSignRequest = {
  pci: string
  userOp: UserOperationWithBigIntAsHex
}

type CoSignResponse = {
  signature: `0x${string}`
}

type GetPermissionsContextRequest = {
  pci: string
}

type GetPermissionsContextResponse = {
  context: `0x${string}`
}

type GetPermissionsResponse = {
  pci: string[]
}

// -- Custom Error Class --------------------------------------------------- //
export class CoSignerApiError extends Error {
  constructor(public status: number, message: string) {
    super(message)
    this.name = 'CoSignerApiError'
  }
}

// -- Helper Function for API Requests ------------------------------------- //
export async function sendCoSignerRequest<
  TRequest,
  TResponse,
  TQueryParams extends Record<string, string>
>({
  url,
  method,
  request,
  queryParams = {} as TQueryParams,
  headers,
  transformRequest
}: {
  url: string
  method: Method
  request?: TRequest
  queryParams?: TQueryParams
  headers: Record<string, string>
  transformRequest?: (data: TRequest) => unknown
}): Promise<TResponse> {
  try {
    const config = {
      method,
      url,
      params: queryParams,
      headers,
      data:
        method !== 'GET'
          ? transformRequest
            ? transformRequest(request as TRequest)
            : request
          : undefined
    }

    const response = await axios(config)
    return response.data
  } catch (error) {
    if (axios.isAxiosError(error)) {
      const axiosError = error as AxiosError
      if (axiosError.response) {
        throw new CoSignerApiError(
          axiosError.response.status,
          JSON.stringify(axiosError.response.data)
        )
      } else {
        throw new CoSignerApiError(500, 'Network error')
      }
    }
    throw error
  }
}

// Class to interact with the WalletConnect CoSigner API
export class CosignerService {
  private baseUrl: string
  private projectId: string

  constructor(projectId: string) {
    this.baseUrl = COSIGNER_BASE_URL
    this.projectId = projectId
  }

  async addPermission(address: string, data: AddPermissionRequest): Promise<AddPermissionResponse> {
    const url = `${this.baseUrl}/${encodeURIComponent(address)}`

    return await sendCoSignerRequest<
      AddPermissionRequest,
      AddPermissionResponse,
      { projectId: string }
    >({
      url,
      method: 'POST',
      request: data,
      queryParams: { projectId: this.projectId },
      headers: { 'Content-Type': 'application/json' }
    })
  }

  async activatePermissions(
    address: string,
    updateData: ActivatePermissionsRequest
  ): Promise<void> {
    const url = `${this.baseUrl}/${encodeURIComponent(address)}/activate`
    await sendCoSignerRequest<ActivatePermissionsRequest, never, { projectId: string }>({
      url,
      method: 'POST',
      request: updateData,
      queryParams: { projectId: this.projectId },
      headers: { 'Content-Type': 'application/json' }
    })
  }

  async coSignUserOperation(address: string, coSignData: CoSignRequest): Promise<CoSignResponse> {
    const url = `${this.baseUrl}/${encodeURIComponent(address)}/sign`

    return await sendCoSignerRequest<CoSignRequest, CoSignResponse, { projectId: string }>({
      url,
      method: 'POST',
      request: coSignData,
      queryParams: { projectId: this.projectId },
      headers: { 'Content-Type': 'application/json' },
      transformRequest: (value: CoSignRequest) => JSON.stringify(value, bigIntReplacer)
    })
  }

  async getPermissionsContext(
    address: string,
    getPermissionsContextRequest: GetPermissionsContextRequest
  ): Promise<GetPermissionsContextResponse> {
    // need to change the method to use POST method and pass pci in the body with url as /{address}/getContext
    const url = `${this.baseUrl}/${encodeURIComponent(address)}/getcontext`
    return await sendCoSignerRequest<
      never,
      GetPermissionsContextResponse,
      { projectId: string; pci: string }
    >({
      url,
      method: 'GET',
      // request: getPermissionsContextRequest,
      queryParams: { projectId: this.projectId, pci: getPermissionsContextRequest.pci },
      headers: { 'Content-Type': 'application/json' }
    })
  }

  async getPermissions(address: string): Promise<GetPermissionsResponse> {
    const url = `${this.baseUrl}/${encodeURIComponent(address)}`
    return await sendCoSignerRequest<never, GetPermissionsResponse, { projectId: string }>({
      url,
      method: 'GET',
      queryParams: { projectId: this.projectId },
      headers: { 'Content-Type': 'application/json' }
    })
  }

  async revokePermission(address: string, revokeData: RevokePermissionRequest): Promise<void> {
    const url = `${this.baseUrl}/${encodeURIComponent(address)}/revoke`
    await sendCoSignerRequest<RevokePermissionRequest, never, { projectId: string }>({
      url,
      method: 'POST',
      request: revokeData,
      queryParams: { projectId: this.projectId },
      headers: { 'Content-Type': 'application/json' }
    })
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/builders/SafeUserOpBuilder.ts">
import { generatePrivateKey, privateKeyToAccount, signMessage } from 'viem/accounts'
import {
  PrepareCallsParams,
  PrepareCallsReturnValue,
  SendPreparedCallsParams,
  SendPreparedCallsReturnValue,
  UserOpBuilder,
  UserOperationWithBigIntAsHex
} from './UserOpBuilder'
import {
  Address,
  Chain,
  createPublicClient,
  encodeAbiParameters,
  Hex,
  http,
  parseAbi,
  PublicClient,
  toHex,
  trim
} from 'viem'
import { signerToSafeSmartAccount } from 'permissionless/accounts'
import {
  createSmartAccountClient,
  ENTRYPOINT_ADDRESS_V07,
  getUserOperationHash
} from 'permissionless'
import {
  createPimlicoBundlerClient,
  createPimlicoPaymasterClient
} from 'permissionless/clients/pimlico'
import { bundlerUrl, paymasterUrl, publicClientUrl } from '@/utils/SmartAccountUtil'
import { getChainById } from '@/utils/ChainUtil'
import { SAFE_FALLBACK_HANDLER_STORAGE_SLOT } from '@/consts/smartAccounts'
import { formatSignature, getDummySignature, getNonce } from './UserOpBuilderUtil'
import { CosignerService } from './CosignerService'
const { getAccount } = require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')

const ERC_7579_LAUNCHPAD_ADDRESS: Address = '0xEBe001b3D534B9B6E2500FB78E67a1A137f561CE'

export class SafeUserOpBuilder implements UserOpBuilder {
  protected chain: Chain
  protected publicClient: PublicClient
  protected accountAddress: Address

  constructor(accountAddress: Address, chainId: number) {
    this.chain = getChainById(chainId)
    this.publicClient = createPublicClient({
      transport: http(publicClientUrl({ chain: this.chain }))
    })
    this.accountAddress = accountAddress
  }
  async prepareCalls(
    projectId: string,
    params: PrepareCallsParams
  ): Promise<PrepareCallsReturnValue> {
    const privateKey = generatePrivateKey()
    const signer = privateKeyToAccount(privateKey)

    let erc7579LaunchpadAddress: Address
    const safe4337ModuleAddress = await this.getFallbackHandlerAddress()
    const is7579Safe = await this.is7579Safe()

    if (is7579Safe) {
      erc7579LaunchpadAddress = ERC_7579_LAUNCHPAD_ADDRESS
    }

    const version = await this.getVersion()
    const safeAccount = await signerToSafeSmartAccount(this.publicClient, {
      entryPoint: ENTRYPOINT_ADDRESS_V07,
      signer: signer,
      //@ts-ignore
      safeVersion: version,
      address: this.accountAddress,
      safe4337ModuleAddress,
      //@ts-ignore
      erc7579LaunchpadAddress
    })
    const paymasterClient = createPimlicoPaymasterClient({
      transport: http(paymasterUrl({ chain: this.chain }), {
        timeout: 30000
      }),
      entryPoint: ENTRYPOINT_ADDRESS_V07
    })

    const bundlerTransport = http(bundlerUrl({ chain: this.chain }), {
      timeout: 30000
    })
    const pimlicoBundlerClient = createPimlicoBundlerClient({
      transport: bundlerTransport,
      entryPoint: ENTRYPOINT_ADDRESS_V07
    })
    const smartAccountClient = createSmartAccountClient({
      account: safeAccount,
      entryPoint: ENTRYPOINT_ADDRESS_V07,
      chain: this.chain,
      bundlerTransport,
      middleware: {
        sponsorUserOperation: paymasterClient.sponsorUserOperation,
        gasPrice: async () => (await pimlicoBundlerClient.getUserOperationGasPrice()).fast // if using pimlico bundler
      }
    })

    const account = getAccount({
      address: smartAccountClient.account.address,
      type: 'safe'
    })

    const pci = params.capabilities.permissions?.context!
    const cosignerService = new CosignerService(projectId)
    const caip10AccountAddress = `eip155:${this.chain.id}:${this.accountAddress}`
    const permissionsContext = await cosignerService.getPermissionsContext(caip10AccountAddress, {
      pci
    })
    let nonce: bigint = await getNonce({
      publicClient: this.publicClient,
      account,
      permissionsContext: permissionsContext.context
    })
    const callData = await smartAccountClient.account.encodeCallData(
      params.calls.map(call => ({
        to: call.to,
        value: BigInt(call.value),
        data: call.data
      }))
    )

    const dummySignature = await getDummySignature({
      publicClient: this.publicClient,
      account,
      permissionsContext: permissionsContext.context
    })
    const userOp = await smartAccountClient.prepareUserOperationRequest({
      userOperation: {
        nonce: nonce,
        callData: callData,
        signature: dummySignature
      },
      account: smartAccountClient.account
    })
    const hash = getUserOperationHash({
      userOperation: userOp,
      chainId: this.chain.id,
      entryPoint: ENTRYPOINT_ADDRESS_V07
    })

    return {
      context: params.capabilities.permissions?.context!,
      preparedCalls: {
        chainId: toHex(this.chain.id),
        type: 'user-operation-v07',
        data: userOp
      },
      signatureRequest: {
        hash: hash
      }
    }
  }

  async sendPreparedCalls(
    projectId: string,
    params: SendPreparedCallsParams
  ): Promise<SendPreparedCallsReturnValue> {
    try {
      const { context, preparedCalls, signature } = params
      const { chainId, data, type } = preparedCalls
      const chainIdNumber = parseInt(chainId)
      if (type !== 'user-operation-v07') {
        throw new Error('Invalid preparedCalls type')
      }

      //Get PermissionsContext from WalletConnectCosigner given pci
      const pci = context
      const cosignerService = new CosignerService(projectId)
      const caip10AccountAddress = `eip155:${this.chain.id}:${this.accountAddress}`
      const permissionsContext = await cosignerService.getPermissionsContext(caip10AccountAddress, {
        pci
      })
      if (pci && projectId) {
        const userOpWithBigIntAsHex: UserOperationWithBigIntAsHex = {
          ...data,
          nonce: toHex(BigInt(data.nonce)),
          callGasLimit: toHex(BigInt(data.callGasLimit)),
          verificationGasLimit: toHex(BigInt(data.verificationGasLimit)),
          preVerificationGas: toHex(BigInt(data.preVerificationGas)),
          maxFeePerGas: toHex(BigInt(data.maxFeePerGas)),
          maxPriorityFeePerGas: toHex(BigInt(data.maxPriorityFeePerGas)),
          paymasterPostOpGasLimit: data.paymasterPostOpGasLimit
            ? toHex(BigInt(data.paymasterPostOpGasLimit))
            : undefined,
          paymasterVerificationGasLimit: data.paymasterVerificationGasLimit
            ? toHex(BigInt(data.paymasterVerificationGasLimit))
            : undefined,
          factory: data.factory,
          factoryData: data.factoryData,
          paymaster: data.paymaster,
          paymasterData: data.paymasterData,
          signature: signature
        }
        const cosignerService = new CosignerService(projectId)
        const caip10AccountAddress = `eip155:${chainIdNumber}:${userOpWithBigIntAsHex.sender}`
        const cosignResponse = await cosignerService.coSignUserOperation(caip10AccountAddress, {
          pci,
          userOp: userOpWithBigIntAsHex
        })
        data.signature = cosignResponse.signature
      }

      const account = getAccount({
        address: data.sender,
        type: 'safe'
      })

      if (permissionsContext.context) {
        const formattedSignature = await formatSignature({
          publicClient: this.publicClient,
          account,
          modifiedSignature: data.signature,
          permissionsContext: permissionsContext.context
        })
        data.signature = formattedSignature
      }

      const bundlerTransport = http(bundlerUrl({ chain: this.chain }), {
        timeout: 30000
      })
      const pimlicoBundlerClient = createPimlicoBundlerClient({
        chain: this.chain,
        transport: bundlerTransport,
        entryPoint: ENTRYPOINT_ADDRESS_V07
      })

      const userOpId = await pimlicoBundlerClient.sendUserOperation({
        userOperation: {
          ...data,
          signature: data.signature,
          callGasLimit: BigInt(data.callGasLimit),
          nonce: BigInt(data.nonce),
          preVerificationGas: BigInt(data.preVerificationGas),
          verificationGasLimit: BigInt(data.verificationGasLimit),
          maxFeePerGas: BigInt(data.maxFeePerGas),
          maxPriorityFeePerGas: BigInt(data.maxPriorityFeePerGas),
          paymasterVerificationGasLimit:
            data.paymasterVerificationGasLimit && BigInt(data.paymasterVerificationGasLimit),
          paymasterPostOpGasLimit:
            data.paymasterPostOpGasLimit && BigInt(data.paymasterPostOpGasLimit)
        }
      })

      return `${toHex(this.chain.id)}:${userOpId}`
    } catch (e) {
      console.log(e)
      throw new Error('Failed to sign user operation with cosigner')
    }
  }

  private async getVersion(): Promise<string> {
    const version = await this.publicClient.readContract({
      address: this.accountAddress,
      abi: parseAbi(['function VERSION() view returns (string)']),
      functionName: 'VERSION',
      args: []
    })
    return version
  }

  private async is7579Safe(): Promise<boolean> {
    const accountId = await this.publicClient.readContract({
      address: this.accountAddress,
      abi: parseAbi([
        'function accountId() external view returns (string memory accountImplementationId)'
      ]),
      functionName: 'accountId',
      args: []
    })
    if (accountId.includes('7579') && accountId.includes('safe')) {
      return true
    }
    return false
  }

  private async getFallbackHandlerAddress(): Promise<Address> {
    const value = await this.publicClient.getStorageAt({
      address: this.accountAddress,
      slot: SAFE_FALLBACK_HANDLER_STORAGE_SLOT
    })
    return trim(value as Hex)
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/builders/SmartSessionUtil.ts">
import { Address } from 'viem'
import { baseSepolia, sepolia } from 'viem/chains'

export const TIME_FRAME_POLICY_ADDRESSES: Record<number, Address> = {
  [baseSepolia.id]: '0x9A6c4974dcE237E01Ff35c602CA9555a3c0Fa5EF',
  [sepolia.id]: '0x6E1FCe0ec6feaD8dBD2D36a5b9eCf8e33A538479'
}

export const MULTIKEY_SIGNER_ADDRESSES: Record<number, Address> = {
  [baseSepolia.id]: '0xcaF0461410340F8F366f1F7F7716cF1D90b6bdA4',
  [sepolia.id]: '0x3cA2D7D588FA66248a49c1C885997e5017aF9Dc7'
}

export const MOCK_VALIDATOR_ADDRESSES: Record<number, Address> = {
  [baseSepolia.id]: '0x8F8842B9b7346529484F282902Af173217411076',
  [sepolia.id]: '0xaE15a31afb2770cE4c5C6131925564B03b597Fe3'
}

// All on sepolia
export const SIMPLE_SIGNER = '0x6ff7E9992160bB25f5c67b0Ce389c28d8faD3Bfb' as Address
export const MOCK_POLICY = '0xCBdFFA1e3b0bebAD9ea917910322332B2cfaeC26' as Address
export const UNI_ACTION_POLICY = '0x237C7567Ac09D4DB7Dd48852a438F77a6bd65fc4' as Address
export const USAGE_LIMIT_POLICY = '0x1f265E3beDc6ce93e1A36Dc80E1B1c65844F9861' as Address
export const VALUE_LIMIT_POLICY = '0x6F0eC0c77cCAF4c25ff8FF7113D329caAA769688' as Address

export const TRUSTED_SMART_SESSIONS_ATTERSTER_ADDRESS =
  '0xA4C777199658a41688E9488c4EcbD7a2925Cc23A' as Address
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/builders/UserOpBuilder.ts">
import { Address, Hex } from 'viem'

export type UserOperationWithBigIntAsHex = {
  sender: Address
  nonce: Hex
  factory: Address | undefined
  factoryData: Hex | undefined
  callData: Hex
  callGasLimit: Hex
  verificationGasLimit: Hex
  preVerificationGas: Hex
  maxFeePerGas: Hex
  maxPriorityFeePerGas: Hex
  paymaster: Address | undefined
  paymasterVerificationGasLimit: Hex | undefined
  paymasterPostOpGasLimit: Hex | undefined
  paymasterData: Hex | undefined
  signature: Hex
  initCode?: never
  paymasterAndData?: never
}
export type ErrorResponse = {
  message: string
  error: string
}

export type PrepareCallsParams = {
  from: `0x${string}`
  chainId: `0x${string}`
  calls: {
    to: `0x${string}`
    data: `0x${string}`
    value: `0x${string}`
  }[]
  capabilities: Record<string, any>
}

export type PrepareCallsReturnValue = {
  preparedCalls: {
    type: string
    data: any
    chainId: `0x${string}`
  }
  signatureRequest: {
    hash: `0x${string}` // hash value of userOperation
  }
  context: string
}

export type SendPreparedCallsParams = {
  preparedCalls: {
    type: string
    data: any // userOp
    chainId: `0x${string}`
  }
  signature: `0x${string}`
  context: `0x${string}`
}

export type SendPreparedCallsReturnValue = string

export type GetCallsStatusParams = string
export type GetCallsStatusReturnValue = {
  status: 'PENDING' | 'CONFIRMED'
  receipts?: {
    logs: {
      address: `0x${string}`
      data: `0x${string}`
      topics: `0x${string}`[]
    }[]
    status: `0x${string}` // Hex 1 or 0 for success or failure, respectively
    blockHash: `0x${string}`
    blockNumber: `0x${string}`
    gasUsed: `0x${string}`
    transactionHash: `0x${string}`
  }[]
}
export interface UserOpBuilder {
  prepareCalls(projectId: string, params: PrepareCallsParams): Promise<PrepareCallsReturnValue>
  sendPreparedCalls(
    projectId: string,
    params: SendPreparedCallsParams
  ): Promise<SendPreparedCallsReturnValue>
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/builders/UserOpBuilderUtil.ts">
import type { Account } from '@rhinestone/module-sdk'
const {
  SMART_SESSIONS_ADDRESS,
  encodeUseOrEnableSmartSessionSignature,
  decodeSmartSessionSignature
} = require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')
import { encodeAbiParameters, Hex, pad, PublicClient, slice } from 'viem'
import { ENTRYPOINT_ADDRESS_V07, getAccountNonce } from 'permissionless'

type GetNonceWithContextParams = {
  publicClient: PublicClient
  account: Account
  permissionsContext: Hex
}
type GetDummySignatureParams = {
  publicClient: PublicClient
  permissionsContext: Hex
  account: Account
}
type FormatSignatureParams = {
  publicClient: PublicClient
  modifiedSignature: Hex
  permissionsContext: Hex
  account: Account
}

export async function getDummySignature({
  publicClient,
  permissionsContext,
  account
}: GetDummySignatureParams) {
  const validatorAddress = slice(permissionsContext, 0, 20)
  if (validatorAddress.toLowerCase() !== SMART_SESSIONS_ADDRESS.toLowerCase()) {
    throw new Error('getDummySignature:Invalid permission context')
  }

  const smartSessionSignature = slice(permissionsContext, 20)
  const { permissionId, enableSessionData } = decodeSmartSessionSignature({
    signature: smartSessionSignature,
    account: account
  })
  if (!enableSessionData) {
    throw new Error('EnableSessionData is undefined, invalid smartSessionSignature')
  }
  const signerValidatorInitData =
    enableSessionData?.enableSession.sessionToEnable.sessionValidatorInitData
  const signers = decodeSigners(signerValidatorInitData)
  const dummySignatures: `0x${string}`[] = []
  const dummyECDSASignature: `0x${string}` =
    '0xe8b94748580ca0b4993c9a1b86b5be851bfc076ff5ce3a1ff65bf16392acfcb800f9b4f1aef1555c7fce5599fffb17e7c635502154a0333ba21f3ae491839af51c'
  const dummyPasskeySignature: `0x${string}` =
    '0x00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000001635bc6d0f68ff895cae8a288ecf7542a6a9cd555df784b73e1e2ea7e9104b1db15e9015d280cb19527881c625fee43fd3a405d5b0d199a8c8e6589a7381209e40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97631d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f47b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a22746278584e465339585f3442797231634d77714b724947422d5f3330613051685a36793775634d30424f45222c226f726967696e223a22687474703a2f2f6c6f63616c686f73743a33303030222c2263726f73734f726967696e223a66616c73652c20226f746865725f6b6579735f63616e5f62655f61646465645f68657265223a22646f206e6f7420636f6d7061726520636c69656e74446174614a534f4e20616761696e737420612074656d706c6174652e205365652068747470733a2f2f676f6f2e676c2f796162506578227d000000000000000000000000'
  for (let i = 0; i < signers.length; i++) {
    const signer = signers[i]
    if (signer.type === 0) {
      dummySignatures.push(dummyECDSASignature)
    } else if (signer.type === 1) {
      dummySignatures.push(dummyPasskeySignature)
    }
  }
  const concatenatedDummySignature = encodeAbiParameters([{ type: 'bytes[]' }], [dummySignatures])

  return await encodeUseOrEnableSmartSessionSignature({
    account: account,
    client: publicClient,
    enableSessionData: enableSessionData,
    permissionId: permissionId,
    signature: concatenatedDummySignature
  })
}
export async function formatSignature({
  publicClient,
  account,
  modifiedSignature,
  permissionsContext
}: FormatSignatureParams) {
  const validatorAddress = slice(permissionsContext, 0, 20)
  if (validatorAddress.toLowerCase() !== SMART_SESSIONS_ADDRESS.toLowerCase()) {
    throw new Error('formatSignature:Invalid permission context')
  }

  const smartSessionSignature = slice(permissionsContext, 20)
  const { permissionId, enableSessionData } = decodeSmartSessionSignature({
    signature: smartSessionSignature,
    account: account
  })

  if (!enableSessionData) {
    throw new Error('EnableSessionData is undefined, invalid smartSessionSignature')
  }

  return encodeUseOrEnableSmartSessionSignature({
    account: account,
    client: publicClient,
    enableSessionData: enableSessionData,
    permissionId: permissionId,
    signature: modifiedSignature
  })
}
export async function getNonce({
  publicClient,
  account,
  permissionsContext
}: GetNonceWithContextParams): Promise<bigint> {
  const chainId = await publicClient.getChainId()
  const validatorAddress = slice(permissionsContext, 0, 20)
  if (validatorAddress.toLowerCase() !== SMART_SESSIONS_ADDRESS.toLowerCase()) {
    throw new Error('getNonce:Invalid permission context')
  }

  return await getAccountNonce(publicClient, {
    sender: account.address,
    entryPoint: ENTRYPOINT_ADDRESS_V07,
    key: BigInt(
      pad(validatorAddress, {
        dir: 'right',
        size: 24
      }) || 0
    )
  })
}
function decodeSigners(encodedData: `0x${string}`): Array<{ type: number; data: `0x${string}` }> {
  let offset = 2 // Start after '0x'
  const signers: Array<{ type: number; data: `0x${string}` }> = []

  // Decode the number of signers
  const signersCount = parseInt(encodedData.slice(offset, offset + 2), 16)
  offset += 2

  for (let i = 0; i < signersCount; i++) {
    // Decode signer type
    const signerType = parseInt(encodedData.slice(offset, offset + 2), 16)
    offset += 2

    // Determine data length based on signer type
    let dataLength: number
    if (signerType === 0) {
      dataLength = 40 // 20 bytes
    } else if (signerType === 1) {
      dataLength = 128 // 64 bytes
    } else {
      throw new Error(`Unknown signer type: ${signerType}`)
    }

    // Decode signer data
    const signerData = `0x${encodedData.slice(offset, offset + dataLength)}` as `0x${string}`
    offset += dataLength

    signers.push({ type: signerType, data: signerData })
  }

  return signers
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/BiconomySmartAccountLib.ts">
import { ENTRYPOINT_ADDRESS_V06, SmartAccountClientConfig } from 'permissionless'
import { SmartAccountLib } from './SmartAccountLib'
import {
  SmartAccount,
  signerToBiconomySmartAccount,
  signerToSafeSmartAccount
} from 'permissionless/accounts'
import { EntryPoint } from 'permissionless/types/entrypoint'

export class BiconomySmartAccountLib extends SmartAccountLib {
  async getClientConfig(): Promise<SmartAccountClientConfig<EntryPoint>> {
    this.type = 'Biconomy'
    if (this.entryPoint !== ENTRYPOINT_ADDRESS_V06) {
      throw new Error('Only entrypoint V6 is supported')
    }

    const biconomyAccount = await signerToBiconomySmartAccount(this.publicClient, {
      entryPoint: this.entryPoint,
      signer: this.signer
    })

    return {
      account: biconomyAccount as SmartAccount<EntryPoint>,
      entryPoint: this.entryPoint,
      chain: this.chain,
      bundlerTransport: this.bundlerUrl,
      middleware: {
        gasPrice: async () => (await this.bundlerClient.getUserOperationGasPrice()).fast, // use pimlico bundler to get gas prices
        sponsorUserOperation: this.sponsored ? this.paymasterClient.sponsorUserOperation : undefined
      }
    }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/KernelSmartAccountLib.ts">
import { WalletGrantPermissionsParameters, WalletGrantPermissionsReturnType } from 'viem'
import { publicKeyToAddress } from 'viem/accounts'
import { KernelValidator, signerToEcdsaValidator } from '@zerodev/ecdsa-validator'
import { addressToEmptyAccount, createKernelAccount } from '@zerodev/sdk'
import { serializeSessionKeyAccount, signerToSessionKeyValidator } from '@zerodev/session-key'
import { getUpdateConfigCall } from '@zerodev/weighted-ecdsa-validator'
import { ENTRYPOINT_ADDRESS_V06, SmartAccountClientConfig } from 'permissionless'
import { EntryPoint } from 'permissionless/types/entrypoint'
import { KERNEL_V2_4, KERNEL_V3_1 } from '@zerodev/sdk/constants'
import { KERNEL_V2_VERSION_TYPE, KERNEL_V3_VERSION_TYPE } from '@zerodev/sdk/types'
import { decodeDIDToSecp256k1PublicKey } from '@/utils/HelperUtil'
import { KeySigner } from 'viem/_types/experimental/erc7715/types/signer'
import { SmartAccountLib } from './SmartAccountLib'

type DonutPurchasePermissionData = {
  target: string
  abi: any
  valueLimit: bigint
  functionName: string
}

export class KernelSmartAccountLib extends SmartAccountLib {
  public isDeployed: boolean = false
  public address?: `0x${string}`

  public kernelVersion: KERNEL_V3_VERSION_TYPE | KERNEL_V2_VERSION_TYPE = KERNEL_V3_1
  private validator: KernelValidator<EntryPoint> | undefined

  public type: string = 'Kernel'

  async getClientConfig(): Promise<SmartAccountClientConfig<EntryPoint>> {
    if (this.entryPoint === ENTRYPOINT_ADDRESS_V06) {
      this.kernelVersion = KERNEL_V2_4
    }
    this.validator = await signerToEcdsaValidator(this.publicClient, {
      signer: this.signer,
      entryPoint: this.entryPoint,
      kernelVersion: this.kernelVersion
    })

    const kernelAccount = await createKernelAccount(this.publicClient, {
      plugins: {
        sudo: this.validator
      },
      entryPoint: this.entryPoint,
      kernelVersion: this.kernelVersion
    })
    return {
      name: 'KernelSmartAccount',
      account: kernelAccount,
      chain: this.chain,
      entryPoint: this.entryPoint,
      bundlerTransport: this.bundlerUrl,
      middleware: {
        gasPrice: async () => (await this.bundlerClient.getUserOperationGasPrice()).fast, // use pimlico bundler to get gas prices
        sponsorUserOperation: this.sponsored ? this.paymasterClient.sponsorUserOperation : undefined
      }
    }
  }

  async issueSessionKey(address: `0x${string}`, permissions: string): Promise<string> {
    if (!this.publicClient) {
      throw new Error('Client not initialized')
    }
    if (!address) {
      throw new Error('Target address is required')
    }
    const parsedPermissions = JSON.parse(permissions)
    const sessionKeyAddress = address
    console.log('Issuing new session key', { sessionKeyAddress })
    const emptySessionKeySigner = addressToEmptyAccount(sessionKeyAddress)
    console.log(parsedPermissions)
    const sessionKeyValidator = await signerToSessionKeyValidator(this.publicClient, {
      signer: emptySessionKeySigner,
      validatorData: {
        permissions: parsedPermissions
      },
      kernelVersion: this.kernelVersion,
      entryPoint: this.entryPoint
    })
    const sessionKeyAccount = await createKernelAccount(this.publicClient, {
      plugins: {
        sudo: this.validator,
        regular: sessionKeyValidator
      },
      entryPoint: this.entryPoint,
      kernelVersion: this.kernelVersion
    })
    console.log('Session key account initialized', { address: sessionKeyAccount.address })
    const serializedSessionKey = await serializeSessionKeyAccount(sessionKeyAccount)
    return serializedSessionKey
  }

  async grantPermissions(
    grantPermissionsRequestParams: WalletGrantPermissionsParameters
  ): Promise<WalletGrantPermissionsReturnType> {
    if (!this.publicClient) {
      throw new Error('Client not initialized')
    }
    console.log('grantPermissions', { grantPermissionsRequestParams })

    const signer = grantPermissionsRequestParams.signer
    // check if signer type is  AccountSigner then it will have data.id
    if (signer && !(signer.type === 'key')) {
      throw Error('Currently only supporting KeySigner Type for permissions')
    }

    const typedSigner = signer as KeySigner
    const pubkey = decodeDIDToSecp256k1PublicKey(typedSigner.data.id)

    const emptySessionKeySigner = addressToEmptyAccount(publicKeyToAddress(pubkey as `0x${string}`))

    const permissions = grantPermissionsRequestParams.permissions
    const zeroDevPermissions = []

    for (const permission of permissions) {
      if (permission.type === 'donut-purchase') {
        const data = permission.data as DonutPurchasePermissionData
        zeroDevPermissions.push({
          target: data.target,
          abi: data.abi,
          valueLimit: data.valueLimit,
          functionName: data.functionName
        })
      }
    }
    const sessionKeyValidator = await signerToSessionKeyValidator(this.publicClient, {
      signer: emptySessionKeySigner,
      validatorData: {
        // @ts-ignore
        permissions: zeroDevPermissions
      },
      kernelVersion: this.kernelVersion,
      entryPoint: this.entryPoint
    })
    const sessionKeyAccount = await createKernelAccount(this.publicClient, {
      plugins: {
        sudo: this.validator,
        regular: sessionKeyValidator
      },
      entryPoint: this.entryPoint,
      kernelVersion: this.kernelVersion
    })

    const serializedSessionKey = await serializeSessionKeyAccount(sessionKeyAccount)

    return {
      permissionsContext: serializedSessionKey,
      grantedPermissions: grantPermissionsRequestParams.permissions,
      expiry: grantPermissionsRequestParams.expiry
    } as WalletGrantPermissionsReturnType
  }

  async updateCoSigners(signers: `0x${string}`[]) {
    if (!this.client || !this.publicClient || !this.client.account) {
      throw new Error('Client not initialized')
    }
    const currentAddress = this.signer.address

    if (signers.length === 0 || signers.length > 2) {
      throw new Error('Invalid signer setup')
    }
    const coSigners = signers.map(address => {
      return {
        address,
        weight: 100 / signers.length
      }
    })
    const newSigners = [{ address: currentAddress, weight: 100 }, ...coSigners]
    console.log('Updating account Co-Signers', { newSigners })

    const updateCall = getUpdateConfigCall(this.entryPoint, this.kernelVersion, {
      threshold: 100,
      signers: newSigners
    })

    await this.sendTransaction(updateCall)
  }

  getAccount() {
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }
    return this.client.account
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/SafeSmartAccountLib.ts">
import {
  ENTRYPOINT_ADDRESS_V07,
  SmartAccountClientConfig,
  isSmartAccountDeployed
} from 'permissionless'
import { SmartAccountLib } from './SmartAccountLib'
import { SmartAccount, signerToSafeSmartAccount } from 'permissionless/accounts'
import { EntryPoint } from 'permissionless/types/entrypoint'
import { Address, Hex, createWalletClient, http, toHex } from 'viem'
import { TRUSTED_SMART_SESSIONS_ATTERSTER_ADDRESS } from './builders/SmartSessionUtil'
import {
  SmartSessionGrantPermissionsRequest,
  WalletGrantPermissionsResponse
} from '@reown/appkit-experimental/smart-session'
import { getContext } from './builders/ContextBuilderUtil'
import { Execution, Module } from '@rhinestone/module-sdk'

const {
  SMART_SESSIONS_ADDRESS,
  getTrustAttestersAction,
  getAccount,
  getSmartSessionsValidator,
  findTrustedAttesters,
  installModule
} = require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')
export class SafeSmartAccountLib extends SmartAccountLib {
  protected ERC_7579_LAUNCHPAD_ADDRESS: Address = '0xEBe001b3D534B9B6E2500FB78E67a1A137f561CE'
  protected SAFE_4337_MODULE_ADDRESS: Address = '0x3Fdb5BC686e861480ef99A6E3FaAe03c0b9F32e2'

  async getClientConfig(): Promise<SmartAccountClientConfig<EntryPoint>> {
    this.type = 'Safe'
    const safeAccount = await signerToSafeSmartAccount(this.publicClient, {
      safeVersion: '1.4.1',
      entryPoint: ENTRYPOINT_ADDRESS_V07,
      safe4337ModuleAddress: this.SAFE_4337_MODULE_ADDRESS,
      //@ts-ignore
      erc7579LaunchpadAddress: this.ERC_7579_LAUNCHPAD_ADDRESS,
      signer: this.signer
    })
    return {
      name: 'Safe7579SmartAccount',
      account: safeAccount as SmartAccount<EntryPoint>,
      entryPoint: ENTRYPOINT_ADDRESS_V07,
      chain: this.chain,
      bundlerTransport: this.bundlerUrl,
      middleware: {
        gasPrice: async () => (await this.bundlerClient.getUserOperationGasPrice()).fast, // use pimlico bundler to get gas prices
        sponsorUserOperation: this.sponsored ? this.paymasterClient.sponsorUserOperation : undefined
      }
    }
  }

  async manageModule(calls: { to: Address; value: bigint; data: Hex }[]) {
    const userOpHash = await this.sendBatchTransaction(calls)
    return await this.bundlerClient.waitForUserOperationReceipt({
      hash: userOpHash
    })
  }

  /* 7715 method */
  async grantPermissions(
    grantPermissionsRequestParameters: SmartSessionGrantPermissionsRequest
  ): Promise<WalletGrantPermissionsResponse> {
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }
    await this.ensureAccountReadyForGrantPermissions()

    const walletClient = createWalletClient({
      chain: this.chain,
      account: this.signer,
      transport: http()
    })
    console.log('walletClient chainId:', walletClient.chain.id)

    const permissionContext = await getContext(this.publicClient, walletClient, {
      account: getAccount({
        address: this.client.account.address,
        type: 'safe'
      }),
      grantPermissionsRequest: grantPermissionsRequestParameters
    })

    console.log(`Returning the permissions request`)
    return {
      ...grantPermissionsRequestParameters,
      context: permissionContext as Hex,
      chainId: toHex(this.chain.id),
      accountMeta: {
        factory: (await this.client.account.getFactory()) || '0x',
        factoryData: (await this.client.account.getFactoryData()) || '0x'
      },
      expiry: grantPermissionsRequestParameters.expiry
    }
  }

  /**
   * Check Safe7579 Account is ready for processing this RPC request
   * - Check Account is deployed
   * - Check SmartSession Attesters are trusted
   * - Check Permission Validator & Mock Validator modules are installed
   * If not, Deploy and installed all necessary module and enable trusted attester if not trusted for processing this RPC request
   * @returns
   */
  private async ensureAccountReadyForGrantPermissions(): Promise<void> {
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }
    try {
      const setUpSmartAccountForSmartSession: Execution[] = []

      const [isAccountDeployed, isSmartAccountTrustSmartSessionAttesters] = await Promise.all([
        isSmartAccountDeployed(this.publicClient, this.client.account.address),
        this.isSmartAccountTrustSmartSessionAttesters()
      ])

      let smartSessionValidatorInstalled = false
      if (isAccountDeployed) {
        smartSessionValidatorInstalled = await this.isValidatorModuleInstalled(
          SMART_SESSIONS_ADDRESS as Address
        )
      }

      if (
        isAccountDeployed &&
        smartSessionValidatorInstalled &&
        isSmartAccountTrustSmartSessionAttesters
      ) {
        console.log('Account is already set up with required modules')
        return
      }

      console.log('Setting up the Account with required modules')

      if (!isAccountDeployed || !smartSessionValidatorInstalled) {
        const smartSessionValidator: Module = getSmartSessionsValidator({})
        const installSmartSessionValidatorAction = await installModule({
          client: this.publicClient,
          account: getAccount({
            address: this.client.account.address,
            type: 'safe'
          }),
          module: smartSessionValidator
        })

        setUpSmartAccountForSmartSession.push(installSmartSessionValidatorAction[0])
      }

      if (!isSmartAccountTrustSmartSessionAttesters) {
        console.log('Smart Account do not trusted the attesters of the smartsessions module')
        console.log('Enable trusting the attesters of the smartsessions module')
        const trustAttestersAction = getTrustAttestersAction({
          attesters: [TRUSTED_SMART_SESSIONS_ATTERSTER_ADDRESS],
          threshold: 1
        })
        setUpSmartAccountForSmartSession.push(trustAttestersAction)
      }

      console.log('Setting up the Account with Executions', { setUpSmartAccountForSmartSession })
      const userOpHash = await this.sendBatchTransaction(
        setUpSmartAccountForSmartSession.map(action => {
          return {
            to: action.target,
            value: action.value.valueOf(),
            data: action.callData
          }
        })
      )
      const receipt = await this.bundlerClient.waitForUserOperationReceipt({ hash: userOpHash })
      console.log(`Account setup receipt:`, receipt)
      console.log('Account setup completed')
    } catch (error) {
      console.error(`Error ensuring account is ready for grant permissions: ${error}`)
      throw error
    }
  }

  private async isValidatorModuleInstalled(address: Address): Promise<boolean> {
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }
    return this.client.isModuleInstalled({
      address,
      type: 'validator',
      account: this.client.account,
      context: '0x'
    })
  }

  private async isSmartAccountTrustSmartSessionAttesters(): Promise<boolean> {
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }

    const attesters = await findTrustedAttesters({
      client: this.publicClient,
      accountAddress: this.client.account.address
    })

    if (attesters.length > 0) {
      return Boolean(
        attesters.find(
          (attester: Address) =>
            attester.toLowerCase() === TRUSTED_SMART_SESSIONS_ATTERSTER_ADDRESS.toLowerCase()
        )
      )
    }

    return false
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/smart-accounts/SmartAccountLib.ts">
import {
  Hex,
  PrivateKeyAccount,
  PublicClient,
  createPublicClient,
  http,
  createClient,
  HttpTransport,
  Address,
  Chain
} from 'viem'
import { EIP155Wallet } from '../EIP155Lib'
import { JsonRpcProvider } from '@ethersproject/providers'
import { privateKeyToAccount } from 'viem/accounts'
import {
  PimlicoPaymasterClient,
  createPimlicoPaymasterClient
} from 'permissionless/clients/pimlico'
import {
  BundlerActions,
  BundlerClient,
  ENTRYPOINT_ADDRESS_V06,
  ENTRYPOINT_ADDRESS_V07,
  SmartAccountClient,
  SmartAccountClientConfig,
  bundlerActions,
  createSmartAccountClient
} from 'permissionless'
import { PimlicoBundlerActions, pimlicoBundlerActions } from 'permissionless/actions/pimlico'
import {
  PIMLICO_NETWORK_NAMES,
  publicClientUrl,
  publicRPCUrl,
  UrlConfig
} from '@/utils/SmartAccountUtil'
import { EntryPoint } from 'permissionless/types/entrypoint'
import { Erc7579Actions, erc7579Actions } from 'permissionless/actions/erc7579'
import { SmartAccount } from 'permissionless/accounts'
import { SendCallsParams, SendCallsPaymasterServiceCapabilityParam } from '@/data/EIP5792Data'
import { UserOperation } from 'permissionless/_types/types'
import { paymasterActionsEip7677 } from 'permissionless/experimental'
import { getSendCallData } from '@/utils/EIP5792WalletUtil'

type SmartAccountLibOptions = {
  privateKey: string
  chain: Chain
  sponsored?: boolean
  entryPointVersion?: number
}

export abstract class SmartAccountLib implements EIP155Wallet {
  // Options
  public chain: Chain
  public sponsored: boolean = true
  public entryPoint: EntryPoint

  // Signer
  protected signer: PrivateKeyAccount
  #signerPrivateKey: string

  // Clients
  protected publicClient: PublicClient
  protected paymasterClient: PimlicoPaymasterClient<EntryPoint>
  protected bundlerClient: BundlerClient<EntryPoint> &
    BundlerActions<EntryPoint> &
    PimlicoBundlerActions
  protected client:
    | (SmartAccountClient<EntryPoint> &
        PimlicoBundlerActions &
        Erc7579Actions<EntryPoint, SmartAccount<EntryPoint> | undefined>)
    | undefined

  // Transport
  protected bundlerUrl: HttpTransport
  protected paymasterUrl: HttpTransport

  // Utility
  public type: string
  public initialized = false

  public constructor({
    privateKey,
    chain,
    sponsored = false,
    entryPointVersion = 6
  }: SmartAccountLibOptions) {
    const apiKey = process.env.NEXT_PUBLIC_PIMLICO_KEY
    const publicClientRPCUrl = process.env.NEXT_PUBLIC_LOCAL_CLIENT_URL || publicRPCUrl({ chain })
    const paymasterUrl = ({ chain }: UrlConfig) => {
      const localPaymasterUrl = process.env.NEXT_PUBLIC_LOCAL_PAYMASTER_URL
      if (localPaymasterUrl) {
        return localPaymasterUrl
      }
      return `https://api.pimlico.io/v2/${PIMLICO_NETWORK_NAMES[chain.name]}/rpc?apikey=${apiKey}`
    }

    const bundlerUrl = ({ chain }: UrlConfig) => {
      const localBundlerUrl = process.env.NEXT_PUBLIC_LOCAL_BUNDLER_URL
      if (localBundlerUrl) {
        return localBundlerUrl
      }
      return `https://api.pimlico.io/v1/${PIMLICO_NETWORK_NAMES[chain.name]}/rpc?apikey=${apiKey}`
    }

    this.entryPoint = ENTRYPOINT_ADDRESS_V06
    if (entryPointVersion === 7) {
      this.entryPoint = ENTRYPOINT_ADDRESS_V07
    }

    this.chain = chain
    this.sponsored = sponsored
    this.#signerPrivateKey = privateKey
    this.signer = privateKeyToAccount(privateKey as Hex)

    this.bundlerUrl = http(bundlerUrl({ chain: this.chain }), {
      timeout: 30000
    })
    this.paymasterUrl = http(paymasterUrl({ chain: this.chain }), {
      timeout: 30000
    })

    this.publicClient = createPublicClient({
      chain: this.chain,
      transport: http(publicClientUrl({ chain: this.chain }))
    })

    this.paymasterClient = createPimlicoPaymasterClient({
      transport: this.paymasterUrl,
      entryPoint: this.entryPoint,
      chain: this.chain
    })

    this.bundlerClient = createClient({
      transport: this.bundlerUrl,
      chain: this.chain
    })
      .extend(bundlerActions(this.entryPoint))
      .extend(pimlicoBundlerActions(this.entryPoint))

    const name = this.constructor.name.replace('SmartAccountLib', '')
    this.type = name && name.length > 0 ? name : 'Unknown'
  }

  abstract getClientConfig(): Promise<SmartAccountClientConfig<EntryPoint>>

  async init() {
    const config = await this.getClientConfig()
    this.client = createSmartAccountClient(config)
      .extend(pimlicoBundlerActions(this.entryPoint))
      .extend(erc7579Actions({ entryPoint: this.entryPoint }))
    console.log('Smart account initialized', {
      address: this.client?.account?.address,
      chain: this.chain.name,
      type: this.type
    })
    this.initialized = true
  }

  getMnemonic(): string {
    throw new Error('Method not implemented.')
  }
  getPrivateKey(): string {
    return this.#signerPrivateKey
  }
  getAddress(): string {
    if (!this.client) {
      throw new Error('Client not initialized')
    }
    return this.client.account?.address || ''
  }
  async signMessage(message: string): Promise<string> {
    if (!this.client) {
      throw new Error('Client not initialized')
    }
    const signature = await this.client.account?.signMessage({ message })
    return signature || ''
  }
  async _signTypedData(
    domain: any,
    types: any,
    data: any,
    _primaryType?: string | undefined
  ): Promise<string> {
    if (!this.client) {
      throw new Error('Client not initialized')
    }
    console.log('Signing typed data with Smart Account', { type: this.type, domain, types, data })
    const primaryType = _primaryType || ''
    const signature = await this.client.account?.signTypedData({
      domain,
      types,
      primaryType,
      message: data
    })
    return signature || ''
  }
  connect(_provider: JsonRpcProvider): any {
    if (!this.client) {
      throw new Error('Client not initialized')
    }
    return this
  }
  async signTransaction(transaction: any): Promise<string> {
    if (!this.client || !this.client.account) {
      throw new Error('Client not initialized')
    }
    const signature = await this.client.account.signTransaction(transaction)
    return signature || ''
  }
  async sendTransaction({ to, value, data }: { to: Address; value: bigint | Hex; data: Hex }) {
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }
    const txResult = await this.client.sendTransaction({
      to,
      value: BigInt(value),
      data,
      account: this.client.account,
      chain: this.chain
    })
    return txResult
  }

  async sendBatchTransaction(
    args: {
      to: Address
      value: bigint
      data: Hex
    }[]
  ) {
    console.log('Sending transaction from smart account', { type: this.type, args })
    if (!this.client || !this.client.account) {
      throw new Error('Client not initialized')
    }

    const userOp = await this.client.prepareUserOperationRequest({
      userOperation: {
        callData: await this.client.account.encodeCallData(args)
      },
      account: this.client.account
    })

    const newSignature = await this.client.account.signUserOperation(userOp)
    userOp.signature = newSignature

    const userOpHash = await this.bundlerClient.sendUserOperation({
      userOperation: userOp
    })
    return userOpHash
  }

  getAccount() {
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }
    return this.client.account
  }

  async sendERC5792Calls(sendCallsParam: SendCallsParams) {
    if (!this.client || !this.client.account) {
      throw new Error('Client not initialized')
    }
    const calls = getSendCallData(sendCallsParam)

    const capabilities = sendCallsParam.capabilities
    if (capabilities && capabilities['paymasterService']) {
      const paymasterService = capabilities[
        'paymasterService'
      ] as SendCallsPaymasterServiceCapabilityParam

      return this.handleERC5792CallsWithPaymasterService({
        paymasterService,
        calls
      })
    }

    return this.sendBatchTransaction(calls)
  }

  async handleERC5792CallsWithPaymasterService(args: {
    paymasterService: SendCallsPaymasterServiceCapabilityParam
    calls: {
      to: `0x${string}`
      value: bigint
      data: `0x${string}`
    }[]
  }) {
    console.log('executing sendCalls with paymasterService')
    const { paymasterService, calls } = args
    if (!this.client?.account) {
      throw new Error('Client not initialized')
    }
    const gasPrice = (await this.bundlerClient.getUserOperationGasPrice()).fast
    const userOpPreStubData: Omit<
      UserOperation<'v0.7'>,
      'signature' | 'paymaster' | 'paymasterData'
    > = {
      sender: this.client.account.address,
      nonce: await this.client.account.getNonce(),
      factory: await this.client.account.getFactory(),
      factoryData: await this.client.account.getFactoryData(),
      callData: await this.client.account.encodeCallData(calls),
      callGasLimit: 0n,
      verificationGasLimit: 0n,
      preVerificationGas: 0n,
      maxFeePerGas: gasPrice.maxFeePerGas,
      maxPriorityFeePerGas: gasPrice.maxPriorityFeePerGas,
      // paymaster: '0x',
      paymasterVerificationGasLimit: 0n,
      paymasterPostOpGasLimit: 0n
      // paymasterData: '0x',
      // signature: '0x'
    }

    const paymasterClient = createClient({
      chain: this.chain,
      transport: http(paymasterService.url)
    }).extend(paymasterActionsEip7677(ENTRYPOINT_ADDRESS_V07))

    const paymasterStubData = await paymasterClient.getPaymasterStubData({
      userOperation: userOpPreStubData,
      chain: this.chain,
      context: paymasterService.context
    })
    console.log({ paymasterStubData })
    const userOpWithStubData: UserOperation<'v0.7'> = {
      ...userOpPreStubData,
      ...paymasterStubData,
      verificationGasLimit: paymasterStubData.paymasterVerificationGasLimit ?? 0n,
      signature: '0x'
    }

    const dummySignature = await this.client.account.getDummySignature(userOpWithStubData)
    userOpWithStubData.signature = dummySignature

    const gasEstimation = await this.bundlerClient.estimateUserOperationGas({
      userOperation: userOpWithStubData
    })
    console.log({ gasEstimation })
    const userOpWithGasEstimates: UserOperation<'v0.7'> = {
      ...userOpWithStubData,
      ...gasEstimation
    }

    const paymasterData = await paymasterClient.getPaymasterData({
      userOperation: {
        ...userOpWithGasEstimates,
        paymasterPostOpGasLimit: gasEstimation.paymasterPostOpGasLimit || 0n,
        paymasterVerificationGasLimit: gasEstimation.paymasterVerificationGasLimit || 0n
      },
      chain: this.chain,
      context: paymasterService.context
    })
    console.log({ paymasterData })
    const userOpWithPaymasterData: UserOperation<'v0.7'> = {
      ...userOpWithGasEstimates,
      ...paymasterData
    }

    const userOp = userOpWithPaymasterData

    const newSignature = await this.client.account.signUserOperation(userOp)
    console.log('Signatures', { old: userOp.signature, new: newSignature })

    userOp.signature = newSignature

    const userOpHash = await this.bundlerClient.sendUserOperation({
      userOperation: userOp
    })
    console.log({ userOpHash })
    return userOpHash
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/Bip122Lib.ts">
import ECPairFactory from 'ecpair'
import * as bitcoin from 'bitcoinjs-lib'
import * as ecc from 'tiny-secp256k1'
import * as bip39 from 'bip39'
import BIP32Factory, { BIP32Interface } from 'bip32'
import bitcoinMessage from 'bitcoinjs-message'
import { schnorr } from '@noble/secp256k1'
import { BIP122_CHAINS, BIP122_TESTNET_ID, IBip122ChainId } from '@/data/Bip122Data'
bitcoin.initEccLib(ecc)

const ECPair = ECPairFactory(ecc)
const bip32 = BIP32Factory(ecc)
interface IInitArguments {
  privateKey?: string
}

interface IUTXO {
  txid: string
  vout: number
  value: number
  status: {
    confirmed: boolean
    block_height: number
    block_hash: string
    block_time: number
  }
}

interface ICreateTransaction {
  network: bitcoin.Network
  recipientAddress: string
  amount: number
  changeAddress: string
  memo?: string
  utxos: IUTXO[]
  privateKeyWIF: string
  feeRate: number
}

interface IAddressData {
  address: string
  path: string
  publicKey: string
}

interface IPsbtInput {
  address: string
  index: number
  sighashTypes: number[]
}

interface ISignPsbt {
  account: string
  psbt: string
  signInputs: IPsbtInput[]
  broadcast: boolean
  chainId: IBip122ChainId
}

const validator = (pubkey: Buffer, msghash: Buffer, signature: Buffer): boolean => {
  return ECPair.fromPublicKey(pubkey).verify(msghash, signature)
}

/**
 * Library
 */
export default class Bip122Lib {
  private account: BIP32Interface
  private mnemonic: string
  private addresses = {} as Record<IBip122ChainId, Map<string, IAddressData>>
  private ordinals = {} as Record<IBip122ChainId, Map<string, IAddressData>>
  private keys = {} as Record<
    IBip122ChainId,
    Map<string, { wif: string; network: bitcoin.Network }>
  >

  constructor(key?: string) {
    this.keys = Object.values(BIP122_CHAINS).reduce((acc, chain) => {
      acc[chain.caip2] = new Map<string, { wif: string; network: bitcoin.Network }>()
      return acc
    }, this.keys)
    this.addresses = Object.values(BIP122_CHAINS).reduce((acc, chain) => {
      acc[chain.caip2] = new Map<string, IAddressData>()
      return acc
    }, this.addresses)
    this.ordinals = Object.values(BIP122_CHAINS).reduce((acc, chain) => {
      acc[chain.caip2] = new Map<string, IAddressData>()
      return acc
    }, this.ordinals)

    this.mnemonic = key ? key : bip39.generateMnemonic()
    const seed = bip39.mnemonicToSeedSync(this.mnemonic)
    const root = bip32.fromSeed(seed)
    this.account = bip32.fromBase58(root.toBase58())
    const addressIndex = (localStorage.getItem(`${seed}_index`) || 0) as number
    this.loadAddresses(addressIndex)
  }

  static async init({ privateKey }: IInitArguments) {
    return new Bip122Lib(privateKey)
  }

  public getAddress(chainId: IBip122ChainId) {
    return Array.from(this.addresses[chainId].values())[0].address
  }

  public getOrdinalsAddress(chainId: IBip122ChainId) {
    return Array.from(this.ordinals[chainId].values())[0].address
  }

  public getPrivateKey() {
    return this.mnemonic
  }

  public getAddresses(chainId: IBip122ChainId, intentions?: string[]) {
    if (intentions && intentions[0] === 'ordinal') {
      return this.ordinals[chainId]
    }
    return this.addresses[chainId]
  }

  public async signMessage({
    message,
    address,
    protocol,
    chainId
  }: {
    message: string
    address: string
    protocol?: string
    chainId: IBip122ChainId
  }) {
    if (protocol && protocol !== 'ecdsa') {
      throw new Error(`Supported signing protols: ecdsa, received: ${protocol}`)
    }
    const addressData = this.getAddressData(address, chainId)
    if (!addressData) {
      throw new Error(`Unkown address: ${address}`)
    }
    const keyData = this.keys[chainId].get(address)!
    var keyPair = ECPair.fromWIF(keyData.wif)
    var privateKey = keyPair.privateKey!

    let signature
    if (this.isOrdinal(address, chainId)) {
      const messageHash = bitcoin.crypto.sha256(Buffer.from(message))

      const sig = await schnorr.sign(messageHash, privateKey)
      signature = Buffer.from(sig)
    } else {
      signature = bitcoinMessage.sign(message, privateKey, keyPair.compressed, {
        segwitType: 'p2wpkh'
      })
    }

    return {
      signature: signature.toString('hex').replace('0x', ''),
      address
    }
  }

  public async sendTransfer(params: {
    account: string
    recipientAddress: string
    amount: string
    changeAddress?: string
    memo?: string
    chainId: IBip122ChainId
  }) {
    const { account, recipientAddress, amount, changeAddress, memo, chainId } = params
    const satoshis = parseInt(amount)

    const addressData = this.getAddressData(account, chainId)
    if (!addressData) {
      throw new Error(`Unkown address: ${account}`)
    }

    if (satoshis < 0) {
      throw new Error(`Invalid amount: ${amount}`)
    }

    const utxos = (await this.getUTXOs(account, chainId)) as IUTXO[]
    if (!utxos || utxos.length === 0) {
      throw new Error(`No UTXOs found for address: ${account}`)
    }

    let utxosValue = 0
    const utxosToSpend: IUTXO[] = []
    utxos.forEach(utxo => {
      utxosValue += utxo.value
      utxosToSpend.push(utxo)
      if (utxosValue >= satoshis) {
        return
      }
    })

    const keyData = this.keys[chainId].get(account)!
    const transaction = await this.createTransaction({
      network: keyData.network,
      recipientAddress,
      amount: satoshis,
      changeAddress: changeAddress || account,
      utxos: utxosToSpend,
      privateKeyWIF: keyData.wif,
      memo,
      feeRate: await this.getFeeRate()
    })
    return await this.broadcastTransaction(transaction, chainId)
  }

  async getUTXOs(address: string, chainId: IBip122ChainId): Promise<IUTXO[]> {
    const isTestnet = this.isTestnet(chainId)
    // make chain dynamic
    return await (
      await fetch(`https://mempool.space${isTestnet ? '/testnet' : ''}/api/address/${address}/utxo`)
    ).json()
  }

  async broadcastTransaction(transaction: string, chainId: IBip122ChainId) {
    const isTestnet = this.isTestnet(chainId)
    const result = await fetch(`https://mempool.space${isTestnet ? '/testnet' : ''}/api/tx`, {
      method: 'POST',
      body: transaction
    })

    if (result.ok) {
      return await result.text()
    }
    throw new Error('Error broadcasting transaction: ' + (await result.text()))
  }

  getAvailableBalance(utxos: IUTXO[]) {
    return utxos.reduce((acc, { value }) => acc + value, 0)
  }

  private async getFeeRate() {
    const defaultFeeRate = 2
    try {
      const response = await fetch('https://mempool.space/api/v1/fees/recommended')
      if (response.ok) {
        const data = await response.json()
        return parseInt(data?.economyFee ?? defaultFeeRate)
      }
    } catch (e) {
      console.error('Error fetching fee rate', e)
    }
    return defaultFeeRate
  }

  private generateAddress({
    index,
    coinType,
    chainId,
    change = false,
    taproot = false
  }: {
    index: number
    coinType: string
    chainId: IBip122ChainId
    change?: boolean
    taproot?: boolean
  }) {
    const network = this.getNetwork(coinType)
    const path = `m/84'/${coinType}'/0'/${change ? 1 : 0}/${index}`
    const child = this.account.derivePath(path)
    let address
    if (taproot) {
      address = bitcoin.payments.p2tr({
        pubkey: child.publicKey.slice(1),
        network
      }).address!
    } else {
      address = bitcoin.payments.p2wpkh({
        pubkey: child.publicKey,
        network
      }).address!
    }
    const wif = child.toWIF()
    this.keys[chainId].set(address, { wif, network })
    return { address, path, publicKey: child.publicKey.toString('hex') }
  }

  private loadAddresses(startIndex = 0) {
    console.log('Loading addresses...')
    console.log('Keys:', this.keys)
    console.log('Addresses:', this.addresses)
    console.log('Ordinals:', this.ordinals)
    Object.keys(this.keys).forEach(chainId => {
      const data = BIP122_CHAINS[chainId as IBip122ChainId]
      const addressesToLoad = startIndex + 20

      for (let i = startIndex; i < addressesToLoad; i++) {
        const addressParams = {
          index: i,
          chainId: data.caip2,
          coinType: data.coinType
        }
        // payment addresses
        const addressData = this.generateAddress(addressParams)
        this.addresses[data.caip2].set(addressData.address, addressData)
        // ordinals
        const taprootAddress = this.generateAddress({
          ...addressParams,
          taproot: true
        })
        this.ordinals[data.caip2].set(taprootAddress.address, taprootAddress)
      }
      console.log('Loaded addresses:', this.addresses, this.ordinals)
    })
  }

  private getNetwork(coinType: string) {
    if (coinType === '0') {
      return bitcoin.networks.bitcoin
    } else if (coinType === '1') {
      return bitcoin.networks.testnet
    }
    throw new Error(`Unsupported coin type: ${coinType}`)
  }

  private async createTransaction({
    network,
    recipientAddress,
    amount,
    changeAddress,
    memo,
    utxos,
    privateKeyWIF,
    feeRate
  }: ICreateTransaction) {
    const psbt = new bitcoin.Psbt({ network })
    const keyPair = ECPair.fromWIF(privateKeyWIF)
    const payment = bitcoin.payments.p2wpkh({
      pubkey: keyPair.publicKey,
      network: bitcoin.networks.testnet
    })

    utxos.forEach(utxo => {
      psbt.addInput({
        hash: utxo.txid,
        index: utxo.vout,
        witnessUtxo: {
          script: Buffer.from(payment.output?.toString('hex')!, 'hex'),
          value: utxo.value
        }
      })
    })

    psbt.addOutput({
      address: recipientAddress,
      value: amount
    })
    const change = this.calculateChange(utxos, amount, feeRate)

    if (change > 0) {
      psbt.addOutput({
        address: changeAddress,
        value: change
      })
    }

    if (memo) {
      const data = Buffer.from(memo, 'utf8')
      const embed = bitcoin.payments.embed({ data: [data] })
      psbt.addOutput({
        script: embed.output!,
        value: 0
      })
    }

    psbt.signAllInputs(keyPair)

    psbt.validateSignaturesOfInput(0, validator)

    psbt.finalizeAllInputs()

    const tx = psbt.extractTransaction()

    return tx.toHex()
  }

  public async signPsbt({ account, psbt, signInputs, broadcast = false, chainId }: ISignPsbt) {
    const keyData = this.keys[chainId].get(account)!
    const keyPair = ECPair.fromWIF(keyData.wif)
    const transaction = bitcoin.Psbt.fromBase64(psbt, { network: keyData.network })
    signInputs.forEach(({ address, index, sighashTypes }) => {
      let keyPairToSignWith = keyPair
      if (address !== account) {
        const keyData = this.keys[chainId].get(address)!
        keyPairToSignWith = ECPair.fromWIF(keyData.wif)
      }
      transaction.signInput(index, keyPairToSignWith, sighashTypes)
    })
    transaction.validateSignaturesOfInput(0, validator)
    transaction.finalizeAllInputs()

    if (!broadcast) {
      return {
        psbt: transaction.toBase64()
      }
    }

    const tx = transaction.extractTransaction()
    const txId = await this.broadcastTransaction(tx.toHex(), chainId)
    return {
      psbt: transaction.toBase64(),
      txid: txId
    }
  }

  // Helper function to calculate change
  private calculateChange(utxos: IUTXO[], amount: number, feeRate: number): number {
    const inputSum = utxos.reduce((sum, utxo) => sum + utxo.value, 0)
    /**
     * 10 bytes: This is an estimated fixed overhead for the transaction.
     * 148 bytes: This is the average size of each input (UTXO).
     * 34 bytes: This is the size of each output.
     * The multiplication by 2 indicates that there are usually two outputs in a typical transaction (one for the recipient and one for change)
     */
    const estimatedSize = 10 + 148 * utxos.length + 34 * 2
    const fee = estimatedSize * feeRate
    const change = inputSum - amount - fee
    return change
  }

  private getAddressData(address: string, chainId: IBip122ChainId) {
    const addressData = this.addresses[chainId].get(address)
    if (addressData) return addressData
    return this.ordinals[chainId].get(address)
  }

  private isOrdinal(address: string, chainId: IBip122ChainId) {
    return this.ordinals[chainId].has(address)
  }

  private isTestnet(chainId: IBip122ChainId) {
    return chainId.includes(BIP122_TESTNET_ID)
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/CosmosLib.ts">
import { Secp256k1Wallet, StdSignDoc } from '@cosmjs/amino'
import { fromHex } from '@cosmjs/encoding'
import { DirectSecp256k1Wallet } from '@cosmjs/proto-signing'
// @ts-expect-error
import { SignDoc } from '@cosmjs/proto-signing/build/codec/cosmos/tx/v1beta1/tx'
import { Wallet } from 'ethers'

/**
 * Constants
 */
const DEFAULT_PATH = "m/44'/118'/0'/0/0"
const DEFAULT_PREFIX = 'cosmos'

/**
 * Types
 */
interface IInitArguments {
  mnemonic?: string
  path?: string
  prefix?: string
}

/**
 * Library
 */
export default class CosmosLib {
  private mnemonic: string
  private directSigner: DirectSecp256k1Wallet
  private aminoSigner: Secp256k1Wallet

  constructor(mnemonic: string, directSigner: DirectSecp256k1Wallet, aminoSigner: Secp256k1Wallet) {
    this.directSigner = directSigner
    this.mnemonic = mnemonic
    this.aminoSigner = aminoSigner
  }

  static async init({ mnemonic, path, prefix }: IInitArguments) {
    const wallet = mnemonic
      ? Wallet.fromMnemonic(mnemonic, path ?? DEFAULT_PATH)
      : Wallet.createRandom({ path: path ?? DEFAULT_PATH })
    const privateKey = fromHex(wallet.privateKey.replace('0x', ''))
    const directSigner = await DirectSecp256k1Wallet.fromKey(privateKey, prefix ?? DEFAULT_PREFIX)
    const aminoSigner = await Secp256k1Wallet.fromKey(privateKey, prefix ?? DEFAULT_PREFIX)

    return new CosmosLib(wallet.mnemonic.phrase, directSigner, aminoSigner)
  }

  public getMnemonic() {
    return this.mnemonic
  }

  public async getAddress() {
    const account = await this.directSigner.getAccounts()

    return account[0].address
  }

  public async signDirect(address: string, signDoc: SignDoc) {
    return await this.directSigner.signDirect(address, signDoc)
  }

  public async signAmino(address: string, signDoc: StdSignDoc) {
    return await this.aminoSigner.signAmino(address, signDoc)
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/EIP155Lib.ts">
import { providers, Wallet } from 'ethers'

/**
 * Types
 */
interface IInitArgs {
  mnemonic?: string
}
export interface EIP155Wallet {
  getMnemonic(): string
  getPrivateKey(): string
  getAddress(): string
  signMessage(message: string): Promise<string>
  _signTypedData(domain: any, types: any, data: any, _primaryType?: string): Promise<string>
  connect(provider: providers.JsonRpcProvider): Wallet
  signTransaction(transaction: providers.TransactionRequest): Promise<string>
}

/**
 * Library
 */
export default class EIP155Lib implements EIP155Wallet {
  wallet: Wallet

  constructor(wallet: Wallet) {
    this.wallet = wallet
  }

  static init({ mnemonic }: IInitArgs) {
    const wallet = mnemonic ? Wallet.fromMnemonic(mnemonic) : Wallet.createRandom()

    return new EIP155Lib(wallet)
  }

  getMnemonic() {
    return this.wallet.mnemonic.phrase
  }

  getPrivateKey() {
    return this.wallet.privateKey
  }

  getAddress() {
    return this.wallet.address
  }

  signMessage(message: string) {
    return this.wallet.signMessage(message)
  }

  _signTypedData(domain: any, types: any, data: any, _primaryType?: string) {
    return this.wallet._signTypedData(domain, types, data)
  }

  connect(provider: providers.JsonRpcProvider) {
    return this.wallet.connect(provider)
  }

  signTransaction(transaction: providers.TransactionRequest) {
    return this.wallet.signTransaction(transaction)
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/KadenaLib.ts">
import { restoreKeyPairFromSecretKey, genKeyPair, sign } from '@kadena/cryptography-utils'
import { IKeyPair } from '@kadena/types'

interface IInitArguments {
  secretKey?: string
}

export default class KadenaLib {
  keyPair: IKeyPair

  constructor(keyPair: IKeyPair) {
    this.keyPair = keyPair
  }

  static init({ secretKey }: IInitArguments) {
    const keyPair = secretKey ? restoreKeyPairFromSecretKey(secretKey) : genKeyPair()

    return new KadenaLib(keyPair)
  }

  public getAddress() {
    return this.keyPair.publicKey
  }

  public getSecretKey() {
    return this.keyPair.secretKey!
  }

  public signRequest(transaction: string) {
    const signResponse = sign(transaction.toString(), this.keyPair)

    return { body: { cmd: transaction, sigs: [signResponse.sig] } }
  }

  public quicksignRequest(transactions: any) {
    const transaction = transactions.commandSigDatas[0].cmd
    const signResponse = sign(transaction.toString(), this.keyPair)

    return {
      responses: [
        {
          outcome: { result: 'success', hash: signResponse.hash },
          commandSigData: { sigs: [{ sig: signResponse.sig, pubKey: this.keyPair.publicKey }] }
        }
      ]
    }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/MultiversxLib.ts">
import { Transaction, SignableMessage } from '@multiversx/sdk-core'
import { Mnemonic, UserSecretKey, UserWallet, UserSigner } from '@multiversx/sdk-wallet'

/**
 * Types
 */
interface IInitArgs {
  mnemonic?: string
}

/**
 * Library
 */
export default class MultiversxLib {
  wallet: UserWallet
  mnemonic: Mnemonic
  password: string

  constructor(mnemonic: Mnemonic) {
    this.mnemonic = mnemonic
    this.password = 'password' // test purposes only

    this.wallet = UserWallet.fromMnemonic({
      password: this.password,
      mnemonic: mnemonic.toString()
    })
  }

  static init({ mnemonic }: IInitArgs) {
    const mnemonicObj = mnemonic ? Mnemonic.fromString(mnemonic) : Mnemonic.generate()

    return new MultiversxLib(mnemonicObj)
  }

  getMnemonic() {
    const secretKey = this.mnemonic.getWords().join(' ')

    return secretKey
  }

  getAddress() {
    const secretKey = UserWallet.decryptSecretKey(this.wallet.toJSON(), this.password)
    const address = secretKey.generatePublicKey().toAddress().bech32()

    return address
  }

  async signMessage(message: string) {
    const secretKey = UserWallet.decryptSecretKey(this.wallet.toJSON(), this.password)
    const secretKeyHex = secretKey.hex()

    const signMessage = new SignableMessage({
      message: Buffer.from(message)
    })

    const signer = new UserSigner(UserSecretKey.fromString(secretKeyHex))
    const signature = await signer.sign(signMessage.serializeForSigning())

    return { signature: signature.toString('hex') }
  }

  async signTransaction(transaction: any) {
    const secretKey = UserWallet.decryptSecretKey(this.wallet.toJSON(), this.password)
    const secretKeyHex = secretKey.hex()

    const signTransaction = Transaction.fromPlainObject(transaction)

    const signer = new UserSigner(UserSecretKey.fromString(secretKeyHex))
    const signature = await signer.sign(signTransaction.serializeForSigning())

    return { signature: signature.toString('hex') }
  }

  async signTransactions(transactions: any[]) {
    const secretKey = UserWallet.decryptSecretKey(this.wallet.toJSON(), this.password)
    const secretKeyHex = secretKey.hex()

    const signatures = await Promise.all(
      transactions.map(async (transaction: any): Promise<any> => {
        const signTransaction = Transaction.fromPlainObject(transaction)
        const signer = new UserSigner(UserSecretKey.fromString(secretKeyHex))
        const signature = await signer.sign(signTransaction.serializeForSigning())

        return { signature: signature.toString('hex') }
      })
    )

    return { signatures }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/NearLib.ts">
import {
  InMemorySigner,
  providers,
  keyStores as nearKeyStores,
  transactions as nearTransactions,
  utils
} from 'near-api-js'
import { AccessKeyView } from 'near-api-js/lib/providers/provider'

import { walletkit } from '@/utils/WalletConnectUtil'
import { NEAR_TEST_CHAINS, TNearChain } from '@/data/NEARData'
import { Schema, serialize } from 'borsh'

const MAX_ACCOUNTS = 2

interface Account {
  accountId: string
  publicKey: string
}

interface Transaction {
  signerId: string
  receiverId: string
  actions: Array<nearTransactions.Action>
}

interface CreateTransactionsParams {
  chainId: string
  transactions: Array<Transaction>
}

interface GetAccountsParams {
  topic: string
}

interface SignInParams {
  chainId: string
  topic: string
  permission: nearTransactions.FunctionCallPermission
  accounts: Array<Account>
}

interface SignOutParams {
  chainId: string
  topic: string
  accounts: Array<Account>
}

interface SignTransactionsParams {
  chainId: string
  topic: string
  transactions: Array<nearTransactions.Transaction>
}

interface SignAndSendTransactionParams {
  chainId: string
  topic: string
  transaction: nearTransactions.Transaction
}

interface SignAndSendTransactionsParams {
  chainId: string
  topic: string
  transactions: Array<nearTransactions.Transaction>
}

export interface SignMessageParamsNEP {
  message: string
  recipient: string
  nonce: Buffer
  callbackUrl?: string
  state?: string
}

interface SignMessageParams {
  chainId: string
  messageParams: SignMessageParamsNEP & {
    accountId?: string
  }
}

interface SignedMessage {
  accountId: string
  publicKey: string
  signature: string
  state?: string
}

export class MessagePayload {
  tag: number
  message: string
  nonce: Buffer
  recipient: string
  callbackUrl?: string

  constructor(data: SignMessageParamsNEP) {
    // The tag's value is a hardcoded value as per
    // defined in the NEP [NEP413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)
    this.tag = 2147484061
    this.message = data.message
    this.nonce = data.nonce
    this.recipient = data.recipient
    if (data.callbackUrl) {
      this.callbackUrl = data.callbackUrl
    }
  }
}

export const payloadSchema: Schema = {
  struct: {
    tag: 'u32',
    message: 'string',
    nonce: { array: { type: 'u8', len: 32 } },
    recipient: 'string',
    callbackUrl: { option: 'string' }
  }
}

export class NearWallet {
  private networkId: string
  private keyStore: nearKeyStores.KeyStore

  static async init(networkId: string) {
    const keyStore = new nearKeyStores.BrowserLocalStorageKeyStore()
    const accounts = await keyStore.getAccounts(networkId)

    for (let i = 0; i < Math.max(MAX_ACCOUNTS - accounts.length, 0); i += 1) {
      const { accountId, keyPair } = await NearWallet.createDevAccount()

      await keyStore.setKey(networkId, accountId, keyPair)
    }

    return new NearWallet(networkId, keyStore)
  }

  static async createDevAccount() {
    const keyPair = utils.KeyPair.fromRandom('ed25519')
    const randomNumber = Math.floor(
      Math.random() * (99999999999999 - 10000000000000) + 10000000000000
    )
    const accountId = `dev-${Date.now()}-${randomNumber}`
    const publicKey = keyPair.getPublicKey().toString()

    fetch(`https://helper.testnet.near.org/account`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        newAccountId: accountId,
        newAccountPublicKey: publicKey
      })
    }).catch(error => {
      console.error('Failed to create NEAR dev account: ', error)
    })

    return {
      accountId,
      keyPair
    }
  }

  private constructor(networkId: string, keyStore: nearKeyStores.KeyStore) {
    this.networkId = networkId
    this.keyStore = keyStore
  }

  getKeyStore() {
    return this.keyStore
  }

  // Retrieve all imported accounts from wallet.
  async getAllAccounts(): Promise<Array<Account>> {
    const accountIds = await this.keyStore.getAccounts(this.networkId)

    return Promise.all(
      accountIds.map(async accountId => {
        const keyPair = await this.keyStore.getKey(this.networkId, accountId)

        return {
          accountId,
          publicKey: keyPair.getPublicKey().toString()
        }
      })
    )
  }

  private isAccountsValid(topic: string, accounts: Array<{ accountId: string }>) {
    const session = walletkit.engine.signClient.session.get(topic)
    const validAccountIds = session.namespaces.near.accounts.map(accountId => {
      return accountId.split(':')[2]
    })

    return accounts.every(({ accountId }) => {
      return validAccountIds.includes(accountId)
    })
  }

  private isTransactionsValid(topic: string, transactions: Array<nearTransactions.Transaction>) {
    const accounts = transactions.map(({ signerId }) => ({ accountId: signerId }))

    return this.isAccountsValid(topic, accounts)
  }

  async createTransactions({
    chainId,
    transactions
  }: CreateTransactionsParams): Promise<Array<nearTransactions.Transaction>> {
    const provider = new providers.JsonRpcProvider(NEAR_TEST_CHAINS[chainId as TNearChain].rpc)
    const txs: Array<nearTransactions.Transaction> = []

    const [block, accounts] = await Promise.all([
      provider.block({ finality: 'final' }),
      this.getAllAccounts()
    ])

    for (let i = 0; i < transactions.length; i += 1) {
      const transaction = transactions[i]
      const account = accounts.find(x => x.accountId === transaction.signerId)

      if (!account) {
        throw new Error('Invalid signer id')
      }

      const accessKey = await provider.query<AccessKeyView>({
        request_type: 'view_access_key',
        finality: 'final',
        account_id: transaction.signerId,
        public_key: account.publicKey
      })

      txs.push(
        nearTransactions.createTransaction(
          transaction.signerId,
          utils.PublicKey.from(account.publicKey),
          transaction.receiverId,
          accessKey.nonce + i + 1,
          transaction.actions,
          utils.serialize.base_decode(block.header.hash)
        )
      )
    }

    return txs
  }

  async getAccounts({ topic }: GetAccountsParams): Promise<Array<Account>> {
    const session = walletkit.engine.signClient.session.get(topic)
    return Promise.all(
      session.namespaces.near.accounts.map(async account => {
        const accountId = account.split(':')[2]
        const keyPair = await this.keyStore.getKey(this.networkId, accountId)

        return {
          accountId,
          publicKey: keyPair.getPublicKey().toString()
        }
      })
    )
  }

  async signIn({ chainId, topic, permission, accounts }: SignInParams): Promise<Array<Account>> {
    if (!this.isAccountsValid(topic, accounts)) {
      throw new Error('Invalid accounts')
    }

    const result: Array<Account> = []

    for (let i = 0; i < accounts.length; i += 1) {
      const account = accounts[i]

      try {
        const [transaction] = await this.createTransactions({
          chainId,
          transactions: [
            {
              signerId: account.accountId,
              receiverId: account.accountId,
              actions: [
                nearTransactions.addKey(
                  utils.PublicKey.from(account.publicKey),
                  nearTransactions.functionCallAccessKey(
                    permission.receiverId,
                    permission.methodNames,
                    permission.allowance
                  )
                )
              ]
            }
          ]
        })

        await this.signAndSendTransaction({ chainId, topic, transaction })

        result.push(account)
      } catch (err) {
        console.log(`Failed to create FunctionCall access key for ${account.accountId}`)
        console.error(err)
      }
    }

    return result
  }

  async signOut({ chainId, topic, accounts }: SignOutParams): Promise<Array<Account>> {
    if (!this.isAccountsValid(topic, accounts)) {
      throw new Error('Invalid accounts')
    }

    const result: Array<Account> = []

    for (let i = 0; i < accounts.length; i += 1) {
      const account = accounts[i]

      try {
        const [transaction] = await this.createTransactions({
          chainId,
          transactions: [
            {
              signerId: account.accountId,
              receiverId: account.accountId,
              actions: [nearTransactions.deleteKey(utils.PublicKey.from(account.publicKey))]
            }
          ]
        })

        await this.signAndSendTransaction({ chainId, topic, transaction })
      } catch (err) {
        console.log(`Failed to remove FunctionCall access key for ${account.accountId}`)
        console.error(err)

        result.push(account)
      }
    }

    return result
  }

  async signTransactions({
    chainId,
    topic,
    transactions
  }: SignTransactionsParams): Promise<Array<nearTransactions.SignedTransaction>> {
    const networkId = chainId.split(':')[1]
    const signer = new InMemorySigner(this.keyStore)
    const signedTxs: Array<nearTransactions.SignedTransaction> = []

    if (!this.isTransactionsValid(topic, transactions)) {
      throw new Error('Invalid transactions')
    }

    for (let i = 0; i < transactions.length; i += 1) {
      const transaction = transactions[i]

      const [, signedTx] = await nearTransactions.signTransaction(
        transaction,
        signer,
        transaction.signerId,
        networkId
      )

      signedTxs.push(signedTx)
    }

    return signedTxs
  }

  async signAndSendTransaction({
    chainId,
    topic,
    transaction
  }: SignAndSendTransactionParams): Promise<providers.FinalExecutionOutcome> {
    const provider = new providers.JsonRpcProvider(NEAR_TEST_CHAINS[chainId as TNearChain].rpc)
    const [signedTx] = await this.signTransactions({
      chainId,
      topic,
      transactions: [transaction]
    })

    return provider.sendTransaction(signedTx)
  }

  async signAndSendTransactions({
    chainId,
    topic,
    transactions
  }: SignAndSendTransactionsParams): Promise<Array<providers.FinalExecutionOutcome>> {
    const provider = new providers.JsonRpcProvider(NEAR_TEST_CHAINS[chainId as TNearChain].rpc)
    const signedTxs = await this.signTransactions({ chainId, topic, transactions })
    const results: Array<providers.FinalExecutionOutcome> = []

    for (let i = 0; i < signedTxs.length; i += 1) {
      const signedTx = signedTxs[i]

      results.push(await provider.sendTransaction(signedTx))
    }

    return results
  }

  async signMessage({ chainId, messageParams }: SignMessageParams): Promise<SignedMessage> {
    const { message, nonce, recipient, callbackUrl, state, accountId } = messageParams
    const nonceArray = Buffer.from(nonce)

    if (nonceArray.length !== 32) {
      throw Error('Expected nonce to be a 32 bytes buffer')
    }

    const accounts = await this.getAllAccounts()
    const account = accounts.find(acc => acc.accountId === accountId)

    // If no accountId is provided in params default to the first accountId in accounts.
    // in a real wallet it would default to the `active/selected` account
    // this is because we should be able to use `signMessage` without `signIn`.
    const accId = account ? account.accountId : accounts[0].accountId

    const signer = new InMemorySigner(this.getKeyStore())
    const networkId = chainId.split(':')[1]

    // Create the message payload and sign it
    const payload = new MessagePayload({ message, nonce: nonceArray, recipient, callbackUrl })
    const encodedPayload = serialize(payloadSchema, payload)
    const signed = await signer.signMessage(encodedPayload, accId, networkId)

    return {
      accountId: accId,
      publicKey: signed.publicKey.toString(),
      signature: Buffer.from(signed.signature).toString('base64')
    }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/PolkadotLib.ts">
import { Keyring } from '@polkadot/keyring'
import { cryptoWaitReady, mnemonicGenerate } from '@polkadot/util-crypto'
import { KeyringPair } from '@polkadot/keyring/types'
import { u8aToHex } from '@polkadot/util'
import { SignerPayloadJSON } from '@polkadot/types/types'
import { TypeRegistry } from '@polkadot/types'

/**
 * Types
 */
interface IInitArguments {
  mnemonic?: string
}

/**
 * Library
 */
export default class PolkadotLib {
  keypair: KeyringPair
  mnemonic: string
  registry: TypeRegistry

  constructor(keypair: KeyringPair, mnemonic: string) {
    this.keypair = keypair
    this.mnemonic = mnemonic
    this.registry = new TypeRegistry()
  }

  static async init({ mnemonic }: IInitArguments) {
    // wait till  WASM is initialized, in case it is not initialized already (WASM is required for 'sr25519').
    await cryptoWaitReady()

    // create a keyring to load the account.
    const keyring = new Keyring({ type: 'sr25519', ss58Format: 1 })

    mnemonic = mnemonic || mnemonicGenerate()
    const keypair = keyring.createFromUri(mnemonic)

    return new PolkadotLib(keypair, mnemonic)
  }

  public getAddress() {
    return this.keypair.address
  }

  public getMnemonic() {
    return this.mnemonic
  }

  public async signMessage(message: string) {
    return {
      signature: u8aToHex(this.keypair.sign(message))
    }
  }

  public async signTransaction(payload: SignerPayloadJSON) {
    this.registry.setSignedExtensions(payload.signedExtensions)
    const txPayload = this.registry.createType('ExtrinsicPayload', payload, {
      version: payload.version
    })

    const { signature } = txPayload.sign(this.keypair)
    return { signature }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/SolanaLib.ts">
import {
  Keypair,
  Connection,
  SendOptions,
  VersionedTransaction,
  PublicKey,
  Transaction,
  SystemProgram
} from '@solana/web3.js'
import bs58 from 'bs58'
import nacl from 'tweetnacl'
import {
  getAssociatedTokenAddress,
  createTransferInstruction,
  TOKEN_PROGRAM_ID,
  getOrCreateAssociatedTokenAccount
} from '@solana/spl-token'
import { SOLANA_MAINNET_CHAINS, SOLANA_TEST_CHAINS } from '@/data/SolanaData'

/**
 * Types
 */
interface IInitArguments {
  secretKey?: Uint8Array
}

/**
 * Library
 */
export default class SolanaLib {
  keypair: Keypair

  constructor(keypair: Keypair) {
    this.keypair = keypair
  }

  static init({ secretKey }: IInitArguments) {
    const keypair = secretKey ? Keypair.fromSecretKey(secretKey) : Keypair.generate()

    return new SolanaLib(keypair)
  }

  public async getAddress() {
    return await this.keypair.publicKey.toBase58()
  }

  public getSecretKey() {
    return this.keypair.secretKey.toString()
  }

  public async signMessage(
    params: SolanaLib.SignMessage['params']
  ): Promise<SolanaLib.SignMessage['result']> {
    const signature = nacl.sign.detached(bs58.decode(params.message), this.keypair.secretKey)
    const bs58Signature = bs58.encode(signature)

    return { signature: bs58Signature }
  }

  public async signTransaction(
    params: SolanaLib.SignTransaction['params']
  ): Promise<SolanaLib.SignTransaction['result']> {
    const transaction = this.deserialize(params.transaction)
    this.sign(transaction)

    return {
      transaction: this.serialize(transaction),
      signature: bs58.encode(transaction.signatures[0])
    }
  }

  public async signAndSendTransaction(
    params: SolanaLib.SignAndSendTransaction['params'],
    chainId: string
  ): Promise<SolanaLib.SignAndSendTransaction['result']> {
    const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc

    if (!rpc) {
      throw new Error('There is no RPC URL for the provided chain')
    }

    const connection = new Connection(rpc)
    const transaction = this.deserialize(params.transaction)
    this.sign(transaction)

    const signature = await connection.sendTransaction(transaction, {
      maxRetries: 3,
      preflightCommitment: 'recent',
      ...params.options
    })

    return { signature }
  }

  public async signAllTransactions(
    params: SolanaLib.SignAllTransactions['params']
  ): Promise<SolanaLib.SignAllTransactions['result']> {
    const signedTransactions = params.transactions.map(transaction => {
      const transactionObj = this.deserialize(transaction)

      this.sign(transactionObj)

      return this.serialize(transactionObj)
    })

    return { transactions: signedTransactions }
  }

  private serialize(transaction: VersionedTransaction): string {
    return Buffer.from(transaction.serialize()).toString('base64')
  }

  private deserialize(transaction: string): VersionedTransaction {
    let bytes: Uint8Array
    try {
      bytes = bs58.decode(transaction)
    } catch {
      // Convert base64 to Uint8Array to avoid type issues
      const buffer = Buffer.from(transaction, 'base64')
      bytes = new Uint8Array(buffer)
    }

    return VersionedTransaction.deserialize(bytes)
  }

  private sign(transaction: VersionedTransaction) {
    transaction.sign([this.keypair])
  }

  /**
   * Send SOL to a recipient
   * @param recipientAddress The recipient's address
   * @param amount The amount to send in lamports (as a bigint)
   * @returns The transaction signature/hash
   */
  public async sendSol(recipientAddress: string, chainId: string, amount: bigint): Promise<string> {
    console.log({ chainId })
    const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc

    if (!rpc) {
      throw new Error('There is no RPC URL for the provided chain')
    }

    const connection = new Connection(rpc, 'confirmed')
    const fromPubkey = this.keypair.publicKey
    const toPubkey = new PublicKey(recipientAddress)

    // Create a simple SOL transfer transaction
    const transaction = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey,
        toPubkey,
        lamports: amount
      })
    )

    // Get recent blockhash
    const { blockhash } = await connection.getLatestBlockhash('confirmed')
    transaction.recentBlockhash = blockhash
    transaction.feePayer = fromPubkey

    // Sign the transaction
    transaction.sign(this.keypair)

    // Send and confirm the transaction
    const signature = await connection.sendRawTransaction(transaction.serialize())

    // Wait for confirmation
    await connection.confirmTransaction(signature, 'confirmed')

    return signature
  }

  /**
   * Send an SPL token to a recipient
   * @param tokenAddress The token's mint address
   * @param recipientAddress The recipient's address
   * @param amount The amount to send (as a bigint)
   * @returns The transaction signature/hash
   */
  public async sendSplToken(
    tokenAddress: string,
    recipientAddress: string,
    chainId: string,
    amount: bigint
  ): Promise<string> {
    const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc

    if (!rpc) {
      throw new Error('There is no RPC URL for the provided chain')
    }

    const connection = new Connection(rpc, 'confirmed')
    const fromWallet = this.keypair
    const fromPubkey = fromWallet.publicKey
    const toPubkey = new PublicKey(recipientAddress)
    const mint = new PublicKey(tokenAddress)

    // Get sender's token account (create if it doesn't exist)
    const fromTokenAccount = await getOrCreateAssociatedTokenAccount(
      connection,
      fromWallet,
      mint,
      fromPubkey
    )

    // Check if recipient has a token account WITHOUT creating one
    const associatedTokenAddress = await getAssociatedTokenAddress(mint, toPubkey)

    const recipientTokenAccount = await connection.getAccountInfo(associatedTokenAddress)

    if (!recipientTokenAccount) {
      throw new Error(
        `Recipient ${recipientAddress} doesn't have a token account for this SPL token. Transaction cannot proceed.`
      )
    }

    // Create transfer instruction to existing account
    const transferInstruction = createTransferInstruction(
      fromTokenAccount.address,
      associatedTokenAddress,
      fromPubkey,
      amount,
      [],
      TOKEN_PROGRAM_ID
    )

    // Create transaction and add the transfer instruction
    const transaction = new Transaction().add(transferInstruction)

    // Get recent blockhash
    const { blockhash } = await connection.getLatestBlockhash('confirmed')
    transaction.recentBlockhash = blockhash
    transaction.feePayer = fromPubkey

    // Sign the transaction
    transaction.sign(fromWallet)

    // Send and confirm the transaction
    const signature = await connection.sendRawTransaction(transaction.serialize())

    // Wait for confirmation
    await connection.confirmTransaction(signature, 'confirmed')

    return signature
  }
}

export namespace SolanaLib {
  type RPCRequest<Params, Result> = {
    params: Params
    result: Result
  }

  export type SignMessage = RPCRequest<{ message: string }, { signature: string }>

  export type SignTransaction = RPCRequest<
    { transaction: string },
    { transaction: string; signature: string }
  >

  export type SignAndSendTransaction = RPCRequest<
    { transaction: string; options?: SendOptions },
    { signature: string }
  >

  export type SignAllTransactions = RPCRequest<
    { transactions: string[] },
    { transactions: string[] }
  >
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/TezosLib.ts">
import { TezosToolkit } from '@taquito/taquito'
import { InMemorySigner } from '@taquito/signer'
import { localForger } from '@taquito/local-forging'
import { Wallet } from 'ethers/'

/**
 * Constants
 */
const DEFAULT_PATH = "m/44'/1729'/0'/0'"
const DEFAULT_CURVE = 'ed25519'

/**
 * Types
 */
interface IInitArguments {
  mnemonic?: string
  path?: string
  curve?: 'ed25519' | 'secp256k1'
}

/**
 * Library
 */
export default class TezosLib {
  tezos: TezosToolkit
  signer: InMemorySigner
  mnemonic: string
  secretKey: string
  publicKey: string
  address: string
  curve: 'ed25519' | 'secp256k1'

  constructor(
    tezos: TezosToolkit,
    mnemonic: string,
    signer: InMemorySigner,
    secretKey: string,
    publicKey: string,
    address: string,
    curve: 'ed25519' | 'secp256k1'
  ) {
    this.tezos = tezos
    this.mnemonic = mnemonic
    this.signer = signer
    this.secretKey = secretKey
    this.publicKey = publicKey
    this.address = address
    this.curve = curve
  }

  static async init({ mnemonic, path, curve }: IInitArguments) {
    const params = {
      mnemonic: mnemonic ?? Wallet.createRandom().mnemonic.phrase,
      derivationPath: path ?? DEFAULT_PATH,
      curve: curve ?? DEFAULT_CURVE
    }

    const Tezos = new TezosToolkit('https://mainnet.api.tez.ie')

    const signer = InMemorySigner.fromMnemonic(params)

    Tezos.setSignerProvider(signer)

    const secretKey = await signer.secretKey()
    const publicKey = await signer.publicKey()
    const address = await signer.publicKeyHash()

    return new TezosLib(Tezos, params.mnemonic, signer, secretKey, publicKey, address, params.curve)
  }

  public getMnemonic() {
    return this.mnemonic
  }

  public getPublicKey() {
    return this.publicKey
  }

  public getCurve() {
    return this.curve
  }

  public getAddress() {
    return this.address
  }

  public async signTransaction(transaction: any) {
    const prepared = await this.tezos.prepare.batch(
      transaction.map((tx: any) => ({
        amount: tx.amount,
        to: tx.destination,
        kind: tx.kind,
        mutez: true
      }))
    )

    const forged = await localForger.forge(prepared.opOb)

    const tx = await this.signer.sign(forged, new Uint8Array([3]))

    const hash = await this.tezos.rpc.injectOperation(tx.sbytes)

    return hash
  }

  public async signPayload(payload: any) {
    return await this.signer.sign(payload)
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/lib/TronLib.ts">
// @ts-ignore
import TronWeb from 'tronweb'

/**
 * Types
 */
interface IInitArguments {
  privateKey: string
}

/**
 * Library
 */
export default class TronLib {
  privateKey: string
  tronWeb: any

  constructor(privateKey: string) {
    this.privateKey = privateKey
    this.tronWeb = new TronWeb({
      // Nile TestNet, if you want to use in MainNet, change the fullHost to 'https://api.trongrid.io', or use tronWeb.setFullNode
      fullHost: 'https://nile.trongrid.io/',
      privateKey: privateKey
    })
  }

  static async init({ privateKey }: IInitArguments) {
    if (!privateKey) {
      const account = TronWeb.utils.accounts.generateAccount()
      return new TronLib(account.privateKey)
    } else {
      return new TronLib(privateKey)
    }
  }

  public getAddress() {
    return this.tronWeb.defaultAddress.base58
  }

  public createAccount() {
    return this.tronWeb.createAccount()
  }

  public setFullNode(node: string) {
    return this.tronWeb.setFullNode(node)
  }

  public async signMessage(message: string) {
    const signedtxn = await this.tronWeb.trx.signMessageV2(message)
    return signedtxn
  }

  public async signTransaction(transaction: any) {
    const signedtxn = await this.tronWeb.trx.sign(transaction.transaction)
    return signedtxn
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/accounts/[eip155Address]/modules/[module]/index.tsx">
import ModuleActions from '@/components/ModuleActions'
import PageHeader from '@/components/PageHeader'
import { Module, supportedModules } from '@/data/ERC7579ModuleData'
import { Loading, Spacer, Text } from '@nextui-org/react'
import { useRouter } from 'next/router'
import { Fragment, useEffect, useState } from 'react'

export default function ModulePage() {
  const [accountType, setAccountType] = useState('')
  const [accountAddress, setAccountAddress] = useState('')
  const [chainId, setChainId] = useState('')
  const [module, setModule] = useState<Module>()

  const { query } = useRouter()

  useEffect(() => {
    if (query?.eip155Address) {
      const type = (query.eip155Address as string).split(':')[0]
      const chain = (query.eip155Address as string).split(':')[1]
      const address = (query.eip155Address as string).split(':')[2]
      setAccountType(type)
      setChainId(chain)
      setAccountAddress(address)
    }
    if (query?.module) {
      const erc7579module = supportedModules.find(m => m.url === `/${query.module as string}`)
      setModule(erc7579module)
    }
  }, [query])

  if (!module || !accountAddress || !accountType || !chainId) {
    return <Loading />
  }

  return (
    <Fragment>
      <PageHeader title={`${module.name}`} />
      <Text>{module.description}</Text>
      <Spacer y={1} />
      <ModuleActions accountAddress={accountAddress} chainId={chainId} view={module?.view} />
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/accounts/[eip155Address]/index.tsx">
import PageHeader from '@/components/PageHeader'
import { getChainData, getViemChain } from '@/data/chainsUtil'
import SettingsStore from '@/store/SettingsStore'
import { truncate } from '@/utils/HelperUtil'
import ModulesManagement from '@/views/ModulesManagement'
import { Card, Divider, Row, Text } from '@nextui-org/react'
import { useRouter } from 'next/router'
import { isSmartAccountDeployed } from 'permissionless'
import { Fragment, useCallback, useEffect, useState } from 'react'
import { useSnapshot } from 'valtio'
import { Address, Chain, createPublicClient, http } from 'viem'

export default function AccountPage() {
  const [chainId, setChainId] = useState('')
  const [accountType, setAccountType] = useState('')
  const [accountAddress, setAccountAddress] = useState('')
  const [isAccountDeployed, setIsAccountDeployed] = useState(false)
  const [isFetching, setFetching] = useState(false)
  const [selectedChain, setSelectedChain] = useState<Chain>()
  const {
    smartAccountEnabled,
    kernelSmartAccountAddress,
    kernelSmartAccountEnabled,
    safeSmartAccountAddress,
    safeSmartAccountEnabled,
    biconomySmartAccountAddress,
    biconomySmartAccountEnabled,
    moduleManagementEnabled
  } = useSnapshot(SettingsStore.state)
  const { query } = useRouter()

  useEffect(() => {
    if (query?.eip155Address) {
      const type = (query.eip155Address as string).split(':')[0]
      const chainId = (query.eip155Address as string).split(':')[1]
      const address = (query.eip155Address as string).split(':')[2]
      setAccountType(type)
      setChainId(chainId)
      setAccountAddress(address)
    }
  }, [query])

  const isSmartContractAccountDeployed = useCallback(
    async (accountAddress: Address, chain: Chain) => {
      const publicClient = createPublicClient({
        transport: http(),
        chain: chain
      })

      return await isSmartAccountDeployed(publicClient, accountAddress)
    },
    []
  )
  useEffect(() => {
    if (!chainId || !accountAddress || !accountType) return
    setFetching(true)
    const chain = getViemChain(parseInt(chainId))
    setSelectedChain(chain)
    chain &&
      isSmartContractAccountDeployed(accountAddress as Address, chain)
        .then(result => {
          setIsAccountDeployed(result)
        })
        .finally(() => setFetching(false))
  }, [
    chainId,
    accountType,
    accountAddress,
    isSmartContractAccountDeployed,
    kernelSmartAccountAddress,
    safeSmartAccountAddress,
    biconomySmartAccountAddress
  ])

  if (!smartAccountEnabled) {
    return (
      <Fragment>
        <PageHeader title="Account Details" />
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>
          Please Enable smart accounts
        </Text>
      </Fragment>
    )
  }

  if (
    !(accountType === 'Kernel' || accountType === 'Safe' || accountType === 'Biconomy') ||
    !selectedChain
  ) {
    return (
      <Fragment>
        <PageHeader title="Account Details" />
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>
          Unknown smart account
        </Text>
      </Fragment>
    )
  }

  if (
    (accountType === 'Kernel' && !kernelSmartAccountEnabled) ||
    (accountType === 'Safe' && !safeSmartAccountEnabled) ||
    (accountType === 'Biconomy' && !biconomySmartAccountEnabled)
  ) {
    return (
      <Fragment>
        <PageHeader title="Account Details" />
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>
          Please enable {accountType} smart account
        </Text>
      </Fragment>
    )
  }

  return (
    <Fragment>
      <PageHeader title="Account Details" />
      <Card>
        <Card.Body
          css={{
            paddingTop: '$0',
            flexDirection: 'column',
            overflow: 'hidden'
          }}
        >
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Type</Text>
            {accountType.toLocaleUpperCase()} SCA
          </Row>
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Address</Text>
            {accountAddress ? truncate(accountAddress, 19) : '<no address available>'}
          </Row>
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Deployed</Text>
            {isAccountDeployed ? 'true' : 'false'}
          </Row>
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Chain</Text>
            <Text>{selectedChain?.name}</Text>
          </Row>

          {moduleManagementEnabled ? (
            <Fragment>
              <Divider css={{ marginBottom: '$10' }} />
              {!isFetching && (
                <ModulesManagement
                  accountAddress={accountAddress}
                  accountType={accountType}
                  chainId={chainId}
                  isDeployed={isAccountDeployed}
                />
              )}
            </Fragment>
          ) : (
            <Row justify="space-between" align="center">
              <Text h4>Module Management</Text>
              <Text>Disabled</Text>
            </Row>
          )}
        </Card.Body>
      </Card>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/api/wallet.ts">
import {
  handleGetAssets,
  WalletGetAssetsRequest,
  WalletGetAssetsResponse
} from '@/data/EIP7811Data'
import {
  ErrorResponse,
  GetCallsStatusParams,
  GetCallsStatusReturnValue,
  PrepareCallsParams,
  PrepareCallsReturnValue,
  SendPreparedCallsParams,
  SendPreparedCallsReturnValue
} from '@/lib/smart-accounts/builders/UserOpBuilder'
import { getChainById } from '@/utils/ChainUtil'
import { PIMLICO_NETWORK_NAMES } from '@/utils/SmartAccountUtil'
import { getUserOpBuilder } from '@/utils/UserOpBuilderUtil'
import { NextApiRequest, NextApiResponse } from 'next'
import { ENTRYPOINT_ADDRESS_V07 } from 'permissionless'
import { createPimlicoBundlerClient } from 'permissionless/clients/pimlico'
import { http, toHex } from 'viem'

type JsonRpcRequest = {
  jsonrpc: '2.0'
  id: number | string
  method: string
  params: any[]
}

type JsonRpcResponse<T> = {
  jsonrpc: '2.0'
  id: number | string | null
  result?: T
  error?: {
    code: number
    message: string
    data?: any
  }
}

type SupportedMethods =
  | 'wallet_prepareCalls'
  | 'wallet_sendPreparedCalls'
  | 'wallet_getCallsStatus'
  | 'wallet_getAssets'
const ERROR_CODES = {
  INVALID_REQUEST: -32600,
  METHOD_NOT_FOUND: -32601,
  INVALID_PARAMS: -32602,
  INTERNAL_ERROR: -32000
}

function createErrorResponse(
  id: number | string | null,
  code: number,
  message: string,
  data?: any
): JsonRpcResponse<never> {
  return {
    jsonrpc: '2.0',
    id,
    error: { code, message, data }
  }
}

async function handlePrepareCalls(
  projectId: string,
  params: PrepareCallsParams[]
): Promise<PrepareCallsReturnValue> {
  const [data] = params
  const chainId = parseInt(data.chainId, 16)
  const account = data.from
  const chain = getChainById(chainId)
  const builder = await getUserOpBuilder({ account, chain })
  return builder.prepareCalls(projectId, data)
}

async function handleSendPreparedCalls(
  projectId: string,
  params: SendPreparedCallsParams[]
): Promise<SendPreparedCallsReturnValue> {
  const [data] = params
  const chainId = parseInt(data.preparedCalls.chainId, 16)
  const account = data.preparedCalls.data.sender
  const chain = getChainById(chainId)
  const builder = await getUserOpBuilder({ account, chain })
  return builder.sendPreparedCalls(projectId, data)
}

async function handleGetCallsStatus(
  projectId: string,
  params: GetCallsStatusParams[]
): Promise<GetCallsStatusReturnValue> {
  const [userOpIdentifier] = params
  const chainId = userOpIdentifier.split(':')[0]
  const userOpHash = userOpIdentifier.split(':')[1]
  const chain = getChainById(parseInt(chainId, 16))
  const pimlicoChainName = PIMLICO_NETWORK_NAMES[chain.name]
  const apiKey = process.env.NEXT_PUBLIC_PIMLICO_KEY
  const localBundlerUrl = process.env.NEXT_PUBLIC_LOCAL_BUNDLER_URL
  const bundlerUrl =
    localBundlerUrl || `https://api.pimlico.io/v1/${pimlicoChainName}/rpc?apikey=${apiKey}`
  const bundlerClient = createPimlicoBundlerClient({
    entryPoint: ENTRYPOINT_ADDRESS_V07,
    transport: http(bundlerUrl)
  })
  const userOpReceipt = await bundlerClient.getUserOperationReceipt({
    hash: userOpHash as `0x${string}`
  })
  const receipt: GetCallsStatusReturnValue = {
    status: userOpReceipt ? 'CONFIRMED' : 'PENDING',
    receipts: userOpReceipt
      ? [
          {
            logs: userOpReceipt.logs.map(log => ({
              data: log.data,
              address: log.address,
              topics: log.topics
            })),
            blockHash: userOpReceipt.receipt.blockHash,
            blockNumber: toHex(userOpReceipt.receipt.blockNumber),
            gasUsed: toHex(userOpReceipt.actualGasUsed),
            transactionHash: userOpReceipt.receipt.transactionHash,
            status: userOpReceipt.success ? '0x1' : '0x0'
          }
        ]
      : undefined
  }
  return receipt
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<
    JsonRpcResponse<
      | PrepareCallsReturnValue[]
      | SendPreparedCallsReturnValue[]
      | GetCallsStatusReturnValue[]
      | WalletGetAssetsResponse[]
      | ErrorResponse
    >
  >
) {
  if (req.method === 'OPTIONS') {
    return res.status(200).end()
  }

  if (req.method !== 'POST') {
    return res
      .status(405)
      .json(createErrorResponse(null, ERROR_CODES.INVALID_REQUEST, 'Invalid Request'))
  }

  const jsonRpcRequest: JsonRpcRequest = req.body
  const { id, method, params } = jsonRpcRequest
  if (
    ![
      'wallet_prepareCalls',
      'wallet_sendPreparedCalls',
      'wallet_getCallsStatus',
      'wallet_getAssets'
    ].includes(method)
  ) {
    return res
      .status(200)
      .json(createErrorResponse(id, ERROR_CODES.METHOD_NOT_FOUND, `${method} method not found`))
  }

  const projectId = req.query.projectId as string
  if (!projectId) {
    return res
      .status(200)
      .json(createErrorResponse(id, ERROR_CODES.INVALID_PARAMS, 'Invalid projectId'))
  }

  try {
    let response:
      | PrepareCallsReturnValue
      | SendPreparedCallsReturnValue
      | GetCallsStatusReturnValue
      | WalletGetAssetsResponse

    switch (method as SupportedMethods) {
      case 'wallet_prepareCalls':
        response = await handlePrepareCalls(projectId, params as PrepareCallsParams[])
        return res.status(200).json({
          jsonrpc: '2.0',
          id,
          result: [response] as PrepareCallsReturnValue[]
        })

      case 'wallet_sendPreparedCalls':
        response = await handleSendPreparedCalls(projectId, params as SendPreparedCallsParams[])
        return res.status(200).json({
          jsonrpc: '2.0',
          id,
          result: [response] as SendPreparedCallsReturnValue[]
        })

      case 'wallet_getCallsStatus':
        response = await handleGetCallsStatus(projectId, params as GetCallsStatusParams[])
        return res.status(200).json({
          jsonrpc: '2.0',
          id,
          result: [response] as GetCallsStatusReturnValue[]
        })

      case 'wallet_getAssets':
        console.log('wallet_getAssets call received')
        response = await handleGetAssets(projectId, params as WalletGetAssetsRequest[])
        return res.status(200).json({
          jsonrpc: '2.0',
          id,
          result: [response] as WalletGetAssetsResponse[]
        })

      default:
        throw new Error(`Unsupported method: ${method}`)
    }
  } catch (error: any) {
    console.error(error)
    return res
      .status(200)
      .json(
        createErrorResponse(
          id,
          ERROR_CODES.INTERNAL_ERROR,
          `${method}: Internal error`,
          error.message
        )
      )
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/_app.tsx">
import { Toaster } from 'react-hot-toast'
import { useEffect } from 'react'
import { createTheme, NextUIProvider } from '@nextui-org/react'

import Layout from '@/components/Layout'
import Modal from '@/components/Modal'
import useInitialization from '@/hooks/useInitialization'
import useWalletConnectEventsManager from '@/hooks/useWalletConnectEventsManager'
import { walletkit } from '@/utils/WalletConnectUtil'
import { RELAYER_EVENTS } from '@walletconnect/core'
import { AppProps } from 'next/app'
import '../../public/main.css'
import { styledToast } from '@/utils/HelperUtil'

export default function App({ Component, pageProps }: AppProps) {
  // Step 1 - Initialize wallets and wallet connect client
  const initialized = useInitialization()

  // Step 2 - Once initialized, set up wallet connect event manager
  useWalletConnectEventsManager(initialized)
  useEffect(() => {
    if (!initialized) return
    walletkit?.core.relayer.on(RELAYER_EVENTS.connect, () => {
      styledToast('Network connection is restored!', 'success')
    })

    walletkit?.core.relayer.on(RELAYER_EVENTS.disconnect, () => {
      styledToast('Network connection lost.', 'error')
    })
  }, [initialized])
  return (
    <NextUIProvider theme={createTheme({ type: 'dark' })}>
      <Layout initialized={initialized}>
        <Toaster />
        <Component {...pageProps} />
      </Layout>

      <Modal />
    </NextUIProvider>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/account.tsx">
import PageHeader from '@/components/PageHeader'
import SettingsStore from '@/store/SettingsStore'
import { truncate } from '@/utils/HelperUtil'
import {
  biconomyAllowedChains,
  kernelAllowedChains,
  safeAllowedChains
} from '@/utils/SmartAccountUtil'
import ModulesManagement from '@/views/ModulesManagement'
import { Card, Divider, Row, Text } from '@nextui-org/react'
import { useRouter } from 'next/router'
import { isSmartAccountDeployed } from 'permissionless'
import { Fragment, useCallback, useEffect, useState } from 'react'
import { useSnapshot } from 'valtio'
import { Address, Chain, createPublicClient, http } from 'viem'

export default function AccountPage() {
  const [accountType, setAccountType] = useState('')
  const [chainId, setChainId] = useState('')
  const [accountAddress, setAccountAddress] = useState('')
  const [isAccountDeployed, setIsAccountDeployed] = useState(false)
  const [selectedChain, setSelectedChain] = useState<Chain>()
  const {
    smartAccountEnabled,
    kernelSmartAccountAddress,
    kernelSmartAccountEnabled,
    safeSmartAccountAddress,
    safeSmartAccountEnabled,
    biconomySmartAccountAddress,
    biconomySmartAccountEnabled,
    moduleManagementEnabled
  } = useSnapshot(SettingsStore.state)
  const { query } = useRouter()

  useEffect(() => {
    if (query?.accountType) {
      setAccountType(query.accountType as string)
    }
    if (query?.chainId) {
      setChainId(query.chainId as string)
    }
  }, [query])

  const isSmartContractAccountDeployed = useCallback(
    async (accountAddress: Address, chain: Chain) => {
      const publicClient = createPublicClient({
        transport: http(),
        chain: chain
      })

      return await isSmartAccountDeployed(publicClient, accountAddress)
    },
    []
  )
  useEffect(() => {
    if (!chainId || !accountType) return

    let address, chain
    if (accountType === 'Kernel') {
      address = kernelSmartAccountAddress as Address
      chain = kernelAllowedChains.find(c => c.id === parseInt(chainId))
    } else if (accountType === 'Safe') {
      address = safeSmartAccountAddress as Address
      chain = safeAllowedChains.find(c => c.id === parseInt(chainId))
    } else if (accountType === 'Biconomy') {
      address = biconomySmartAccountAddress as Address
      chain = biconomyAllowedChains.find(c => c.id === parseInt(chainId))
    }

    if (address && chain) {
      setAccountAddress(address)
      setSelectedChain(chain)

      isSmartContractAccountDeployed(address, chain).then(result => {
        setIsAccountDeployed(result)
      })
    }
  }, [
    accountType,
    chainId,
    isSmartContractAccountDeployed,
    kernelSmartAccountAddress,
    safeSmartAccountAddress,
    biconomySmartAccountAddress
  ])

  if (!smartAccountEnabled) {
    return (
      <Fragment>
        <PageHeader title="Account Details" />
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>
          Please Enable smart accounts
        </Text>
      </Fragment>
    )
  }

  if (
    !(accountType === 'Kernel' || accountType === 'Safe' || accountType === 'Biconomy') ||
    !selectedChain
  ) {
    return (
      <Fragment>
        <PageHeader title="Account Details" />
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>
          Unknown smart account
        </Text>
      </Fragment>
    )
  }

  if (
    (accountType === 'Kernel' && !kernelSmartAccountEnabled) ||
    (accountType === 'Safe' && !safeSmartAccountEnabled) ||
    (accountType === 'Biconomy' && !biconomySmartAccountEnabled)
  ) {
    return (
      <Fragment>
        <PageHeader title="Account Details" />
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>
          Please enable {accountType} smart account
        </Text>
      </Fragment>
    )
  }

  return (
    <Fragment>
      <PageHeader title="Account Details" />
      <Card>
        <Card.Body
          css={{
            paddingTop: '$0',
            flexDirection: 'column',
            overflow: 'hidden'
          }}
        >
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Type</Text>
            {accountType.toLocaleUpperCase()} SCA
          </Row>
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Address</Text>
            {accountAddress ? truncate(accountAddress, 19) : '<no address available>'}
          </Row>
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Deployed</Text>
            {isAccountDeployed ? 'true' : 'false'}
          </Row>
          <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
            <Text h4>Chain</Text>
            <Text>{selectedChain?.name}</Text>
          </Row>

          {moduleManagementEnabled ? (
            <Fragment>
              <Divider css={{ marginBottom: '$10' }} />
              <ModulesManagement
                accountAddress={accountAddress}
                accountType={accountType}
                chainId={chainId}
                isDeployed={isAccountDeployed}
              />
            </Fragment>
          ) : (
            <Row justify="space-between" align="center">
              <Text h4>Module Management</Text>
              <Text>Disabled</Text>
            </Row>
          )}
        </Card.Body>
      </Card>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/index.tsx">
import AccountCard from '@/components/AccountCard'
import AccountPicker from '@/components/AccountPicker'
import PageHeader from '@/components/PageHeader'
import { COSMOS_MAINNET_CHAINS } from '@/data/COSMOSData'
import { EIP155_MAINNET_CHAINS, EIP155_TEST_CHAINS } from '@/data/EIP155Data'
import { SOLANA_MAINNET_CHAINS, SOLANA_TEST_CHAINS } from '@/data/SolanaData'
import { POLKADOT_MAINNET_CHAINS, POLKADOT_TEST_CHAINS } from '@/data/PolkadotData'
import { MULTIVERSX_MAINNET_CHAINS, MULTIVERSX_TEST_CHAINS } from '@/data/MultiversxData'
import { TRON_MAINNET_CHAINS, TRON_TEST_CHAINS } from '@/data/TronData'
import { NEAR_TEST_CHAINS } from '@/data/NEARData'
import { TEZOS_MAINNET_CHAINS, TEZOS_TEST_CHAINS } from '@/data/TezosData'
import { KADENA_MAINNET_CHAINS, KADENA_TEST_CHAINS } from '@/data/KadenaData'
import SettingsStore from '@/store/SettingsStore'
import { Text } from '@nextui-org/react'
import { Fragment } from 'react'
import { useSnapshot } from 'valtio'
import useSmartAccounts from '@/hooks/useSmartAccounts'
import { BIP122_CHAINS } from '@/data/Bip122Data'
import { useRouter } from 'next/router'
import ChainAbstractionBalanceCard from '@/components/ChainAbstractionBalanceCard'

export default function HomePage() {
  const {
    testNets,
    eip155Address,
    cosmosAddress,
    solanaAddress,
    polkadotAddress,
    nearAddress,
    multiversxAddress,
    tronAddress,
    tezosAddress,
    kadenaAddress,
    bip122Address,
    smartAccountEnabled,
    chainAbstractionEnabled
  } = useSnapshot(SettingsStore.state)
  const { getAvailableSmartAccounts } = useSmartAccounts()
  const { push } = useRouter()
  return (
    <Fragment>
      <PageHeader title="Accounts">
        <AccountPicker data-testid="account-picker" />
      </PageHeader>
      {chainAbstractionEnabled ? <ChainAbstractionBalanceCard /> : null}
      <Text h4 css={{ marginBottom: '$5' }}>
        Mainnets
      </Text>
      {Object.entries(EIP155_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={eip155Address}
          chainId={caip10.toString()}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(COSMOS_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={cosmosAddress}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(SOLANA_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={solanaAddress}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(POLKADOT_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={polkadotAddress}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(MULTIVERSX_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={multiversxAddress}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(TRON_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={tronAddress}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(TEZOS_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={tezosAddress}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(KADENA_MAINNET_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={kadenaAddress}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}
      {Object.entries(BIP122_CHAINS).map(([caip10, { name, logo, rgb }]) => (
        <AccountCard
          key={name}
          name={name}
          logo={logo}
          rgb={rgb}
          address={bip122Address}
          chainId={caip10}
          data-testid={'chain-card-' + caip10.toString()}
        />
      ))}

      {testNets ? (
        <Fragment>
          <Text h4 css={{ marginBottom: '$5' }}>
            Testnets
          </Text>
          {Object.entries(EIP155_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={eip155Address}
              chainId={caip10.toString()}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
          {Object.entries(EIP155_TEST_CHAINS).map(([caip10, { name, logo, rgb, chainId }]) => {
            if (smartAccountEnabled) {
              return (
                <div key={`${name}-smart`} style={{ marginBottom: 10 }}>
                  {getAvailableSmartAccounts()
                    .filter(account => {
                      return account.chain.id === chainId
                    })
                    .map(account => {
                      return (
                        <div
                          style={{ marginBottom: 10, cursor: 'pointer' }}
                          key={`${name}-${account.type.toLowerCase()}`}
                          onClick={() =>
                            push({
                              pathname: `/accounts/${account.type}:${chainId}:${account.address}`
                            })
                          }
                        >
                          <AccountCard
                            key={`${name}-${account.type.toLowerCase()}`}
                            name={`${account.type} Smart Account \n ${name}`}
                            logo={logo}
                            rgb={rgb}
                            address={account.address}
                            chainId={caip10.toString()}
                            data-testid={`chain-card-${caip10.toString()}-${account.type.toLowerCase()}`}
                          />
                        </div>
                      )
                    })}
                </div>
              )
            }
          })}
          {Object.entries(SOLANA_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={solanaAddress}
              chainId={caip10}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
          {Object.entries(POLKADOT_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={polkadotAddress}
              chainId={caip10}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
          {Object.entries(NEAR_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={nearAddress}
              chainId={caip10}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
          {Object.entries(MULTIVERSX_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={multiversxAddress}
              chainId={caip10}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
          {Object.entries(TRON_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={tronAddress}
              chainId={caip10}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
          {Object.entries(TEZOS_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={tezosAddress}
              chainId={caip10}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
          {Object.entries(KADENA_TEST_CHAINS).map(([caip10, { name, logo, rgb }]) => (
            <AccountCard
              key={name}
              name={name}
              logo={logo}
              rgb={rgb}
              address={kadenaAddress}
              chainId={caip10}
              data-testid={'chain-card-' + caip10.toString()}
            />
          ))}
        </Fragment>
      ) : null}
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/pairings.tsx">
import PageHeader from '@/components/PageHeader'
import PairingCard from '@/components/PairingCard'
import { walletkit } from '@/utils/WalletConnectUtil'
import { Text } from '@nextui-org/react'
import { getSdkError } from '@walletconnect/utils'
import { Fragment, useState } from 'react'

export default function PairingsPage() {
  const [pairings, setPairings] = useState(walletkit.core.pairing.getPairings())

  async function onDelete(topic: string) {
    await walletkit.disconnectSession({ topic, reason: getSdkError('USER_DISCONNECTED') })
    const newPairings = pairings.filter(pairing => pairing.topic !== topic)
    setPairings(newPairings)
  }

  return (
    <Fragment>
      <PageHeader title="Pairings" />
      {pairings.length ? (
        pairings.map(pairing => {
          const { peerMetadata } = pairing

          return (
            <PairingCard
              key={pairing.topic}
              logo={peerMetadata?.icons[0]}
              url={peerMetadata?.url}
              name={peerMetadata?.name}
              topic={pairing.topic}
              onDelete={() => onDelete(pairing.topic)}
              data-testid={'pairing-' + pairing.topic}
            />
          )
        })
      ) : (
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>No pairings</Text>
      )}
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/session.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import PageHeader from '@/components/PageHeader'
import ProjectInfoCard from '@/components/ProjectInfoCard'
import SessionChainCard from '@/components/SessionChainCard'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import { Button, Col, Divider, Loading, Row, Text } from '@nextui-org/react'
import { getSdkError } from '@walletconnect/utils'
import { useRouter } from 'next/router'
import { Fragment, useCallback, useEffect, useMemo, useState } from 'react'

/**
 * Component
 */
export default function SessionPage() {
  const [topic, setTopic] = useState('')
  const [updated, setUpdated] = useState(new Date())
  const { query, replace } = useRouter()
  const [updateLoading, setUpdateLoading] = useState(false)
  const [pingLoading, setPingLoading] = useState(false)
  const [emitLoading, setEmitLoading] = useState(false)
  const [deleteLoading, setDeleteLoading] = useState(false)
  const [pendingRequests, setPendingRequests] = useState<any[]>([])

  useEffect(() => {
    if (query?.topic) {
      setTopic(query.topic as string)
    }
  }, [query])

  const session = useMemo(
    () => walletkit.engine.signClient.session.values.find(s => s.topic === topic),
    [topic]
  )
  const namespaces = useMemo(() => session?.namespaces, [session])

  // Get necessary data from session
  const expiryDate = useMemo(() => new Date(session?.expiry! * 1000), [session])
  const getPendingRequests = useCallback(() => {
    if (!session) return
    const allPending = walletkit.getPendingSessionRequests()
    const requestsForSession = allPending?.filter(r => r.topic === session.topic)
    setPendingRequests(requestsForSession)
  }, [session])

  useEffect(() => {
    const interval = setInterval(() => {
      getPendingRequests()
    }, 1000)
    getPendingRequests()
    return () => clearInterval(interval)
  }, [getPendingRequests])

  // Handle deletion of a session
  const onDeleteSession = useCallback(async () => {
    setDeleteLoading(true)
    try {
      await walletkit.disconnectSession({ topic, reason: getSdkError('USER_DISCONNECTED') })
      replace('/sessions')
    } catch (e) {
      styledToast((e as Error).message, 'error')
    }
    setDeleteLoading(false)
  }, [topic, replace])

  const onSessionPing = useCallback(async () => {
    setPingLoading(true)
    await walletkit.engine.signClient.ping({ topic })
    setPingLoading(false)
  }, [topic])

  const onSessionEmit = useCallback(async () => {
    setEmitLoading(true)
    try {
      const namespace = Object.keys(session?.namespaces!)[0]
      const chainId = session?.namespaces[namespace].chains?.[0]
      await walletkit.emitSessionEvent({
        topic,
        event: { name: 'chainChanged', data: 'Hello World' },
        chainId: chainId! // chainId: 'eip155:1'
      })
    } catch (e) {
      styledToast((e as Error).message, 'error')
    }
    setEmitLoading(false)
  }, [session?.namespaces, topic])

  const onSessionUpdate = useCallback(async () => {
    setUpdateLoading(true)
    try {
      const session = walletkit.engine.signClient.session.get(topic)
      const baseAddress = '0x70012948c348CBF00806A3C79E3c5DAdFaAa347'
      const namespaceKeyToUpdate = Object.keys(session?.namespaces)[0]
      const namespaceToUpdate = session?.namespaces[namespaceKeyToUpdate]
      await walletkit.updateSession({
        topic,
        namespaces: {
          ...session?.namespaces,
          [namespaceKeyToUpdate]: {
            ...session?.namespaces[namespaceKeyToUpdate],
            accounts: namespaceToUpdate.accounts.concat(
              `${namespaceToUpdate.chains?.[0]}:${baseAddress}${Math.floor(
                Math.random() * (9 - 1 + 1) + 0
              )}`
            ) // generates random number between 0 and 9
          }
        }
      })
      setUpdated(new Date())
    } catch (e) {
      styledToast((e as Error).message, 'error')
    }
    setUpdateLoading(false)
  }, [topic])

  return !session ? (
    <></>
  ) : (
    <Fragment>
      <PageHeader title="Session Details" />

      <ProjectInfoCard metadata={session.peer.metadata} />

      <Divider y={2} />
      {pendingRequests.length > 0 ? (
        <Fragment>
          <Text h4 css={{ marginBottom: '$5' }}>
            Pending Requests ({pendingRequests.length})
          </Text>
          {pendingRequests.map((request, index) => {
            return (
              <Fragment key={index}>
                <Row>
                  <Col>
                    <Text css={{ color: '$gray400' }}>
                      {request.id} - ⏳{' '}
                      {(
                        (request.params.request?.expiryTimestamp * 1000 - Date.now()) /
                        1000
                      ).toFixed(0)}
                      s
                    </Text>
                  </Col>
                </Row>
              </Fragment>
            )
          })}
          <Divider y={2} />
        </Fragment>
      ) : null}
      {namespaces &&
        Object.keys(namespaces).map(chain => {
          return (
            <Fragment key={chain}>
              <Text h4 css={{ marginBottom: '$5' }}>{`Review ${chain} permissions`}</Text>
              <SessionChainCard
                namespace={namespaces[chain]}
                data-testid={'session-card' + namespaces[chain]}
              />
              <Divider y={2} />
            </Fragment>
          )
        })}

      <Row justify="space-between">
        <Text h5>Expiry</Text>
        <Text css={{ color: '$gray400' }}>
          {expiryDate.toDateString()} - {expiryDate.toLocaleTimeString()}
        </Text>
      </Row>

      <Row justify="space-between">
        <Text h5>Last Updated</Text>
        <Text css={{ color: '$gray400' }}>
          {updated.toDateString()} - {updated.toLocaleTimeString()}
        </Text>
      </Row>

      <Row css={{ marginTop: '$10' }}>
        <Button
          flat
          css={{ width: '100%' }}
          color="error"
          onClick={onDeleteSession}
          data-testid="session-delete-button"
        >
          {deleteLoading ? <Loading size="sm" color="error" type="points" /> : 'Delete'}
        </Button>
      </Row>

      <Row css={{ marginTop: '$10' }}>
        <Button
          flat
          css={{ width: '100%' }}
          color="primary"
          onClick={onSessionPing}
          data-testid="session-ping-button"
        >
          {pingLoading ? <Loading size="sm" color="primary" type="points" /> : 'Ping'}
        </Button>
      </Row>

      <Row css={{ marginTop: '$10' }}>
        <Button
          flat
          css={{ width: '100%' }}
          color="secondary"
          onClick={onSessionEmit}
          data-testid="session-emit-button"
        >
          {emitLoading ? <Loading size="sm" color="secondary" type="points" /> : 'Emit'}
        </Button>
      </Row>

      <Row css={{ marginTop: '$10' }}>
        <Button
          flat
          css={{ width: '100%' }}
          color="warning"
          onClick={onSessionUpdate}
          data-testid="session-update-button"
        >
          {updateLoading ? <Loading size="sm" color="warning" type="points" /> : 'Update'}
        </Button>
      </Row>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/sessions.tsx">
import PageHeader from '@/components/PageHeader'
import SessionCard from '@/components/SessionCard'
import SettingsStore from '@/store/SettingsStore'
import { Text } from '@nextui-org/react'
import { Fragment, useEffect } from 'react'
import { useSnapshot } from 'valtio'
import { refreshSessionsList } from './wc'

export default function SessionsPage() {
  const { sessions } = useSnapshot(SettingsStore.state)
  useEffect(() => refreshSessionsList(), [])
  if (!sessions.length) {
    return (
      <Fragment>
        <PageHeader title="Sessions" />
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>No sessions</Text>
      </Fragment>
    )
  }

  return (
    <Fragment>
      <PageHeader title="Sessions" />
      {sessions.length
        ? sessions.map(session => {
            const { name, icons, url } = session.peer.metadata

            return (
              <SessionCard
                key={session.topic}
                topic={session.topic}
                name={name}
                logo={icons[0]}
                url={url}
              />
            )
          })
        : null}
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/settings.tsx">
import PageHeader from '@/components/PageHeader'
import RelayRegionPicker from '@/components/RelayRegionPicker'
import SettingsStore from '@/store/SettingsStore'
import { cosmosWallets } from '@/utils/CosmosWalletUtil'
import { eip155Wallets } from '@/utils/EIP155WalletUtil'
import { solanaWallets } from '@/utils/SolanaWalletUtil'
import { multiversxWallets } from '@/utils/MultiversxWalletUtil'
import { tronWallets } from '@/utils/TronWalletUtil'
import { kadenaWallets } from '@/utils/KadenaWalletUtil'
import { Card, Col, Divider, Row, Switch, Text } from '@nextui-org/react'
import { Fragment } from 'react'
import { useSnapshot } from 'valtio'
import packageJSON from '../../package.json'
import { tezosWallets } from '@/utils/TezosWalletUtil'

export default function SettingsPage() {
  const {
    testNets,
    smartAccountSponsorshipEnabled,
    eip155Address,
    cosmosAddress,
    solanaAddress,
    multiversxAddress,
    tronAddress,
    tezosAddress,
    kadenaAddress,
    smartAccountEnabled,
    kernelSmartAccountEnabled,
    safeSmartAccountEnabled,
    biconomySmartAccountEnabled,
    moduleManagementEnabled,
    chainAbstractionEnabled
  } = useSnapshot(SettingsStore.state)

  return (
    <Fragment>
      <PageHeader title="Settings" />

      <Text h4 css={{ marginBottom: '$5' }}>
        Packages
      </Text>
      <Row justify="space-between" align="center">
        <Text color="$gray400">@reown/walletkit</Text>
        <Text color="$gray400">{packageJSON.dependencies['@reown/walletkit']}</Text>
      </Row>

      <Divider y={2} />

      <Text h4 css={{ marginBottom: '$5' }}>
        Testnets
      </Text>
      <Row justify="space-between" align="center">
        <Switch
          checked={testNets}
          onChange={SettingsStore.toggleTestNets}
          data-testid="settings-toggle-testnets"
        />
        <Text>{testNets ? 'Enabled' : 'Disabled'}</Text>
      </Row>

      <Divider y={2} />

      <Row>
        <Col>
          <Text h4 css={{ marginBottom: '$5' }}>
            Chain Abstraction
          </Text>
          {testNets ? (
            <>
              <Row justify="space-between" align="center">
                <Switch
                  checked={chainAbstractionEnabled}
                  onChange={SettingsStore.toggleChainAbstractionEnabled}
                  data-testid="settings-toggle-chain-abstraction-enabled"
                />
                <Text>{chainAbstractionEnabled ? 'Enabled' : 'Disabled'}</Text>
              </Row>
            </>
          ) : (
            <Text color="$gray400">This feature requires testnets</Text>
          )}
        </Col>
      </Row>

      <Divider y={2} />

      <Row>
        <Col>
          <Text h4 css={{ marginBottom: '$5' }}>
            Smart Accounts
          </Text>
          {testNets ? (
            <>
              <Row justify="space-between" align="center">
                <Switch
                  checked={smartAccountEnabled}
                  onChange={SettingsStore.toggleSmartAccountEnabled}
                  data-testid="settings-toggle-smart-account-enabled"
                />
                <Text>{smartAccountEnabled ? 'Enabled' : 'Disabled'}</Text>
              </Row>

              {smartAccountEnabled ? (
                <>
                  <Text h4 css={{ marginBottom: '$5', marginTop: '$5' }}>
                    ZeroDev Smart Account
                  </Text>
                  <Row justify="space-between" align="center">
                    <Switch
                      checked={kernelSmartAccountEnabled}
                      onChange={SettingsStore.toggleKernelSmartAccountsEnabled}
                      data-testid="settings-toggle-smart-account-sponsorship"
                    />
                    <Text>{kernelSmartAccountEnabled ? 'Enabled' : 'Disabled'}</Text>
                  </Row>

                  <Text h4 css={{ marginBottom: '$5', marginTop: '$5' }}>
                    Safe Smart Account
                  </Text>
                  <Row justify="space-between" align="center">
                    <Switch
                      checked={safeSmartAccountEnabled}
                      onChange={SettingsStore.toggleSafeSmartAccountsEnabled}
                      data-testid="settings-toggle-smart-account-sponsorship"
                    />
                    <Text>{safeSmartAccountEnabled ? 'Enabled' : 'Disabled'}</Text>
                  </Row>

                  <Text h4 css={{ marginBottom: '$5', marginTop: '$5' }}>
                    Biconomy Smart Account
                  </Text>
                  <Row justify="space-between" align="center">
                    <Switch
                      checked={biconomySmartAccountEnabled}
                      onChange={SettingsStore.toggleBiconomySmartAccountsEnabled}
                      data-testid="settings-toggle-smart-account-sponsorship"
                    />
                    <Text>{biconomySmartAccountEnabled ? 'Enabled' : 'Disabled'}</Text>
                  </Row>

                  <Text h4 css={{ marginBottom: '$5', marginTop: '$5' }}>
                    Sponsorship (Pimlico)
                  </Text>
                  <Row justify="space-between" align="center">
                    <Switch
                      checked={smartAccountSponsorshipEnabled}
                      onChange={SettingsStore.toggleSmartAccountSponsorship}
                      data-testid="settings-toggle-smart-account-sponsorship"
                    />
                    <Text>{smartAccountSponsorshipEnabled ? 'Enabled' : 'Disabled'}</Text>
                  </Row>
                  <Divider y={2} />
                  <Text h4 css={{ marginBottom: '$5', cursor: 'pointer' }}>
                    Module Management
                  </Text>
                  <Row justify="space-between" align="center">
                    <Switch
                      disabled={
                        !kernelSmartAccountEnabled &&
                        !safeSmartAccountEnabled &&
                        !biconomySmartAccountEnabled
                      }
                      checked={moduleManagementEnabled}
                      onChange={SettingsStore.toggleModuleManagement}
                      data-testid="settings-toggle-module-management"
                    />
                    <Text>{moduleManagementEnabled ? 'Enabled' : 'Disabled'}</Text>
                  </Row>
                </>
              ) : null}
            </>
          ) : (
            <Text color="$gray400">This feature requires testnets</Text>
          )}
        </Col>
      </Row>

      <Divider y={2} />

      <Row justify="space-between" align="center">
        <Text h4 css={{ marginBottom: '$5' }}>
          Relayer Region
        </Text>
        <RelayRegionPicker />
      </Row>

      <Divider y={2} />

      <Text css={{ color: '$yellow500', marginBottom: '$5', textAlign: 'left', padding: 0 }}>
        Warning: mnemonics and secret keys are provided for development purposes only and should not
        be used elsewhere!
      </Text>

      <Text h4 css={{ marginTop: '$5', marginBottom: '$5' }}>
        EIP155 Mnemonic
      </Text>
      <Card bordered borderWeight="light" css={{ minHeight: '100px' }}>
        <Text css={{ fontFamily: '$mono' }}>{eip155Wallets[eip155Address].getMnemonic()}</Text>
      </Card>

      <Text h4 css={{ marginTop: '$10', marginBottom: '$5' }}>
        Cosmos Mnemonic
      </Text>
      <Card bordered borderWeight="light" css={{ minHeight: '100px' }}>
        <Text css={{ fontFamily: '$mono' }}>{cosmosWallets[cosmosAddress].getMnemonic()}</Text>
      </Card>

      <Text h4 css={{ marginTop: '$10', marginBottom: '$5' }}>
        Solana Secret Key
      </Text>
      <Card bordered borderWeight="light" css={{ minHeight: '215px', wordWrap: 'break-word' }}>
        <Text css={{ fontFamily: '$mono' }}>{solanaWallets[solanaAddress].getSecretKey()}</Text>
      </Card>

      <Text h4 css={{ marginTop: '$10', marginBottom: '$5' }}>
        MultiversX Mnemonic
      </Text>
      <Card bordered borderWeight="light" css={{ minHeight: '215px', wordWrap: 'break-word' }}>
        <Text css={{ fontFamily: '$mono' }}>
          {multiversxWallets[multiversxAddress].getMnemonic()}
        </Text>
      </Card>

      <Text h4 css={{ marginTop: '$10', marginBottom: '$5' }}>
        Tron Private Key
      </Text>
      <Card bordered borderWeight="light" css={{ minHeight: '100px', wordWrap: 'break-word' }}>
        <Text css={{ fontFamily: '$mono' }}>{tronWallets[tronAddress].privateKey}</Text>
      </Card>

      <Text h4 css={{ marginTop: '$10', marginBottom: '$5' }}>
        Tezos Mnemonic
      </Text>
      <Card bordered borderWeight="light" css={{ minHeight: '100px', wordWrap: 'break-word' }}>
        <Text css={{ fontFamily: '$mono' }}>{tezosWallets[tezosAddress].getMnemonic()}</Text>
      </Card>

      <Text h4 css={{ marginTop: '$10', marginBottom: '$5' }}>
        Kadena Secret Key
      </Text>
      <Card bordered borderWeight="light" css={{ wordWrap: 'break-word' }}>
        <Text css={{ fontFamily: '$mono' }}>{kadenaWallets[kadenaAddress].getSecretKey()}</Text>
      </Card>

      <Text h4 css={{ marginTop: '$10', marginBottom: '$5' }}></Text>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/walletconnect.tsx">
import { parseUri } from '@walletconnect/utils'
import PageHeader from '@/components/PageHeader'
import QrReader from '@/components/QrReader'
import { walletkit } from '@/utils/WalletConnectUtil'
import { Button, Input, Loading, Text } from '@nextui-org/react'
import { Fragment, useEffect, useState } from 'react'
import { styledToast } from '@/utils/HelperUtil'
import ModalStore from '@/store/ModalStore'

export default function WalletConnectPage(params: { deepLink?: string }) {
  const { deepLink } = params
  const [uri, setUri] = useState('')
  const [loading, setLoading] = useState(false)

  async function onConnect(uri: string) {
    const { topic: pairingTopic } = parseUri(uri)
    // if for some reason, the proposal is not received, we need to close the modal when the pairing expires (5mins)
    const pairingExpiredListener = ({ topic }: { topic: string }) => {
      if (pairingTopic === topic) {
        styledToast('Pairing expired. Please try again with new Connection URI', 'error')
        ModalStore.close()
        walletkit.core.pairing.events.removeListener('pairing_expire', pairingExpiredListener)
      }
    }
    walletkit.once('session_proposal', () => {
      walletkit.core.pairing.events.removeListener('pairing_expire', pairingExpiredListener)
    })
    try {
      setLoading(true)
      walletkit.core.pairing.events.on('pairing_expire', pairingExpiredListener)
      await walletkit.pair({ uri })
    } catch (error) {
      styledToast((error as Error).message, 'error')
      ModalStore.close()
    } finally {
      setLoading(false)
      setUri('')
    }
  }

  useEffect(() => {
    if (deepLink) {
      onConnect(deepLink)
    }
  }, [deepLink])

  return (
    <Fragment>
      <PageHeader title="WalletConnect" />
      <>
        <QrReader onConnect={onConnect} />

        <Text size={13} css={{ textAlign: 'center', marginTop: '$10', marginBottom: '$10' }}>
          or use walletconnect uri
        </Text>

        <Input
          css={{ width: '100%' }}
          bordered
          aria-label="wc url connect input"
          placeholder="e.g. wc:a281567bb3e4..."
          onChange={e => setUri(e.target.value)}
          value={uri}
          data-testid="uri-input"
          contentRight={
            <Button
              size="xs"
              disabled={!uri}
              css={{ marginLeft: -60 }}
              onClick={() => onConnect(uri)}
              color="gradient"
              data-testid="uri-connect-button"
            >
              {loading ? <Loading size="md" type="points" color={'white'} /> : 'Connect'}
            </Button>
          }
        />
      </>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/pages/wc.tsx">
import { Text } from '@nextui-org/react'
import { Fragment, useCallback, useEffect, useState } from 'react'
import { useRouter } from 'next/router'
import WalletConnectPage from './walletconnect'
import ModalStore from '@/store/ModalStore'
import { useSnapshot } from 'valtio'
import SettingsStore from '@/store/SettingsStore'
import { walletkit } from '@/utils/WalletConnectUtil'

export default function DeepLinkPairingPage() {
  const state = useSnapshot(ModalStore.state)
  const router = useRouter()
  const [loadingMessage, setLoadingMessage] = useState<string>('')
  const [requestTimeout, setRequestTimeout] = useState<NodeJS.Timeout | null>(null)

  const uri = router.query.uri as string
  const requestId = router.query.requestId as string

  const removeTimeout = useCallback(() => {
    if (requestTimeout) {
      clearTimeout(requestTimeout)
    }
  }, [requestTimeout])

  useEffect(() => {
    if (state.view == 'LoadingModal') {
      const timeout = setTimeout(() => {
        setLoadingMessage('Your request is taking longer than usual. Feel free to try again.')
      }, 15_000)
      setRequestTimeout(timeout)
    } else if (state.view) {
      removeTimeout()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [state.view])

  useEffect(() => {
    if (uri || requestId) {
      ModalStore.open('LoadingModal', { loadingMessage }, () => {
        console.log('Modal closed')
        window.close()
      })
    }
  }, [uri, requestId, loadingMessage])

  if (!uri && !requestId) {
    return (
      <Fragment>
        <Text css={{ opacity: '0.5', textAlign: 'center', marginTop: '$20' }}>
          No URI provided via `?uri=` params
        </Text>
      </Fragment>
    )
  }

  return <WalletConnectPage deepLink={uri} />
}

export function refreshSessionsList() {
  if (!walletkit) return
  SettingsStore.setSessions(Object.values(walletkit.getActiveSessions()))
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/schema/WalletCheckoutSchema.ts">
import {
  CheckoutErrorCode,
  ContractInteraction,
  createCheckoutError,
  SolanaContractInteraction
} from '@/types/wallet_checkout'
import { z } from 'zod'

// ======== Helper Validation Functions ========

/**
 * Validates if a string follows the CAIP-19 format
 * Simple validation: chainNamespace:chainId/assetNamespace:assetReference
 */
export function isValidCAIP19AssetId(assetId: string): boolean {
  if (typeof assetId !== 'string') return false

  // Format: namespace:chainId/assetNamespace:assetReference
  const chainAssetParts = assetId.split('/')
  if (chainAssetParts.length !== 2) return false

  const chainParts = chainAssetParts[0]?.split(':')
  const assetParts = chainAssetParts[1]?.split(':')

  return (
    chainParts?.length === 2 &&
    chainParts[0]?.length > 0 &&
    chainParts[1]?.length > 0 &&
    assetParts.length === 2 &&
    assetParts[0]?.length > 0 &&
    assetParts[1]?.length > 0
  )
}

/**
 * Validates if a string follows the CAIP-10 format
 * Simple validation: chainNamespace:chainId:address
 */
export function isValidCAIP10AccountId(accountId: string): boolean {
  if (typeof accountId !== 'string') return false

  // Basic check: should be in format namespace:chainId:address
  const parts = accountId.split(':')
  return parts.length === 3 && parts[0]?.length > 0 && parts[1]?.length > 0 && parts[2]?.length > 0
}

/**
 * Validates if a Solana instruction is valid
 */
export function isValidSolanaInstruction(instruction: SolanaContractInteraction['data']): boolean {
  try {
    if (!instruction || typeof instruction !== 'object') return false

    // Check for required properties
    if (!instruction.programId || typeof instruction.programId !== 'string') return false
    if (!instruction.accounts || !Array.isArray(instruction.accounts)) return false
    if (!instruction.data || typeof instruction.data !== 'string') return false

    // Validate each account
    for (const account of instruction.accounts) {
      if (!account || typeof account !== 'object') return false
      if (!account.pubkey || typeof account.pubkey !== 'string') return false
      if (typeof account.isSigner !== 'boolean') return false
      if (typeof account.isWritable !== 'boolean') return false
    }

    return true
  } catch (e) {
    return false
  }
}

/**
 * Checks if an EVM call is valid
 */
export function isValidEvmCall(call: { to: string; data: string; value?: string }): boolean {
  if (!call.to || typeof call.to !== 'string') return false
  if (!call.data || typeof call.data !== 'string') return false
  // Check value only if it's provided
  if (call.value !== undefined && (typeof call.value !== 'string' || !call.value)) return false
  return true
}

/**
 * Checks if the chain IDs in the asset and recipient match
 */
export function matchingChainIds(assetId: string, accountId: string): boolean {
  try {
    if (typeof assetId !== 'string' || typeof accountId !== 'string') {
      return false
    }

    // Extract chain namespace and ID from asset
    const assetChainPart = assetId.split('/')[0]
    if (!assetChainPart) return false

    // Extract chain namespace and ID from account
    const accountParts = accountId.split(':')
    if (accountParts.length < 2) return false

    const accountChainPart = `${accountParts[0]}:${accountParts[1]}`

    return assetChainPart === accountChainPart
  } catch (e) {
    return false
  }
}

/**
 * Validates Solana-specific asset format
 */
function validateSolanaAsset(asset: string, ctx: z.RefinementCtx) {
  const assetParts = asset.split('/')
  if (assetParts.length !== 2) return

  const chainParts = assetParts[0].split(':')
  if (chainParts[0] !== 'solana') return

  // For Solana assets, validate asset namespace and reference
  const assetType = assetParts[1].split(':')
  if (assetType.length !== 2) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Invalid Solana asset format: ${asset}`
    })
    throw createCheckoutError(
      CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
      `Invalid Solana asset format: ${asset}`
    )
  }

  // Check supported Solana asset namespaces
  if (assetType[0] !== 'slip44' && assetType[0] !== 'token') {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Unsupported Solana asset namespace: ${assetType[0]}`
    })
    throw createCheckoutError(
      CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
      `Unsupported Solana asset namespace: ${assetType[0]}`
    )
  }

  // For slip44, validate the coin type is 501 for SOL
  if (assetType[0] === 'slip44' && assetType[1] !== '501') {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Invalid Solana slip44 asset reference: ${assetType[1]}`
    })
    throw createCheckoutError(
      CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
      `Invalid Solana slip44 asset reference: ${assetType[1]}`
    )
  }
}

/**
 * Validates EVM-specific asset format
 */
function validateEvmAsset(asset: string, ctx: z.RefinementCtx) {
  const assetParts = asset.split('/')
  if (assetParts.length !== 2) return

  const chainParts = assetParts[0].split(':')
  if (chainParts[0] !== 'eip155') return

  // For EVM assets, validate asset namespace and reference
  const assetType = assetParts[1].split(':')
  if (assetType.length !== 2) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Invalid EVM asset format: ${asset}`
    })
    throw createCheckoutError(
      CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
      `Invalid EVM asset format: ${asset}`
    )
  }

  // Check supported EVM asset namespaces
  if (assetType[0] !== 'slip44' && assetType[0] !== 'erc20') {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Unsupported EVM asset namespace: ${assetType[0]}`
    })
    throw createCheckoutError(
      CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
      `Unsupported EVM asset namespace: ${assetType[0]}`
    )
  }

  // For slip44, validate the coin type is 60 for ETH
  if (assetType[0] === 'slip44' && assetType[1] !== '60') {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Invalid EVM slip44 asset reference: ${assetType[1]}`
    })
    throw createCheckoutError(
      CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
      `Invalid EVM slip44 asset reference: ${assetType[1]}`
    )
  }
}

/**
 * Validates asset format based on chain type
 */
function validateAssetFormat(asset: string, ctx: z.RefinementCtx) {
  const assetParts = asset.split('/')
  if (assetParts.length !== 2) return

  const chainParts = assetParts[0].split(':')

  // Validate based on chain namespace
  switch (chainParts[0]) {
    case 'solana':
      validateSolanaAsset(asset, ctx)
      break
    case 'eip155':
      validateEvmAsset(asset, ctx)
      break
  }
}

// ======== Basic Schema Definitions ========

export const ProductMetadataSchema = z.object({
  name: z.string().min(1, 'Product name is required'),
  description: z.string().optional(),
  imageUrl: z.string().url().optional(),
  price: z.string().optional()
})

export const SolanaAccountSchema = z.object({
  pubkey: z.string().min(1, 'Account public key is required'),
  isSigner: z.boolean(),
  isWritable: z.boolean()
})

export const SolanaInstructionDataSchema = z.object({
  programId: z.string().min(1, 'Program ID is required'),
  accounts: z.array(SolanaAccountSchema).min(1, 'At least one account is required'),
  data: z.string().min(1, 'Instruction data is required')
})

// ======== Contract Interaction Schemas ========

const EvmCallSchema = z
  .object({
    to: z.string().min(1),
    data: z.string().min(1),
    value: z.string().optional()
  })
  .refine(isValidEvmCall, {
    message: 'Invalid EVM call data'
  })

const SolanaInstructionSchema = z
  .object({
    programId: z.string().min(1),
    accounts: z.array(SolanaAccountSchema).min(1),
    data: z.string().min(1)
  })
  .refine(isValidSolanaInstruction, {
    message: 'Invalid Solana instruction data'
  })

export const ContractInteractionSchema = z
  .object({
    type: z.string().min(1, 'Contract interaction type is required'),
    data: z.any()
  })
  .superRefine((interaction, ctx) => {
    // Check if interaction type is supported
    if (interaction.type !== 'evm-calls' && interaction.type !== 'solana-instruction') {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Unsupported contract interaction type'
      })
      throw createCheckoutError(CheckoutErrorCode.UNSUPPORTED_CONTRACT_INTERACTION)
    }

    // Validate based on interaction type
    if (interaction.type === 'evm-calls') {
      validateEvmCalls(interaction, ctx)
    } else if (interaction.type === 'solana-instruction') {
      validateSolanaInstruction(interaction, ctx)
    }
  })

// Extracted validation functions for cleaner code
function validateEvmCalls(interaction: any, ctx: z.RefinementCtx) {
  if (!interaction.data || !Array.isArray(interaction.data) || interaction.data.length === 0) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Invalid EVM calls data structure'
    })
    throw createCheckoutError(CheckoutErrorCode.INVALID_CONTRACT_INTERACTION_DATA)
  }

  // Validate each EVM call
  for (const call of interaction.data) {
    try {
      EvmCallSchema.parse(call)
    } catch (e) {
      throw createCheckoutError(CheckoutErrorCode.INVALID_CONTRACT_INTERACTION_DATA)
    }
  }
}

function validateSolanaInstruction(interaction: any, ctx: z.RefinementCtx) {
  if (!interaction.data || typeof interaction.data !== 'object') {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Invalid Solana instruction data structure'
    })
    throw createCheckoutError(CheckoutErrorCode.INVALID_CONTRACT_INTERACTION_DATA)
  }

  try {
    SolanaInstructionSchema.parse(interaction.data)
  } catch (e) {
    throw createCheckoutError(CheckoutErrorCode.INVALID_CONTRACT_INTERACTION_DATA)
  }
}

// ======== Payment Schema Definitions ========

// Asset validation schema with chain-specific checks
const AssetSchema = z
  .string()
  .min(1, 'Asset is required')
  .refine(isValidCAIP19AssetId, 'Invalid CAIP-19 asset')
  .superRefine(validateAssetFormat)

export const PaymentOptionSchema = z
  .object({
    asset: AssetSchema,
    amount: z.string().regex(/^0x[0-9a-fA-F]+$/, 'Amount must be a hex string'),
    recipient: z.string().refine(isValidCAIP10AccountId, 'Invalid CAIP-10 recipient').optional(),
    contractInteraction: ContractInteractionSchema.optional()
  })
  .refine(
    data =>
      (data.recipient && !data.contractInteraction) ||
      (!data.recipient && data.contractInteraction),
    'Either recipient or contractInteraction must be provided, but not both'
  )
  .refine(data => {
    if (!data.recipient) return true
    return matchingChainIds(data.asset, data.recipient)
  }, 'Asset and recipient must be on the same chain')

// ======== Checkout Request Schema ========

export const CheckoutRequestSchema = z.object({
  orderId: z.string().max(128, 'Order ID must not exceed 128 characters'),
  acceptedPayments: z.array(PaymentOptionSchema).min(1, 'At least one payment option is required'),
  products: z.array(ProductMetadataSchema).optional(),
  expiry: z.number().int().optional()
})
</file>

<file path="advanced/wallets/react-wallet-v2/src/store/ModalStore.ts">
import { SessionTypes, SignClientTypes } from '@walletconnect/types'
import { proxy, subscribe } from 'valtio'

/**
 * Types
 */
interface ModalData {
  proposal?: SignClientTypes.EventArguments['session_proposal']
  requestEvent?: SignClientTypes.EventArguments['session_request']
  requestSession?: SessionTypes.Struct
  loadingMessage?: string
  authRequest?: SignClientTypes.EventArguments['session_authenticate']
}

interface State {
  open: boolean
  view?:
    | 'SessionProposalModal'
    | 'SessionSignModal'
    | 'SessionSignTypedDataModal'
    | 'SessionSendTransactionModal'
    | 'SessionGrantPermissionsModal'
    | 'SessionSendCallsModal'
    | 'SessionUnsuportedMethodModal'
    | 'SessionSignCosmosModal'
    | 'SessionSignSolanaModal'
    | 'SessionSignPolkadotModal'
    | 'SessionSignNearModal'
    | 'SessionSignMultiversxModal'
    | 'SessionSignTronModal'
    | 'SessionSignTezosModal'
    | 'SessionSignKadenaModal'
    | 'SessionAuthenticateModal'
    | 'LoadingModal'
    | 'SessionSignBip122Modal'
    | 'SessionGetBip122AddressesModal'
    | 'SessionSendTransactionBip122Modal'
    | 'SessionCheckoutModal'
  data?: ModalData
}

/**
 * State
 */
const state = proxy<State>({
  open: false
})

/**
 * Store / Actions
 */
const ModalStore = {
  state,

  open(view: State['view'], data: State['data'], onClose?: () => void) {
    state.view = view
    state.data = data
    state.open = true
    if (!onClose) return
    const unsubscribe = subscribe(state, () => {
      if (!state.open) {
        console.log('ModalStore: Closing modal')
        unsubscribe()
        onClose?.()
      }
    })
  },

  close() {
    state.open = false
  }
}

export default ModalStore
</file>

<file path="advanced/wallets/react-wallet-v2/src/store/SettingsStore.ts">
import { createOrRestoreEIP155Wallet } from '@/utils/EIP155WalletUtil'
import {
  createOrRestoreBiconomySmartAccount,
  createOrRestoreKernelSmartAccount,
  createOrRestoreSafeSmartAccount,
  removeSmartAccount
} from '@/utils/SmartAccountUtil'
import { Verify, SessionTypes } from '@walletconnect/types'
import { proxy } from 'valtio'

const TEST_NETS_ENABLED_KEY = 'TEST_NETS'
const CA_ENABLED_KEY = 'CHAIN_ABSTRACTION'
const SMART_ACCOUNTS_ENABLED_KEY = 'SMART_ACCOUNTS'
const ZERO_DEV_SMART_ACCOUNTS_ENABLED_KEY = 'ZERO_DEV_SMART_ACCOUNTS'
const SAFE_SMART_ACCOUNTS_ENABLED_KEY = 'SAFE_SMART_ACCOUNTS'
const BICONOMY_SMART_ACCOUNTS_ENABLED_KEY = 'BICONOMY_SMART_ACCOUNTS'
const MODULE_MANAGEMENT_ENABLED_KEY = 'MODULE_MANAGEMENT'

/**
 * Types
 */
interface State {
  testNets: boolean
  account: number
  eip155Address: string
  cosmosAddress: string
  solanaAddress: string
  polkadotAddress: string
  nearAddress: string
  multiversxAddress: string
  tronAddress: string
  tezosAddress: string
  kadenaAddress: string
  bip122Address: string
  kernelSmartAccountAddress: string
  safeSmartAccountAddress: string
  biconomySmartAccountAddress: string
  relayerRegionURL: string
  activeChainId: string
  currentRequestVerifyContext?: Verify.Context
  sessions: SessionTypes.Struct[]
  smartAccountSponsorshipEnabled: boolean
  smartAccountEnabled: boolean
  kernelSmartAccountEnabled: boolean
  safeSmartAccountEnabled: boolean
  biconomySmartAccountEnabled: boolean
  moduleManagementEnabled: boolean
  chainAbstractionEnabled: boolean
}

/**
 * State
 */
const state = proxy<State>({
  testNets:
    typeof localStorage !== 'undefined'
      ? Boolean(localStorage.getItem(TEST_NETS_ENABLED_KEY))
      : true,
  account: 0,
  activeChainId: '1',
  eip155Address: '',
  cosmosAddress: '',
  solanaAddress: '',
  polkadotAddress: '',
  nearAddress: '',
  multiversxAddress: '',
  tronAddress: '',
  tezosAddress: '',
  kadenaAddress: '',
  bip122Address: '',
  kernelSmartAccountAddress: '',
  safeSmartAccountAddress: '',
  biconomySmartAccountAddress: '',
  relayerRegionURL: '',
  sessions: [],
  smartAccountSponsorshipEnabled: false,
  smartAccountEnabled:
    typeof localStorage !== 'undefined'
      ? Boolean(localStorage.getItem(SMART_ACCOUNTS_ENABLED_KEY))
      : false,
  kernelSmartAccountEnabled:
    typeof localStorage !== 'undefined'
      ? Boolean(localStorage.getItem(ZERO_DEV_SMART_ACCOUNTS_ENABLED_KEY))
      : false,
  safeSmartAccountEnabled:
    typeof localStorage !== 'undefined'
      ? Boolean(localStorage.getItem(SAFE_SMART_ACCOUNTS_ENABLED_KEY))
      : false,
  biconomySmartAccountEnabled:
    typeof localStorage !== 'undefined'
      ? Boolean(localStorage.getItem(BICONOMY_SMART_ACCOUNTS_ENABLED_KEY))
      : false,
  moduleManagementEnabled:
    typeof localStorage !== 'undefined'
      ? Boolean(localStorage.getItem(MODULE_MANAGEMENT_ENABLED_KEY))
      : false,
  chainAbstractionEnabled:
    typeof localStorage !== 'undefined' ? Boolean(localStorage.getItem(CA_ENABLED_KEY)) : false
})

/**
 * Store / Actions
 */
const SettingsStore = {
  state,

  setAccount(value: number) {
    state.account = value
  },

  setEIP155Address(eip155Address: string) {
    state.eip155Address = eip155Address
  },

  setCosmosAddress(cosmosAddresses: string) {
    state.cosmosAddress = cosmosAddresses
  },

  setSolanaAddress(solanaAddress: string) {
    state.solanaAddress = solanaAddress
  },

  setPolkadotAddress(polkadotAddress: string) {
    state.polkadotAddress = polkadotAddress
  },
  setNearAddress(nearAddress: string) {
    state.nearAddress = nearAddress
  },
  setKadenaAddress(kadenaAddress: string) {
    state.kadenaAddress = kadenaAddress
  },
  setbip122Address(bip122Address: string) {
    state.bip122Address = bip122Address
  },
  setRelayerRegionURL(relayerRegionURL: string) {
    state.relayerRegionURL = relayerRegionURL
  },

  setMultiversxAddress(multiversxAddress: string) {
    state.multiversxAddress = multiversxAddress
  },

  setTronAddress(tronAddress: string) {
    state.tronAddress = tronAddress
  },

  setTezosAddress(tezosAddress: string) {
    state.tezosAddress = tezosAddress
  },

  setKernelSmartAccountAddress(smartAccountAddress: string) {
    state.kernelSmartAccountAddress = smartAccountAddress
  },
  setSafeSmartAccountAddress(smartAccountAddress: string) {
    state.safeSmartAccountAddress = smartAccountAddress
  },
  setBiconomySmartAccountAddress(smartAccountAddress: string) {
    state.biconomySmartAccountAddress = smartAccountAddress
  },

  setActiveChainId(value: string) {
    state.activeChainId = value
  },

  setCurrentRequestVerifyContext(context: Verify.Context) {
    state.currentRequestVerifyContext = context
  },
  setSessions(sessions: SessionTypes.Struct[]) {
    state.sessions = sessions
  },

  toggleTestNets() {
    state.testNets = !state.testNets
    if (state.testNets) {
      state.smartAccountSponsorshipEnabled = true
      localStorage.setItem(TEST_NETS_ENABLED_KEY, 'YES')
    } else {
      state.smartAccountSponsorshipEnabled = false
      localStorage.removeItem(TEST_NETS_ENABLED_KEY)
    }
  },

  toggleSmartAccountSponsorship() {
    if (!state.testNets) return
    state.smartAccountSponsorshipEnabled = !state.smartAccountSponsorshipEnabled
  },

  toggleSmartAccountEnabled() {
    state.smartAccountEnabled = !state.smartAccountEnabled
    if (state.smartAccountEnabled) {
      localStorage.setItem(SMART_ACCOUNTS_ENABLED_KEY, 'YES')
    } else {
      localStorage.removeItem(SMART_ACCOUNTS_ENABLED_KEY)
    }
  },
  toggleModuleManagement() {
    state.moduleManagementEnabled = !state.moduleManagementEnabled
    if (state.moduleManagementEnabled) {
      localStorage.setItem(MODULE_MANAGEMENT_ENABLED_KEY, 'YES')
    } else {
      localStorage.removeItem(MODULE_MANAGEMENT_ENABLED_KEY)
    }
  },

  toggleChainAbstractionEnabled() {
    state.chainAbstractionEnabled = !state.chainAbstractionEnabled
    if (state.chainAbstractionEnabled) {
      localStorage.setItem(CA_ENABLED_KEY, 'YES')
    } else {
      localStorage.removeItem(CA_ENABLED_KEY)
    }
  },

  async toggleKernelSmartAccountsEnabled() {
    state.kernelSmartAccountEnabled = !state.kernelSmartAccountEnabled
    if (state.kernelSmartAccountEnabled) {
      const { eip155Addresses, eip155Wallets } = createOrRestoreEIP155Wallet()
      const { kernelSmartAccountAddress } = await createOrRestoreKernelSmartAccount(
        eip155Wallets[eip155Addresses[0]].getPrivateKey()
      )
      SettingsStore.setKernelSmartAccountAddress(kernelSmartAccountAddress)
      localStorage.setItem(ZERO_DEV_SMART_ACCOUNTS_ENABLED_KEY, 'YES')
    } else {
      removeSmartAccount(SettingsStore.state.kernelSmartAccountAddress)
      SettingsStore.setKernelSmartAccountAddress('')
      state.moduleManagementEnabled = false
      localStorage.removeItem(MODULE_MANAGEMENT_ENABLED_KEY)
      localStorage.removeItem(ZERO_DEV_SMART_ACCOUNTS_ENABLED_KEY)
    }
  },

  async toggleSafeSmartAccountsEnabled() {
    state.safeSmartAccountEnabled = !state.safeSmartAccountEnabled
    if (state.safeSmartAccountEnabled) {
      const { eip155Addresses, eip155Wallets } = createOrRestoreEIP155Wallet()
      const { safeSmartAccountAddress } = await createOrRestoreSafeSmartAccount(
        eip155Wallets[eip155Addresses[0]].getPrivateKey()
      )
      SettingsStore.setSafeSmartAccountAddress(safeSmartAccountAddress)
      localStorage.setItem(SAFE_SMART_ACCOUNTS_ENABLED_KEY, 'YES')
    } else {
      removeSmartAccount(SettingsStore.state.safeSmartAccountAddress)
      SettingsStore.setSafeSmartAccountAddress('')
      state.moduleManagementEnabled = false
      localStorage.removeItem(MODULE_MANAGEMENT_ENABLED_KEY)
      localStorage.removeItem(SAFE_SMART_ACCOUNTS_ENABLED_KEY)
    }
  },

  async toggleBiconomySmartAccountsEnabled() {
    state.biconomySmartAccountEnabled = !state.biconomySmartAccountEnabled
    if (state.biconomySmartAccountEnabled) {
      const { eip155Addresses, eip155Wallets } = createOrRestoreEIP155Wallet()
      const { biconomySmartAccountAddress } = await createOrRestoreBiconomySmartAccount(
        eip155Wallets[eip155Addresses[0]].getPrivateKey()
      )
      SettingsStore.setBiconomySmartAccountAddress(biconomySmartAccountAddress)
      localStorage.setItem(BICONOMY_SMART_ACCOUNTS_ENABLED_KEY, 'YES')
    } else {
      removeSmartAccount(SettingsStore.state.biconomySmartAccountAddress)
      SettingsStore.setBiconomySmartAccountAddress('')
      state.moduleManagementEnabled = false
      localStorage.removeItem(MODULE_MANAGEMENT_ENABLED_KEY)
      localStorage.removeItem(BICONOMY_SMART_ACCOUNTS_ENABLED_KEY)
    }
  }
}

export default SettingsStore
</file>

<file path="advanced/wallets/react-wallet-v2/src/store/WalletCheckoutCtrl.ts">
import { CheckoutRequest, DetailedPaymentOption } from '@/types/wallet_checkout'
import WalletCheckoutUtil from '@/utils/WalletCheckoutUtil'
import { proxy } from 'valtio'

interface State {
  checkoutRequest: CheckoutRequest | null
  feasiblePayments: DetailedPaymentOption[]
}

const state = proxy<State>({
  checkoutRequest: null,
  feasiblePayments: []
})

const WalletCheckoutCtrl = {
  state,
  actions: {
    setCheckoutRequest(request: CheckoutRequest) {
      state.checkoutRequest = request
    },
    setFeasiblePayments(payments: DetailedPaymentOption[]) {
      state.feasiblePayments = payments
    },
    clearCheckoutRequest() {
      state.checkoutRequest = null
    },
    clearFeasiblePayments() {
      state.feasiblePayments = []
    },
    async prepareFeasiblePayments(request: CheckoutRequest) {
      const payments = await WalletCheckoutUtil.getFeasiblePayments(request)
      this.setFeasiblePayments(payments.feasiblePayments)
      this.setCheckoutRequest(request)
      return payments.feasiblePayments
    },
    reset() {
      state.checkoutRequest = null
      state.feasiblePayments = []
    }
  }
}

export default WalletCheckoutCtrl
</file>

<file path="advanced/wallets/react-wallet-v2/src/types/wallet_checkout.ts">
/**
 * Hexadecimal string representation with '0x' prefix
 */
export type Hex = `0x${string}`

/**
 * Metadata for a product included in the checkout
 * @property name - The name of the product
 * @property description - Optional description of the product
 * @property imageUrl - Optional URL to an image of the product
 * @property price - Optional price of the product in a human-readable format (e.g. "$100.00")
 */
export type ProductMetadata = {
  /** The name of the product */
  name: string
  /** Optional description of the product */
  description?: string
  /** Optional URL to an image of the product */
  imageUrl?: string
  /** Optional price of the product in a human-readable format (e.g. "$100.00") */
  price?: string
}

/**
 * Smart contract interaction details
 * @property type - The type of contract interaction (e.g. "evm-calls", "solana-instruction")
 * @property data - Data required for the specific contract interaction type
 */
export type ContractInteraction = {
  /** The type of contract interaction (e.g. "evm-calls", "solana-instruction") */
  type: string
  /** Data required for the specific contract interaction type */
  data: any
}

/**
 * EVM-specific contract interaction
 * @property type - Must be "evm-calls"
 * @property data - Array of contract call data objects
 */
export type EvmContractInteraction = {
  /** Must be "evm-calls" */
  type: 'evm-calls'
  /** Array of contract call data objects */
  data: {
    /** Contract address */
    to: string
    /** Optional additional ETH value */
    value?: Hex
    /** Contract call data */
    data: Hex
  }[]
}

/**
 * Solana-specific contract interaction
 * @property type - Must be "solana-instruction"
 * @property data - Array of Solana instruction data objects
 */
export type SolanaContractInteraction = {
  type: 'solana-instruction'
  data: {
    programId: string // Program ID
    accounts: {
      // Accounts involved in the instruction
      pubkey: string
      isSigner: boolean
      isWritable: boolean
    }[]
    data: string // Base64-encoded instruction data
  }
}

/**
 * A payment option for the checkout
 * @property asset - CAIP-19 asset identifier
 * @property amount - Hex-encoded amount of the asset to transfer
 * @property recipient - Optional CAIP-10 account ID of the recipient (required for direct payments)
 * @property contractInteraction - Optional contract interaction details (required for contract-based payments)
 */
export type PaymentOption = {
  /** CAIP-19 asset identifier */
  asset: string
  /** Hex-encoded amount of the asset to transfer */
  amount: Hex
  /** CAIP-10 account ID of the recipient (required for direct payments) */
  recipient?: string
  /** Contract interaction details (required for contract-based payments) */
  contractInteraction?: ContractInteraction
}

/**
 * Checkout request parameters
 * @property orderId - Unique identifier for this checkout request (max 128 chars)
 * @property acceptedPayments - Array of accepted payment options
 * @property products - Optional array of product metadata
 * @property expiry - Optional UNIX timestamp (seconds) after which the payment request expires
 */
export type CheckoutRequest = {
  /** Unique identifier for this checkout request (max 128 chars) */
  orderId: string
  /** Array of accepted payment options */
  acceptedPayments: PaymentOption[]
  /** Optional array of product metadata */
  products?: ProductMetadata[]
  /** Optional UNIX timestamp (seconds) after which the payment request expires */
  expiry?: number
}

/**
 * Checkout result returned by the wallet
 * @property orderId - Matching order ID from the original request
 * @property txid - Transaction identifier on the blockchain
 * @property recipient - Optional CAIP-10 account ID that received the payment
 * @property asset - Optional CAIP-19 asset identifier that was used for payment
 * @property amount - Optional hex-encoded amount that was paid
 */
export type CheckoutResult = {
  /** Matching order ID from the original request */
  orderId: string
  /** Transaction identifier on the blockchain */
  txid: string
  /** CAIP-10 account ID that received the payment */
  recipient?: string
  /** CAIP-19 asset identifier that was used for payment */
  asset?: string
  /** Hex-encoded amount that was paid */
  amount?: Hex
}

/**
 * Error codes for wallet_checkout method
 */
export enum CheckoutErrorCode {
  /** User rejected the payment */
  USER_REJECTED = 4001,
  /** No matching assets available in user's wallet */
  NO_MATCHING_ASSETS = 4100,
  /** Checkout has expired */
  CHECKOUT_EXPIRED = 4200,
  /** Insufficient funds for the payment */
  INSUFFICIENT_FUNDS = 4300,
  /** Unsupported contract interaction type */
  UNSUPPORTED_CONTRACT_INTERACTION = 4400,
  /** Invalid contract interaction data */
  INVALID_CONTRACT_INTERACTION_DATA = 4401,
  /** Contract interaction failed during execution */
  CONTRACT_INTERACTION_FAILED = 4402,
  /** Method not found (wallet doesn't support wallet_checkout) */
  METHOD_NOT_FOUND = -32601,
  /** Invalid checkout request */
  INVALID_CHECKOUT_REQUEST = 4500,
  /** Direct payment failed */
  DIRECT_PAYMENT_ERROR = 4600
}

/**
 * Standard error messages for checkout error codes
 */
export const CheckoutErrorMessages: Record<CheckoutErrorCode, string> = {
  [CheckoutErrorCode.USER_REJECTED]: 'User rejected payment',
  [CheckoutErrorCode.NO_MATCHING_ASSETS]: 'No matching assets available',
  [CheckoutErrorCode.CHECKOUT_EXPIRED]: 'Checkout expired',
  [CheckoutErrorCode.INSUFFICIENT_FUNDS]: 'Insufficient funds',
  [CheckoutErrorCode.UNSUPPORTED_CONTRACT_INTERACTION]: 'Unsupported contract interaction',
  [CheckoutErrorCode.INVALID_CONTRACT_INTERACTION_DATA]: 'Invalid contract interaction data',
  [CheckoutErrorCode.CONTRACT_INTERACTION_FAILED]: 'Contract interaction failed',
  [CheckoutErrorCode.METHOD_NOT_FOUND]: 'Method not found',
  [CheckoutErrorCode.INVALID_CHECKOUT_REQUEST]: 'Invalid checkout request',
  [CheckoutErrorCode.DIRECT_PAYMENT_ERROR]: 'Direct payment failed'
}

/**
 * Checkout error class
 * @extends Error
 */
export class CheckoutError extends Error {
  /** Error code indicating the type of error */
  code: CheckoutErrorCode
  /** Description of the error */
  message: string
  /** Optional additional data about the error */
  data?: any

  constructor(code: CheckoutErrorCode, message?: string, data?: any) {
    super(message)
    this.code = code
    this.data = data
    this.message = message || getErrorMessage(code)
  }
}

export type CheckoutErrorResponse = {
  code: number
  message: string
}

/**
 * Get a standard error message for a checkout error code
 * @param code - The error code
 * @returns The standard error message for the code
 */
export function getErrorMessage(code: CheckoutErrorCode): string {
  return CheckoutErrorMessages[code] || 'Unknown error'
}

/**
 * Create a checkout error with the standard message for the error code
 * @param code - The error code
 * @param customMessage - Optional custom message to override the standard one
 * @param data - Optional additional error data
 * @returns A checkout error object
 */
export function createCheckoutError(
  code: CheckoutErrorCode,
  customMessage?: string,
  data?: any
): CheckoutError {
  return new CheckoutError(code, customMessage, data)
}

export type DetailedPaymentOption = PaymentOption & {
  assetMetadata: {
    assetIcon: string
    assetName: string
    assetSymbol: string
    assetNamespace: string
    assetDecimals: number
    assetBalance: bigint
  }
  chainMetadata: {
    chainId: string
    chainName: string
    chainNamespace: string
    chainIcon: string
  }
  fee: {
    gasFee: number
    decimals: number
    feeSymbol: string
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/Bip122RequestHandlerUtil.ts">
import { KADENA_SIGNING_METHODS } from '@/data/KadenaData'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'
import { getWalletAddressFromParams } from './HelperUtil'
import { BIP122_SIGNING_METHODS, IBip122ChainId } from '@/data/Bip122Data'
import { bip122Addresses, bip122Wallet } from './Bip122WalletUtil'

export async function approveBip122Request(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request } = params
  const chainId = params.chainId as IBip122ChainId
  const account = request.params.account
  const wallet = bip122Wallet
  console.log('wallet:', wallet, bip122Wallet)
  console.log('account:', account)
  console.log('request:', request.method)
  switch (request.method) {
    case BIP122_SIGNING_METHODS.BIP122_SIGN_MESSAGE:
      const message = request.params.message
      const address = request.params.address
      const protocol = request.params.protocol
      console.log(
        'signing message:',
        message,
        'with address:',
        address || account,
        'chainId:',
        params
      )
      const signature = await wallet.signMessage({
        message,
        address: address || account,
        protocol,
        chainId
      })
      return formatJsonRpcResult(id, signature)
    case BIP122_SIGNING_METHODS.BIP122_SEND_TRANSACTION:
      const transactionParams = request.params
      console.log('signing transaction:', transactionParams, 'with account:', account)
      const txid = await wallet.sendTransfer({
        account: transactionParams.account,
        recipientAddress: transactionParams.recipientAddress,
        amount: transactionParams.amount,
        changeAddress: transactionParams.changeAddress,
        memo: transactionParams.memo,
        chainId
      })
      console.log('signed transaction:', txid)
      return formatJsonRpcResult(id, { txid })
    case BIP122_SIGNING_METHODS.BIP122_GET_ACCOUNT_ADDRESSES:
      console.log('getting addresses for account:', account)
      const addresses = wallet.getAddresses(chainId)
      return formatJsonRpcResult(id, Array.from(addresses.values()))
    case BIP122_SIGNING_METHODS.BIP122_SIGN_PSBT:
      const psbt = request.params.psbt
      const signInputs = request.params.signInputs
      const broadcast = request.params.broadcast
      console.log(
        'signing psbt:',
        psbt,
        'with account:',
        account,
        'inputs:',
        signInputs,
        'broadcast:',
        broadcast
      )
      const result = await wallet.signPsbt({
        account,
        psbt,
        signInputs,
        broadcast,
        chainId
      })
      console.log('signed psbt:', result)
      return formatJsonRpcResult(id, result)
    default:
      throw new Error(getSdkError('UNSUPPORTED_METHODS').message)
  }
}

export function rejectBip122Request(
  request: SignClientTypes.EventArguments['session_request'],
  message?: string
) {
  const { id } = request

  return formatJsonRpcError(id, message || getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/Bip122WalletUtil.ts">
import { BIP122_MAINNET_CAIP2, BIP122_TESTNET_CAIP2 } from '@/data/Bip122Data'
import BitcoinLib from '@/lib/Bip122Lib'

export let wallet1: BitcoinLib
export let wallet2: BitcoinLib
export let bip122Wallet: BitcoinLib
export let bip122Addresses: string[]

/**
 * Utilities
 */
export async function createOrRestoreBip122Wallet() {
  const privateKey1 = localStorage.getItem('BITCOIN_PRIVATE_KEY_1')

  if (privateKey1) {
    wallet1 = await BitcoinLib.init({ privateKey: privateKey1 })
    // wallet2 = await BitcoinLib.init({ privateKey: privateKey2 })
  } else {
    wallet1 = await BitcoinLib.init({})
    // Don't store private keys in local storage in a production project!
    localStorage.setItem('BITCOIN_PRIVATE_KEY_1', wallet1.getPrivateKey())
    console.log('BITCOIN_PRIVATE_KEY_1', wallet1.getPrivateKey())
  }

  const mainnetAddress = wallet1.getAddress(BIP122_MAINNET_CAIP2)

  console.log('address1', { mainnetAddress, privateKey1 }, mainnetAddress)

  bip122Wallet = wallet1
  bip122Addresses = [
    `${BIP122_MAINNET_CAIP2}:${wallet1.getAddress(BIP122_MAINNET_CAIP2)}`,
    `${BIP122_MAINNET_CAIP2}:${wallet1.getOrdinalsAddress(BIP122_MAINNET_CAIP2)}`,
    `${BIP122_TESTNET_CAIP2}:${wallet1.getAddress(BIP122_TESTNET_CAIP2)}`,
    `${BIP122_TESTNET_CAIP2}:${wallet1.getOrdinalsAddress(BIP122_TESTNET_CAIP2)}`
  ]

  return {
    bip122Wallet,
    bip122Addresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/ChainAbstractionService.ts">
import axios from 'axios'
import { CA_ORCHESTRATOR_BASE_URL } from './ConstantsUtil'

export interface Transaction {
  from: string
  to: string
  value: string
  gas: string
  gasPrice: string
  data: string
  nonce: string
  maxFeePerGas: string
  maxPriorityFeePerGas: string
  chainId: string
}

interface CheckResponse {
  requiresMultiChain: boolean
}

interface RouteResponse {
  transactions: Transaction[]
  orchestrationId: string
}
interface OrchestrationStatusResponse {
  status: 'pending' | 'completed' | 'error'
  createdAt: number
}

export class ChainAbstractionService {
  private baseUrl: string
  private projectId: string

  constructor() {
    this.baseUrl = CA_ORCHESTRATOR_BASE_URL
    if (!process.env.NEXT_PUBLIC_PROJECT_ID) {
      throw new Error('Project ID is not defined')
    }
    this.projectId = process.env.NEXT_PUBLIC_PROJECT_ID
  }

  async checkTransaction(transaction: Transaction): Promise<boolean> {
    try {
      const response = await axios.post<CheckResponse>(
        `${this.baseUrl}/check?projectId=${this.projectId}`,
        { transaction }
      )
      return response.data.requiresMultiChain
    } catch (error) {
      console.error('ChainAbstractionService: Error checking transaction:', error)
      throw error
    }
  }

  async routeTransaction(transaction: Transaction): Promise<RouteResponse> {
    try {
      const response = await axios.post<RouteResponse>(
        `${this.baseUrl}/route?projectId=${this.projectId}`,
        { transaction }
      )
      return response.data
    } catch (error) {
      console.error('ChainAbstractionService: Error routing transaction:', error)
      throw error
    }
  }
  async getOrchestrationStatus(orchestrationId: string): Promise<OrchestrationStatusResponse> {
    try {
      const response = await axios.get<OrchestrationStatusResponse>(
        `${this.baseUrl}/status?projectId=${this.projectId}&orchestrationId=${orchestrationId}`
      )
      return response.data
    } catch (error) {
      console.error('ChainAbstractionService: Error getting orchestration status :', error)
      throw error
    }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/ChainUtil.ts">
import * as chains from 'viem/chains'
import { Chain } from 'viem/chains'

export function getChainById(chainId: number): Chain {
  for (const chain of Object.values(chains)) {
    if (chain.id === chainId) {
      return chain
    }
  }

  throw new Error(`Chain with id ${chainId} not found`)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/ConstantsUtil.ts">
export const COSIGNER_BASE_URL = 'https://rpc.walletconnect.org/v1/sessions'
export const CA_ORCHESTRATOR_BASE_URL = 'https://rpc.walletconnect.org/v1/ca/orchestrator'
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/CosmosRequestHandler.ts">
import { COSMOS_SIGNING_METHODS } from '@/data/COSMOSData'
import { cosmosAddresses, cosmosWallets } from '@/utils/CosmosWalletUtil'
import { getWalletAddressFromParams } from '@/utils/HelperUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'
import { parseSignDocValues } from 'cosmos-wallet'

export async function approveCosmosRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request } = params
  const wallet = cosmosWallets[getWalletAddressFromParams(cosmosAddresses, params)]

  switch (request.method) {
    case COSMOS_SIGNING_METHODS.COSMOS_SIGN_DIRECT:
      const signedDirect = await wallet.signDirect(
        request.params.signerAddress,
        parseSignDocValues(request.params.signDoc)
      )
      return formatJsonRpcResult(id, signedDirect.signature)

    case COSMOS_SIGNING_METHODS.COSMOS_SIGN_AMINO:
      const signedAmino = await wallet.signAmino(
        request.params.signerAddress,
        request.params.signDoc
      )
      return formatJsonRpcResult(id, signedAmino.signature)

    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectCosmosRequest(request: SignClientTypes.EventArguments['session_request']) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/CosmosWalletUtil.ts">
import CosmosLib from '@/lib/CosmosLib'

export let wallet1: CosmosLib
export let wallet2: CosmosLib
export let cosmosWallets: Record<string, CosmosLib>
export let cosmosAddresses: string[]

let address1: string
let address2: string

/**
 * Utilities
 */
export async function createOrRestoreCosmosWallet() {
  const mnemonic1 = localStorage.getItem('COSMOS_MNEMONIC_1')
  const mnemonic2 = localStorage.getItem('COSMOS_MNEMONIC_2')

  if (mnemonic1 && mnemonic2) {
    wallet1 = await CosmosLib.init({ mnemonic: mnemonic1 })
    wallet2 = await CosmosLib.init({ mnemonic: mnemonic2 })
  } else {
    wallet1 = await CosmosLib.init({})
    wallet2 = await CosmosLib.init({})

    // Don't store mnemonic in local storage in a production project!
    localStorage.setItem('COSMOS_MNEMONIC_1', wallet1.getMnemonic())
    localStorage.setItem('COSMOS_MNEMONIC_2', wallet2.getMnemonic())
  }

  address1 = await wallet1.getAddress()
  address2 = await wallet2.getAddress()

  cosmosWallets = {
    [address1]: wallet1,
    [address2]: wallet2
  }
  cosmosAddresses = Object.keys(cosmosWallets)

  return {
    cosmosWallets,
    cosmosAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/EIP155RequestHandlerUtil.ts">
import { EIP155_CHAINS, EIP155_SIGNING_METHODS, TEIP155Chain } from '@/data/EIP155Data'
import { getWallet } from '@/utils/EIP155WalletUtil'
import { getSignParamsMessage, getSignTypedDataParamsData } from '@/utils/HelperUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'
import { providers } from 'ethers'
import { KernelSmartAccountLib } from '@/lib/smart-accounts/KernelSmartAccountLib'
import SettingsStore from '@/store/SettingsStore'

type RequestEventArgs = Omit<SignClientTypes.EventArguments['session_request'], 'verifyContext'>

export async function approveEIP155Request(requestEvent: RequestEventArgs) {
  const { params, id } = requestEvent
  const { chainId, request } = params

  SettingsStore.setActiveChainId(chainId)

  const wallet = await getWallet(params)

  switch (request.method) {
    case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
    case EIP155_SIGNING_METHODS.ETH_SIGN:
      try {
        const message = getSignParamsMessage(request.params)
        const signedMessage = await wallet.signMessage(message)
        return formatJsonRpcResult(id, signedMessage)
      } catch (error: any) {
        console.error(error)
        alert(error.message)
        return formatJsonRpcError(id, error.message)
      }

    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      try {
        const {
          domain,
          types,
          message: data,
          primaryType
        } = getSignTypedDataParamsData(request.params)

        // intercept for smart account getPermissions mock
        if (domain.name === 'eth_getPermissions_v1' && wallet instanceof KernelSmartAccountLib) {
          const permissionContext = await wallet.issueSessionKey(
            data.targetAddress,
            data.permissions
          )
          return formatJsonRpcResult(id, permissionContext)
        }

        // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471
        delete types.EIP712Domain
        const signedData = await wallet._signTypedData(domain, types, data, primaryType)
        return formatJsonRpcResult(id, signedData)
      } catch (error: any) {
        console.error(error)
        alert(error.message)
        return formatJsonRpcError(id, error.message)
      }

    case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      try {
        const provider = new providers.JsonRpcProvider(EIP155_CHAINS[chainId as TEIP155Chain].rpc)
        const sendTransaction = request.params[0]
        const connectedWallet = await wallet.connect(provider)
        const txResponse = await connectedWallet.sendTransaction(sendTransaction)
        const txHash = typeof txResponse === 'string' ? txResponse : txResponse?.hash
        const txReceipt = await txResponse.wait()
        console.log(
          `Transaction broadcasted on chain ${chainId} , ${{ txHash }}, status: ${txReceipt.status}`
        )
        return formatJsonRpcResult(id, txHash)
      } catch (error: any) {
        console.error(error)
        return formatJsonRpcError(id, error.message)
      }

    case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
      try {
        const signTransaction = request.params[0]
        const signature = await wallet.signTransaction(signTransaction)
        return formatJsonRpcResult(id, signature)
      } catch (error: any) {
        console.error(error)
        alert(error.message)
        return formatJsonRpcError(id, error.message)
      }
    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectEIP155Request(request: RequestEventArgs) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/EIP155WalletUtil.ts">
import EIP155Lib from '@/lib/EIP155Lib'
import { smartAccountWallets } from './SmartAccountUtil'
import { getWalletAddressFromParams } from './HelperUtil'

export let wallet1: EIP155Lib
export let wallet2: EIP155Lib
export let eip155Wallets: Record<string, EIP155Lib>
export let eip155Addresses: string[]

let address1: string
let address2: string

/**
 * Utilities
 */
export function createOrRestoreEIP155Wallet() {
  const mnemonic1 = localStorage.getItem('EIP155_MNEMONIC_1')
  const mnemonic2 = localStorage.getItem('EIP155_MNEMONIC_2')

  if (mnemonic1 && mnemonic2) {
    wallet1 = EIP155Lib.init({ mnemonic: mnemonic1 })
    wallet2 = EIP155Lib.init({ mnemonic: mnemonic2 })
  } else {
    wallet1 = EIP155Lib.init({})
    wallet2 = EIP155Lib.init({})

    // Don't store mnemonic in local storage in a production project!
    localStorage.setItem('EIP155_MNEMONIC_1', wallet1.getMnemonic())
    localStorage.setItem('EIP155_MNEMONIC_2', wallet2.getMnemonic())
  }

  address1 = wallet1.getAddress()
  address2 = wallet2.getAddress()

  eip155Wallets = {
    [address1]: wallet1,
    [address2]: wallet2
  }
  eip155Addresses = Object.keys(eip155Wallets)

  return {
    eip155Wallets,
    eip155Addresses
  }
}

/**
 * Get wallet for the address in params
 */
export const getWallet = async (params: any) => {
  const eoaWallet = eip155Wallets[getWalletAddressFromParams(eip155Addresses, params)]
  if (eoaWallet) {
    return eoaWallet
  }

  /**
   * Smart accounts
   */
  const chainId = params?.chainId?.split(':')[1]
  console.log('Chain ID', { chainId })
  console.log('PARAMS', { params })

  const address = getWalletAddressFromParams(
    Object.keys(smartAccountWallets)
      .filter(key => {
        const parts = key.split(':')
        return parts[0] === chainId
      })
      .map(key => {
        return key.split(':')[1]
      }),
    params
  )
  if (!address) {
    console.log('Library not initialized for requested address', {
      address,
      values: Object.keys(smartAccountWallets)
    })
    throw new Error('Library not initialized for requested address')
  }
  const lib = smartAccountWallets[`${chainId}:${address}`]
  if (lib) {
    return lib
  }
  console.log('Library not found', {
    target: `${chainId}:address`,
    values: Object.keys(smartAccountWallets)
  })
  throw new Error('Cannot find wallet for requested address')
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/EIP5792RequestHandlerUtils.ts">
import { EIP155_CHAINS, TEIP155Chain } from '@/data/EIP155Data'
import {
  EIP5792_METHODS,
  GetCallsParams,
  GetCallsResult,
  GetCapabilitiesResult,
  SendCallsParams,
  supportedEIP5792CapabilitiesForEOA,
  supportedEIP5792CapabilitiesForSCA
} from '@/data/EIP5792Data'
import { getWallet } from '@/utils/EIP155WalletUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'
import SettingsStore from '@/store/SettingsStore'
import EIP155Lib from '@/lib/EIP155Lib'
import {
  ENTRYPOINT_ADDRESS_V07,
  GetUserOperationReceiptReturnType,
  createBundlerClient
} from 'permissionless'
import { http, toHex } from 'viem'
type RequestEventArgs = Omit<SignClientTypes.EventArguments['session_request'], 'verifyContext'>
const getCallsReceipt = async (getCallParams: GetCallsParams) => {
  /**
   * This is hardcode implementation of wallet_getCallsStatus
   * as we are not maintaining the data for calls bundled right now.
   * Getting directly from bundler the receipt on sepolia chain.
   */
  const apiKey = process.env.NEXT_PUBLIC_PIMLICO_KEY
  const localBundlerUrl = process.env.NEXT_PUBLIC_LOCAL_BUNDLER_URL
  const bundlerUrl = localBundlerUrl || `https://api.pimlico.io/v1/sepolia/rpc?apikey=${apiKey}`
  const bundlerClient = createBundlerClient({
    entryPoint: ENTRYPOINT_ADDRESS_V07,
    transport: http(bundlerUrl)
  })
  const userOpReceipt = (await bundlerClient.getUserOperationReceipt({
    hash: getCallParams as `0x${string}`
  })) as GetUserOperationReceiptReturnType | null
  const receipt: GetCallsResult = {
    status: userOpReceipt ? 'CONFIRMED' : 'PENDING',
    receipts: userOpReceipt
      ? [
          {
            logs: userOpReceipt.logs.map(log => ({
              data: log.data,
              address: log.address,
              topics: log.topics
            })),
            blockHash: userOpReceipt.receipt.blockHash,
            blockNumber: toHex(userOpReceipt.receipt.blockNumber),
            gasUsed: toHex(userOpReceipt.actualGasUsed),
            transactionHash: userOpReceipt.receipt.transactionHash,
            status: userOpReceipt.success ? '0x1' : '0x0'
          }
        ]
      : undefined
  }
  return receipt
}

export async function approveEIP5792Request(requestEvent: RequestEventArgs) {
  const { params, id } = requestEvent
  const { chainId, request } = params
  SettingsStore.setActiveChainId(chainId)
  switch (request.method) {
    case EIP5792_METHODS.WALLET_GET_CAPABILITIES: {
      const wallet = await getWallet(params)
      if (wallet instanceof EIP155Lib)
        return formatJsonRpcResult<GetCapabilitiesResult>(id, supportedEIP5792CapabilitiesForEOA)

      return formatJsonRpcResult<GetCapabilitiesResult>(id, supportedEIP5792CapabilitiesForSCA)
    }
    case EIP5792_METHODS.WALLET_GET_CALLS_STATUS: {
      try {
        const getCallParams = request.params[0] as GetCallsParams
        const receipt = await getCallsReceipt(getCallParams)
        return formatJsonRpcResult(id, receipt)
      } catch (error: any) {
        console.error(error)
        alert(error.message)
        return formatJsonRpcError(id, error.message)
      }
    }

    case EIP5792_METHODS.WALLET_SHOW_CALLS_STATUS: {
      // TODO: Added support for show calls status
      return formatJsonRpcError(id, 'Not supported.')
    }
    case EIP5792_METHODS.WALLET_SEND_CALLS: {
      try {
        const wallet = await getWallet(params)
        if (wallet instanceof EIP155Lib) {
          return formatJsonRpcError(id, "Wallet currently don't support batch call for EOA")
        }
        const isChainSupported =
          supportedEIP5792CapabilitiesForSCA[toHex(EIP155_CHAINS[chainId as TEIP155Chain].chainId)]
            .atomicBatch?.supported || false
        if (!isChainSupported)
          return formatJsonRpcError(
            id,
            `Wallet currently don't support batch call for chainId ${chainId}`
          )
        // chainId on request Params should be same as request Event
        const sendCallParams: SendCallsParams = request.params[0] as SendCallsParams
        if (chainId.split(':')[1] !== BigInt(sendCallParams.chainId).toString())
          return formatJsonRpcError(id, 'ChainId mismatch')
        const userOpHash = await wallet.sendERC5792Calls(sendCallParams)
        return formatJsonRpcResult(id, userOpHash)
      } catch (error: any) {
        console.error(error)
        alert(error.message)
        return formatJsonRpcError(id, error.message)
      }
    }
    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectEIP5792Request(request: RequestEventArgs) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/EIP5792WalletUtil.ts">
import { eip155Addresses } from './EIP155WalletUtil'
import {
  GetCapabilitiesResult,
  SendCallsParams,
  supportedEIP5792CapabilitiesForEOA,
  supportedEIP5792CapabilitiesForSCA
} from '@/data/EIP5792Data'

export function getWalletCapabilities(addresses: string[]) {
  const walletCapabilities: GetCapabilitiesResult = {}
  addresses.forEach(address => {
    const namespacesAddress = address.split(':')
    // address will be the last index element whether
    // its a simple address or namespace:chainId:address
    const addr = namespacesAddress[namespacesAddress.length - 1]
    if (eip155Addresses.includes(addr)) {
      // no capabilities support for EOA for now.
      return
    }
    walletCapabilities[addr] = supportedEIP5792CapabilitiesForSCA
  })
  return walletCapabilities
}

export const getSendCallData = (sendCallParams: SendCallsParams) => {
  return sendCallParams.calls.map(call => ({
    to: call.to,
    value: BigInt(call.value || 0),
    data: call.data || '0x'
  }))
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/EIP7715RequestHandlerUtils.ts">
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SessionTypes, SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'
import SettingsStore from '@/store/SettingsStore'
import { EIP7715_METHOD } from '@/data/EIP7715Data'
import {
  SmartSessionGrantPermissionsRequest,
  WalletGrantPermissionsResponse
} from '@reown/appkit-experimental/smart-session'
import { SafeSmartAccountLib } from '@/lib/smart-accounts/SafeSmartAccountLib'
import { walletkit } from './WalletConnectUtil'
import { smartAccountWallets } from './SmartAccountUtil'
import { KernelSmartAccountLib } from '@/lib/smart-accounts/KernelSmartAccountLib'
type RequestEventArgs = Omit<SignClientTypes.EventArguments['session_request'], 'verifyContext'>

function getSmartAccountLibFromSession(requestSession: SessionTypes.Struct, chainId: string) {
  const sessionAccounts = requestSession.namespaces['eip155'].accounts.filter(value =>
    value.startsWith(chainId)
  )
  const sessionAccountsAddresses = sessionAccounts.map(value => value.split(':').slice(1).join(':'))
  const smartAccounts = Object.keys(smartAccountWallets)
  const smartWalletAddress = smartAccounts.find(smartAccount =>
    sessionAccountsAddresses.some(address => address.toLowerCase() === smartAccount.toLowerCase())
  )

  if (!smartWalletAddress) {
    console.log('Library not initialized for requested address', {
      smartWalletAddress,
      values: Object.keys(smartAccountWallets)
    })
    throw new Error('Library not initialized for requested address')
  }
  const lib = smartAccountWallets[smartWalletAddress]
  if (lib) {
    return lib
  }
  console.log('Library not found', {
    target: `${smartWalletAddress}`,
    values: Object.keys(smartAccountWallets)
  })
  throw new Error('Cannot find wallet for requested address')
}

export async function approveEIP7715Request(requestEvent: RequestEventArgs) {
  const { params, id, topic } = requestEvent
  const requestSession = walletkit.engine.signClient.session.get(topic)
  const { chainId, request } = params
  SettingsStore.setActiveChainId(chainId)
  switch (request.method) {
    case EIP7715_METHOD.WALLET_GRANT_PERMISSIONS: {
      const wallet = getSmartAccountLibFromSession(requestSession, chainId)
      let grantPermissionsRequestParams: SmartSessionGrantPermissionsRequest = request.params[0]
      if (
        wallet instanceof SafeSmartAccountLib
        //TODO:fix kernel grantPermissions
        // || wallet instanceof KernelSmartAccountLib
      ) {
        const grantPermissionsResponse: WalletGrantPermissionsResponse =
          await wallet.grantPermissions(grantPermissionsRequestParams)
        return formatJsonRpcResult<WalletGrantPermissionsResponse>(id, grantPermissionsResponse)
      }

      // for any other wallet instance return un_supported
      return formatJsonRpcError(id, getSdkError('UNSUPPORTED_ACCOUNTS').message)
    }
    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectEIP7715Request(request: RequestEventArgs) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED').message)
}

export function createErrorResponse(request: RequestEventArgs, errorMessage: string) {
  const { id } = request

  return formatJsonRpcError(id, errorMessage)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/ERC7579AccountUtils.ts">
import { Address, Chain, createPublicClient, http } from 'viem'
import { smartAccountWallets } from './SmartAccountUtil'
import { SafeSmartAccountLib } from '@/lib/smart-accounts/SafeSmartAccountLib'
import { Execution, Module, ModuleType } from '@rhinestone/module-sdk'
import { getViemChain } from '@/data/chainsUtil'
const { getAccount, isModuleInstalled, installModule, getOwnableValidatorOwners } =
  require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')

function getSmartWallet(accountAddress: string, chainId: string) {
  const smartAccount = `${chainId}:${accountAddress}`
  const account = Object.keys(smartAccountWallets).find(sca => {
    return sca.toLowerCase() === smartAccount.toLowerCase()
  })
  if (account) {
    const lib = smartAccountWallets[account]
    if (lib) {
      return lib
    }
  }
}

export async function installERC7579Module(args: {
  accountAddress: string
  chainId: string
  module: Module
}) {
  const { accountAddress, chainId, module } = args
  const smartContractWallet = getSmartWallet(accountAddress, chainId)
  if (module && smartContractWallet?.chain && smartContractWallet instanceof SafeSmartAccountLib) {
    const client = await getPublicClient(smartContractWallet.chain)

    // Create the account object
    const account = getAccount({
      address: smartContractWallet.getAccount().address,
      initCode: await smartContractWallet.getAccount().getInitCode(),
      type: 'erc7579-implementation'
    })

    // Get the executions required to install the module
    const executions = await installModule({
      client,
      account,
      module
    })
    const calls = executions.map(execution => {
      return {
        to: execution.target,
        data: execution.callData,
        value: BigInt(execution.value.toString())
      }
    })
    const txReceipt = await smartContractWallet.manageModule(calls)
    console.log({ txReceipt })
    return txReceipt
  }
}

export async function manageERC7579Module(args: {
  accountAddress: string
  chainId: string
  executions: Execution[]
}) {
  const { accountAddress, chainId, executions } = args
  const smartContractWallet = getSmartWallet(accountAddress, chainId)
  if (
    executions &&
    smartContractWallet?.chain &&
    smartContractWallet instanceof SafeSmartAccountLib
  ) {
    const calls = executions.map(execution => {
      return {
        to: execution.target,
        data: execution.callData,
        value: BigInt(execution.value.toString())
      }
    })

    const txReceipt = await smartContractWallet.manageModule(calls)
    console.log({ txReceipt })
    return txReceipt
  }
}

export async function getERC7579OwnableValidatorOwners({
  accountAddress,
  chainId
}: {
  accountAddress: string
  chainId: string
}): Promise<Address[]> {
  try {
    const smartContractWallet = getSmartWallet(accountAddress, chainId)
    if (smartContractWallet?.chain) {
      const client = await getPublicClient(smartContractWallet.chain)
      const account = getAccount({
        address: smartContractWallet.getAccount().address,
        initCode: await smartContractWallet.getAccount().getInitCode(),
        type: 'erc7579-implementation'
      })
      return (await getOwnableValidatorOwners({
        account,
        client
      })) as Address[]
    }
    return []
  } catch (err) {
    console.error(err)
    return []
  }
}

export function getPublicClient(chain: Chain) {
  return createPublicClient({
    transport: http(),
    chain: chain
  })
}

export async function isERC7579ModuleInstalled(
  address: Address,
  chainId: string,
  moduleType: ModuleType,
  moduleAddress: Address
) {
  const chain = getViemChain(parseInt(chainId))
  if (!chain) throw new Error(`Invalid chainId:${chainId}.`)
  const publicClient = await getPublicClient(chain)
  const smartWallet = getSmartWallet(address, chainId)
  if (!smartWallet) throw new Error(`Account ${address} not found.`)
  const account = getAccount({
    address,
    type: 'erc7579-implementation',
    initCode: await smartWallet.getAccount().getInitCode(), // optional
    deployedOnChains: [parseInt(chainId)] // optional
  })
  const erc7579Module: Module = {
    module: moduleAddress,
    type: moduleType,
    initData: '0x',
    deInitData: '0x',
    additionalContext: '0x',
    address: moduleAddress
  }
  return await isModuleInstalled({
    client: publicClient, // The client object of type PublicClient from viem
    account, // The account object
    module: erc7579Module // The module object
  })
}

export const isModuleInstalledAbi = [
  {
    type: 'function',
    name: 'isModuleInstalled',
    inputs: [
      { name: 'moduleType', type: 'uint256', internalType: 'uint256' },
      { name: 'module', type: 'address', internalType: 'address' },
      {
        name: 'additionalContext',
        type: 'bytes',
        internalType: 'bytes'
      }
    ],
    outputs: [{ name: '', type: 'bool', internalType: 'bool' }],
    stateMutability: 'view'
  }
] as const

export const AccountExecuteAbi = [
  {
    inputs: [
      {
        internalType: 'address',
        name: 'to',
        type: 'address'
      },
      {
        internalType: 'uint256',
        name: 'value',
        type: 'uint256'
      },
      {
        internalType: 'bytes',
        name: 'data',
        type: 'bytes'
      },
      {
        internalType: 'enum Operation',
        name: '',
        type: 'uint8'
      }
    ],
    name: 'execute',
    outputs: [],
    stateMutability: 'payable',
    type: 'function'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'address',
            name: 'to',
            type: 'address'
          },
          {
            internalType: 'uint256',
            name: 'value',
            type: 'uint256'
          },
          {
            internalType: 'bytes',
            name: 'data',
            type: 'bytes'
          }
        ],
        internalType: 'struct Call[]',
        name: 'calls',
        type: 'tuple[]'
      }
    ],
    name: 'executeBatch',
    outputs: [],
    stateMutability: 'payable',
    type: 'function'
  }
] as const
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/HelperUtil.ts">
import toast from 'react-hot-toast'
import { COSMOS_MAINNET_CHAINS, TCosmosChain } from '@/data/COSMOSData'
import { EIP155_CHAINS, TEIP155Chain } from '@/data/EIP155Data'
import { MULTIVERSX_CHAINS, TMultiversxChain } from '@/data/MultiversxData'
import { NEAR_CHAINS, NEAR_TEST_CHAINS, TNearChain } from '@/data/NEARData'
import { POLKADOT_CHAINS, TPolkadotChain } from '@/data/PolkadotData'
import { SOLANA_CHAINS, TSolanaChain } from '@/data/SolanaData'
import { TEZOS_CHAINS, TTezosChain } from '@/data/TezosData'
import { TRON_CHAINS, TTronChain } from '@/data/TronData'
import { KADENA_CHAINS, TKadenaChain } from '@/data/KadenaData'

import { utils } from 'ethers'
import { Verify } from '@walletconnect/types'
import bs58 from 'bs58'

/**
 * Truncates string (in the middle) via given lenght value
 */
export function truncate(value: string, length: number) {
  if (value?.length <= length) {
    return value
  }

  const separator = '...'
  const stringLength = length - separator.length
  const frontLength = Math.ceil(stringLength / 2)
  const backLength = Math.floor(stringLength / 2)

  return value.substring(0, frontLength) + separator + value.substring(value.length - backLength)
}

/**
 * Converts hex to utf8 string if it is valid bytes
 */
export function convertHexToUtf8(value: string) {
  if (utils.isHexString(value)) {
    return utils.toUtf8String(value)
  }

  return value
}

/**
 * Gets message from various signing request methods by filtering out
 * a value that is not an address (thus is a message).
 * If it is a hex string, it gets converted to utf8 string
 */
export function getSignParamsMessage(params: string[]) {
  const message = params.filter(p => !utils.isAddress(p))[0]

  return convertHexToUtf8(message)
}

/**
 * Gets data from various signTypedData request methods by filtering out
 * a value that is not an address (thus is data).
 * If data is a string convert it to object
 */
export function getSignTypedDataParamsData(params: string[]) {
  const data = params.filter(p => !utils.isAddress(p))[0]

  if (typeof data === 'string') {
    return JSON.parse(data)
  }

  return data
}

/**
 * Get our address from params checking if params string contains one
 * of our wallet addresses
 */
export function getWalletAddressFromParams(addresses: string[], params: any) {
  const paramsString = JSON.stringify(params)
  let address = ''

  addresses.forEach(addr => {
    if (paramsString.toLowerCase().includes(addr.toLowerCase())) {
      address = addr
    }
  })

  return address
}

/**
 * Check if chain is part of EIP155 standard
 */
export function isEIP155Chain(chain: string) {
  return chain.includes('eip155')
}

/**
 * Check if chain is part of COSMOS standard
 */
export function isCosmosChain(chain: string) {
  return chain.includes('cosmos')
}

/**
 * Check if chain is part of SOLANA standard
 */
export function isSolanaChain(chain: string) {
  return chain.includes('solana')
}

/**
 * Check if chain is part of POLKADOT standard
 */
export function isPolkadotChain(chain: string) {
  return chain.includes('polkadot')
}

/**
 * Check if chain is part of NEAR standard
 */
export function isNearChain(chain: string) {
  return chain.includes('near')
}

/**
 * Check if chain is part of KADENA standard
 */
export function isKadenaChain(chain: string) {
  return chain.includes('kadena')
}

/**
 * Check if chain is part of MULTIVERSX standard
 */
export function isMultiversxChain(chain: string) {
  return chain.includes('mvx')
}

/**
 * Check if chain is part of TRON standard
 */
export function isTronChain(chain: string) {
  return chain.includes('tron')
}

/**
 * Check if chain is part of Tezos standard
 */
export function isTezosChain(chain: string) {
  return chain.includes('tezos')
}

/**
 * Formats chainId to its name
 */
export function formatChainName(chainId: string) {
  return (
    COSMOS_MAINNET_CHAINS[chainId as TCosmosChain]?.name ??
    EIP155_CHAINS[chainId as TEIP155Chain]?.name ??
    MULTIVERSX_CHAINS[chainId as TMultiversxChain]?.name ??
    NEAR_TEST_CHAINS[chainId as TNearChain]?.name ??
    POLKADOT_CHAINS[chainId as TPolkadotChain]?.name ??
    SOLANA_CHAINS[chainId as TSolanaChain]?.name ??
    TRON_CHAINS[chainId as TTronChain]?.name ??
    TEZOS_CHAINS[chainId as TTezosChain]?.name ??
    KADENA_CHAINS[chainId as TKadenaChain]?.name ??
    chainId
  )
}

export function styledToast(message: string, type: string) {
  if (type === 'success') {
    toast.success(message, {
      position: 'bottom-left',
      style: {
        borderRadius: '10px',
        background: '#333',
        color: '#fff'
      }
    })
  } else if (type === 'error') {
    toast.error(message, {
      position: 'bottom-left',
      style: {
        borderRadius: '10px',
        background: '#333',
        color: '#fff'
      }
    })
  }
}

export const decodeDIDToSecp256k1PublicKey = (did: string): string => {
  // Check if the DID starts with the correct prefix
  if (!did.startsWith('did:key:zQ3s')) {
    throw new Error('Invalid DID format. Must start with "did:key:zQ3s"')
  }

  // Extract the Base58 encoded part
  const encodedPart = did.slice('did:key:zQ3s'.length)

  // Decode the Base58 string
  const decodedBuffer = bs58.decode(encodedPart)

  // Convert the Buffer to a hex string
  const publicKey = Buffer.from(decodedBuffer).toString('hex')

  // Add the '0x' prefix
  return '0x' + publicKey
}

export enum KEY_TYPES {
  secp256k1 = 'secp256k1',
  secp256r1 = 'secp256r1',
  ed25519 = 'ed25519',
  x25519 = 'x25519',
  rsa = 'rsa',
  'p-384' = 'p-384',
  'p-521' = 'p-521'
}

export const decodeDIDToPublicKey = (
  did: string
): {
  key: `0x${string}`
  keyType: KEY_TYPES
} => {
  // Define the DID prefix to key type mapping
  const didPrefixToKeyType: Record<string, KEY_TYPES> = {
    'did:key:zQ3s': KEY_TYPES.secp256k1,
    'did:key:zDn': KEY_TYPES.secp256r1,
    'did:key:z6Mk': KEY_TYPES.ed25519,
    'did:key:z6LS': KEY_TYPES.x25519,
    'did:key:z4MX': KEY_TYPES.rsa,
    'did:key:z82L': KEY_TYPES['p-384'],
    'did:key:z2J9': KEY_TYPES['p-521']
  }

  // Find the matching key type prefix
  const matchingPrefix = Object.keys(didPrefixToKeyType).find(prefix => did.startsWith(prefix))

  if (!matchingPrefix) {
    throw new Error('Invalid DID format. Unsupported key type.')
  }

  // Extract the Base58 encoded part
  const encodedPart = did.slice(matchingPrefix.length)

  // Decode the Base58 string
  const decodedBuffer = bs58.decode(encodedPart)

  // Convert the Buffer to a hex string
  const publicKey = Buffer.from(decodedBuffer).toString('hex')

  // Add the '0x' prefix
  const formattedPublicKey = `0x${publicKey}` as `0x${string}`

  // Get the key type
  const keyType = didPrefixToKeyType[matchingPrefix]

  return {
    key: formattedPublicKey,
    keyType
  }
}

export function bigIntReplacer(_key: string, value: any) {
  if (typeof value === 'bigint') {
    return value.toString()
  }

  return value
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/KadenaRequestHandlerUtil.ts">
import { KADENA_SIGNING_METHODS } from '@/data/KadenaData'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'
import { getWalletAddressFromParams } from './HelperUtil'
import { kadenaAddresses, kadenaWallets } from './KadenaWalletUtil'

export async function approveKadenaRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request } = params
  const account = getWalletAddressFromParams(kadenaAddresses, params)
  const wallet = kadenaWallets[account]

  switch (request.method) {
    case KADENA_SIGNING_METHODS.KADENA_GET_ACCOUNTS:
      const mockAccount = `k:${account}`

      return formatJsonRpcResult(id, {
        accounts: [
          {
            account: mockAccount,
            publicKey: account,
            kadenaAccounts: [
              {
                name: mockAccount,
                contract: 'coin',
                chains: ['2', '4', '7', '18']
              },
              {
                name: 'w:abcdabcdabcdabcd',
                contract: 'coin',
                chains: ['8', '17']
              }
            ]
          }
        ]
      })

    case KADENA_SIGNING_METHODS.KADENA_SIGN:
      const signedRequest = wallet.signRequest(request.params)
      return formatJsonRpcResult(id, signedRequest)

    case KADENA_SIGNING_METHODS.KADENA_QUICKSIGN:
      const signedMessage = wallet.quicksignRequest(request.params)
      return formatJsonRpcResult(id, signedMessage)

    default:
      throw new Error(getSdkError('UNSUPPORTED_METHODS').message)
  }
}

export function rejectKadenaRequest(request: SignClientTypes.EventArguments['session_request']) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/KadenaWalletUtil.ts">
import KadenaLib from '@/lib/KadenaLib'

export let wallet: KadenaLib
export let kadenaWallets: Record<string, KadenaLib>
export let kadenaAddresses: string[]

/**
 * Utilities
 */

export async function createOrRestoreKadenaWallet() {
  const secretKey = localStorage.getItem('KADENA_SECRET_KEY')

  if (secretKey) {
    wallet = KadenaLib.init({ secretKey })
  } else {
    wallet = KadenaLib.init({})
  }

  if (wallet.getSecretKey()) {
    localStorage.setItem('KADENA_SECRET_KEY', wallet.getSecretKey())
  }

  const address = wallet.getAddress()
  kadenaAddresses = [address]

  kadenaWallets = {
    [address]: wallet
  }

  return {
    kadenaWallets,
    kadenaAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/MultibridgeUtil.ts">
import { createPublicClient, decodeFunctionData, erc20Abi, getContract, Hex, http } from 'viem'
import { arbitrum, base, optimism } from 'viem/chains'
import { getChainById } from './ChainUtil'
import { providers } from 'ethers'
import { EIP155_CHAINS, TEIP155Chain } from '@/data/EIP155Data'

const BASE_URL = 'https://api.socket.tech/v2'
const WHITELIST_BRIDGES = 'across'
const AMOUNT_MULTIPLIER = 1.05

export const supportedAssets: Record<string, Record<number, Hex>> = {
  USDC: {
    [base.id]: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
    [optimism.id]: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',
    [arbitrum.id]: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831'
  }
} as const

const assetDecimals: Record<string, number> = {
  USDC: 6
}

export const supportedChains = [base, optimism, arbitrum] as const

export function getCrossChainTokens(address: Hex): Record<number, Hex> | undefined {
  const otherTokens: Record<number, Hex> = {}

  for (const asset in supportedAssets) {
    for (const chainId in supportedAssets[asset]) {
      if (supportedAssets[asset][chainId] === address) {
        continue
      }
      otherTokens[chainId] = supportedAssets[asset][chainId]
    }
  }
  return Object.keys(otherTokens).length > 0 ? otherTokens : undefined
}

export function getAssetByContractAddress(address: Hex): string {
  for (const [asset, chains] of Object.entries(supportedAssets)) {
    for (const contractAddress of Object.values(chains)) {
      if (contractAddress.toLowerCase() === address.toLowerCase()) {
        return asset
      }
    }
  }
  throw new Error('Asset not found for the given contract address')
}

export function convertTokenBalance(asset: string, amount: number): number {
  const decimals = assetDecimals[asset]
  if (!decimals) {
    throw new Error('Asset not supported')
  }
  const balance = amount / 10 ** decimals
  return balance
}

export async function getErc20TokenBalance(
  tokenAddress: Hex,
  chainId: number,
  account: Hex,
  convert: boolean = true
): Promise<number> {
  const publicClient = createPublicClient({
    chain: getChainById(chainId),
    transport: http()
  })
  const contract = getContract({
    address: tokenAddress,
    abi: erc20Abi,
    client: publicClient
  })
  const result = await contract.read.balanceOf([account])
  if (!convert) {
    return Number(result)
  }
  const decimals = await contract.read.decimals()
  const balance = BigInt(result) / BigInt(10 ** decimals)
  return Number(balance)
}

type Erc20Transfer = {
  from: Hex
  to: Hex
  contract: Hex
  amount: number
}

export function decodeErc20Transaction({
  data,
  from,
  to
}: {
  data: string
  from: string
  to: string
}): Erc20Transfer | null {
  const { functionName, args } = decodeFunctionData({
    abi: erc20Abi,
    data: data as Hex
  })
  if (functionName !== 'transfer') {
    return null
  }

  return {
    to: args[0],
    contract: to as Hex,
    amount: Number(args[1]),
    from: from as Hex
  }
}

async function sendSocketRequest(
  method: 'GET' | 'POST',
  endpoint: string,
  body?: any
): Promise<any> {
  const url = new URL(`${BASE_URL}/${endpoint}`)

  const API_KEY = process.env['NEXT_PUBLIC_SOCKET_KEY']
  if (!API_KEY) {
    throw new Error('Socket API key is not set up')
  }
  const headers: any = {
    'API-KEY': API_KEY,
    Accept: 'application/json'
  }
  if (method === 'POST') {
    headers['Content-Type'] = 'application/json'
  }
  const response = await fetch(url, {
    method,
    headers,
    body: method === 'POST' ? JSON.stringify(body) : undefined
  })
  if (response.status >= 300) {
    throw new Error('Unable to send request to Socket')
  }

  const json = await response.json()
  return json
}

interface BridgingParams {
  fromChainId: number
  toChainId: number
  fromAssetAddress: string
  toAssetAddress: string
  amount: number
  userAddress: string
  uniqueRoutesPerBridge?: boolean
  sort?: 'output' | 'gas' | 'time'
  singleTxOnly?: boolean
}

async function getQuote(params: BridgingParams): Promise<any> {
  const urlParams = new URLSearchParams()
  urlParams.set('fromChainId', params.fromChainId.toString())
  urlParams.set('fromTokenAddress', params.fromAssetAddress)
  urlParams.set('toChainId', params.toChainId.toString())
  urlParams.set('toTokenAddress', params.toAssetAddress)
  urlParams.set('fromAmount', params.amount.toString())
  urlParams.set('userAddress', params.userAddress)
  urlParams.set('includeBridges', WHITELIST_BRIDGES)
  if (params.uniqueRoutesPerBridge !== undefined) {
    urlParams.set('uniqueRoutesPerBridge', params.uniqueRoutesPerBridge.toString())
  }
  if (params.sort !== undefined) {
    urlParams.set('sort', params.sort)
  }
  if (params.singleTxOnly !== undefined) {
    urlParams.set('singleTxOnly', params.singleTxOnly.toString())
  }

  const json = await sendSocketRequest('GET', `quote?${urlParams.toString()}`)
  return json
}

async function getRouteTransactionData(route: any): Promise<any> {
  const json = await sendSocketRequest('POST', 'build-tx', { route })
  return json
}

interface AllowanceCheckParams {
  chainId: number
  owner: string
  allowanceTarget: number
  tokenAddress: string
}

async function checkAllowance(params: AllowanceCheckParams): Promise<any> {
  const urlParams = new URLSearchParams()
  urlParams.set('chainID', params.chainId.toString())
  urlParams.set('owner', params.owner)
  urlParams.set('allowanceTarget', params.allowanceTarget.toString())
  urlParams.set('tokenAddress', params.tokenAddress)

  const json = await sendSocketRequest('GET', `approval/check-allowance?${urlParams.toString()}`)
  return json
}

interface ApprovalTransactionParams {
  chainId: number
  owner: string
  allowanceTarget: number
  tokenAddress: string
  amount: number
}

async function getApprovalTransactionData(params: ApprovalTransactionParams): Promise<any> {
  const urlParams = new URLSearchParams()
  urlParams.set('chainID', params.chainId.toString())
  urlParams.set('owner', params.owner)
  urlParams.set('allowanceTarget', params.allowanceTarget.toString())
  urlParams.set('tokenAddress', params.tokenAddress)
  urlParams.set('amount', params.amount.toString())

  const json = await sendSocketRequest('GET', `approval/build-tx?${urlParams.toString()}`)
  return json
}

interface BridgeStatusParams {
  transactionHash: string
  fromChainId: number
  toChainId: number
}

async function getBridgeStatus(params: BridgeStatusParams): Promise<any> {
  const urlParams = new URLSearchParams()
  urlParams.set('transactionHash', params.transactionHash)
  urlParams.set('fromChainId', params.fromChainId.toString())
  urlParams.set('toChainId', params.toChainId.toString())

  const json = await sendSocketRequest('GET', `bridge-status?${urlParams.toString()}`)
  return json
}

async function getBridgingTransactions(
  bridgingParams: BridgingParams,
  walletAddress: string
): Promise<any> {
  const transactions = []
  const originalAmount = bridgingParams.amount
  bridgingParams.amount = Math.round(originalAmount * AMOUNT_MULTIPLIER)
  const quote = await getQuote(bridgingParams)
  const route = quote.result.routes[0]
  if (!route) {
    throw new Error('No routes found')
  }
  const apiReturnData = await getRouteTransactionData(route)
  const approvalData = apiReturnData.result.approvalData
  const { allowanceTarget, minimumApprovalAmount } = approvalData
  const sourceChainProvider = new providers.JsonRpcProvider(
    EIP155_CHAINS[`eip155:${bridgingParams.fromChainId}` as TEIP155Chain].rpc
  )
  let currentNonce = await sourceChainProvider.getTransactionCount(walletAddress)
  if (approvalData !== null) {
    const allowanceCheckStatus = await checkAllowance({
      chainId: bridgingParams.fromChainId,
      owner: bridgingParams.userAddress,
      allowanceTarget,
      tokenAddress: bridgingParams.fromAssetAddress
    })
    const allowanceValue = allowanceCheckStatus.result?.value
    if (minimumApprovalAmount > allowanceValue) {
      const approvalTransactionData = await getApprovalTransactionData({
        chainId: bridgingParams.fromChainId,
        owner: bridgingParams.userAddress,
        allowanceTarget,
        tokenAddress: bridgingParams.fromAssetAddress,
        amount: bridgingParams.amount
      })
      const gasPrice = sourceChainProvider.getGasPrice()
      const gasEstimate = await sourceChainProvider.estimateGas({
        from: walletAddress,
        to: approvalTransactionData.result?.to,
        value: '0x00',
        data: approvalTransactionData.result?.data,
        gasPrice: gasPrice
      })
      transactions.push({
        from: approvalTransactionData.result?.from,
        to: approvalTransactionData.result?.to,
        value: '0x00',
        data: approvalTransactionData.result?.data,
        gasPrice: gasPrice,
        gasLimit: gasEstimate,
        nonce: currentNonce
      })
      currentNonce++
    }
  }
  const gasPrice = await sourceChainProvider.getGasPrice()
  let gasEstimate = BigInt('0x029a6b') * BigInt(4)
  try {
    const res = await sourceChainProvider.estimateGas({
      from: walletAddress,
      to: apiReturnData.result.txTarget,
      value: apiReturnData.result.value,
      data: apiReturnData.result.txData,
      gasPrice: gasPrice
    })
    gasEstimate = BigInt(res.toNumber())
    console.log('Gas Estimate', gasEstimate)
  } catch {
    console.log('Failed gas estimate. Using default with 4x increase')
  }
  transactions.push({
    from: walletAddress,
    to: apiReturnData.result.txTarget,
    data: apiReturnData.result.txData,
    value: apiReturnData.result.value,
    gasPrice: gasPrice,
    gasLimit: gasEstimate,
    nonce: currentNonce
  })
  return transactions
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/MultiversxRequestHandlerUtil.ts">
import { MULTIVERSX_SIGNING_METHODS } from '@/data/MultiversxData'
import { getWalletAddressFromParams } from '@/utils/HelperUtil'
import { multiversxAddresses, multiversxWallets } from '@/utils/MultiversxWalletUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'

export async function approveMultiversxRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request } = params
  const account = getWalletAddressFromParams(multiversxAddresses, params)
  const wallet = multiversxWallets[account]

  switch (request.method) {
    case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_MESSAGE:
      const signedMessage = await wallet.signMessage(request.params.message)
      return formatJsonRpcResult(id, signedMessage)

    case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_TRANSACTION:
      const signTransaction = request.params.transaction
      // Transactions must be signed with the Sender's Private Key before submitting them to the MultiversX Network.
      // Signing is performed with the Ed25519 algorithm.
      const signature = await wallet.signTransaction(signTransaction)

      return formatJsonRpcResult(id, signature)

    case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_TRANSACTIONS:
      // MultiversX Allows for a Batch of Transactions to be signed
      const signTransactions = request.params.transactions

      const signatures = await wallet.signTransactions(signTransactions)
      return formatJsonRpcResult(id, signatures)

    case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_LOGIN_TOKEN:
    case MULTIVERSX_SIGNING_METHODS.MULTIVERSX_SIGN_NATIVE_AUTH_TOKEN:
      // Sometimes a dApp (and its backend) might want to reliably assign an off-chain user identity to a MultiversX address.
      // On this purpose, the signing providers allow a login token to be used within the login flow  - this token is signed using the wallet of the user.
      // Afterwards, a backend application would normally verify the signature of the token
      const message = `${account}${request.params.token}`
      const { signature: signedLoginToken } = await wallet.signMessage(message)

      return formatJsonRpcResult(id, { signature: signedLoginToken })

    default:
      throw new Error(getSdkError('UNSUPPORTED_METHODS').message)
  }
}

export function rejectMultiversxRequest(
  request: SignClientTypes.EventArguments['session_request']
) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/MultiversxWalletUtil.ts">
import MultiversxLib from '@/lib/MultiversxLib'

export let wallet1: MultiversxLib
export let wallet2: MultiversxLib
export let multiversxWallets: Record<string, MultiversxLib>
export let multiversxAddresses: string[]

let address1: string
let address2: string

/**
 * Utilities
 */
export async function createOrRestoreMultiversxWallet() {
  const mnemonic1 = localStorage.getItem('MULTIVERSX_MNEMONIC_1')
  const mnemonic2 = localStorage.getItem('MULTIVERSX_MNEMONIC_2')

  if (mnemonic1 && mnemonic2) {
    wallet1 = await MultiversxLib.init({ mnemonic: mnemonic1 })
    wallet2 = await MultiversxLib.init({ mnemonic: mnemonic2 })
  } else {
    wallet1 = await MultiversxLib.init({})
    wallet2 = await MultiversxLib.init({})

    // Don't store mnemonic in local storage in a production project!
    localStorage.setItem('MULTIVERSX_MNEMONIC_1', wallet1.getMnemonic())
    localStorage.setItem('MULTIVERSX_MNEMONIC_2', wallet2.getMnemonic())
  }

  address1 = await wallet1.getAddress()
  address2 = await wallet2.getAddress()

  multiversxWallets = {
    [address1]: wallet1,
    [address2]: wallet2
  }
  multiversxAddresses = Object.keys(multiversxWallets)

  return {
    multiversxWallets,
    multiversxAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/NearRequestHandlerUtil.ts">
import { NEAR_SIGNING_METHODS, NEAR_TEST_CHAINS } from '@/data/NEARData'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'
import { nearWallet } from '@/utils/NearWalletUtil'
import { InMemorySigner, transactions, utils, Connection } from 'near-api-js'
import { Transaction } from '@near-wallet-selector/core'
import { createAction } from '@near-wallet-selector/wallet-utils'

export async function approveNearRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id, topic } = requestEvent
  const { chainId, request } = params

  switch (request.method) {
    case NEAR_SIGNING_METHODS.NEAR_SIGN_IN: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const accounts = await nearWallet.signIn({
        chainId,
        topic,
        permission: request.params.permission,
        accounts: request.params.accounts
      })

      return formatJsonRpcResult(id, accounts)
    }
    case NEAR_SIGNING_METHODS.NEAR_SIGN_OUT: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const accounts = await nearWallet.signOut({
        chainId,
        topic,
        accounts: request.params.accounts
      })

      return formatJsonRpcResult(id, accounts)
    }
    case NEAR_SIGNING_METHODS.NEAR_GET_ACCOUNTS: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const accounts = await nearWallet.getAccounts({ topic })

      return formatJsonRpcResult(id, accounts)
    }
    case NEAR_SIGNING_METHODS.NEAR_SIGN_TRANSACTION: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const [signedTx] = await nearWallet.signTransactions({
        chainId,
        topic,
        transactions: [transactions.Transaction.decode(Buffer.from(request.params.transaction))]
      })

      return formatJsonRpcResult(id, signedTx.encode())
    }
    case NEAR_SIGNING_METHODS.NEAR_SIGN_AND_SEND_TRANSACTION: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const [transaction] = await nearWallet.createTransactions({
        chainId,
        transactions: [
          {
            ...params.request.params.transaction,
            actions: params.request.params.transaction.actions.map(createAction)
          }
        ]
      })

      const result = await nearWallet.signAndSendTransaction({
        chainId,
        topic,
        transaction
      })

      return formatJsonRpcResult(id, result)
    }
    case NEAR_SIGNING_METHODS.NEAR_SIGN_TRANSACTIONS: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const signedTxs = await nearWallet.signTransactions({
        chainId,
        topic,
        transactions: params.request.params.transactions.map((tx: Uint8Array) => {
          return transactions.Transaction.decode(Buffer.from(tx))
        })
      })

      return formatJsonRpcResult(
        id,
        signedTxs.map(x => x.encode())
      )
    }
    case NEAR_SIGNING_METHODS.NEAR_VERIFY_OWNER: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const accounts = await nearWallet.getAllAccounts()
      const account = accounts.find(acc => acc.accountId === params.request.params.accountId)

      if (!account) {
        throw new Error(`Did not find account with id: ${params.request.params.accountId}`)
      }

      if (!NEAR_TEST_CHAINS[chainId]) {
        throw new Error('Invalid chain id')
      }

      const signer = new InMemorySigner(nearWallet.getKeyStore())
      const networkId = chainId.split(':')[1]
      const connection = Connection.fromConfig({
        networkId,
        provider: { type: 'JsonRpcProvider', args: { url: NEAR_TEST_CHAINS[chainId].rpc } },
        signer
      })

      const blockInfo = await connection.provider.block({ finality: 'final' })
      const publicKey = utils.PublicKey.from(account.publicKey)

      const data = {
        accountId: account.accountId,
        message: params.request.params.message,
        blockId: blockInfo.header.hash,
        publicKey: Buffer.from(publicKey.data).toString('base64'),
        keyType: publicKey.keyType
      }

      const encoded = new Uint8Array(Buffer.from(JSON.stringify(data)))
      const signed = await signer.signMessage(encoded, account.accountId, networkId)

      return formatJsonRpcResult(id, {
        ...data,
        signature: Buffer.from(signed.signature).toString('base64'),
        keyType: signed.publicKey.keyType
      })
    }
    case NEAR_SIGNING_METHODS.NEAR_SIGN_MESSAGE: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const { accountId, publicKey, signature } = await nearWallet.signMessage({
        chainId,
        messageParams: params.request.params
      })

      return formatJsonRpcResult(id, {
        accountId,
        publicKey,
        signature
      })
    }
    case NEAR_SIGNING_METHODS.NEAR_SIGN_AND_SEND_TRANSACTIONS: {
      console.log('approve', { id, params })

      if (!chainId) {
        throw new Error('Invalid chain id')
      }

      const transactions = await nearWallet.createTransactions({
        chainId,
        transactions: params.request.params.transactions.map((transaction: Transaction) => ({
          ...transaction,
          actions: transaction.actions.map(createAction)
        }))
      })

      const result = await nearWallet.signAndSendTransactions({
        chainId,
        topic,
        transactions
      })

      return formatJsonRpcResult(id, result)
    }
    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectNearRequest(request: SignClientTypes.EventArguments['session_request']) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/NearWalletUtil.ts">
import { NearWallet } from '@/lib/NearLib'

export let nearAddresses: string[]
export let nearWallet: NearWallet

/**
 * Utilities
 */
export async function createOrRestoreNearWallet() {
  // NEAR only supports dev accounts in testnet.
  const wallet = await NearWallet.init('testnet')
  const accounts = await wallet.getAllAccounts()

  nearAddresses = accounts.map(x => x.accountId)
  nearWallet = wallet

  return {
    nearWallet,
    nearAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/PaymentValidatorUtil.ts">
import { getChainData } from '@/data/chainsUtil'
import {
  type PaymentOption,
  type DetailedPaymentOption,
  Hex,
  SolanaContractInteraction
} from '@/types/wallet_checkout'
import { createPublicClient, erc20Abi, http, getContract, encodeFunctionData } from 'viem'
import TransactionSimulatorUtil from './TransactionSimulatorUtil'
import SettingsStore from '@/store/SettingsStore'
import { getSolanaTokenData, getTokenData } from '@/data/tokenUtil'
import { getChainById } from './ChainUtil'
import { blockchainApiRpc } from '@/data/EIP155Data'
import {
  Connection,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction
} from '@solana/web3.js'
import { SOLANA_TEST_CHAINS } from '@/data/SolanaData'
import { SOLANA_MAINNET_CHAINS } from '@/data/SolanaData'
import { createTransferInstruction, TOKEN_PROGRAM_ID } from '@solana/spl-token'
import { createAssociatedTokenAccountInstruction } from '@solana/spl-token'
import { getAssociatedTokenAddress } from '@solana/spl-token'
/**
 * Interface for token details
 */
interface TokenDetails {
  balance: bigint
  decimals: number
  symbol: string
  name: string
}

/**
 * Utility class for validating and preparing payment options
 */
export class PaymentValidationUtils {
  // Constants for fallback asset paths
  private static readonly PLACEHOLDER_TOKEN_ICON = '/token-logos/token-placeholder.png'
  private static readonly PLACEHOLDER_CHAIN_ICON = '/chain-logos/chain-placeholder.png'

  /**
   * Parses and validates a CAIP-19 asset ID
   *
   * @param asset - CAIP-19 asset ID string
   * @returns Object containing parsed asset details
   * @throws Error if asset is not in CAIP-19 format
   */
  private static getAssetDetails(asset: string) {
    if (typeof asset !== 'string') throw new Error('Invalid asset value, must be a string')

    // Format: namespace:chainId/assetNamespace:assetReference
    const chainAssetParts = asset.split('/')
    if (chainAssetParts.length !== 2)
      throw new Error('Invalid asset value, must be in CAIP-19 format')

    const chainParts = chainAssetParts[0]?.split(':')
    const assetParts = chainAssetParts[1]?.split(':')

    if (chainParts.length !== 2) throw new Error('Invalid asset value, must be in CAIP-19 format')
    if (assetParts.length !== 2) throw new Error('Invalid asset value, must be in CAIP-19 format')
    const chainNamespace = chainParts[0]
    const chainId = chainParts[1]
    const assetNamespace = assetParts[0]
    const assetAddress = assetParts[1]

    return {
      chainNamespace,
      chainId,
      assetNamespace,
      assetAddress
    }
  }

  /**
   * Extracts the blockchain address from a CAIP-10 formatted string
   *
   * @param recipient - CAIP-10 recipient address
   * @returns The extracted address or null if invalid
   */
  private static extractAddressFromCAIP10(recipient?: string): string | null {
    if (!recipient) return null
    const parts = recipient.split(':')
    return parts.length === 3 ? parts[2] : null
  }

  /**
   * Checks if an asset namespace is supported for payments
   *
   * @param assetNamespace - The asset namespace to check
   * @returns Whether the namespace is supported
   */
  private static isSupportedAssetNamespace(assetNamespace: string): boolean {
    // Support ERC20 tokens, native tokens, and solana token
    return ['erc20', 'slip44', 'token'].includes(assetNamespace)
  }

  // methods to get token details

  private static async getNativeAssetDetails(
    chainId: number,
    account: `0x${string}`
  ): Promise<TokenDetails> {
    const publicClient = createPublicClient({
      chain: getChainById(chainId),
      transport: http(blockchainApiRpc(Number(chainId)))
    })

    const balance = await publicClient.getBalance({
      address: account
    })

    return {
      balance: balance,
      decimals: 18,
      symbol: 'ETH',
      name: 'Ethereum'
    }
  }

  private static async getErc20TokenDetails(
    tokenAddress: Hex,
    chainId: number,
    account: Hex
  ): Promise<TokenDetails> {
    const publicClient = createPublicClient({
      chain: getChainById(chainId),
      transport: http(blockchainApiRpc(Number(chainId)))
    })

    const contract = getContract({
      address: tokenAddress,
      abi: erc20Abi,
      client: publicClient
    })

    const [decimals, symbol, name, balance] = await Promise.all([
      contract.read.decimals(),
      contract.read.symbol(),
      contract.read.name(),
      contract.read.balanceOf([account])
    ])

    return {
      balance: balance,
      decimals: decimals,
      symbol: symbol,
      name: name
    }
  }

  private static async getSolNativeAssetDetails(
    account: string,
    chainId: string
  ): Promise<TokenDetails> {
    const defaultTokenDetails: TokenDetails = {
      balance: BigInt(0),
      decimals: 9,
      symbol: 'SOL',
      name: 'Solana'
    }

    try {
      // Get the RPC URL for the chain
      const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc

      if (!rpc) {
        return defaultTokenDetails
      }

      // Connect to Solana
      const connection = new Connection(rpc, 'confirmed')
      const publicKey = new PublicKey(account)

      const balance = await connection.getBalance(publicKey)
      return {
        ...defaultTokenDetails,
        balance: BigInt(balance)
      }
    } catch (error) {
      console.error('Error getting SOL balance:', error)
      return defaultTokenDetails
    }
  }

  private static async getSplTokenDetails(
    tokenAddress: string,
    account: string,
    chainId: string,
    caip19AssetAddress: string
  ): Promise<TokenDetails> {
    const defaultTokenDetails: TokenDetails = {
      balance: BigInt(0),
      decimals: 6,
      symbol: 'UNK',
      name: 'Unknown Token'
    }

    try {
      const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc

      if (!rpc) {
        return defaultTokenDetails
      }

      // Connect to Solana
      const connection = new Connection(rpc, 'confirmed')
      const publicKey = new PublicKey(account)
      const mintAddress = new PublicKey(tokenAddress)

      const token = getSolanaTokenData(caip19AssetAddress)

      // Get token balance
      let balance = BigInt(0)
      let decimals = token?.decimals || 0 // Use known token decimals or default

      // Find the associated token account(s)
      const tokenAccounts = await connection.getParsedTokenAccountsByOwner(publicKey, {
        mint: mintAddress
      })

      // If token account exists, get balance
      if (tokenAccounts.value.length > 0) {
        const tokenAccountPubkey = tokenAccounts.value[0].pubkey
        const tokenBalance = await connection.getTokenAccountBalance(tokenAccountPubkey)
        balance = BigInt(tokenBalance.value.amount)

        // Update decimals from on-chain data if not a known token
        if (!token) {
          decimals = tokenBalance.value.decimals
        }
      } else if (!token) {
        // If no token accounts and not a known token, try to get decimals from mint
        const mintInfo = await connection.getParsedAccountInfo(mintAddress)
        if (mintInfo.value) {
          const parsedMintInfo = (mintInfo.value.data as any).parsed?.info
          decimals = parsedMintInfo?.decimals || decimals
        }
      }

      // Return with known metadata or fallback to generic
      return {
        balance,
        decimals,
        symbol: token?.symbol || tokenAddress.slice(0, 4).toUpperCase(),
        name: token?.name || `SPL Token (${tokenAddress.slice(0, 8)}...)`
      }
    } catch (error) {
      // Return default values in case of error
      return defaultTokenDetails
    }
  }

  // methods to simulate payments
  private static async simulateEvmContractInteraction(
    contractInteraction: any,
    chainId: string,
    account: string
  ): Promise<number | null> {
    if (!contractInteraction?.data) {
      return null
    }

    if (Array.isArray(contractInteraction.data)) {
      const simulateEvmTransaction = await TransactionSimulatorUtil.simulateEvmTransaction(
        chainId,
        account as `0x${string}`,
        contractInteraction.data as { to: string; value: string; data: string }[]
      )
      return simulateEvmTransaction
    }
    // If data is not an array, it's an invalid format
    return null
  }
  private static async simulateSolanaContractInteraction(params: {
    contractInteraction: SolanaContractInteraction
    account: string
    chainId: string
  }) {
    try {
      const { contractInteraction, account, chainId } = params
      const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc
      if (!rpc) {
        return null
      }

      const connection = new Connection(rpc, 'confirmed')
      const publicKey = new PublicKey(account)
      // Create a new transaction
      const transaction = new Transaction()

      const instruction = contractInteraction.data
      const accountMetas = instruction.accounts.map(acc => ({
        pubkey: new PublicKey(acc.pubkey),
        isSigner: acc.isSigner,
        isWritable: acc.isWritable
      }))

      // Create the instruction
      const txInstruction = new TransactionInstruction({
        programId: new PublicKey(instruction.programId),
        keys: accountMetas,
        data: Buffer.from(instruction.data, 'base64')
      })

      // Add to transaction
      transaction.add(txInstruction)

      const simulationResult = await TransactionSimulatorUtil.simulateSolanaTransaction({
        connection,
        transaction,
        feePayer: publicKey
      })
      console.log({ simulationResult })
      return simulationResult
    } catch (e) {
      return null
    }
  }
  private static async simulateSolanaNativeTransfer(params: {
    account: string
    recipientAddress: string
    amount: string
    chainId: string
  }) {
    try {
      const { account, recipientAddress, amount, chainId } = params
      const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc
      if (!rpc) {
        return null
      }

      const connection = new Connection(rpc, 'confirmed')
      const publicKey = new PublicKey(account)

      const transaction = new Transaction()
      transaction.add(
        SystemProgram.transfer({
          fromPubkey: publicKey,
          toPubkey: new PublicKey(recipientAddress),
          lamports: BigInt(amount)
        })
      )
      const simulationResult = await TransactionSimulatorUtil.simulateSolanaTransaction({
        connection,
        transaction,
        feePayer: publicKey
      })
      console.log({ simulationResult })
      return simulationResult
    } catch (e) {
      return null
    }
  }
  private static async simulateSolanaTokenTransfer(params: {
    account: string
    recipientAddress: string
    amount: bigint
    tokenAddress: string
    chainId: string
  }) {
    try {
      const { account, recipientAddress, amount, tokenAddress, chainId } = params
      const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc
      if (!rpc) {
        return null
      }

      const connection = new Connection(rpc, 'confirmed')
      const fromPubkey = new PublicKey(account)
      const mintAddress = new PublicKey(tokenAddress)
      const toPubkey = new PublicKey(recipientAddress)

      const fromTokenAccountAddress = await getAssociatedTokenAddress(mintAddress, fromPubkey)

      const fromTokenAccount = await connection.getAccountInfo(fromTokenAccountAddress)
      if (!fromTokenAccount) {
        return null
      }

      const toTokenAccountAddress = await getAssociatedTokenAddress(mintAddress, toPubkey)
      const recipientTokenAccount = await connection.getAccountInfo(toTokenAccountAddress)

      // Create transaction
      const transaction = new Transaction()

      // Add instruction to create recipient token account if needed
      if (!recipientTokenAccount) {
        const createAccountInstruction = createAssociatedTokenAccountInstruction(
          fromPubkey,
          toTokenAccountAddress,
          toPubkey,
          mintAddress
        )
        transaction.add(createAccountInstruction)
      }

      // Add transfer instruction
      const transferInstruction = createTransferInstruction(
        fromTokenAccountAddress,
        toTokenAccountAddress,
        fromPubkey,
        amount,
        [],
        TOKEN_PROGRAM_ID
      )
      transaction.add(transferInstruction)

      const simulationResult = await TransactionSimulatorUtil.simulateSolanaTransaction({
        connection,
        transaction,
        feePayer: fromPubkey
      })
      console.log({ simulationResult })
      return simulationResult
    } catch (e) {
      return null
    }
  }

  private static createDetailedPaymentOption(
    payment: PaymentOption,
    tokenDetails: TokenDetails,
    assetNamespace: string,
    chainId: string,
    chainNamespace: string,
    gasDetails: {
      gasFee: number
      decimals: number
      feeSymbol: string
    }
  ): DetailedPaymentOption {
    const chainData = getChainData(`${chainNamespace}:${chainId}`)
    const tokenMetadata = getTokenData(tokenDetails.symbol)

    return {
      ...payment,
      assetMetadata: {
        assetIcon: tokenMetadata?.icon || PaymentValidationUtils.PLACEHOLDER_TOKEN_ICON,
        assetName: tokenDetails.name,
        assetSymbol: tokenDetails.symbol,
        assetNamespace: assetNamespace,
        assetDecimals: tokenDetails.decimals,
        assetBalance: tokenDetails.balance
      },
      chainMetadata: {
        chainId: chainId,
        chainName: chainData?.name || '',
        chainNamespace: chainNamespace,
        chainIcon: chainData?.logo || PaymentValidationUtils.PLACEHOLDER_CHAIN_ICON
      },
      fee: {
        gasFee: gasDetails.gasFee,
        decimals: gasDetails.decimals,
        feeSymbol: gasDetails.feeSymbol
      }
    }
  }

  private static async getDetailedDirectPaymentOption(payment: PaymentOption): Promise<{
    validatedPayment: DetailedPaymentOption | null
    hasMatchingAsset: boolean
  }> {
    try {
      // Extract recipient address
      const recipientAddress = PaymentValidationUtils.extractAddressFromCAIP10(payment.recipient)
      if (!recipientAddress) {
        return { validatedPayment: null, hasMatchingAsset: false }
      }

      // Parse asset details
      const { chainId, assetAddress, chainNamespace, assetNamespace } =
        PaymentValidationUtils.getAssetDetails(payment.asset)

      // Check if asset namespace is supported
      if (!PaymentValidationUtils.isSupportedAssetNamespace(assetNamespace)) {
        return { validatedPayment: null, hasMatchingAsset: false }
      }

      let result

      switch (chainNamespace) {
        case 'solana':
          result = await this.processSolanaDirectPayment(
            payment,
            recipientAddress,
            chainId,
            assetAddress,
            assetNamespace
          )
          break

        case 'eip155':
          result = await this.processEvmDirectPayment(
            payment,
            recipientAddress,
            chainId,
            assetAddress,
            assetNamespace
          )
          break

        default:
          return { validatedPayment: null, hasMatchingAsset: false }
      }

      return result
    } catch (error) {
      console.error('Error validating payment option:', error)
      return { validatedPayment: null, hasMatchingAsset: false }
    }
  }

  private static async processSolanaDirectPayment(
    payment: PaymentOption,
    recipientAddress: string,
    chainId: string,
    assetAddress: string,
    assetNamespace: string
  ): Promise<{
    validatedPayment: DetailedPaymentOption | null
    hasMatchingAsset: boolean
  }> {
    const account = SettingsStore.state.solanaAddress
    let tokenDetails: TokenDetails | undefined
    let simulationResult: number | null

    if (assetNamespace === 'slip44' && assetAddress === '501') {
      simulationResult = await this.simulateSolanaNativeTransfer({
        account,
        recipientAddress: recipientAddress,
        amount: payment.amount,
        chainId: `solana:${chainId}`
      })
      tokenDetails = simulationResult
        ? await this.getSolNativeAssetDetails(account, `solana:${chainId}`)
        : undefined
    } else if (assetNamespace === 'token') {
      simulationResult = await this.simulateSolanaTokenTransfer({
        account,
        recipientAddress: recipientAddress,
        amount: BigInt(payment.amount),
        tokenAddress: assetAddress,
        chainId: `solana:${chainId}`
      })
      tokenDetails = simulationResult
        ? await this.getSplTokenDetails(assetAddress, account, `solana:${chainId}`, payment.asset)
        : undefined
    } else {
      return { validatedPayment: null, hasMatchingAsset: false }
    }
    console.log({ simulationResult })
    // Check if token details were assigned
    if (!tokenDetails) {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    // Check if user has the asset (balance > 0)
    const hasMatchingAsset = tokenDetails.balance > BigInt(0)
    console.log({ tokenDetails })
    if (!hasMatchingAsset) {
      return { validatedPayment: null, hasMatchingAsset }
    }

    // Create detailed payment option with metadata
    const detailedPayment = simulationResult
      ? PaymentValidationUtils.createDetailedPaymentOption(
          payment,
          tokenDetails,
          assetNamespace,
          chainId,
          'solana',
          {
            gasFee: simulationResult,
            decimals: 9,
            feeSymbol: 'SOL'
          }
        )
      : null

    return { validatedPayment: detailedPayment, hasMatchingAsset: true }
  }

  private static async processEvmDirectPayment(
    payment: PaymentOption,
    recipientAddress: string,
    chainId: string,
    assetAddress: string,
    assetNamespace: string
  ): Promise<{
    validatedPayment: DetailedPaymentOption | null
    hasMatchingAsset: boolean
  }> {
    const account = SettingsStore.state.eip155Address as `0x${string}`
    let tokenDetails: TokenDetails | undefined
    let simulationResult: number | null

    if (assetNamespace === 'erc20') {
      simulationResult = await PaymentValidationUtils.simulateEvmContractInteraction(
        {
          data: [
            {
              to: assetAddress as `0x${string}`,
              value: '0x0',
              data: encodeFunctionData({
                abi: erc20Abi,
                functionName: 'transfer',
                args: [recipientAddress as `0x${string}`, BigInt(payment.amount)]
              })
            }
          ]
        },
        chainId,
        account
      )
      tokenDetails = await PaymentValidationUtils.getErc20TokenDetails(
        assetAddress as `0x${string}`,
        Number(chainId),
        account as `0x${string}`
      )
    } else if (assetNamespace === 'slip44' && assetAddress === '60') {
      // slip44:60 - native ETH token
      simulationResult = await TransactionSimulatorUtil.simulateEvmTransaction(
        chainId,
        account as `0x${string}`,
        [
          {
            to: recipientAddress as `0x${string}`,
            value: payment.amount,
            data: '0x'
          }
        ]
      )
      tokenDetails = await PaymentValidationUtils.getNativeAssetDetails(
        Number(chainId),
        account as `0x${string}`
      )
    } else {
      return { validatedPayment: null, hasMatchingAsset: false }
    }
    console.log({ simulationResult })
    // Check if token details were assigned
    if (!tokenDetails || simulationResult === undefined) {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    // Check if user has the asset (balance > 0)
    const hasMatchingAsset = tokenDetails.balance > BigInt(0)
    console.log({ tokenDetails })
    if (!hasMatchingAsset) {
      return { validatedPayment: null, hasMatchingAsset }
    }

    // Create detailed payment option with metadata
    const detailedPayment = simulationResult
      ? PaymentValidationUtils.createDetailedPaymentOption(
          payment,
          tokenDetails,
          assetNamespace,
          chainId,
          'eip155',
          {
            gasFee: simulationResult,
            decimals: 18,
            feeSymbol: 'ETH'
          }
        )
      : null

    return { validatedPayment: detailedPayment, hasMatchingAsset: true }
  }

  private static async getDetailedContractPaymentOption(payment: PaymentOption): Promise<{
    validatedPayment: DetailedPaymentOption | null
    hasMatchingAsset: boolean
  }> {
    try {
      const { asset, contractInteraction } = payment

      if (!contractInteraction) {
        return { validatedPayment: null, hasMatchingAsset: false }
      }

      // Parse asset details
      const { chainId, assetAddress, chainNamespace, assetNamespace } =
        PaymentValidationUtils.getAssetDetails(asset)

      // Check if asset namespace is supported
      if (!PaymentValidationUtils.isSupportedAssetNamespace(assetNamespace)) {
        return { validatedPayment: null, hasMatchingAsset: false }
      }

      let result

      switch (chainNamespace) {
        case 'solana':
          result = await this.processSolanaContractPayment(
            payment,
            chainId,
            assetAddress,
            assetNamespace,
            contractInteraction
          )
          break

        case 'eip155':
          result = await this.processEvmContractPayment(
            payment,
            chainId,
            assetAddress,
            assetNamespace,
            contractInteraction
          )
          break

        default:
          return { validatedPayment: null, hasMatchingAsset: false }
      }

      return result
    } catch (error) {
      console.error('Error validating contract payment option:', error)
      return { validatedPayment: null, hasMatchingAsset: false }
    }
  }

  private static async processSolanaContractPayment(
    payment: PaymentOption,
    chainId: string,
    assetAddress: string,
    assetNamespace: string,
    contractInteraction: any
  ): Promise<{
    validatedPayment: DetailedPaymentOption | null
    hasMatchingAsset: boolean
  }> {
    const account = SettingsStore.state.solanaAddress
    let tokenDetails: TokenDetails | undefined
    let simulationResult = null

    if (contractInteraction.type !== 'solana-instruction') {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    simulationResult = await this.simulateSolanaContractInteraction({
      contractInteraction: contractInteraction as SolanaContractInteraction,
      account,
      chainId: `solana:${chainId}`
    })
    if (!simulationResult) {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    if (assetNamespace === 'slip44' && assetAddress === '501') {
      // Native SOL
      tokenDetails = await this.getSolNativeAssetDetails(account, `solana:${chainId}`)
    } else if (assetNamespace === 'token') {
      // SPL token
      tokenDetails = await this.getSplTokenDetails(
        assetAddress,
        account,
        `solana:${chainId}`,
        payment.asset
      )
    } else {
      return { validatedPayment: null, hasMatchingAsset: false }
    }
    console.log({ simulationResult })
    // Check if token details were assigned
    if (!tokenDetails) {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    // Check if user has the asset (balance > 0)
    const hasMatchingAsset = tokenDetails.balance > BigInt(0)

    // Create detailed payment option with metadata
    const detailedPayment = simulationResult
      ? PaymentValidationUtils.createDetailedPaymentOption(
          payment,
          tokenDetails,
          assetNamespace,
          chainId,
          'solana',
          {
            gasFee: simulationResult,
            decimals: 9,
            feeSymbol: 'SOL'
          }
        )
      : null
    return { validatedPayment: detailedPayment, hasMatchingAsset }
  }

  private static async processEvmContractPayment(
    payment: PaymentOption,
    chainId: string,
    assetAddress: string,
    assetNamespace: string,
    contractInteraction: any
  ): Promise<{
    validatedPayment: DetailedPaymentOption | null
    hasMatchingAsset: boolean
  }> {
    const account = SettingsStore.state.eip155Address as `0x${string}`
    let tokenDetails: TokenDetails | undefined
    let simulationResult = null

    if (contractInteraction.type !== 'evm-calls') {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    simulationResult = await PaymentValidationUtils.simulateEvmContractInteraction(
      contractInteraction,
      chainId,
      account
    )
    console.log({ simulationResult })
    if (!simulationResult) {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    if (assetNamespace === 'erc20') {
      tokenDetails = await PaymentValidationUtils.getErc20TokenDetails(
        assetAddress as `0x${string}`,
        Number(chainId),
        account as `0x${string}`
      )
    } else if (assetNamespace === 'slip44') {
      // must be slip44 since we already checked supported namespaces
      tokenDetails = await PaymentValidationUtils.getNativeAssetDetails(
        Number(chainId),
        account as `0x${string}`
      )
    } else {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    // Check if token details were assigned
    if (!tokenDetails) {
      return { validatedPayment: null, hasMatchingAsset: false }
    }

    // Check if user has the asset (balance > 0)
    const hasMatchingAsset = tokenDetails.balance > BigInt(0)

    // Create detailed payment option with metadata
    const detailedPayment = simulationResult
      ? PaymentValidationUtils.createDetailedPaymentOption(
          payment,
          tokenDetails,
          assetNamespace,
          chainId,
          'eip155',
          {
            gasFee: simulationResult,
            decimals: 18,
            feeSymbol: 'ETH'
          }
        )
      : null
    return { validatedPayment: detailedPayment, hasMatchingAsset }
  }

  static async findFeasiblePayments(payments: PaymentOption[]): Promise<{
    feasiblePayments: DetailedPaymentOption[]
    isUserHaveAtleastOneMatchingAssets: boolean
  }> {
    let isUserHaveAtleastOneMatchingAssets = false

    const results = await Promise.all(
      payments.map(async payment => {
        if (payment.recipient && !payment.contractInteraction) {
          // Direct payment
          return await this.getDetailedDirectPaymentOption(payment)
        } else if (payment.contractInteraction) {
          return await this.getDetailedContractPaymentOption(payment)
        } else {
          console.warn('Invalid payment: missing both recipient and contractInteraction')
          return { validatedPayment: null, hasMatchingAsset: false }
        }
      })
    )

    // Collect results
    const feasiblePayments: DetailedPaymentOption[] = []

    for (const result of results) {
      if (result.hasMatchingAsset) {
        isUserHaveAtleastOneMatchingAssets = true
      }

      if (result.validatedPayment) {
        feasiblePayments.push(result.validatedPayment)
      }
    }

    return {
      feasiblePayments,
      isUserHaveAtleastOneMatchingAssets
    }
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/PolkadotRequestHandlerUtil.ts">
import { POLKADOT_SIGNING_METHODS } from '@/data/PolkadotData'
import { getWalletAddressFromParams } from '@/utils/HelperUtil'
import { getPolkadotWallet, polkadotAddresses, polkadotWallets } from '@/utils/PolkadotWalletUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'

export async function approvePolkadotRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request } = params
  const address = request.params?.address
  const wallet = getPolkadotWallet(address)

  if (!wallet) {
    throw new Error('Polkadot wallet does not exist')
  }

  switch (request.method) {
    case POLKADOT_SIGNING_METHODS.POLKADOT_SIGN_MESSAGE:
      const signature = await wallet.signMessage(request.params.message)
      return formatJsonRpcResult(id, signature)

    case POLKADOT_SIGNING_METHODS.POLKADOT_SIGN_TRANSACTION:
      const signedTx = await wallet?.signTransaction(request.params.transactionPayload)
      return formatJsonRpcResult(id, signedTx)

    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectPolkadotRequest(request: SignClientTypes.EventArguments['session_request']) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/PolkadotWalletUtil.ts">
import PolkadotLib from '@/lib/PolkadotLib'
import { addressEq } from '@polkadot/util-crypto'

export let wallet1: PolkadotLib
export let wallet2: PolkadotLib
export let polkadotWallets: Record<string, PolkadotLib>
export let polkadotAddresses: string[]

let address1: string
let address2: string

/**
 * Utilities
 */
export function getPolkadotWallet(address: string) {
  let wallet = Object.entries(polkadotWallets).find(([walletAddress, _]) => {
    return addressEq(address, walletAddress)
  })
  return wallet?.[1]
}

export async function createOrRestorePolkadotWallet() {
  const mnemonic1 = localStorage.getItem('POLKADOT_MNEMONIC_1')
  const mnemonic2 = localStorage.getItem('POLKADOT_MNEMONIC_2')

  if (mnemonic1 && mnemonic2) {
    wallet1 = await PolkadotLib.init({ mnemonic: mnemonic1 })
    wallet2 = await PolkadotLib.init({ mnemonic: mnemonic2 })
  } else {
    wallet1 = await PolkadotLib.init({})
    wallet2 = await PolkadotLib.init({})

    // Don't store mnemonic in local storage in a production project!
    localStorage.setItem('POLKADOT_MNEMONIC_1', wallet1.getMnemonic())
    localStorage.setItem('POLKADOT_MNEMONIC_2', wallet2.getMnemonic())
  }

  address1 = wallet1.getAddress()
  address2 = wallet2.getAddress()

  polkadotWallets = {
    [address1]: wallet1,
    [address2]: wallet2
  }
  polkadotAddresses = Object.keys(polkadotWallets)

  return {
    polkadotWallets,
    polkadotAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/SmartAccountUtil.ts">
import { BiconomySmartAccountLib } from './../lib/smart-accounts/BiconomySmartAccountLib'
import { Hex, Chain as ViemChain } from 'viem'
import { SessionTypes } from '@walletconnect/types'
import { Chain, allowedChains } from '@/consts/smartAccounts'
import { KernelSmartAccountLib } from '@/lib/smart-accounts/KernelSmartAccountLib'
import { baseSepolia, sepolia } from 'viem/chains'
import { SafeSmartAccountLib } from '@/lib/smart-accounts/SafeSmartAccountLib'
import { SmartAccountLib } from '@/lib/smart-accounts/SmartAccountLib'

// Entrypoints [I think this is constant but JIC]
export const ENTRYPOINT_ADDRESSES: Record<Chain['name'], Hex> = {
  Sepolia: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
  'Polygon Mumbai': '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
  Goerli: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
  'Base Sepolia': '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789'
}

// Paymasters
// https://docs.pimlico.io/paymaster/erc20-paymaster/contract-addresses
export const PAYMASTER_ADDRESSES: Record<Chain['name'], Hex> = {
  Sepolia: '0x0000000000325602a77416A16136FDafd04b299f',
  'Polygon Mumbai': '0x000000000009B901DeC1aaB9389285965F49D387',
  Goerli: '0xEc43912D8C772A0Eba5a27ea5804Ba14ab502009',
  'Base Sepolia': '0xEc43912D8C772A0Eba5a27ea5804Ba14ab502009' //Dummy
}

// USDC
export const USDC_ADDRESSES: Record<Chain['name'], Hex> = {
  Sepolia: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238',
  'Polygon Mumbai': '0x9999f7fea5938fd3b1e26a12c3f2fb024e194f97',
  Goerli: '0x07865c6e87b9f70255377e024ace6630c1eaa37f',
  'Base Sepolia': '0x07865c6e87b9f70255377e024ace6630c1eaa37f' //Dummy
}

// RPC URLs
export const RPC_URLS: Record<ViemChain['name'], string> = {
  Sepolia: 'https://rpc.ankr.com/eth_sepolia',
  'Polygon Mumbai': 'https://mumbai.rpc.thirdweb.com',
  Goerli: 'https://ethereum-goerli.publicnode.com',
  'Base Sepolia': 'https://sepolia.base.org'
}

// Pimlico RPC names
export const PIMLICO_NETWORK_NAMES: Record<ViemChain['name'], string> = {
  Sepolia: 'sepolia',
  'Polygon Mumbai': 'mumbai',
  Goerli: 'goerli',
  'Base Sepolia': 'base-sepolia'
}

export const publicRPCUrl = ({ chain }: UrlConfig) => {
  return RPC_URLS[chain?.name]
}

export function supportedAddressPriority(
  namespaces: SessionTypes.Namespaces,
  smartAccountAddress: string,
  providedAllowedChains: Partial<typeof allowedChains>
) {
  const namespaceKeys = Object.keys(namespaces)
  const [nameSpaceKey] = namespaceKeys
  // get chain ids from namespaces
  const [chainIds] = namespaceKeys.map(key => namespaces[key].chains)
  if (!chainIds) {
    return []
  }
  const allowedChainIds = chainIds.filter(id => {
    const chainId = id.replace(`${nameSpaceKey}:`, '')
    return providedAllowedChains.map(chain => chain?.id.toString()).includes(chainId)
  })
  if (allowedChainIds.length === 0) return []
  const parsedAllowedChainIds = allowedChainIds.map(chain => chain.replace(`${nameSpaceKey}:`, ''))
  if (parsedAllowedChainIds.length > 0 && smartAccountAddress) {
    const returnVal = parsedAllowedChainIds.map(
      chainId => `${nameSpaceKey}:${chainId}:${smartAccountAddress}`
    )
    return returnVal
  }
  return []
}

export const kernelAllowedChains = [sepolia]
export const safeAllowedChains = [sepolia, baseSepolia]
export const biconomyAllowedChains = [sepolia]

export let smartAccountWallets: Record<string, SmartAccountLib | KernelSmartAccountLib> = {}

export function isAllowedKernelChain(chainId: number): boolean {
  return kernelAllowedChains.some(chain => chain.id == chainId)
}

export async function createOrRestoreKernelSmartAccount(privateKey: string) {
  const lib = new KernelSmartAccountLib({
    privateKey,
    chain: sepolia,
    sponsored: true,
    entryPointVersion: 6
  })
  await lib.init()
  const address = lib.getAddress()
  const key = `${sepolia.id}:${address}`
  if (!smartAccountWallets[key]) {
    smartAccountWallets[key] = lib
  }
  return {
    kernelSmartAccountAddress: address
  }
}

export function isAllowedSafeChain(chainId: number): boolean {
  return safeAllowedChains.some(chain => chain.id == chainId)
}

const initializeSafeSmartAccountLib = async (chain: Chain, privateKey: string) => {
  try {
    const lib = new SafeSmartAccountLib({
      privateKey,
      chain,
      sponsored: true,
      entryPointVersion: 7
    })
    await lib.init()
    return lib
  } catch (error) {
    console.error(`Error initializing SafeSmartAccountLib for chain ${chain}:`, error)
    return null // or throw error if you want to stop the entire process
  }
}
export async function createOrRestoreSafeSmartAccount(privateKey: string) {
  if (safeAllowedChains.length === 0) {
    throw new Error('No allowed chains for SafeSmartAccount')
  }

  const libs = await Promise.all(
    safeAllowedChains.map(chain => initializeSafeSmartAccountLib(chain, privateKey))
  ).then(results => results.filter((lib): lib is NonNullable<typeof lib> => lib !== null))

  if (libs.length === 0) {
    throw new Error('No safe smart account initialized')
  }

  libs.forEach(lib => {
    const address = lib.getAddress()
    const key = `${lib.chain.id}:${address}`
    if (!smartAccountWallets[key]) {
      smartAccountWallets[key] = lib
    }
  })

  const safeSmartAccountAddress: string = libs[0].getAddress()

  return {
    safeSmartAccountAddress
  }
}
export function removeSmartAccount(address: string) {
  const key = `${sepolia.id}:${address}`
  if (smartAccountWallets[key]) {
    delete smartAccountWallets[key]
  }
}
export function removeSmartAccounts(addresses: string[]) {
  addresses.forEach(address => {
    if (smartAccountWallets[address]) {
      delete smartAccountWallets[address]
    }
  })
}

export async function createOrRestoreBiconomySmartAccount(privateKey: string) {
  const lib = new BiconomySmartAccountLib({ privateKey, chain: sepolia, sponsored: true })
  await lib.init()
  const address = lib.getAddress()
  const key = `${sepolia.id}:${address}`
  if (!smartAccountWallets[key]) {
    smartAccountWallets[key] = lib
  }
  return {
    biconomySmartAccountAddress: address
  }
}

export type UrlConfig = {
  chain: Chain | ViemChain
}

export const publicClientUrl = ({ chain }: UrlConfig) => {
  return process.env.NEXT_PUBLIC_LOCAL_CLIENT_URL || publicRPCUrl({ chain })
}

export const paymasterUrl = ({ chain }: UrlConfig) => {
  const apiKey = process.env.NEXT_PUBLIC_PIMLICO_KEY
  if (apiKey == null) {
    throw new Error('Pimlico API Key not set')
  }

  const localPaymasterUrl = process.env.NEXT_PUBLIC_LOCAL_PAYMASTER_URL
  if (localPaymasterUrl) {
    return localPaymasterUrl
  }
  return `https://api.pimlico.io/v2/${PIMLICO_NETWORK_NAMES[chain.name]}/rpc?apikey=${apiKey}`
}

export const bundlerUrl = ({ chain }: UrlConfig) => {
  const apiKey = process.env.NEXT_PUBLIC_PIMLICO_KEY
  if (apiKey == null) {
    throw new Error('Pimlico API Key not set')
  }
  const localBundlerUrl = process.env.NEXT_PUBLIC_LOCAL_BUNDLER_URL
  if (localBundlerUrl) {
    return localBundlerUrl
  }
  return `https://api.pimlico.io/v1/${PIMLICO_NETWORK_NAMES[chain.name]}/rpc?apikey=${apiKey}`
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/SolanaRequestHandlerUtil.ts">
import { SOLANA_SIGNING_METHODS } from '@/data/SolanaData'
import { getWalletAddressFromParams } from '@/utils/HelperUtil'
import { solanaAddresses, solanaWallets } from '@/utils/SolanaWalletUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { Transaction, VersionedTransaction } from '@solana/web3.js'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'

export async function approveSolanaRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request, chainId } = params

  // Get addresses used in the transaction to select the correct wallet
  params.request.params.publicKeys = ['transaction', 'transactions'].reduce((addresses, key) => {
    const serialized = request.params[key]

    if (serialized) {
      const serializedArray = Array.isArray(serialized) ? serialized : [serialized]
      addresses.push(
        ...Array.from(
          new Set(
            serializedArray
              .map(base64String => Buffer.from(base64String, 'base64'))
              .map(VersionedTransaction.deserialize)
              .flatMap(tx => tx.message.staticAccountKeys.map(key => key.toBase58()))
          )
        )
      )
    }
    return addresses
  }, [] as string[])

  const wallet = solanaWallets[getWalletAddressFromParams(solanaAddresses, params)]

  try {
    switch (request.method) {
      case SOLANA_SIGNING_METHODS.SOLANA_SIGN_MESSAGE:
        const signedMessage = await wallet.signMessage(request.params)
        return formatJsonRpcResult(id, signedMessage)

      case SOLANA_SIGNING_METHODS.SOLANA_SIGN_TRANSACTION:
        const signedTransaction = await wallet.signTransaction(request.params)
        return formatJsonRpcResult(id, signedTransaction)

      case SOLANA_SIGNING_METHODS.SOLANA_SIGN_AND_SEND_TRANSACTION:
        const signedAndSentTransaction = await wallet.signAndSendTransaction(
          request.params,
          chainId
        )
        return formatJsonRpcResult(id, signedAndSentTransaction)

      case SOLANA_SIGNING_METHODS.SOLANA_SIGN_ALL_TRANSACTIONS:
        const signedTransactions = await wallet.signAllTransactions(request.params)
        return formatJsonRpcResult(id, signedTransactions)

      default:
        throw new Error(getSdkError('INVALID_METHOD').message)
    }
  } catch (error) {
    return formatJsonRpcError(id, (error as Error)?.message)
  }
}

export function rejectSolanaRequest(request: SignClientTypes.EventArguments['session_request']) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/SolanaWalletUtil.ts">
import SolanaLib from '@/lib/SolanaLib'

export let wallet1: SolanaLib
export let wallet2: SolanaLib
export let solanaWallets: Record<string, SolanaLib>
export let solanaAddresses: string[]

let address1: string
let address2: string

/**
 * Utilities
 */
export async function createOrRestoreSolanaWallet() {
  const secretKey1 = localStorage.getItem('SOLANA_SECRET_KEY_1')
  const secretKey2 = localStorage.getItem('SOLANA_SECRET_KEY_2')

  if (secretKey1 && secretKey2) {
    const secretArray1: number[] = Object.values(JSON.parse(secretKey1))
    const secretArray2: number[] = Object.values(JSON.parse(secretKey2))
    wallet1 = SolanaLib.init({ secretKey: Uint8Array.from(secretArray1) })
    wallet2 = SolanaLib.init({ secretKey: Uint8Array.from(secretArray2) })
  } else {
    wallet1 = SolanaLib.init({})
    wallet2 = SolanaLib.init({})

    // Don't store secretKey in local storage in a production project!
    localStorage.setItem(
      'SOLANA_SECRET_KEY_1',
      JSON.stringify(Array.from(wallet1.keypair.secretKey))
    )
    localStorage.setItem(
      'SOLANA_SECRET_KEY_2',
      JSON.stringify(Array.from(wallet2.keypair.secretKey))
    )
  }

  address1 = await wallet1.getAddress()
  address2 = await wallet2.getAddress()

  solanaWallets = {
    [address1]: wallet1,
    [address2]: wallet2
  }
  solanaAddresses = Object.keys(solanaWallets)

  return {
    solanaWallets,
    solanaAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/TezosRequestHandlerUtil.ts">
import { TEZOS_SIGNING_METHODS } from '@/data/TezosData'
import { tezosWallets } from '@/utils/TezosWalletUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'

export async function approveTezosRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request } = params

  const wallet = tezosWallets[request.params.account ?? Object.keys(tezosWallets)[0]]
  const allWallets = Object.keys(tezosWallets).map(key => tezosWallets[key])

  switch (request.method) {
    case TEZOS_SIGNING_METHODS.TEZOS_GET_ACCOUNTS:
      return formatJsonRpcResult(
        id,
        allWallets.map(wallet => ({
          algo: wallet.getCurve(),
          address: wallet.getAddress(),
          pubkey: wallet.getPublicKey()
        }))
      )

    case TEZOS_SIGNING_METHODS.TEZOS_SEND:
      const sendResponse = await wallet.signTransaction(request.params.operations)

      return formatJsonRpcResult(id, { hash: sendResponse })

    case TEZOS_SIGNING_METHODS.TEZOS_SIGN:
      const signResponse = await wallet.signPayload(request.params.payload)

      return formatJsonRpcResult(id, { signature: signResponse.prefixSig })

    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectTezosRequest(request: SignClientTypes.EventArguments['session_request']) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/TezosWalletUtil.ts">
import TezosLib from '@/lib/TezosLib'

export let wallet1: TezosLib
export let wallet2: TezosLib
export let tezosWallets: Record<string, TezosLib>
export let tezosAddresses: string[]

let address1: string
let address2: string

/**
 * Utilities
 */
export function getTezosWallet(address: string) {
  let wallet = Object.entries(tezosWallets).find(([walletAddress, _]) => {
    return address === walletAddress
  })
  return wallet?.[1]
}

export async function createOrRestoreTezosWallet() {
  const mnemonic1 = localStorage.getItem('TEZOS_MNEMONIC_1')
  const mnemonic2 = localStorage.getItem('TEZOS_MNEMONIC_2')

  if (mnemonic1 && mnemonic2) {
    wallet1 = await TezosLib.init({ mnemonic: mnemonic1 })
    wallet2 = await TezosLib.init({ mnemonic: mnemonic2 })
  } else {
    wallet1 = await TezosLib.init({})
    wallet2 = await TezosLib.init({})

    // Don't store mnemonic in local storage in a production project!
    localStorage.setItem('TEZOS_MNEMONIC_1', wallet1.getMnemonic())
    localStorage.setItem('TEZOS_MNEMONIC_2', wallet2.getMnemonic())
  }

  address1 = wallet1.getAddress()
  address2 = wallet2.getAddress()

  tezosWallets = {
    [address1]: wallet1,
    [address2]: wallet2
  }
  tezosAddresses = Object.keys(tezosWallets)

  return {
    tezosWallets,
    tezosAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/TransactionSimulatorUtil.ts">
import { blockchainApiRpc } from '@/data/EIP155Data'
import { Connection, PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js'
import { createPublicClient, http } from 'viem'

const TransactionSimulatorUtil = {
  /**
   * Checks if a transaction would be valid by attempting to estimate gas
   * Returns true if estimation succeeds, false if it would fail
   *
   * @param chainId - The blockchain chain ID
   * @param fromWalletAddress - The sender's wallet address
   * @param calls - Array of transaction details to simulate
   * @returns Boolean indicating if all transactions would be valid
   */
  simulateEvmTransaction: async (
    chainId: string,
    fromWalletAddress: string,
    calls: { to: string; value: string; data?: string }[]
  ) => {
    if (!calls || calls.length === 0) {
      console.warn('No transaction calls provided for simulation.')
      return null
    }

    const client = createPublicClient({
      transport: http(blockchainApiRpc(Number(chainId)))
    })
    let totalGasFee: bigint = BigInt(0)
    // Process all calls in parallel with individual error handling
    for (const [index, call] of calls.entries()) {
      try {
        // Estimate gas required for the transaction
        const gasEstimate = await client.estimateGas({
          account: fromWalletAddress as `0x${string}`,
          to: call.to as `0x${string}`,
          value: BigInt(call.value || '0x0'),
          data: (call.data || '0x') as `0x${string}`
        })

        // Retrieve current gas price
        const gasPrice = await client.getGasPrice()

        // Calculate gas fee for this transaction
        const gasFee = gasEstimate * gasPrice
        totalGasFee += gasFee
      } catch (error) {
        console.warn(
          `Simulation failed for transaction #${index + 1} to ${call.to}: ${
            error instanceof Error ? error.message : 'Unknown error'
          }`
        )
        return null
      }
    }
    // Convert totalGasFee from bigint to number
    const totalGasFeeNumber = Number(totalGasFee)

    // Check for potential precision loss during conversion
    if (!Number.isSafeInteger(totalGasFeeNumber)) {
      console.warn('Total gas fee exceeds safe integer limit and may be imprecise.')
      return null
    }
    return totalGasFeeNumber
  },

  /**
   * Simulates a Solana transaction
   *
   * @param connection - Solana connection
   * @param transaction - Transaction to simulate
   * @param feePayer - Fee payer's public key
   * @returns Object with simulation success status and error details if applicable
   * @throws CheckoutError if there's a critical simulation error that should block the transaction
   */
  async simulateSolanaTransaction(param: {
    connection: Connection
    transaction: Transaction
    feePayer: PublicKey
  }): Promise<number | null> {
    try {
      const { connection, transaction, feePayer } = param

      // Set the fee payer and recent blockhash
      transaction.feePayer = feePayer
      const { blockhash } = await connection.getLatestBlockhash()
      transaction.recentBlockhash = blockhash

      // Convert the transaction to a VersionedTransaction
      const versionedTransaction = new VersionedTransaction(transaction.compileMessage())

      // Get the fee for the transaction message
      const feeResponse = await connection.getFeeForMessage(versionedTransaction.message)
      const fee = feeResponse.value

      if (fee === null) {
        console.warn('Failed to fetch transaction fee.')
        return null
      }

      console.log('Estimated transaction fee:', fee)

      // Simulate the transaction
      const simulation = await connection.simulateTransaction(transaction)
      if (simulation.value.err) {
        console.warn('Solana simulation error:', simulation.value.err)
        return null
      }

      return fee
    } catch (error) {
      console.error('Error during transaction simulation:', error)
      return null
    }
  }
}

export default TransactionSimulatorUtil
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/TronRequestHandlerUtil.ts">
import { TRON_MAINNET_CHAINS, TRON_TEST_CHAINS, TRON_SIGNING_METHODS } from '@/data/TronData'
import { getWalletAddressFromParams } from '@/utils/HelperUtil'
import { tronAddresses, tronWallets } from '@/utils/TronWalletUtil'
import { formatJsonRpcError, formatJsonRpcResult } from '@json-rpc-tools/utils'
import { SignClientTypes } from '@walletconnect/types'
import { getSdkError } from '@walletconnect/utils'

export async function approveTronRequest(
  requestEvent: SignClientTypes.EventArguments['session_request']
) {
  const { params, id } = requestEvent
  const { request } = params

  const wallet = tronWallets[getWalletAddressFromParams(tronAddresses, params)]

  if (TRON_MAINNET_CHAINS[params.chainId]) {
    wallet.setFullNode(TRON_MAINNET_CHAINS[params.chainId].fullNode)
  } else if (TRON_TEST_CHAINS[params.chainId]) {
    wallet.setFullNode(TRON_TEST_CHAINS[params.chainId].fullNode)
  } else {
    throw new Error('Invalid chain id')
  }

  switch (request.method) {
    case TRON_SIGNING_METHODS.TRON_SIGN_MESSAGE:
      const signedMessage = await wallet.signMessage(request.params.message)
      const res = {
        signature: signedMessage
      }
      return formatJsonRpcResult(id, res)

    case TRON_SIGNING_METHODS.TRON_SIGN_TRANSACTION:
      const signedTransaction = await wallet.signTransaction(request.params.transaction)
      const resData = {
        result: signedTransaction
      }
      return formatJsonRpcResult(id, resData)

    default:
      throw new Error(getSdkError('INVALID_METHOD').message)
  }
}

export function rejectTronRequest(request: SignClientTypes.EventArguments['session_request']) {
  const { id } = request

  return formatJsonRpcError(id, getSdkError('USER_REJECTED_METHODS').message)
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/TronWalletUtil.ts">
import TronLib from '@/lib/TronLib'

export let tronWeb1: TronLib
export let tronWeb2: TronLib
export let tronWallets: Record<string, TronLib>
export let tronAddresses: string[]

let address1: string
let address2: string

/**
 * Utilities
 */
export async function createOrRestoreTronWallet() {
  const privateKey1 = localStorage.getItem('TRON_PrivateKey_1')
  const privateKey2 = localStorage.getItem('TRON_PrivateKey_2')

  if (privateKey1 && privateKey2) {
    tronWeb1 = await TronLib.init({ privateKey: privateKey1 })
    tronWeb2 = await TronLib.init({ privateKey: privateKey2 })
  } else {
    tronWeb1 = await TronLib.init({ privateKey: '' })
    tronWeb2 = await TronLib.init({ privateKey: '' })

    // Don't store privateKey in local storage in a production project!
    localStorage.setItem('TRON_PrivateKey_1', tronWeb1.privateKey)
    localStorage.setItem('TRON_PrivateKey_2', tronWeb2.privateKey)
  }

  address1 = tronWeb1.getAddress()
  address2 = tronWeb2.getAddress()

  tronWallets = {
    [address1]: tronWeb1,
    [address2]: tronWeb2
  }

  tronAddresses = Object.keys(tronWallets)

  return {
    tronWallets,
    tronAddresses
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/UserOpBuilderUtil.ts">
import { SafeUserOpBuilder } from '@/lib/smart-accounts/builders/SafeUserOpBuilder'
import { UserOpBuilder } from '@/lib/smart-accounts/builders/UserOpBuilder'
import {
  Address,
  Chain,
  createPublicClient,
  getAddress,
  http,
  PublicClient,
  size,
  slice
} from 'viem'
import { publicClientUrl } from './SmartAccountUtil'
import {
  SAFE_4337_MODULE_ADDRESSES,
  SAFE_FALLBACK_HANDLER_STORAGE_SLOT
} from '@/consts/smartAccounts'

type GetUserOpBuilderParams = {
  account: Address
  chain: Chain
  publicClient?: PublicClient
}

export async function getUserOpBuilder(params: GetUserOpBuilderParams): Promise<UserOpBuilder> {
  let publicClient = params.publicClient
  if (!publicClient) {
    publicClient = createPublicClient({
      transport: http(publicClientUrl({ chain: params.chain }))
    })
  }
  if (await isSafeAccount(publicClient, params.account)) {
    return new SafeUserOpBuilder(params.account, params.chain.id)
  }

  throw new Error('Unsupported implementation type')
}

async function isSafeAccount(publicClient: PublicClient, address: Address): Promise<Boolean> {
  try {
    const storageValue = await publicClient.getStorageAt({
      address,
      slot: SAFE_FALLBACK_HANDLER_STORAGE_SLOT
    })
    if (!storageValue) {
      return false
    }
    const safe4337ModuleAddress = getAddress(slice(storageValue, size(storageValue) - 20))
    return SAFE_4337_MODULE_ADDRESSES.includes(safe4337ModuleAddress)
  } catch (error) {
    console.log('Unable to check if account is Safe', error)
    return false
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/WalletCheckoutPaymentHandler.ts">
import { encodeFunctionData } from 'viem'
import { erc20Abi } from 'viem'
import { Connection, PublicKey, Transaction, TransactionInstruction } from '@solana/web3.js'
import { Buffer } from 'buffer'

import {
  DetailedPaymentOption,
  CheckoutErrorCode,
  CheckoutError,
  SolanaContractInteraction
} from '@/types/wallet_checkout'
import { SOLANA_MAINNET_CHAINS } from '@/data/SolanaData'
import { SOLANA_TEST_CHAINS } from '@/data/SolanaData'

export interface PaymentResult {
  txHash: string
}

const WalletCheckoutPaymentHandler = {
  /**
   * Validates if a checkout request has expired
   */
  validateCheckoutExpiry(checkoutRequest: any): void {
    if (checkoutRequest.expiry) {
      const currentTime = Math.floor(Date.now() / 1000)
      if (currentTime > checkoutRequest.expiry) {
        throw new CheckoutError(CheckoutErrorCode.CHECKOUT_EXPIRED, 'Checkout request has expired')
      }
    }
  },

  /**
   * Process a Solana contract interaction
   */
  async processSolanaContractInteraction(
    wallet: any,
    contractInteraction: SolanaContractInteraction,
    chainId: string
  ): Promise<PaymentResult> {
    const rpc = { ...SOLANA_TEST_CHAINS, ...SOLANA_MAINNET_CHAINS }[chainId]?.rpc

    if (!rpc) {
      throw new Error(`There is no RPC URL for the provided chain ${chainId}`)
    }
    const connection = new Connection(rpc)

    // Create a new transaction
    const transaction = new Transaction()

    const instruction = contractInteraction.data
    const accountMetas = instruction.accounts.map(acc => ({
      pubkey: new PublicKey(acc.pubkey),
      isSigner: acc.isSigner,
      isWritable: acc.isWritable
    }))

    // Create the instruction
    const txInstruction = new TransactionInstruction({
      programId: new PublicKey(instruction.programId),
      keys: accountMetas,
      data: Buffer.from(instruction.data, 'base64')
    })

    // Add to transaction
    transaction.add(txInstruction)

    // Set the wallet's public key as feePayer
    const walletAddress = await wallet.getAddress()
    const publicKey = new PublicKey(walletAddress)
    transaction.feePayer = publicKey

    // Get recent blockhash from the connection
    const { blockhash } = await connection.getLatestBlockhash('confirmed')
    transaction.recentBlockhash = blockhash

    const txHash = await connection.sendRawTransaction(transaction.serialize())
    await connection.confirmTransaction(txHash, 'confirmed')

    return { txHash }
  },
  /**
   * Process any payment type and handle errors
   */
  async processPayment(wallet: any, payment: DetailedPaymentOption): Promise<PaymentResult> {
    try {
      const { contractInteraction, recipient, asset, chainMetadata } = payment
      const { chainNamespace, chainId } = chainMetadata

      // ------ Process Solana payments ------
      if (chainNamespace === 'solana') {
        // Check if wallet supports Solana operations
        if (!wallet.getAddress || !wallet.signAndSendTransaction) {
          throw new CheckoutError(
            CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
            'Solana payment requires a compatible wallet'
          )
        }
        // Contract interaction payment
        if (
          contractInteraction &&
          !recipient &&
          contractInteraction.type === 'solana-instruction'
        ) {
          return await this.processSolanaContractInteraction(
            wallet,
            contractInteraction as SolanaContractInteraction,
            `${chainNamespace}:${chainId}`
          )
        }
        // Direct payment (with recipient)
        if (recipient && !contractInteraction) {
          const recipientAddress = recipient.split(':')[2]
          const assetParts = asset.split('/')
          const assetNamespace = assetParts[1]?.split(':')[0]
          const assetReference = assetParts[1]?.split(':')[1]

          // Handle SOL transfers (slip44:501)
          if (assetNamespace === 'slip44' && assetReference === '501') {
            const txHash = await wallet.sendSol(
              recipientAddress,
              `${chainNamespace}:${chainId}`,
              BigInt(payment.amount)
            )
            return { txHash }
          }

          // Handle SPL token transfers (token:<mint-address>)
          if (assetNamespace === 'token') {
            const txHash = await wallet.sendSplToken(
              assetReference,
              recipientAddress,
              `${chainNamespace}:${chainId}`,
              BigInt(payment.amount)
            )
            return { txHash }
          }
        }
      }

      // Ensure wallet is an EVM wallet
      if (!wallet.sendTransaction) {
        throw new CheckoutError(
          CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
          'EVM payment requires an EVM wallet'
        )
      }
      // Direct payment (with recipient)
      if (recipient && !contractInteraction) {
        const { asset, amount, assetMetadata } = payment
        const { assetNamespace } = assetMetadata
        const assetAddress = asset.split(':')[2]
        const recipientAddress = recipient.split(':')[2] as `0x${string}`

        // Handle ETH transfers
        if (assetNamespace === 'slip44' && assetAddress === '60') {
          const tx = await wallet.sendTransaction({
            to: recipientAddress,
            value: BigInt(amount)
          })
          return { txHash: tx.hash }
        }

        // Handle ERC20 transfers
        if (assetNamespace === 'erc20') {
          const calldata = encodeFunctionData({
            abi: erc20Abi,
            functionName: 'transfer',
            args: [recipientAddress, BigInt(amount)]
          })
          const tx = await wallet.sendTransaction({
            to: assetAddress,
            value: '0x0',
            data: calldata
          })
          return { txHash: tx.hash }
        }
      }
      // Contract interaction payment
      if (
        contractInteraction &&
        !recipient &&
        Array.isArray(contractInteraction.data) &&
        contractInteraction.type === 'evm-calls'
      ) {
        let lastTxHash = '0x'

        for (const call of contractInteraction.data) {
          console.log('Processing contract call:', call)
          const tx = await wallet.sendTransaction({
            to: call.to,
            value: call.value,
            data: call.data
          })
          console.log('Transaction sent:', tx)
          lastTxHash = tx.hash
        }

        return { txHash: lastTxHash }
      }

      // Neither or both are present
      throw new CheckoutError(CheckoutErrorCode.INVALID_CHECKOUT_REQUEST)
    } catch (error) {
      console.error('Payment processing error:', error)

      // If it's already a CheckoutError, pass it through
      if (error instanceof CheckoutError) {
        throw error
      }

      // Otherwise create an appropriate error based on payment type
      const { contractInteraction } = payment
      const errorCode = contractInteraction
        ? CheckoutErrorCode.CONTRACT_INTERACTION_FAILED
        : CheckoutErrorCode.DIRECT_PAYMENT_ERROR

      throw new CheckoutError(errorCode)
    }
  }
}

export default WalletCheckoutPaymentHandler
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/WalletCheckoutUtil.ts">
import { z } from 'zod'
import {
  type PaymentOption,
  type DetailedPaymentOption,
  type CheckoutRequest,
  CheckoutErrorCode,
  createCheckoutError,
  CheckoutError
} from '@/types/wallet_checkout'
import { CheckoutRequestSchema } from '@/schema/WalletCheckoutSchema'
import { PaymentValidationUtils } from './PaymentValidatorUtil'

const WalletCheckoutUtil = {
  /**
   * Format the recipient address for display
   * Shortens the address with ellipsis for better display
   *
   * @param recipient - CAIP-10 account ID
   * @returns The formatted recipient address
   */
  formatRecipient(recipient: string): string {
    try {
      const parts = recipient.split(':')
      if (parts.length !== 3) return recipient

      const address = parts[2]
      if (address.length < 10) return address

      return `${address.substring(0, 10)}...${address.substring(address.length - 4)}`
    } catch (e) {
      return recipient
    }
  },

  /**
   * Validates a checkout request structure and payment options using Zod schemas
   * Throws an error if the request is invalid
   *
   * @param checkoutRequest - The checkout request to validate
   * @throws CheckoutError if validation fails
   */
  validateCheckoutRequest(checkoutRequest: CheckoutRequest): void {
    try {
      // Check for request expiry
      if (checkoutRequest.expiry) {
        const currentTime = Math.floor(Date.now() / 1000) // Current time in seconds
        if (currentTime > checkoutRequest.expiry) {
          throw createCheckoutError(CheckoutErrorCode.CHECKOUT_EXPIRED)
        }
      }

      // Use Zod to validate the checkout request structure
      CheckoutRequestSchema.parse(checkoutRequest)
    } catch (error) {
      if (error instanceof z.ZodError) {
        const errorDetails = error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')
        throw createCheckoutError(
          CheckoutErrorCode.INVALID_CHECKOUT_REQUEST,
          `Validation failed: ${errorDetails}`
        )
      }
      throw error
    }
  },

  /**
   * Prepares a checkout request by validating it and checking if the user has sufficient balances
   * for at least one payment option.
   *
   * @param checkoutRequest - The checkout request to prepare
   * @returns A promise that resolves to an object with feasible payments
   * @throws CheckoutError if validation or preparation fails
   */
  async getFeasiblePayments(checkoutRequest: CheckoutRequest): Promise<{
    feasiblePayments: DetailedPaymentOption[]
  }> {
    this.validateCheckoutRequest(checkoutRequest)
    const { acceptedPayments } = checkoutRequest

    // find feasible direct payments
    const { feasiblePayments, isUserHaveAtleastOneMatchingAssets } =
      await PaymentValidationUtils.findFeasiblePayments(acceptedPayments)

    // This return error if user have no matching assets
    if (!isUserHaveAtleastOneMatchingAssets && !feasiblePayments) {
      throw createCheckoutError(CheckoutErrorCode.NO_MATCHING_ASSETS)
    }

    // This return error if user have atleast one matching assets but no feasible payments
    if (feasiblePayments.length === 0) {
      throw createCheckoutError(CheckoutErrorCode.INSUFFICIENT_FUNDS)
    }

    return { feasiblePayments }
  },

  // Add these methods directly to the object
  formatCheckoutSuccessResponse<T>(id: number | string, result: T) {
    return {
      jsonrpc: '2.0',
      id: typeof id === 'string' ? parseInt(id) : id,
      result
    }
  },

  formatCheckoutErrorResponse(id: number | string, error: Error | CheckoutError | unknown) {
    // Default error code for unknown errors
    let code = CheckoutErrorCode.INVALID_CHECKOUT_REQUEST
    let message = 'Unknown error'
    let data = undefined

    // Handle different error types
    if (error instanceof CheckoutError) {
      code = error.code
      message = error.message
      data = error.data
    } else if (error instanceof Error) {
      message = error.message
    } else if (typeof error === 'string') {
      message = error
    }

    return {
      jsonrpc: '2.0',
      id: typeof id === 'string' ? parseInt(id) : id,
      error: {
        code,
        message,
        data
      }
    }
  }
}

export default WalletCheckoutUtil
</file>

<file path="advanced/wallets/react-wallet-v2/src/utils/WalletConnectUtil.ts">
import { WalletKit, IWalletKit } from '@reown/walletkit'
import { Core } from '@walletconnect/core'
export let walletkit: IWalletKit

export async function createWalletKit(relayerRegionURL: string) {
  const core = new Core({
    projectId: process.env.NEXT_PUBLIC_PROJECT_ID,
    relayUrl: relayerRegionURL ?? process.env.NEXT_PUBLIC_RELAY_URL,
    logger: 'trace'
  })
  walletkit = await WalletKit.init({
    core,
    metadata: {
      name: 'React Wallet Example',
      description: 'React Wallet for WalletConnect',
      url: 'https://walletconnect.com/',
      icons: ['https://avatars.githubusercontent.com/u/37784886']
    },
    signConfig: {
      disableRequestQueue: true
    }
  })

  try {
    const clientId = await walletkit.engine.signClient.core.crypto.getClientId()
    console.log('WalletConnect ClientID: ', clientId)
    localStorage.setItem('WALLETCONNECT_CLIENT_ID', clientId)
  } catch (error) {
    console.error('Failed to set WalletConnect clientId in localStorage: ', error)
  }
}

export async function updateSignClientChainId(chainId: string, address: string) {
  console.log('chainId', chainId, address)
  // get most recent session
  const sessions = walletkit.getActiveSessions()
  if (!sessions) return
  const namespace = chainId.split(':')[0]
  Object.values(sessions).forEach(async session => {
    await walletkit.updateSession({
      topic: session.topic,
      namespaces: {
        ...session.namespaces,
        [namespace]: {
          ...session.namespaces[namespace],
          chains: [
            ...new Set([chainId].concat(Array.from(session?.namespaces?.[namespace]?.chains || [])))
          ],
          accounts: [
            ...new Set(
              [`${chainId}:${address}`].concat(
                Array.from(session?.namespaces?.[namespace]?.accounts || [])
              )
            )
          ]
        }
      }
    })
    await new Promise(resolve => setTimeout(resolve, 1000))

    const chainChanged = {
      topic: session.topic,
      event: {
        name: 'chainChanged',
        data: parseInt(chainId.split(':')[1])
      },
      chainId: chainId
    }

    const accountsChanged = {
      topic: session.topic,
      event: {
        name: 'accountsChanged',
        data: [`${chainId}:${address}`]
      },
      chainId
    }
    await walletkit.emitSessionEvent(chainChanged)
    await walletkit.emitSessionEvent(accountsChanged)
  })
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/LoadingModal.tsx">
import { Col, Divider, Link, Loading, Row, Text, styled } from '@nextui-org/react'
import { CoreTypes } from '@walletconnect/types'
import NewReleasesIcon from '@mui/icons-material/NewReleases'
import RequestModalContainer from '@/components/RequestModalContainer'
import { useSnapshot } from 'valtio'
import ModalStore from '@/store/ModalStore'

export default function LoadingModal() {
  const state = useSnapshot(ModalStore.state)
  const message = state.data?.loadingMessage

  return (
    <RequestModalContainer title="">
      <div style={{ textAlign: 'center', padding: '20px' }}>
        <Row>
          <Col>
            <Loading size="lg" />
          </Col>
        </Row>
        <Row align="center">
          <Col>
            <Text h3>Loading your request...</Text>
          </Col>
        </Row>
        {message ? (
          <div style={{ textAlign: 'center' }}>
            <Divider y={1} />
            <Text>{message}</Text>
          </div>
        ) : null}
      </div>
    </RequestModalContainer>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/ModulesManagement.tsx">
import { Module, supportedModules } from '@/data/ERC7579ModuleData'
import { isERC7579ModuleInstalled } from '@/utils/ERC7579AccountUtils'
import { Loading, Row, Text, Card, Container } from '@nextui-org/react'
import { Fragment, useCallback, useEffect, useState } from 'react'
import { Address } from 'viem'
import { useRouter } from 'next/router'
import { styledToast } from '@/utils/HelperUtil'

interface ModulesManagementProps {
  accountType: string
  accountAddress: string
  isDeployed: boolean
  chainId: string
}
// Define the type for the state which combines Module and the isInstalled attribute
type ModuleWithStatus = Module & { isInstalled: boolean }

export default function ModulesManagement({
  accountAddress,
  accountType,
  chainId,
  isDeployed
}: ModulesManagementProps) {
  const [modulesWithStatus, setModulesWithStatus] = useState<ModuleWithStatus[]>(
    supportedModules.map(module => ({ ...module, isInstalled: false }))
  )
  const { query, push } = useRouter()
  const [modulesStatusLoading, setModuleStatusLoading] = useState(true)

  const checkModulesStatus = useCallback(async () => {
    if (!chainId) {
      styledToast('Invalid chainId', 'error')
      setModuleStatusLoading(false)
      return
    }
    if (!isDeployed) {
      setModuleStatusLoading(false)
      return
    }
    setModuleStatusLoading(true)
    const moduleStatusPromises = supportedModules.map(async module => {
      const moduleType = module.type
      const moduleAddress = module.moduleAddress as Address
      const isInstalled = await isERC7579ModuleInstalled(
        accountAddress as Address,
        chainId,
        moduleType,
        moduleAddress
      )
      return {
        ...module,
        isInstalled
      }
    })

    const modulesWithStatus = await Promise.all(moduleStatusPromises)
    setModulesWithStatus(modulesWithStatus)
    setModuleStatusLoading(false)
  }, [accountAddress, chainId, isDeployed])

  useEffect(() => {
    if (accountType !== 'Biconomy') {
      checkModulesStatus()
    }
  }, [accountType, checkModulesStatus])

  return (
    <Fragment>
      <Text h4 css={{ marginBottom: '$5' }}>
        Module Management
      </Text>
      {modulesStatusLoading && isDeployed ? (
        <Loading />
      ) : (
        <Container gap={0} fluid>
          {modulesWithStatus.map(module => (
            <Card
              key={module.moduleAddress}
              hoverable
              clickable
              bordered
              css={{ marginBottom: '$5' }}
              onClick={() =>
                push({
                  pathname: `/accounts/${query.eip155Address}/modules${module.url}`
                })
              }
            >
              <Row align={'center'} justify="space-between">
                <Text>{module.name}</Text>
                <Text h6 color={module.isInstalled ? 'success' : 'error'}>
                  {module.isInstalled ? 'Installed' : 'Not Installed'}
                </Text>
              </Row>
            </Card>
          ))}
        </Container>
      )}
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/OwnableValidatorActions.tsx">
import { Button, Container, Loading, Row, Text, Textarea } from '@nextui-org/react'
import { Fragment, useCallback, useEffect, useState } from 'react'
import OwnableValidatorInstallAction from './OwnableValidatorInstallAction'
import OwnableValidatorUninstallActions from './OwnableValidatorUninstallAction'
import OwnableValidatorSetThresholdAction from './OwnableValidatorSetThresholdAction'
import OwnableValidatorAddOwnerAction from './OwnableValidatorAddOwnerAction'
import {
  getERC7579OwnableValidatorOwners,
  isERC7579ModuleInstalled
} from '@/utils/ERC7579AccountUtils'
import { Address } from 'viem'
import { RefreshOutlined } from '@material-ui/icons'
const { OWNABLE_VALIDATOR_ADDRESS } =
  require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')
export default function OwnableValidatorActions({
  accountAddress,
  chainId
}: {
  accountAddress: string
  chainId: string
}) {
  const [owners, setOwners] = useState<string[]>([])
  const [threshold, setThreshold] = useState(0)
  const [isInstalled, setInstalled] = useState(false)
  const [isRefeshing, setRefreshing] = useState(false)
  const moduleType = 'validator'
  const moduleAddress = OWNABLE_VALIDATOR_ADDRESS

  const getModuleState = useCallback(async () => {
    const ownersPromise = getERC7579OwnableValidatorOwners({ accountAddress, chainId })
    const installationStatusPromise = isERC7579ModuleInstalled(
      accountAddress as Address,
      chainId,
      moduleType,
      moduleAddress
    )
    try {
      const [owners, isInstalledResult] = await Promise.all([
        ownersPromise,
        installationStatusPromise
      ])
      setOwners(owners)
      setInstalled(isInstalledResult)
    } catch (error) {
      console.error('Error fetching module state:', error)
    }
  }, [accountAddress, chainId, moduleAddress])

  const onRefresh = async () => {
    setRefreshing(true)
    await getModuleState()
    setRefreshing(false)
  }

  useEffect(() => {
    getModuleState()
  }, [accountAddress, chainId, getModuleState, moduleAddress])

  return (
    <Fragment>
      <Row justify="space-between" align="center" css={{ marginBottom: '$5' }}>
        <Text h3>Module Details</Text>
        <Button size={'sm'} auto icon={!isRefeshing && <RefreshOutlined />} onClick={onRefresh}>
          {isRefeshing && <Loading type="spinner" color="currentColor" />}
        </Button>
      </Row>
      <Row justify="space-between" align="center" css={{ marginBottom: '$5' }}>
        <Text h4>Status</Text>
        {isInstalled ? (
          <Text color="success">Installed</Text>
        ) : (
          <Text color="error">Not Installed</Text>
        )}
      </Row>
      {isInstalled && (
        <Fragment>
          <Text h4 css={{ marginBottom: '$5' }}>
            State
          </Text>
          <Container css={{ marginBottom: '$5' }}>
            <Row justify="space-between" align="center" css={{ marginBottom: '$3' }}>
              <Text>Current Threshold</Text>
              <Text>{threshold}</Text>
            </Row>
            <Row justify="space-between" align="center" css={{ marginBottom: '$5' }}>
              <Text>{`Current Owner's Count`}</Text>
              <Text>{owners.length}</Text>
            </Row>
            <Textarea
              label={`Owners Addresses`}
              width="100%"
              readOnly
              bordered
              minRows={3}
              maxRows={3}
              value={owners.join(',')}
            />
          </Container>
        </Fragment>
      )}

      <Text h4 css={{ marginBottom: '$5' }}>
        Available Actions
      </Text>
      <Container gap={1}>
        {!isInstalled ? (
          <OwnableValidatorInstallAction accountAddress={accountAddress} chainId={chainId} />
        ) : (
          <Fragment>
            <OwnableValidatorUninstallActions accountAddress={accountAddress} chainId={chainId} />
            <OwnableValidatorSetThresholdAction
              accountAddress={accountAddress}
              chainId={chainId}
              moduleState={{ owners, threshold }}
            />
            <OwnableValidatorAddOwnerAction
              accountAddress={accountAddress}
              chainId={chainId}
              moduleState={{ owners, threshold }}
            />
          </Fragment>
        )}
      </Container>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/OwnableValidatorAddOwnerAction.tsx">
import { getChainById } from '@/utils/ChainUtil'
import { getPublicClient, manageERC7579Module } from '@/utils/ERC7579AccountUtils'
import { styledToast } from '@/utils/HelperUtil'
import { Button, Col, Collapse, Input, Loading, Row, Text } from '@nextui-org/react'
import { useState } from 'react'
import { Address, isAddress } from 'viem'
const { getAccount, getAddOwnableValidatorOwnerAction } =
  require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')

export default function OwnableValidatorAddOwnerAction({
  accountAddress,
  chainId,
  moduleState
}: {
  accountAddress: string
  chainId: string
  moduleState?: { owners: string[]; threshold: number }
}) {
  const [newOwner, setNewOwner] = useState('')
  const [isAddingOwner, setAddingOwner] = useState(false)

  const addOwner = async () => {
    try {
      const ownerExists = moduleState?.owners?.some(
        owner => owner.toLowerCase() === newOwner.toLowerCase()
      )

      if (ownerExists) {
        styledToast('Owner already exists', 'error')
        return
      }
      setAddingOwner(true)
      const account = getAccount({
        address: accountAddress as Address,
        type: 'erc7579-implementation'
      })
      const addOwnableValidatorOwnerAction = await getAddOwnableValidatorOwnerAction({
        owner: newOwner as `0x${string}`,
        account,
        client: getPublicClient(getChainById(parseInt(chainId)))
      })

      if (addOwnableValidatorOwnerAction instanceof Error) {
        throw new Error(addOwnableValidatorOwnerAction.message)
      }
      const txReceipt = await manageERC7579Module({
        accountAddress,
        chainId: chainId,
        executions: [addOwnableValidatorOwnerAction]
      })
      if (!txReceipt?.success) {
        styledToast(`Some error occurred`, 'error')
      }

      styledToast(`Added owner Successfully`, 'success')
    } catch (e) {
      console.error((e as Error).message)

      styledToast('Some error occurred', 'error')
    }
    setAddingOwner(false)
  }

  return (
    <Collapse css={{ marginBottom: '$2' }} bordered title={<Text h5>Add Owner</Text>}>
      <Col css={{ padding: '$5', paddingTop: 0 }}>
        <Row fluid justify="space-between" align="center" css={{ marginBottom: '$5' }}>
          <Input
            css={{ width: '100%' }}
            bordered
            value={newOwner}
            label="Owner"
            type="text"
            onChange={e => setNewOwner(e.target.value)}
            placeholder="add owner address"
          />
        </Row>
        <Row justify="flex-end">
          <Button auto disabled={!newOwner || !isAddress(newOwner)} onClick={addOwner}>
            {isAddingOwner ? <Loading type="points" color="currentColor" size="sm" /> : 'Add Owner'}
          </Button>
        </Row>
      </Col>
    </Collapse>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/OwnableValidatorInstallAction.tsx">
import { installERC7579Module } from '@/utils/ERC7579AccountUtils'
import { styledToast } from '@/utils/HelperUtil'
import { Button, Col, Collapse, Input, Loading, Row, Text, Textarea } from '@nextui-org/react'
import { useState } from 'react'
import { getAddress, isAddress } from 'viem'
const { getOwnableValidator } =
  require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')

export default function OwnableValidatorInstallAction({
  accountAddress,
  chainId
}: {
  accountAddress: string
  chainId: string
}) {
  const [threshold, setThreshold] = useState(0)
  const [addresses, setAddresses] = useState('')
  const [isInstalling, setInstalling] = useState(false)

  const isValidAddressAndThreshold = (threshold: number, addresses: string) => {
    const ownerCount = addresses ? addresses.split(',').length : 0

    if (ownerCount === 0 || threshold === 0 || ownerCount < threshold) {
      return false
    }

    const addressArray = addresses.split(',')

    // Check if all addresses are valid
    const allAddressesValid = addressArray.every(address => {
      return isAddress(address.trim()) // Trim whitespace from each address
    })

    return allAddressesValid
  }

  const onInstall = async () => {
    setInstalling(true)
    try {
      if (!addresses) {
        styledToast(`Please enter owner's addresses`, 'error')
        setInstalling(false)
        return
      }
      const ownerCount = addresses.split(',').length
      if (threshold === 0 || threshold > ownerCount) {
        styledToast(`Please enter valid threshold value`, 'error')
        setInstalling(false)
        return
      }
      const installOwnableValidator = getOwnableValidator({
        threshold: threshold,
        owners: addresses.split(',').map(address => getAddress(address))
      })
      const txReceipt = await installERC7579Module({
        accountAddress,
        chainId: chainId,
        module: installOwnableValidator
      })
      if (!txReceipt?.success) {
        styledToast(`Some error occurred`, 'error')
      }

      styledToast(`Module Installed Successfully`, 'success')
    } catch (e) {
      console.error((e as Error).message)
      styledToast(`Some error occurred`, 'error')
    }
    setInstalling(false)
  }

  return (
    <Collapse css={{ marginBottom: '$2' }} bordered title={<Text h5>Install</Text>}>
      <Col css={{ padding: '$5', paddingTop: 0 }}>
        <Row fluid justify="space-between" align="center" css={{ marginBottom: '$5' }}>
          <Input
            css={{ width: '100%' }}
            bordered
            value={threshold || 0}
            label="Threshold"
            type="number"
            onChange={e => setThreshold(parseInt(e.target.value))}
            placeholder="threshold"
          />
        </Row>
        <Row justify="space-between" align="flex-start" css={{ marginBottom: '$5' }}>
          <Textarea
            css={{ width: '100%' }}
            bordered
            maxRows={4}
            minRows={4}
            value={addresses}
            label="Addresses"
            onChange={e => setAddresses(e.target.value)}
            placeholder="Enter comma separated addresses."
          />
        </Row>
        <Row justify="flex-end">
          <Button
            auto
            disabled={!isValidAddressAndThreshold(threshold, addresses)}
            onClick={onInstall}
          >
            {isInstalling ? <Loading type="points" color="currentColor" size="sm" /> : 'Install'}
          </Button>
        </Row>
      </Col>
    </Collapse>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/OwnableValidatorSetThresholdAction.tsx">
import { getERC7579OwnableValidatorOwners, manageERC7579Module } from '@/utils/ERC7579AccountUtils'
import { styledToast } from '@/utils/HelperUtil'
import { Button, Col, Collapse, Input, Loading, Row, Text } from '@nextui-org/react'
import { useEffect, useState } from 'react'
const { getSetOwnableValidatorThresholdAction } =
  require('@rhinestone/module-sdk') as typeof import('@rhinestone/module-sdk')

export default function OwnableValidatorSetThresholdAction({
  accountAddress,
  chainId,
  moduleState
}: {
  accountAddress: string
  chainId: string
  moduleState?: { owners: string[]; threshold: number }
}) {
  const [threshold, setThreshold] = useState(0)
  const ownerCount = (moduleState?.owners || []).length
  const [isUpdatingThreshold, setUpdatingThreshold] = useState(false)
  console.log({ moduleState })
  const updateThreshold = async () => {
    setUpdatingThreshold(true)
    try {
      const setOwnableValidatorThresholdAction = getSetOwnableValidatorThresholdAction({
        threshold
      })
      const txReceipt = await manageERC7579Module({
        accountAddress,
        chainId: chainId,
        executions: [setOwnableValidatorThresholdAction]
      })
      if (!txReceipt?.success) {
        styledToast(`Some error occurred`, 'error')
      }

      styledToast(`Updated threshold Successfully`, 'success')
    } catch (e) {
      console.error(e)
      styledToast((e as Error).message, 'error')
    }
    setUpdatingThreshold(false)
  }

  return (
    <Collapse css={{ marginBottom: '$2' }} bordered title={<Text h5>Update threshold</Text>}>
      <Col css={{ padding: '$5', paddingTop: 0 }}>
        <Row justify="space-between" align="center" css={{ marginBottom: '$5' }}>
          <Text small css={{ paddingLeft: '$2' }}>{`Current Owner's Count `}</Text>
          <Text small>{ownerCount}</Text>
        </Row>
        <Row fluid justify="space-between" align="center" css={{ marginBottom: '$5' }}>
          <Input
            css={{ width: '100%' }}
            bordered
            value={threshold || 0}
            label="Threshold"
            type="number"
            onChange={e => setThreshold(parseInt(e.target.value))}
            placeholder="threshold"
          />
        </Row>
        <Row justify="flex-end">
          <Button
            auto
            disabled={ownerCount === 0 || !threshold || threshold > ownerCount}
            onClick={updateThreshold}
          >
            {isUpdatingThreshold ? (
              <Loading type="points" color="currentColor" size="sm" />
            ) : (
              'Update Threshold'
            )}
          </Button>
        </Row>
      </Col>
    </Collapse>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/OwnableValidatorUninstallAction.tsx">
import { Button, Collapse, Loading, Row, Text } from '@nextui-org/react'
import { useState } from 'react'

export default function OwnableValidatorUninstallActions({
  accountAddress,
  chainId
}: {
  accountAddress: string
  chainId: string
}) {
  const [isUninstalling, setUninstalling] = useState(false)

  const uninstall = async () => {
    setUninstalling(true)
    setUninstalling(false)
  }

  return (
    <Collapse css={{ marginBottom: '$2' }} bordered title={<Text h5>Uninstall</Text>}>
      <Row justify="space-between" align="center">
        <Text>Coming soon...</Text>
        <Button auto color={'error'} disabled onClick={uninstall}>
          {isUninstalling ? <Loading type="points" color="currentColor" size="sm" /> : 'Uninstall'}
        </Button>
      </Row>
    </Collapse>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionAuthenticateModal.tsx">
import { useCallback, useEffect, useMemo, useState } from 'react'
import { useSnapshot } from 'valtio'
import { Col, Row, Text, Code, Checkbox, Grid } from '@nextui-org/react'
import { buildAuthObject, getSdkError, populateAuthPayload } from '@walletconnect/utils'

import ModalStore from '@/store/ModalStore'
import SettingsStore from '@/store/SettingsStore'
import { eip155Addresses, eip155Wallets } from '@/utils/EIP155WalletUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { EIP155_CHAINS, EIP155_SIGNING_METHODS } from '@/data/EIP155Data'
import { styledToast } from '@/utils/HelperUtil'

export default function SessionAuthenticateModal() {
  // Get request and wallet data from store
  const authRequest = ModalStore.state.data?.authRequest

  const { account } = useSnapshot(SettingsStore.state)
  const [messages, setMessages] = useState<
    { authPayload: any; message: string; id: number; iss: string }[]
  >([])
  const [supportedChains] = useState<string[]>(Object.keys(EIP155_CHAINS))
  const [supportedMethods] = useState<string[]>(Object.values(EIP155_SIGNING_METHODS))
  const [signStrategy, setSignStrategy] = useState(1)
  // Ensure request and wallet are defined

  const address = eip155Addresses[account]

  // eslint-disable-next-line react-hooks/rules-of-hooks
  const getMessageToSign = useCallback((authPayload: any, iss: string) => {
    const message = walletkit.engine.signClient.formatAuthMessage({
      request: authPayload,
      iss
    })
    console.log('message', message)
    return message
  }, [])

  useEffect(() => {
    if (!authRequest?.params?.authPayload) return
    console.log('authRequest', authRequest)
    console.log('supportedChains', supportedChains)
    const newAuthPayload = populateAuthPayload({
      authPayload: authRequest?.params?.authPayload,
      chains: supportedChains,
      methods: supportedMethods
    })

    if (signStrategy === 1) {
      try {
        console.log('newAuthPayload', newAuthPayload)
        const iss = `${newAuthPayload.chains[0]}:${address}`
        const message = getMessageToSign(newAuthPayload, iss)
        setMessages([
          {
            authPayload: newAuthPayload,
            message,
            id: authRequest.id,
            iss
          }
        ])
      } catch (e) {
        console.log('error', e)
        styledToast((e as Error).message, 'error')
        ModalStore.close()
      }
    } else if (signStrategy === 2) {
      const messagesToSign: any[] = []
      newAuthPayload.chains.forEach((chain: string) => {
        const iss = `${chain}:${address}`
        const message = walletkit.engine.signClient.formatAuthMessage({
          request: newAuthPayload,
          iss
        })
        messagesToSign.push({
          authPayload: newAuthPayload,
          message,
          iss,
          id: authRequest.id
        })
      })
      setMessages(messagesToSign)
    }
  }, [address, authRequest, getMessageToSign, signStrategy, supportedChains, supportedMethods])

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (messages.length) {
        const signedAuths = []
        for (const message of messages) {
          const signature = await eip155Wallets[address].signMessage(message.message)
          const signedCacao = buildAuthObject(
            message.authPayload,
            {
              t: 'eip191',
              s: signature
            },
            message.iss
          )
          signedAuths.push(signedCacao)
        }
        await walletkit.engine.signClient.approveSessionAuthenticate({
          id: messages[0].id,
          auths: signedAuths
        })
        SettingsStore.setSessions(Object.values(walletkit.getActiveSessions()))
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      ModalStore.close()
    }
  }, [address, messages])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (authRequest?.params?.authPayload) {
      await walletkit.engine.signClient.rejectSessionAuthenticate({
        id: authRequest.id,
        reason: getSdkError('USER_REJECTED')
      })
      ModalStore.close()
    }
  }, [authRequest])

  return (
    <RequestModal
      intention="request a signature"
      metadata={authRequest?.params?.requester.metadata!}
      onApprove={onApprove}
      onReject={onReject}
    >
      <Grid.Container>
        <Grid>
          <Checkbox onChange={() => setSignStrategy(1)} checked={signStrategy === 1}>
            Sign One
          </Checkbox>
        </Grid>
        <Grid style={{ marginLeft: '10px' }}>
          <Checkbox onChange={() => setSignStrategy(2)} checked={signStrategy === 2}>
            Sign All
          </Checkbox>
        </Grid>
      </Grid.Container>
      <Row>
        <Col>
          <Text h5>Messages to Sign ({messages.length})</Text>
          {messages.map((message, index) => {
            console.log('@loop messageToSign', message)
            return (
              <Code key={index}>
                <Text color="$gray400">{message.message}</Text>
              </Code>
            )
          })}
        </Col>
      </Row>
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionCheckoutModal.tsx">
import { Button, Modal, Text, Spacer, Row, Container, Loading } from '@nextui-org/react'
import { Fragment, useCallback, useState, useMemo } from 'react'

import ModalStore from '@/store/ModalStore'
import { walletkit } from '@/utils/WalletConnectUtil'
import { styledToast } from '@/utils/HelperUtil'
import OrderInfoCard from '@/components/OrderInfoCard'
import Products from '@/components/Products'
import {
  CheckoutRequest,
  DetailedPaymentOption,
  CheckoutResult,
  CheckoutError,
  CheckoutErrorCode
} from '@/types/wallet_checkout'
import PaymentOptions from '@/components/PaymentOptions'
import WalletCheckoutUtil from '@/utils/WalletCheckoutUtil'
import SettingsStore from '@/store/SettingsStore'
import { eip155Wallets } from '@/utils/EIP155WalletUtil'
import EIP155Lib from '@/lib/EIP155Lib'
import { providers } from 'ethers'
import { EIP155_CHAINS, TEIP155Chain } from '@/data/EIP155Data'
import WalletCheckoutPaymentHandler from '@/utils/WalletCheckoutPaymentHandler'
import WalletCheckoutCtrl from '@/store/WalletCheckoutCtrl'
import { solanaWallets } from '@/utils/SolanaWalletUtil'

// Custom styles for the modal
const modalStyles = {
  modal: {
    height: 'auto',
    minHeight: '600px',
    maxHeight: '80vh',
    width: '100%',
    maxWidth: '450px',
    display: 'flex',
    flexDirection: 'column' as const
  },
  modalBody: {
    padding: 0,
    flex: '1 1 auto',
    overflowY: 'auto' as const
  },
  footer: {
    padding: '24px',
    maxWidth: '100%',
    boxSizing: 'border-box' as const,
    marginTop: 'auto'
  },
  footerRow: {
    width: '100%',
    margin: '0',
    padding: '0',
    gap: '16px',
    maxWidth: '100%'
  },
  button: {
    flex: '1',
    maxWidth: 'calc(50% - 8px)'
  }
}

export default function SessionCheckoutModal() {
  const [isLoadingReject, setIsLoadingReject] = useState(false)
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [selectedPayment, setSelectedPayment] = useState<DetailedPaymentOption | null>(null)
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession

  const topic = requestEvent?.topic
  const request = requestEvent?.params?.request
  const checkoutRequest = useMemo(() => request?.params?.[0] || ({} as CheckoutRequest), [request])

  // Use our custom hook to fetch payments
  const eip155Address = SettingsStore.state.eip155Address
  const solanaAddress = SettingsStore.state.solanaAddress
  const feasiblePayments = WalletCheckoutCtrl.state.feasiblePayments

  // Handle reject action
  const onReject = useCallback(async () => {
    if (!requestEvent || !topic) return

    try {
      setIsLoadingReject(true)

      const rejection = new CheckoutError(CheckoutErrorCode.USER_REJECTED, 'User rejected payment')

      const response = WalletCheckoutUtil.formatCheckoutErrorResponse(requestEvent.id, rejection)

      await walletkit.respondSessionRequest({ topic, response })
      styledToast('Payment rejected', 'info')
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Get the appropriate wallet based on the selected payment's chain namespace
  const getWalletForPayment = (payment: DetailedPaymentOption) => {
    const { chainMetadata } = payment
    const { chainNamespace, chainId } = chainMetadata

    if (chainNamespace === 'eip155') {
      const wallet = eip155Wallets[eip155Address]
      if (!(wallet instanceof EIP155Lib)) {
        throw new Error('EVM wallet not available')
      }

      // Set up the provider
      const provider = new providers.JsonRpcProvider(
        EIP155_CHAINS[`eip155:${chainId}` as TEIP155Chain].rpc
      )
      return wallet.connect(provider)
    } else if (chainNamespace === 'solana') {
      const wallet = solanaWallets[solanaAddress]
      console.log({ solanaWallet: wallet })
      if (!wallet) {
        throw new Error('Solana wallet not available')
      }
      return wallet
    }

    throw new Error(`Unsupported chain namespace: ${chainNamespace}`)
  }

  // Handle approve action
  const onApprove = useCallback(async () => {
    if (!requestEvent || !topic || !selectedPayment) return

    try {
      setIsLoadingApprove(true)

      // Validate the request before processing
      WalletCheckoutPaymentHandler.validateCheckoutExpiry(checkoutRequest)

      // Get the wallet for this payment
      const wallet = getWalletForPayment(selectedPayment)

      // Process the payment using the unified method
      const result = await WalletCheckoutPaymentHandler.processPayment(wallet, selectedPayment)

      // Handle the result
      if (result.txHash) {
        const response = WalletCheckoutUtil.formatCheckoutSuccessResponse<CheckoutResult>(
          requestEvent.id,
          {
            orderId: checkoutRequest.orderId,
            txid: result.txHash,
            amount: selectedPayment.amount,
            asset: selectedPayment.asset,
            recipient: selectedPayment.recipient
          }
        )

        await walletkit.respondSessionRequest({ topic, response })
        styledToast('Payment approved successfully', 'success')
      }
    } catch (error) {
      // Handle any unexpected errors
      console.error('Error processing payment:', error)
      const response = WalletCheckoutUtil.formatCheckoutErrorResponse(requestEvent.id, error)

      await walletkit.respondSessionRequest({ topic, response })
      styledToast((error as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [checkoutRequest, requestEvent, selectedPayment, topic])

  // Handle payment selection
  const onSelectPayment = useCallback((payment: DetailedPaymentOption) => {
    setSelectedPayment(payment)
  }, [])

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  return (
    <Fragment>
      <Modal.Body css={modalStyles.modalBody}>
        <Container css={{ padding: 8, paddingTop: 12, backgroundColor: '#2A2A2A',  borderRadius: '0 0 40px 40px' }}>
          <Text h4 css={{paddingLeft: '8px'}}>Checkout</Text>
          {/* Products */}
          <Products products={checkoutRequest.products} />

          {/* Payment Options */}
          <PaymentOptions payments={feasiblePayments} onSelectPayment={onSelectPayment} />
        </Container>
        <Container>
           <OrderInfoCard
            orderId={checkoutRequest.orderId}
            expiry={checkoutRequest.expiry}
            selectedPayment={selectedPayment}
            metadata={requestSession.peer.metadata}
          />
        </Container>
         
        
      </Modal.Body>

      <Container css={modalStyles.footer}>
        <Row justify="space-between" css={modalStyles.footerRow}>
          <Button
            auto
            css={modalStyles.button}
            color="error"
            onClick={onReject}
            disabled={isLoadingApprove || isLoadingReject}
          >
            Cancel
          </Button>
          <Button
            auto
            css={modalStyles.button}
            color="success"
            onClick={onApprove}
            disabled={isLoadingApprove || isLoadingReject || !selectedPayment}
          >
            {isLoadingApprove ? <Loading size="md" type="points" /> : 'Pay'}
          </Button>
        </Row>
      </Container>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionGetBip122AddressesModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Col, Divider, Row, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'
import { approveBip122Request, rejectBip122Request } from '@/utils/Bip122RequestHandlerUtil'
import { bip122Wallet } from '@/utils/Bip122WalletUtil'

export default function SessionGetBip122AddressesModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  const { topic, params } = requestEvent
  const { request, chainId } = params
  const account = request.params.account
  const intentions = request.params.intentions
  const addresses = bip122Wallet.getAddresses(intentions)
  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    if (requestEvent) {
      const response = await approveBip122Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingApprove(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectBip122Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="access your BTC addresses"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      {account && (
        <>
          <Row>
            <Col>
              <Text h5>Addresses for account</Text>
              <Text color="$gray400">{account}</Text>
            </Col>
          </Row>
          <Divider y={1} />
        </>
      )}
      <RequestDataCard data={Object.fromEntries(addresses.entries())} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionGrantPermissionsModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'

import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'
import PermissionDetailsCard from '@/components/PermissionDetailsCard'
import {
  approveEIP7715Request,
  createErrorResponse,
  rejectEIP7715Request
} from '@/utils/EIP7715RequestHandlerUtils'
import { GrantPermissionsParameters } from 'viem/experimental'

export default function SessionGrantPermissionsModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params
  let method = request.method

  // const isPermissionRequest = data?.domain?.name === 'eth_getPermissions_v1'
  let grantPermissionsRequestParams: GrantPermissionsParameters = request.params[0]
  console.log({ grantPermissionsRequestParams })
  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingApprove(true)
      const response = await approveEIP7715Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        styledToast((e as Error).message, 'error')
        const response = createErrorResponse(requestEvent, (e as Error).message)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } finally {
        setIsLoadingApprove(false)
        ModalStore.close()
      }
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectEIP7715Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])
  return (
    <RequestModal
      intention="sign a message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      {'Permissions'}
      <PermissionDetailsCard scope={[]} />
      <Divider y={1} />
      <RequestMethodCard methods={[method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionProposalModal.tsx">
import { Col, Grid, Row, Text, styled } from '@nextui-org/react'
import { useCallback, useMemo, useState } from 'react'
import { buildApprovedNamespaces, getSdkError } from '@walletconnect/utils'
import { SessionTypes, SignClientTypes } from '@walletconnect/types'
import DoneIcon from '@mui/icons-material/Done'
import CloseIcon from '@mui/icons-material/Close'
import ModalStore from '@/store/ModalStore'
import { cosmosAddresses } from '@/utils/CosmosWalletUtil'
import { eip155Addresses } from '@/utils/EIP155WalletUtil'
import { polkadotAddresses } from '@/utils/PolkadotWalletUtil'
import { multiversxAddresses } from '@/utils/MultiversxWalletUtil'
import { tronAddresses } from '@/utils/TronWalletUtil'
import { tezosAddresses } from '@/utils/TezosWalletUtil'
import { solanaAddresses } from '@/utils/SolanaWalletUtil'
import { nearAddresses } from '@/utils/NearWalletUtil'
import { kadenaAddresses } from '@/utils/KadenaWalletUtil'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import { EIP155_CHAINS, EIP155_SIGNING_METHODS } from '@/data/EIP155Data'
import { COSMOS_MAINNET_CHAINS, COSMOS_SIGNING_METHODS } from '@/data/COSMOSData'
import { KADENA_CHAINS, KADENA_SIGNING_METHODS } from '@/data/KadenaData'
import { MULTIVERSX_CHAINS, MULTIVERSX_SIGNING_METHODS } from '@/data/MultiversxData'
import { NEAR_CHAINS, NEAR_SIGNING_METHODS } from '@/data/NEARData'
import { POLKADOT_CHAINS, POLKADOT_SIGNING_METHODS } from '@/data/PolkadotData'
import { SOLANA_CHAINS, SOLANA_SIGNING_METHODS } from '@/data/SolanaData'
import { TEZOS_CHAINS, TEZOS_SIGNING_METHODS } from '@/data/TezosData'
import { TRON_CHAINS, TRON_SIGNING_METHODS } from '@/data/TronData'
import ChainDataMini from '@/components/ChainDataMini'
import ChainAddressMini from '@/components/ChainAddressMini'
import { getChainData } from '@/data/chainsUtil'
import RequestModal from '../components/RequestModal'
import ChainSmartAddressMini from '@/components/ChainSmartAddressMini'
import { useSnapshot } from 'valtio'
import SettingsStore from '@/store/SettingsStore'
import usePriorityAccounts from '@/hooks/usePriorityAccounts'
import useSmartAccounts from '@/hooks/useSmartAccounts'
import { EIP5792_METHODS } from '@/data/EIP5792Data'
import { getWalletCapabilities } from '@/utils/EIP5792WalletUtil'
import { bip122Addresses, bip122Wallet } from '@/utils/Bip122WalletUtil'
import {
  BIP122_CHAINS,
  BIP122_EVENTS,
  BIP122_SIGNING_METHODS,
  IBip122ChainId
} from '@/data/Bip122Data'
import { EIP7715_METHOD } from '@/data/EIP7715Data'
import { useRouter } from 'next/router'

const StyledText = styled(Text, {
  fontWeight: 400
} as any)

const StyledSpan = styled('span', {
  fontWeight: 400
} as any)

export default function SessionProposalModal() {
  const { smartAccountEnabled } = useSnapshot(SettingsStore.state)
  // Get proposal data and wallet address from store
  const data = useSnapshot(ModalStore.state)
  const proposal = data?.data?.proposal as SignClientTypes.EventArguments['session_proposal']
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)
  const { getAvailableSmartAccountsOnNamespaceChains } = useSmartAccounts()

  const { query } = useRouter()

  const addressesToApprove = Number(query.addressesToApprove) || null

  const supportedNamespaces = useMemo(() => {
    // eip155
    const eip155Chains = Object.keys(EIP155_CHAINS)
    const eip155Methods = Object.values(EIP155_SIGNING_METHODS)

    //eip5792
    const eip5792Chains = Object.keys(EIP155_CHAINS)
    const eip5792Methods = Object.values(EIP5792_METHODS)

    //eip7715
    const eip7715Chains = Object.keys(EIP155_CHAINS)
    const eip7715Methods = Object.values(EIP7715_METHOD)

    // cosmos
    const cosmosChains = Object.keys(COSMOS_MAINNET_CHAINS)
    const cosmosMethods = Object.values(COSMOS_SIGNING_METHODS)

    // Kadena
    const kadenaChains = Object.keys(KADENA_CHAINS)
    const kadenaMethods = Object.values(KADENA_SIGNING_METHODS)

    // multiversx
    const multiversxChains = Object.keys(MULTIVERSX_CHAINS)
    const multiversxMethods = Object.values(MULTIVERSX_SIGNING_METHODS)

    // near
    const nearChains = Object.keys(NEAR_CHAINS)
    const nearMethods = Object.values(NEAR_SIGNING_METHODS)

    // polkadot
    const polkadotChains = Object.keys(POLKADOT_CHAINS)
    const polkadotMethods = Object.values(POLKADOT_SIGNING_METHODS)

    // solana
    const solanaChains = Object.keys(SOLANA_CHAINS)
    const solanaMethods = Object.values(SOLANA_SIGNING_METHODS)

    // tezos
    const tezosChains = Object.keys(TEZOS_CHAINS)
    const tezosMethods = Object.values(TEZOS_SIGNING_METHODS)

    // tron
    const tronChains = Object.keys(TRON_CHAINS)
    const tronMethods = Object.values(TRON_SIGNING_METHODS)

    // bip122
    const bip122Chains = Object.keys(BIP122_CHAINS)
    const bip122Methods = Object.values(BIP122_SIGNING_METHODS)
    const bip122Events = Object.values(BIP122_EVENTS)

    return {
      eip155: {
        chains: eip155Chains,
        methods: eip155Methods.concat(eip5792Methods).concat(eip7715Methods),
        events: ['accountsChanged', 'chainChanged'],
        accounts: eip155Chains
          .map(chain =>
            eip155Addresses
              .map(account => `${chain}:${account}`)
              .slice(0, addressesToApprove ?? eip155Addresses.length)
          )
          .flat()
      },
      cosmos: {
        chains: cosmosChains,
        methods: cosmosMethods,
        events: [],
        accounts: cosmosChains
          .map(chain => cosmosAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      kadena: {
        chains: kadenaChains,
        methods: kadenaMethods,
        events: [],
        accounts: kadenaChains
          .map(chain => kadenaAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      mvx: {
        chains: multiversxChains,
        methods: multiversxMethods,
        events: [],
        accounts: multiversxChains
          .map(chain => multiversxAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      near: {
        chains: nearChains,
        methods: nearMethods,
        events: ['accountsChanged', 'chainChanged'],
        accounts: nearChains
          .map(chain => nearAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      polkadot: {
        chains: polkadotChains,
        methods: polkadotMethods,
        events: [],
        accounts: polkadotChains
          .map(chain => polkadotAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      solana: {
        chains: solanaChains,
        methods: solanaMethods,
        events: [],
        accounts: solanaChains
          .map(chain => solanaAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      tezos: {
        chains: tezosChains,
        methods: tezosMethods,
        events: [],
        accounts: tezosChains
          .map(chain => tezosAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      tron: {
        chains: tronChains,
        methods: tronMethods,
        events: [],
        accounts: tronChains
          .map(chain => tronAddresses.map(address => `${chain}:${address}`))
          .flat()
      },
      bip122: {
        chains: bip122Chains,
        methods: bip122Methods,
        events: bip122Events,
        accounts: bip122Addresses
      }
    }
  }, [addressesToApprove])
  console.log('supportedNamespaces', supportedNamespaces, eip155Addresses)

  const requestedChains = useMemo(() => {
    if (!proposal) return []
    const required = []
    for (const [key, values] of Object.entries(proposal.params.requiredNamespaces)) {
      const chains = key.includes(':') ? key : values.chains
      required.push(chains)
    }

    const optional = []
    for (const [key, values] of Object.entries(proposal.params.optionalNamespaces)) {
      const chains = key.includes(':') ? key : values.chains
      optional.push(chains)
    }
    console.log('requestedChains', [...new Set([...required.flat(), ...optional.flat()])])

    return [...new Set([...required.flat(), ...optional.flat()])]
  }, [proposal])

  // the chains that are supported by the wallet from the proposal
  const supportedChains = useMemo(
    () =>
      requestedChains
        .map(chain => {
          const chainData = getChainData(chain!)

          if (!chainData) return null

          return chainData
        })
        .filter(chain => chain), // removes null values
    [requestedChains]
  )

  // get required chains that are not supported by the wallet
  const notSupportedChains = useMemo(() => {
    if (!proposal) return []
    const required = []
    for (const [key, values] of Object.entries(proposal.params.requiredNamespaces)) {
      const chains = key.includes(':') ? key : values.chains
      required.push(chains)
    }
    return required
      .flat()
      .filter(
        chain =>
          !supportedChains
            .map(supportedChain => `${supportedChain?.namespace}:${supportedChain?.chainId}`)
            .includes(chain!)
      )
  }, [proposal, supportedChains])
  console.log('notSupportedChains', { notSupportedChains, supportedChains })
  const getAddress = useCallback((namespace?: string) => {
    console.log('getAddress', namespace)
    if (!namespace) return 'N/A'
    switch (namespace) {
      case 'eip155':
        return eip155Addresses[0]
      case 'cosmos':
        return cosmosAddresses[0]
      case 'kadena':
        return kadenaAddresses[0]
      case 'mvx':
        return multiversxAddresses[0]
      case 'near':
        return nearAddresses[0]
      case 'polkadot':
        return polkadotAddresses[0]
      case 'solana':
        return solanaAddresses[0]
      case 'tezos':
        return tezosAddresses[0]
      case 'tron':
        return tronAddresses[0]
      case 'bip122':
        return bip122Addresses[0]
    }
  }, [])

  const namespaces = useMemo(() => {
    try {
      // the builder throws an exception if required namespaces are not supported
      const approvedNamespaces = buildApprovedNamespaces({
        proposal: proposal.params,
        supportedNamespaces
      })

      return approvedNamespaces
    } catch (e) {
      console.error('Error building approved namespaces', e)
    }
  }, [proposal.params, supportedNamespaces])

  const reorderedEip155Accounts = usePriorityAccounts({ namespaces })
  console.log('Reordered accounts', { reorderedEip155Accounts })

  // Hanlde approve action, construct session namespace
  const onApprove = useCallback(async () => {
    console.log('onApprove', { proposal, namespaces })
    try {
      if (proposal && namespaces) {
        setIsLoadingApprove(true)
        if (reorderedEip155Accounts.length > 0) {
          // we should append the smart accounts to the available eip155 accounts
          namespaces.eip155.accounts = reorderedEip155Accounts.concat(namespaces.eip155.accounts)
        }
        //get capabilities for all reorderedEip155Accounts in wallet
        const capabilities = getWalletCapabilities(reorderedEip155Accounts)
        let sessionProperties = {
          capabilities: JSON.stringify(capabilities)
        } as any
        if (namespaces.bip122) {
          const bip122Chain = namespaces.bip122.chains?.[0]!
          sessionProperties.bip122_getAccountAddresses = JSON.stringify({
            payment: Array.from(bip122Wallet.getAddresses(bip122Chain as IBip122ChainId).values()),
            ordinal: Array.from(
              bip122Wallet.getAddresses(bip122Chain as IBip122ChainId, ['ordinal']).values()
            )
          })
        }
        console.log('sessionProperties', sessionProperties)
        await walletkit.approveSession({
          id: proposal.id,
          namespaces,
          sessionProperties
        })
        SettingsStore.setSessions(Object.values(walletkit.getActiveSessions()))
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [namespaces, proposal, reorderedEip155Accounts])

  // Hanlde reject action
  // eslint-disable-next-line react-hooks/rules-of-hooks
  const onReject = useCallback(async () => {
    if (proposal) {
      try {
        setIsLoadingReject(true)
        await new Promise(resolve => setTimeout(resolve, 1000))
        await walletkit.rejectSession({
          id: proposal.id,
          reason: getSdkError('USER_REJECTED_METHODS')
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
    }
    setIsLoadingReject(false)
    ModalStore.close()
  }, [proposal])
  console.log('notSupportedChains', notSupportedChains)
  console.log('supportedChains', supportedChains)
  return (
    <RequestModal
      metadata={proposal.params.proposer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
      infoBoxCondition={notSupportedChains.length > 0 || supportedChains.length === 0}
      disableApprove={notSupportedChains.length > 0 || supportedChains.length === 0}
      infoBoxText={`The session cannot be approved because the wallet does not the support some or all of the proposed chains. Please inspect the console for more information.`}
    >
      <Row>
        <Col>
          <StyledText h4>Requested permissions</StyledText>
        </Col>
      </Row>
      <Row>
        <Col>
          <DoneIcon style={{ verticalAlign: 'bottom' }} />{' '}
          <StyledSpan>View your balance and activity</StyledSpan>
        </Col>
      </Row>
      <Row>
        <Col>
          <DoneIcon style={{ verticalAlign: 'bottom' }} />{' '}
          <StyledSpan>Send approval requests</StyledSpan>
        </Col>
      </Row>
      <Row>
        <Col style={{ color: 'gray' }}>
          <CloseIcon style={{ verticalAlign: 'bottom' }} />
          <StyledSpan>Move funds without permission</StyledSpan>
        </Col>
      </Row>
      <Grid.Container style={{ marginBottom: '10px', marginTop: '10px' }} justify={'space-between'}>
        <Grid>
          <Row style={{ color: 'GrayText' }}>Accounts</Row>
          {(supportedChains.length > 0 &&
            supportedChains.map((chain, i) => {
              return (
                <Row key={i}>
                  <ChainAddressMini key={i} address={getAddress(chain?.namespace) || 'test'} />
                </Row>
              )
            })) || <Row>Non available</Row>}

          <Row style={{ color: 'GrayText' }}>Smart Accounts</Row>
          {smartAccountEnabled &&
            namespaces &&
            getAvailableSmartAccountsOnNamespaceChains(namespaces?.eip155?.chains).map(
              (account, i) => {
                if (!account) {
                  return <></>
                }
                return (
                  <Row key={i}>
                    <ChainSmartAddressMini account={account} />
                  </Row>
                )
              }
            )}
        </Grid>
        <Grid>
          <Row style={{ color: 'GrayText' }} justify="flex-end">
            Chains
          </Row>
          {(supportedChains.length > 0 &&
            supportedChains.map((chain, i) => {
              console.log('chain', chain)
              if (!chain) {
                return <></>
              }

              return (
                <Row key={i}>
                  <ChainDataMini key={i} chainId={`${chain?.namespace}:${chain?.chainId}`} />
                </Row>
              )
            })) || <Row>Non available</Row>}
          <Row style={{ color: 'GrayText' }} justify="flex-end">
            Chains
          </Row>
          {smartAccountEnabled &&
            namespaces &&
            getAvailableSmartAccountsOnNamespaceChains(namespaces?.eip155?.chains).map(
              ({ chain }, i) => {
                if (!chain) {
                  return <></>
                }
                return (
                  <Row key={i} style={{ marginTop: '24px' }}>
                    <ChainDataMini key={i} chainId={`eip155:${chain.id}`} />
                  </Row>
                )
              }
            )}
        </Grid>
      </Grid.Container>
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSendCallsModal.tsx">
import { useCallback, useState } from 'react'
import { Divider, Text } from '@nextui-org/react'
import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { approveEIP5792Request, rejectEIP5792Request } from '@/utils/EIP5792RequestHandlerUtils'

export default function SessionSendCallsModal() {
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession

  const topic = requestEvent?.topic
  const params = requestEvent?.params
  const chainId = params?.chainId
  const request = params?.request
  const transaction = request?.params[0].calls

  // Handle approve action
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent && topic) {
        setIsLoadingApprove(true)
        console.log('Calls approved.')
        const response = await approveEIP5792Request(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent && topic) {
      setIsLoadingReject(true)
      const response = rejectEIP5792Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return request && requestSession ? (
    <RequestModal
      intention="sign a transaction"
      metadata={requestSession?.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequestDataCard data={transaction} />
      <Divider y={1} />
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession?.relay.protocol} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  ) : (
    <Text>Request not found</Text>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSendTransactionBip122Modal.tsx">
import { useCallback, useState } from 'react'
import { Divider, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { approveBip122Request, rejectBip122Request } from '@/utils/Bip122RequestHandlerUtil'
import { JsonRpcResponse } from '@json-rpc-tools/utils'

export default function SessionSendTransactionBip122Modal() {
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession

  const topic = requestEvent?.topic
  const params = requestEvent?.params
  const chainId = params?.chainId
  const request = params?.request
  const transaction = request?.params

  // Handle reject action
  const onReject = useCallback(
    async (rejection?: JsonRpcResponse) => {
      if (requestEvent && topic) {
        setIsLoadingReject(true)
        const response = rejection || rejectBip122Request(requestEvent)
        try {
          await walletkit.respondSessionRequest({
            topic,
            response
          })
        } catch (e) {
          setIsLoadingReject(false)
          styledToast((e as Error).message, 'error')
          return
        }
        setIsLoadingReject(false)
        ModalStore.close()
      }
    },
    [requestEvent, topic]
  )
  // Handle approve action
  const onApprove = useCallback(async () => {
    if (requestEvent && topic) {
      setIsLoadingApprove(true)
      try {
        const response = await approveBip122Request(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingApprove(false)
        styledToast((e as Error).message, 'error')
        onReject(rejectBip122Request(requestEvent, (e as Error).message))
      }
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [onReject, requestEvent, topic])

  return request && requestSession ? (
    <RequestModal
      intention="sign a transaction"
      metadata={requestSession?.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequestDataCard data={transaction} />
      <Divider y={1} />
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession?.relay.protocol} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  ) : (
    <Text>Request not found</Text>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSendTransactionModal.tsx">
import { useCallback, useEffect, useState } from 'react'
import { Card, Divider, Loading, Text } from '@nextui-org/react'
import { approveEIP155Request, rejectEIP155Request } from '@/utils/EIP155RequestHandlerUtil'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import { ChainAbstractionService, Transaction } from '@/utils/ChainAbstractionService'
import ModalStore from '@/store/ModalStore'
import SettingsStore from '@/store/SettingsStore'

import RequestDataCard from '@/components/RequestDataCard'
import RequestDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import RequestModal from '@/components/RequestModal'
import MultibridgeRequestModal from '@/components/MultibridgeRequestModal'

// Types for props used in individual components
type Session = {
  peer: {
    metadata: { name: string; description: string; url: string; icons: string[] }
  }
  relay: { protocol: string }
}

export default function SessionSendTransactionModal() {
  const [isLoadingApprove, setIsLoadingApprove] = useState<boolean>(false)
  const [isLoadingReject, setIsLoadingReject] = useState<boolean>(false)
  const [isReadyForRender, setIsReadyForRender] = useState<boolean>(false)
  const [requiresMultiChain, setRequiresMultiChain] = useState<boolean>(false)
  const [routeTransactions, setRouteTransactions] = useState<Transaction[]>([])
  const [orchestrationId, setOrchestrationId] = useState<string | null>(null)

  // Extract request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const { topic, params } = requestEvent || {}
  const { chainId, request } = params || {}
  const transaction = request?.params[0]

  // Check for multi-chain requirement and handle routing
  useEffect(() => {
    const initializeMultiChainCheck = async (): Promise<void> => {
      setIsReadyForRender(false)

      if (!chainId) {
        console.error('Chain ID is not available')
        setIsReadyForRender(true)
        return
      }

      if (!SettingsStore.state.chainAbstractionEnabled || !request) {
        setIsReadyForRender(true)
        return
      }

      try {
        const caService = new ChainAbstractionService()
        const isMultiChain = await checkMultiChainRequirement(caService, request, chainId)
        if (isMultiChain) {
          await setupRouteTransactions(caService, request, chainId)
        }
      } catch (error) {
        console.error('Error during multi-chain check:', error)
        styledToast('Unable to check multibridge availability', 'error')
      } finally {
        setIsReadyForRender(true)
      }
    }

    initializeMultiChainCheck()
  }, [request, chainId])

  const checkMultiChainRequirement = async (
    caService: ChainAbstractionService,
    request: { params: [{ from: string; to: string; data: string }] },
    chainId: string
  ): Promise<boolean> => {
    const { data, from, to } = request.params[0]
    const isMultiChain = await caService.checkTransaction({
      from,
      to,
      value: '0',
      gas: '0',
      gasPrice: '0',
      data,
      nonce: '0',
      maxFeePerGas: '0',
      maxPriorityFeePerGas: '0',
      chainId
    })
    setRequiresMultiChain(isMultiChain)
    return isMultiChain
  }

  const setupRouteTransactions = async (
    caService: ChainAbstractionService,
    request: { params: [{ from: string; to: string; data: string }] },
    chainId: string
  ): Promise<void> => {
    const { data, from, to } = request.params[0]
    const routeResult = await caService.routeTransaction({
      from,
      to,
      value: '0',
      gas: '0',
      gasPrice: '0',
      data,
      nonce: '0',
      maxFeePerGas: '0',
      maxPriorityFeePerGas: '0',
      chainId
    })
    setRouteTransactions(routeResult.transactions)
    setOrchestrationId(routeResult.orchestrationId)
  }

  const handleApproval = useCallback(async (): Promise<void> => {
    if (!requestEvent || !topic) return
    setIsLoadingApprove(true)
    try {
      const response = await approveEIP155Request(requestEvent)
      await walletkit.respondSessionRequest({ topic, response })
      ModalStore.close()
    } catch (error) {
      styledToast((error as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
    }
  }, [requestEvent, topic])

  const handleRejection = useCallback(async (): Promise<void> => {
    if (!requestEvent || !topic) return
    setIsLoadingReject(true)
    try {
      const response = rejectEIP155Request(requestEvent)
      await walletkit.respondSessionRequest({ topic, response })
      ModalStore.close()
    } catch (error) {
      styledToast((error as Error).message, 'error')
    } finally {
      setIsLoadingReject(false)
    }
  }, [requestEvent, topic])

  if (!request || !requestSession) return <Text>Request not found</Text>
  if (!isReadyForRender) return <LoadingComponent />

  return !requiresMultiChain || orchestrationId == null ? (
    <SingleChainModal
      session={requestSession}
      transaction={transaction}
      chainId={chainId || ''}
      method={params?.request?.method || ''}
      onApprove={handleApproval}
      onReject={handleRejection}
      loadingApprove={isLoadingApprove}
      loadingReject={isLoadingReject}
    />
  ) : (
    <MultiChainModal
      transactions={routeTransactions}
      orchestrationId={orchestrationId}
      onReject={handleRejection}
      loadingReject={isLoadingReject}
    />
  )
}

// Extracted Components for Loading, Single-Chain, and Multi-Chain Modals

const LoadingComponent = (): JSX.Element => (
  <Card>
    <Card.Body css={{ paddingTop: '$20', paddingBottom: '$20' }}>
      <Loading type="points" />
    </Card.Body>
  </Card>
)

type SingleChainModalProps = {
  session: Session
  transaction: any
  chainId: string
  method: string
  onApprove: () => Promise<void>
  onReject: () => Promise<void>
  loadingApprove: boolean
  loadingReject: boolean
}

const SingleChainModal = ({
  session,
  transaction,
  chainId,
  method,
  onApprove,
  onReject,
  loadingApprove,
  loadingReject
}: SingleChainModalProps): JSX.Element => (
  <RequestModal
    intention="sign a transaction"
    metadata={session.peer.metadata}
    onApprove={onApprove}
    onReject={onReject}
    approveLoader={{ active: loadingApprove }}
    rejectLoader={{ active: loadingReject }}
  >
    <RequestDataCard data={transaction} />
    <Divider y={1} />
    <RequestDetailsCard chains={[chainId]} protocol={session.relay.protocol} />
    <Divider y={1} />
    <RequestMethodCard methods={[method]} />
  </RequestModal>
)

type MultiChainModalProps = {
  transactions: Transaction[]
  orchestrationId: string
  onReject: () => Promise<void>
  loadingReject: boolean
}

const MultiChainModal = ({
  transactions,
  orchestrationId,
  onReject,
  loadingReject
}: MultiChainModalProps): JSX.Element => (
  <MultibridgeRequestModal
    transactions={transactions}
    orchestrationId={orchestrationId}
    onReject={onReject}
    rejectLoader={{ active: loadingReject }}
  />
)
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignBip122Modal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Col, Divider, Row, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequestDetailsCard from '@/components/RequestDetalilsCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'
import { approveBip122Request, rejectBip122Request } from '@/utils/Bip122RequestHandlerUtil'

export default function SessionSignBip122Modal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  const { topic, params } = requestEvent
  const { request, chainId } = params
  const message = request.params.message
  const account = request.params.account
  const address = request.params.address
  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    if (requestEvent) {
      const response = await approveBip122Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingApprove(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectBip122Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign a BTC message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <Divider y={1} />
      {message && (
        <>
          <Row>
            <Col>
              <Text h5>Message</Text>
              <code color="$gray400">{message}</code>
            </Col>
          </Row>
          <Divider y={1} />
          <Row>
            <Col>
              <Text h5>To sign with address</Text>
              <Text color="$gray400">{address || account}</Text>
            </Col>
          </Row>
        </>
      )}
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignCosmosModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'
import { useCallback, useState } from 'react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { approveCosmosRequest, rejectCosmosRequest } from '@/utils/CosmosRequestHandler'
import { styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'

export default function SessionSignCosmosModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { chainId, request } = params

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveCosmosRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectCosmosRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign Cosmos transaction"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <RequestDataCard data={params} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignKadenaModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Col, Divider, Row, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequestDetailsCard from '@/components/RequestDetalilsCard'
import ModalStore from '@/store/ModalStore'
import { convertHexToUtf8, styledToast } from '@/utils/HelperUtil'
import { approveKadenaRequest, rejectKadenaRequest } from '@/utils/KadenaRequestHandlerUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'

export default function SessionSignKadenaModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  // Get message, convert it to UTF8 string if it is valid hex
  const message = convertHexToUtf8(request.params.message)

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveKadenaRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
        setIsLoadingApprove(false)
        ModalStore.close()
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectKadenaRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign a Kadena message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequestDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      {message && (
        <>
          <Row>
            <Col>
              <Text h5>Message</Text>
              <Text color="$gray400">{message}</Text>
            </Col>
          </Row>
          <Divider y={1} />
        </>
      )}
      <RequestDataCard data={params} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Col, Divider, Row, Text } from '@nextui-org/react'
import { useCallback, useState } from 'react'

import RequesDetailsCard from '@/components/RequestDetalilsCard'
import ModalStore from '@/store/ModalStore'
import { approveEIP155Request, rejectEIP155Request } from '@/utils/EIP155RequestHandlerUtil'
import { getSignParamsMessage, styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
export default function SessionSignModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  // Get message, convert it to UTF8 string if it is valid hex
  const message = getSignParamsMessage(request.params)

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveEIP155Request(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectEIP155Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="request a signature"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <Row>
        <Col>
          <Text h5>Message</Text>
          <Text color="$gray400" data-testid="request-message-text">
            {message}
          </Text>
        </Col>
      </Row>
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignMultiversxModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'
import { useCallback, useState } from 'react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import {
  approveMultiversxRequest,
  rejectMultiversxRequest
} from '@/utils/MultiversxRequestHandlerUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'

export default function SessionSignMultiversxModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveMultiversxRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectMultiversxRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign a MultiversX message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <RequestDataCard data={params} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignNearModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { transactions } from 'near-api-js'
import { Divider, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequestDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { approveNearRequest, rejectNearRequest } from '@/utils/NearRequestHandlerUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import { NEAR_SIGNING_METHODS } from '@/data/NEARData'
import { styledToast } from '@/utils/HelperUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'

export default function SessionSignNearModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  const formatTransaction = (transaction: Uint8Array) => {
    const tx = transactions.Transaction.decode(Buffer.from(transaction))

    return {
      signerId: tx.signerId,
      receiverId: tx.receiverId,
      publicKey: tx.publicKey.toString(),
      actions: tx.actions.map(action => {
        switch (action.enum) {
          case 'createAccount': {
            return {
              type: 'CreateAccount',
              params: action.createAccount
            }
          }
          case 'deployContract': {
            return {
              type: 'DeployContract',
              params: {
                ...action.deployContract,
                args: Buffer.from(action.deployContract.code).toString()
              }
            }
          }
          case 'functionCall': {
            return {
              type: 'FunctionCall',
              params: {
                ...action.functionCall,
                args: JSON.parse(Buffer.from(action.functionCall.args).toString())
              }
            }
          }
          case 'transfer': {
            return {
              type: 'Transfer',
              params: action.transfer
            }
          }
          case 'stake': {
            return {
              type: 'Stake',
              params: {
                ...action.stake,
                publicKey: action.stake.publicKey.toString()
              }
            }
          }
          case 'addKey': {
            return {
              type: 'AddKey',
              params: {
                ...action.addKey,
                publicKey: action.addKey.publicKey.toString()
              }
            }
          }
          case 'deleteKey': {
            return {
              type: 'DeleteKey',
              params: {
                ...action.deleteKey,
                publicKey: action.deleteKey.publicKey.toString()
              }
            }
          }
          case 'deleteAccount': {
            return {
              type: 'DeleteAccount',
              params: action.deleteAccount
            }
          }
          default:
            return {
              type: action.enum,
              params: {}
            }
        }
      })
    }
  }

  const formatParams = () => {
    switch (params.request.method) {
      case NEAR_SIGNING_METHODS.NEAR_SIGN_TRANSACTION:
        return {
          ...params,
          request: {
            ...params.request,
            params: {
              ...params.request.params,
              transaction: formatTransaction(params.request.params.transaction)
            }
          }
        }
      case NEAR_SIGNING_METHODS.NEAR_SIGN_TRANSACTIONS:
        return {
          ...params,
          request: {
            ...params.request,
            params: {
              ...params.request.params,
              transactions: params.request.params.transactions.map(formatTransaction)
            }
          }
        }
      default:
        return params
    }
  }

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveNearRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectNearRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign NEAR message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequestDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <RequestDataCard data={formatParams()} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignPolkadotModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { approvePolkadotRequest, rejectPolkadotRequest } from '@/utils/PolkadotRequestHandlerUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'

export default function SessionSignPolkadotModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approvePolkadotRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectPolkadotRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign a Polkadot message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <RequestDataCard data={params} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignSolanaModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { approveSolanaRequest, rejectSolanaRequest } from '@/utils/SolanaRequestHandlerUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'

export default function SessionSignSolanaModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveSolanaRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectSolanaRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign a Solana message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <RequestDataCard data={params} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignTezosModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { approveTezosRequest, rejectTezosRequest } from '@/utils/TezosRequestHandlerUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'

export default function SessionSignTezosModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveTezosRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectTezosRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign a Tezos message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <RequestDataCard data={params} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignTronModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { styledToast } from '@/utils/HelperUtil'
import { approveTronRequest, rejectTronRequest } from '@/utils/TronRequestHandlerUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'

export default function SessionSignTronModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params

  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveTronRequest(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectTronRequest(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  return (
    <RequestModal
      intention="sign a Tron message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      <RequestDataCard data={params} />
      <Divider y={1} />
      <RequestMethodCard methods={[request.method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionSignTypedDataModal.tsx">
/* eslint-disable react-hooks/rules-of-hooks */
import { Divider, Text } from '@nextui-org/react'

import RequestDataCard from '@/components/RequestDataCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import ModalStore from '@/store/ModalStore'
import { approveEIP155Request, rejectEIP155Request } from '@/utils/EIP155RequestHandlerUtil'
import { getSignTypedDataParamsData, styledToast } from '@/utils/HelperUtil'
import { walletkit } from '@/utils/WalletConnectUtil'
import RequestModal from '../components/RequestModal'
import { useCallback, useState } from 'react'
import PermissionDetailsCard from '@/components/PermissionDetailsCard'

export default function SessionSignTypedDataModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession
  const [isLoadingApprove, setIsLoadingApprove] = useState(false)
  const [isLoadingReject, setIsLoadingReject] = useState(false)

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { request, chainId } = params
  let method = request.method
  // Get data
  const data = getSignTypedDataParamsData(request.params)

  const isPermissionRequest = data?.domain?.name === 'eth_getPermissions_v1'
  let permissionScope = []
  if (isPermissionRequest) {
    permissionScope = data?.message?.scope || []
    method = 'eth_getPermissions_v1'
    console.log({ permissionScope })
  }
  // Handle approve action (logic varies based on request method)
  const onApprove = useCallback(async () => {
    try {
      if (requestEvent) {
        setIsLoadingApprove(true)
        const response = await approveEIP155Request(requestEvent)
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      }
    } catch (e) {
      styledToast((e as Error).message, 'error')
    } finally {
      setIsLoadingApprove(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])

  // Handle reject action
  const onReject = useCallback(async () => {
    if (requestEvent) {
      setIsLoadingReject(true)
      const response = rejectEIP155Request(requestEvent)
      try {
        await walletkit.respondSessionRequest({
          topic,
          response
        })
      } catch (e) {
        setIsLoadingReject(false)
        styledToast((e as Error).message, 'error')
        return
      }
      setIsLoadingReject(false)
      ModalStore.close()
    }
  }, [requestEvent, topic])
  return (
    <RequestModal
      intention="sign a message"
      metadata={requestSession.peer.metadata}
      onApprove={onApprove}
      onReject={onReject}
      approveLoader={{ active: isLoadingApprove }}
      rejectLoader={{ active: isLoadingReject }}
    >
      <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />
      <Divider y={1} />
      {isPermissionRequest && permissionScope.length > 0 ? (
        <PermissionDetailsCard scope={permissionScope} />
      ) : (
        <RequestDataCard data={data} />
      )}
      <Divider y={1} />
      <RequestMethodCard methods={[method]} />
    </RequestModal>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/SessionUnsuportedMethodModal.tsx">
import { Button, Divider, Modal, Text } from '@nextui-org/react'
import { Fragment } from 'react'

import ProjectInfoCard from '@/components/ProjectInfoCard'
import RequesDetailsCard from '@/components/RequestDetalilsCard'
import RequestMethodCard from '@/components/RequestMethodCard'
import RequestModalContainer from '@/components/RequestModalContainer'
import ModalStore from '@/store/ModalStore'

export default function SessionUnsuportedMethodModal() {
  // Get request and wallet data from store
  const requestEvent = ModalStore.state.data?.requestEvent
  const requestSession = ModalStore.state.data?.requestSession

  // Ensure request and wallet are defined
  if (!requestEvent || !requestSession) {
    return <Text>Missing request data</Text>
  }

  // Get required request data
  const { topic, params } = requestEvent
  const { chainId, request } = params

  return (
    <Fragment>
      <RequestModalContainer title="Unsuported Method">
        <ProjectInfoCard metadata={requestSession.peer.metadata} />

        <Divider y={1} />

        <RequesDetailsCard chains={[chainId ?? '']} protocol={requestSession.relay.protocol} />

        <Divider y={1} />

        <RequestMethodCard methods={[request.method]} />
      </RequestModalContainer>
      <Modal.Footer>
        <Button auto flat color="error" onClick={ModalStore.close}>
          Close
        </Button>
      </Modal.Footer>
    </Fragment>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/src/views/TheatPrompt.tsx">
import { Col, Divider, Link, Row, Text, styled } from '@nextui-org/react'
import { CoreTypes } from '@walletconnect/types'
import NewReleasesIcon from '@mui/icons-material/NewReleases'

import RequestModalContainer from '@/components/RequestModalContainer'

interface IProps {
  metadata: CoreTypes.Metadata
  onApprove: () => void
  onReject: () => void
}

const StyledLink = styled('span', {
  color: '#697177'
} as any)

const StyledProceedButton = styled('p', {
  margin: '10px auto',
  padding: '10px',
  color: '$error',
  cursor: 'pointer'
} as any)

const StyledCloseButton = styled('p', {
  margin: 'auto',
  padding: '10px',
  border: '1px solid $error',
  borderRadius: '30px'
} as any)

export default function ThreatPrompt({ metadata, onApprove, onReject }: IProps) {
  const { icons, name, url } = metadata

  return (
    <RequestModalContainer title="">
      <div style={{ textAlign: 'center', padding: '20px' }}>
        <Row>
          <Col>
            <NewReleasesIcon sx={{ fontSize: '55px', color: '$error' }} color="error" />
          </Col>
        </Row>
        <Row align="center">
          <Col>
            <Text h3>Website flagged</Text>
          </Col>
        </Row>
        <Row align="center">
          <Col>
            <Link
              style={{ verticalAlign: 'middle' }}
              href={url}
              data-testid="session-info-card-url"
            >
              <StyledLink>{url}</StyledLink>
            </Link>
          </Col>
        </Row>
        <div style={{ textAlign: 'center' }}>
          <Divider y={1} />
          <Text>
            This website you`re trying to connect is flagged as malicious by multiple security
            providers. Approving may lead to loss of funds.
          </Text>
          <Row>
            <StyledProceedButton color="$error" onClick={onApprove}>
              Proceed anyway
            </StyledProceedButton>
          </Row>
          <Row>
            <Col span={10} style={{ margin: 'auto', cursor: 'pointer' }} onClick={onReject}>
              <StyledCloseButton>Close</StyledCloseButton>
            </Col>
          </Row>
        </div>
      </div>
    </RequestModalContainer>
  )
}
</file>

<file path="advanced/wallets/react-wallet-v2/.env.local.example">
NEXT_PUBLIC_PROJECT_ID=
NEXT_PUBLIC_RELAY_URL=wss://relay.walletconnect.com
NEXT_PUBLIC_PIMLICO_KEY=
NEXT_PUBLIC_ZERODEV_PROJECT_ID=
#if using local AA infra then set these values
NEXT_PUBLIC_LOCAL_BUNDLER_URL=
NEXT_PUBLIC_LOCAL_PAYMASTER_URL=
NEXT_PUBLIC_LOCAL_CLIENT_URL=

#only for testing
NEXT_PUBLIC_SOCKET_KEY=
</file>

<file path="advanced/wallets/react-wallet-v2/.eslintrc.json">
{
  "extends": ["next/core-web-vitals","prettier"],
  "ignorePatterns": ["next.config.js"],
  "overrides": [
		{
			"extends": ["plugin:package-json/recommended"],
			"files": ["package.json"],
			"parser": "jsonc-eslint-parser",
			"plugins": ["package-json"]
		}
	]
}
</file>

<file path="advanced/wallets/react-wallet-v2/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

.DS_Store

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel
</file>

<file path="advanced/wallets/react-wallet-v2/.prettierignore">
.changeset
coverage
.idea
.next
node_modules
</file>

<file path="advanced/wallets/react-wallet-v2/.prettierrc.json">
{
  "arrowParens": "avoid",
  "parser": "typescript",
  "printWidth": 100,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "none",
  "semi": false
}
</file>

<file path="advanced/wallets/react-wallet-v2/docker-compose.yaml">
services:
  anvil:
    image: ghcr.io/foundry-rs/foundry:nightly-f6208d8db68f9acbe4ff8cd76958309efb61ea0b
    ports: ["8545:8545"]
    entrypoint: [ "anvil","--chain-id", "31337", "--fork-url", "https://gateway.tenderly.co/public/sepolia", "--host", "0.0.0.0", "--block-time", "0.1", "--gas-price", "1", "--silent",]
    platform: linux/amd64
 
  mock-paymaster:
    image: ghcr.io/pimlicolabs/mock-verifying-paymaster:main
    ports: ["3000:3000"]
    environment:
      - ALTO_RPC=http://alto:4337
      - ANVIL_RPC=http://anvil:8545
 
  alto:
    image: ghcr.io/pimlicolabs/mock-alto-bundler:main
    ports: ["4337:4337"]
    environment:
      - ANVIL_RPC=http://anvil:8545
      - SKIP_DEPLOYMENTS=true
</file>

<file path="advanced/wallets/react-wallet-v2/next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/pages/api-reference/config/typescript for more information.
</file>

<file path="advanced/wallets/react-wallet-v2/next.config.js">
module.exports = {
  reactStrictMode: true,
  webpack(config) {
    config.resolve.fallback = {
      ...config.resolve.fallback,
      fs: false
    }
    // needed for tiny-secp256k1 package
    config.experiments.asyncWebAssembly = true
    config.module.rules.push({
      test: /\.wasm$/,
      type: 'webassembly/async'
    })
    return config
  },
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          {
            key: 'Access-Control-Allow-Origin',
            value: '*'
          },
          {
            key: 'Access-Control-Allow-Methods',
            value: 'GET, POST, PUT, DELETE, OPTIONS'
          },
          {
            key: 'Access-Control-Allow-Headers',
            value: 'Content-Type, Authorization'
          }
        ]
      }
    ]
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/package.json">
{
  "name": "react-wallet-v2",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3001",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prettier": "prettier --check '**/*.{js,ts,jsx,tsx}'",
    "prettier:write": "prettier --write '**/*.{js,ts,jsx,tsx}'"
  },
  "dependencies": {
    "@cosmjs/amino": "0.32.3",
    "@cosmjs/encoding": "0.32.3",
    "@cosmjs/proto-signing": "0.32.3",
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "@json-rpc-tools/utils": "1.7.6",
    "@kadena/cryptography-utils": "^0.4.0",
    "@kadena/types": "^0.6.0",
    "@material-ui/core": "^4.12.4",
    "@material-ui/icons": "^4.11.3",
    "@mui/icons-material": "^5.14.9",
    "@mui/material": "^5.14.10",
    "@multiversx/sdk-core": "12.18.0",
    "@multiversx/sdk-wallet": "4.2.0",
    "@near-wallet-selector/wallet-utils": "^8.0.0",
    "@nextui-org/react": "1.0.8-beta.5",
    "@noble/curves": "^1.6.0",
    "@polkadot/keyring": "^10.1.2",
    "@polkadot/types": "^9.3.3",
    "@reown/appkit-experimental": "1.6.8",
    "@reown/walletkit": "1.2.3",
    "@rhinestone/module-sdk": "0.1.25",
    "@solana/spl-token": "^0.4.13",
    "@solana/web3.js": "1.89.2",
    "@taquito/signer": "^15.1.0",
    "@taquito/taquito": "^15.1.0",
    "@types/semver": "^7.5.8",
    "@zerodev/ecdsa-validator": "5.3.0",
    "@zerodev/presets": "5.3.0",
    "@zerodev/sdk": "5.3.1",
    "@zerodev/session-key": "5.4.0",
    "@zerodev/weighted-ecdsa-validator": "5.3.0",
    "bip32": "^4.0.0",
    "bitcoinjs-lib": "^6.1.5",
    "bitcoinjs-message": "^2.2.0",
    "borsh": "^1.0.0",
    "bs58": "6.0.0",
    "cosmos-wallet": "1.2.0",
    "ecpair": "^2.1.0",
    "ethers": "5.7.2",
    "framer-motion": "6.5.1",
    "graphql": "^16.8.2",
    "near-api-js": "^0.45.0",
    "next": "15",
    "permissionless": "0.1.43",
    "react": "18.2.0",
    "react-code-blocks": "0.1.5",
    "react-dom": "18.2.0",
    "react-hot-toast": "^2.4.1",
    "react-qr-reader-es6": "2.2.1-2",
    "solana-wallet": "^1.0.2",
    "tiny-secp256k1": "^2.2.3",
    "tronweb": "^4.4.0",
    "valtio": "1.13.2",
    "viem": "2.17.8",
    "webauthn-p256": "0.0.2"
  },
  "devDependencies": {
    "@types/node": "17.0.35",
    "@types/react": "18.2.61",
    "@types/react-dom": "18.2.19",
    "eslint": "8.15.0",
    "eslint-config-next": "14.1.3",
    "eslint-config-prettier": "8.5.0",
    "eslint-plugin-package-json": "^0.13.1",
    "jsonc-eslint-parser": "^2.4.0",
    "prettier": "2.6.2",
    "typescript": "5.2.2"
  }
}
</file>

<file path="advanced/wallets/react-wallet-v2/README.md">
# Wallet Example (React, Typescript, Ethers, NextJS, Cosmos)

This example aims to demonstrate basic and advanced use cases enabled by WalletConnect's Sign SDK.

**The wallet implements Sign v1 and v2 side-by-side**, to serve as a reference for wallet developers
aiming to support both major versions for backwards compatibility. **All files containing code for the legacy
v1 implementation are prefixed with `Legacy...`.**

Please only use this for reference and development purposes, otherwise you are at risk of losing your funds.

# Useful links

🔗 Live wallet app - https://react-wallet.walletconnect.com <br />
🔗 Live dapp - https://react-app.walletconnect.com <br />
📚 WalletConnect docs - https://docs.walletconnect.com/2.0

## Getting started

Example is built atop of [NextJS](https://nextjs.org/) in order to abstract complexity of setting up bundlers, routing etc. So there are few steps you need to follow in order to set everything up

1. Go to [WalletConnect Cloud](https://cloud.walletconnect.com/sign-in) and obtain a project id

2. Add your project details in [WalletConnectUtil.ts](https://github.com/WalletConnect/web-examples/blob/main/wallets/react-wallet-v2/src/utils/WalletConnectUtil.ts) file

3. Install dependencies `yarn install` or `npm install`

4. Setup your environment variables

```bash
cp .env.local.example .env.local
```

Your `.env.local` now contains the following environment variables:

- `NEXT_PUBLIC_PROJECT_ID` (placeholder) - You can generate your own ProjectId at https://cloud.walletconnect.com
- `NEXT_PUBLIC_RELAY_URL` (already set)

5. Run `yarn dev` or `npm run dev` to start local development

## Navigating through example

1. Initial setup and initializations happen in [_app.ts](https://github.com/WalletConnect/web-examples/blob/main/wallets/react-wallet-v2/src/pages/_app.tsx) file
2. WalletConnect client, ethers and cosmos wallets are initialized in [useInitialization.ts ](https://github.com/WalletConnect/web-examples/blob/main/wallets/react-wallet-v2/src/hooks/useInitialization.ts) hook
3. Subscription and handling of WalletConnect events happens in [useWalletConnectEventsManager.ts](https://github.com/WalletConnect/web-examples/blob/main/wallets/react-wallet-v2/src/hooks/useWalletConnectEventsManager.ts) hook, that opens related [Modal views](https://github.com/WalletConnect/web-examples/tree/main/wallets/react-wallet-v2/src/views) and passes them all necessary data
4. [Modal views](https://github.com/WalletConnect/web-examples/tree/main/wallets/react-wallet-v2/src/views) are responsible for data display and handling approval or rejection actions
5. Upon approval or rejection, modals pass the request data to [RequestHandlerUtil.ts](https://github.com/WalletConnect/web-examples/blob/main/wallets/react-wallet-v2/src/utils/RequestHandlerUtil.ts) that performs all necessary work based on the request method and returns formated json rpc result data that can be then used for WalletConnect client responses

## Preview of wallet and dapp examples in action

https://user-images.githubusercontent.com/3154053/156764521-3492c232-7a93-47ba-88bd-2cee3f8366d4.mp4

## DOM Tags
This section is a key of the DOM elements used for internal E2E testing
Accessible with `data-testid`

### Navbar
| Key | Description |
| ----------- | ----------- |
|  `accounts` | Accounts page |
| `sessions` | Sessions page |
| `wc-connect` |  WC Connect page |
| `pairings` | Pairings page |
| `settings` | Settings Page |

### WC Connect Page
url: `/walletconnect`
| Key | Description |
| ----------- | ----------- |
| `uri-input` | Uri textbox |
| `uri-connect-button` | Uri connect button |
| `qrcode-button` | Use qrcode button | 

### Sessions Page
url: `/session`
| Key | Description |
| ----------- | ----------- |
| `session-card` | Session cards can be accessed by topic |
| `session-icon` | Icon used on session card |
| `session-text` | Text listed on session card |
| `session-link` | Link listed on session card |

### Session Details Page
url: `/session?topic=`
| Key | Description |
| ----------- | ----------- |
| `session-card-${chain}` | Session chain info card |
| `session-delete-button` | Session delete button |
| `session-ping-button` | Session ping button |
| `session-emit-button` | Session emit button |
| `session-update-button` | Session update button |

### Pairing Page
url: `/pairings`
| Key | Description |
| ----------- | ----------- |
| `pairing-${topic}` | Pairing cards can be accessed by topic |
| `pairing-text-${topic}` | Pairing card text in label | 
| `pairing-url-${topic}` | Pairing card link in label| 
| `pairing-delete-${topic}` | Delete pairing by topic |


### Accounts Page
url: `/`
| Key | Description |
| ----------- | ----------- |
| `account-picker` | Account drop down selector|
| `chain-card-${chain id}` | Chain card by chain id |
| `chain-switch-button-${chain id}` | Chain switch button |
| `chain-switch-button-${chain id}` | Chain copy button |

### Settings Page
url: `/settings`
| Key | Description |
| ----------- | ----------- |
| `settings-toggle-testnets` | Toggle testnet support on/off |
| `settings-region-select` | Select relayer region |

### Session Proposal View
| Key | Description |
| ----------- | ----------- |
| `session-approve-button` | Session approve button |
| `session-reject-button` | Session reject button |
| `session-info-card-text` | Session text info in header |
| `session-info-card-url` | Session info url in header |
| `session-info-card-verify` | Session info verify api in header |
| `session-proposal-card-req-{chain}` | Session card for each required chain |
| `session-proposal-card-opt-{chain}` | Session card for each optional chain |
| `account-select-card-${req/opt}-${index}` | Account selection checkbox by account index|
| `account-select-text-${req/opt}-${index}` | Account selection text by account index |


### Sign Request View 
| Key | Description |
| ----------- | ----------- |
| `request-details-chain` | List of chains in the request |
| `request-details-relay-protocol` | Protocol used for request |
| `request-methods` | Methods requested |
| `request-button-reject` | Reject button |
| `request-button-approve` | Approve button |
</file>

<file path="advanced/wallets/react-wallet-v2/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "incremental": true,
    "esModuleInterop": true,
    "downlevelIteration": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "react": ["node_modules/@types/react"],
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="dapps/README.md">
# AppKit Examples

Head over to [appkit-web-examples](https://github.com/reown-com/appkit-web-examples/) to find all of our latest examples.
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

.DS_Store
.next

# dependencies
node_modules
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel

# webstorm ide
.idea

# vscode
.vscode/settings.json
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2021 WalletConnect, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="README.md">
# WalletConnect v2 Examples

Catalogue of various wallet and dapp examples implementing WalletConnect's **SDKs and APIs**. Each example contains its own README with further instructions and explanations.

### AppKit Examples

- [React + Wagmi](https://github.com/WalletConnect/web-examples/tree/main/dapps/appkit/react-wagmi)
- [AppKit + SIWE](https://github.com/WalletConnect/web-examples/tree/main/dapps/appkit-siwe)

### Provider Examples

- [Universal Provider (Solana)](https://github.com/WalletConnect/web-examples/tree/main/dapps/universal-provider-solana)
- [Universal Provider (Tron)](https://github.com/WalletConnect/web-examples/tree/main/dapps/universal-provider-tron)
- [Ethereum Provider](https://github.com/WalletConnect/web-examples/tree/main/dapps/ethereum-provider)

### Advanced Examples

**Wallets:**

- [React Wallet v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/wallets/react-wallet-v2)

**dApps:**

- [React dApp v2](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2)
- [React dApp v2 with Ethers](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-with-ethers)
- [React dApp v2 with Cosmos Provider](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2-cosmos-provider)
- [Chain Abstraction Demo](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/chain-abstraction-demo)
- [Smart Sessions Demo](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/smart-sessions-demo)
- [Chat Demo Agent](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/chat-demo-agent)
</file>

<file path="renovate.json">
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "config:base",
    ":prConcurrentLimit10",
    ":prHourlyLimit2",
    ":semanticCommits",
    ":semanticCommitScope(deps)"
  ],
  "rebaseWhen": "conflicted",
  "packageRules": [
    {
      "matchPackagePatterns": [
        "@walletconnect/core",
        "@walletconnect/sign-client",
        "@walletconnect/types",
        "@walletconnect/universal-provider",
        "@walletconnect/ethereum-provider",
        "@walletconnect/utils",
        "@walletconnect/react-native-compat"
      ],
      "schedule": ["at any time"],
      "groupName": "WalletConnect Monorepo Deps",
      "groupSlug": "walletconnect-monorepo-deps-updates",
      "matchDepTypes": ["dependencies", "devDependencies"]
    },
    {
      "matchPackagePatterns": ["@walletconnect/web3wallet"],
      "schedule": ["at any time"],
      "groupName": "WalletConnect Web3Wallet Deps",
      "groupSlug": "walletconnect-web3wallet-deps-updates",
      "matchDepTypes": ["dependencies", "devDependencies"]
    },
    {
      "matchPackagePatterns": ["@web3modal/*"],
      "schedule": ["at any time"],
      "groupName": "Web3Modal Deps",
      "groupSlug": "web3modal-deps-updates",
      "matchDepTypes": ["dependencies", "devDependencies"]
    },
    {
      "matchPackagePatterns": ["@cosmjs/*"],
      "schedule": ["every weekend"],
      "groupName": "cosmjs Deps",
      "groupSlug": "cosmjs-deps-updates",
      "matchDepTypes": ["dependencies"]
    },
    {
      "matchPackagePatterns": ["*"],
      "schedule": ["every weekend"],
      "matchDepTypes": ["dependencies"]
    },
    {
      "matchPackagePatterns": ["*"],
      "matchDepTypes": ["devDependencies"],
      "enabled": false
    },
    {
      "matchUpdateTypes": ["major"],
      "enabled": false
    }
  ]
}
</file>

<file path="roadmap.md">
# Basic Web Examples

Basic examples/templates for using WalletConnect SDKs

## Table Of Contents:

```bash
.
├── dapps/
│   ├── web3modal
│   ├── web3inbox(TODO)
│   ├── ethereum-provider
│   ├── universal-provider-solana
│   └── universal-provider-cosmos(TODO)
└── wallets/
    ├── web3wallet(TODO)
    ├── web3wallet-ethers(TODO)
    ├── web3wallet-viem(TODO)
    └── web3wallet-wagmi(TODO)
```
</file>

</files>
