This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: appkit/**/*, walletkit/**/*, cloud/**/*, advanced/api/notify/**/*, advanced/multichain/**/*, advanced/providers/**/*, advanced/security/**/*, advanced/walletconnectmodal/**/*, advanced/push-server.mdx, advanced/walletconnect-deprecations.mdx, .github/**/*, .cspell.json, .gitignore, .prettierrc.json, docs.json, external-link-01.mdx, link-spec.mdx, package.json, README.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
advanced/
  api/
    core/
      about.mdx
      pairing.mdx
      relay.mdx
      shared-core.mdx
    sign/
      dapp-usage.mdx
      overview.mdx
      smart-contract-wallet-usage.mdx
      wallet-usage.mdx
  faq.mdx
  glossary.mdx
components/
  Tabs/
    styles.module.css
docs/
  walletkit/
    flutter/
      early-access/
        chain-abstraction.mdx
images/
  assets/
    home/
      dotnet.svg
      family.svg
      rainbow.svg
    github.svg
  reown/
    appkit-logo.svg
    banner-image-light.svg
    banner-image.svg
    browse.svg
    demo.svg
    features.svg
    get-started.svg
    Icon.svg
    migrate.svg
    recipes.svg
    support.svg
    upgrade.svg
    walletkit-logo.svg
  docs-logo.svg
  v.svg
  walletconnect-logo-black.svg
  walletconnect-logo-white.svg
  walletconnect-logo.svg
snippets/
  appkit/
    javascript/
      bitcoin/
        about/
          implementation.mdx
          triggermodal.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        actions.mdx
      ethers5/
        implementation.mdx
      solana/
        about/
          implementation.mdx
          programs.mdx
          triggermodal.mdx
        actions.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        actions.mdx
    next/
      bitcoin/
        about/
          implementation.mdx
          triggermodal.mdx
      core/
        open.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
      ethers5/
        hooks.mdx
        implementation.mdx
        triggermodal.mdx
      solana/
        about/
          implementation.mdx
          programs.mdx
          triggermodal.mdx
        hooks.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
    react/
      bitcoin/
        about/
          implementation.mdx
          triggermodal.mdx
      core/
        open.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
      ethers5/
        hooks.mdx
        implementation.mdx
        triggermodal.mdx
      solana/
        about/
          implementation.mdx
          programs.mdx
          triggermodal.mdx
        hooks.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        hooks.mdx
    react-native/
      ethers/
        about/
          coinbase.mdx
          implementation.mdx
          installation-expo.mdx
          installation.mdx
        email.mdx
        hooks.mdx
      ethers5/
        about/
          coinbase.mdx
          implementation.mdx
          installation-expo.mdx
          installation.mdx
        hooks.mdx
      expo/
        additional-expo48.mdx
      wagmi/
        about/
          coinbase.mdx
          implementation.mdx
          installation-expo.mdx
          installation.mdx
        email.mdx
        hooks.mdx
    shared/
      notifications/
        frontend-integration/
          api/
            events/
              javascript.mdx
              react.mdx
            initialization/
              javascript.mdx
              react.mdx
            managing-notifications/
              javascript.mdx
              react.mdx
            managing-subscription/
              javascript.mdx
              react.mdx
            registering-accounts/
              javascript.mdx
              react.mdx
            registering-push/
              javascript.mdx
              react.mdx
            setting-account/
              javascript.mdx
              react.mdx
            types/
              javascript.mdx
              react.mdx
          migration/
            javascript.mdx
            react.mdx
          usage/
            example/
              javascript.mdx
              react.mdx
            installation/
              javascript.mdx
              react.mdx
      siwe/
        code.mdx
        parameters.mdx
      siwx/
        index.mdx
        siwx-cloud-auth.mdx
        siwx-custom.mdx
        siwx-default.mdx
      bitcoin-provider.mdx
      chain-abstraction.mdx
      components.mdx
      multichain.mdx
      onramp.mdx
      options.mdx
      resources.mdx
      smart-accounts.mdx
      smart-sessions.mdx
      socials.mdx
      sponsored-transactions.mdx
      swaps.mdx
      theming.mdx
    vue/
      bitcoin/
        about/
          implementation.mdx
          triggermodal.mdx
      core/
        open.mdx
      ethers/
        about/
          implementation.mdx
          triggermodal.mdx
        composables.mdx
      ethers5/
        composables.mdx
        implementation.mdx
      solana/
        composables.mdx
        implementation.mdx
        programs.mdx
        triggermodal.mdx
      wagmi/
        about/
          implementation.mdx
          triggermodal.mdx
        composables.mdx
  cloud/
    analytics.mdx
    blockchain-api.mdx
    explorer-submission.mdx
    relay.mdx
    verify.mdx
  walletkit/
    shared/
      chain-abstraction/
        error-handling.mdx
        intro.mdx
      mobile-linking.mdx
  web3modal/
    v2/
      _partials/
        options/
          chains.mdx
          desktopWallets.mdx
          enableAuthMode.mdx
          enableExplorer.mdx
          explorerExcludedWalletIds.mdx
          explorerRecommendedWalletIds.mdx
          mobileWallets.mdx
          privacyPolicyUrl.mdx
          projectId.mdx
          termsOfServiceUrl.mdx
          themeMode.mdx
          themeVariables.mdx
          walletImages.mdx
        themeMode.mdx
        themeVariables.mdx
        wcModalThemeVariablesTable.mdx
  chainlist.mdx
  cloud-banner.mdx
  walletlist.mdx
web3modal/
  v2/
    _partials/
      customisation/
        customChainImages.mdx
        customChainProviders.mdx
        customDefaultChain.mdx
        customExplorerWallets.mdx
        customManualWallets.mdx
        customWagmiChains.mdx
        customWagmiConnectors.mdx
        customWagmiWalletsIntro.mdx
        customWalletImages.mdx
      options/
        chainImages.mdx
        defaultChain.mdx
        enableAccountView.mdx
        enableNetworkView.mdx
        metadata.mdx
        tokenContracts.mdx
        tokenImages.mdx
      obtainProjectId.mdx
      themeVariablesTable.mdx
overview.mdx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="advanced/api/core/about.mdx">
## Next Steps

The next section will walk you through the process of setting up your project to use the library.
</file>

<file path="advanced/api/core/pairing.mdx">
---
title: Pairing API
---

import CloudBanner from "/snippets/cloud-banner.mdx";

The Pairing API is a lightweight API for establishing an encrypted, protocol-agnostic communication layer between peers.
Its purpose is to provide a secure channel for proposing protocols or sending requests between dapp and wallet.

<CloudBanner />

## Installation

<Tabs
	
	
>
<Tab title="Web">

WalletConnect currently offers Sign and Auth SDKs.
To allow a reusable communication channel between peers,
the Pairing API exposes a standard interface and allows for sending and receiving multi-protocol requests over a single pairing.

Each SDK uses the same implementation of `core/pairing` (via `@walletconnect/core`) to manage pairings.
To run multiple SDKs side-by-side (e.g. Sign and Auth), please refer to the [Sharing a Core instance] guide.

</Tab>
<Tab title="iOS">

#### Add SDK for your project.

You can add a WalletConnect Core SDKs to your project with Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub URL: https://github.com/reown-com/reown-swift
4. Tap Add Package
5. Select WalletConnectPairing check mark

</Tab>
<Tab title="Android">

Kotlin implementation of Android CoreClient for all WalletConnect SDKs. This SDK is developed in Kotlin and usable in both Java and Kotlin files.

![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/android-core)

#### Requirements

- Android min SDK 23
- Java 11

#### Installation

root/build.gradle.kts:

```gradle
allprojects {
 repositories {
    mavenCentral()
    maven { url "https://jitpack.io" }
 }
}
```

app/build.gradle

```gradle
implementation("com.walletconnect:android-core:release_version")
```

#### Project set up

To use initialize RelayClient properly you will need a projectId. Go to https://cloud.reown.com/app, register your project and get projectId.

#### CoreClient initialization

Before using any of the WalletConnect Kotlin SDKs, it is necessary to initialize the CoreClient. The initialization of CoreClient must always happen in the Android Application class. Provide the projectId generated in the Reown Cloud, the WebSocket URL, choose the connection type, and pass the application class. You can also pass your own Relay instance using the `RelayConnectionInterface`.

```kotlin
val projectId = "" //Get Project ID at https://cloud.reown.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val application = //Android Application level class
[Optional] val optionalRelay: RelayConnectionInterface? = /*implement interface*/

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = application, relay = optionalRelay)
```

#### Using your own Relay instance

The CoreClient offers the ability to use a custom Relay client. Just creating an instance of `RelayConnectionInterface` and passing it to `CoreClient.initialize`.

```kotlin
...
val optionalRelay: RelayConnectionInterface = /*implement interface*/

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = application, relay = optionalRelay)
```

</Tab>
<Tab title="React Native">

WalletConnect currently offers Sign and Auth SDKs.
To allow a reusable communication channel between peers,
the Pairing API exposes a standard interface and allows for sending and receiving multi-protocol requests over a single pairing.

Each SDK uses the same implementation of `core/pairing` (via `@walletconnect/core`) to manage pairings.
To run multiple SDKs side-by-side (e.g. Sign and Auth), please refer to the [Sharing a Core instance] guide.

</Tab>
<Tab title=".NET">

Install the `WalletConnect.Core` nuget package, which implements the Pairing API

```shell
dotnet add package WalletConnect.Core
```

Once the `WalletConnect.Core` library is installed, create a Metadata object. It will describe your application and define its appearance in a web browser. Then configure the Pair instance with a metadata object you have instantiated.

```csharp
var metadata = new Metadata()
{
    Name = "my-app",
    Description = "My app description",
    Icons = new[] { "https://walletconnect.com/meta/favicon.ico" },
    Url = "https://walletconnect.com",
}

var options = new CoreOptions()
{
    ProjectId = "...",
    Name = "my-app",
}

var core = new WalletConnectCore(options);
core.Pairing.Configure(metadata);
```

</Tab>
<Tab title="Unity">

<Tip>

Since `WalletConnectUnity` is a wrapper around `WalletConnectSharp`, usage of the pairing API is identical to `.NET`. Please refer to .NET documentation on how to use Pairing inside `WalletConnectUnity`.

</Tip>

#### Package Installation

<Tabs>
<Tab title="OpenUPM CLI">

To install packages via OpenUPM, you need to have [Node.js](https://nodejs.org/en/) and [openupm-cli](https://openupm.com/docs/getting-started.html#installing-openupm-cli) installed. Once you have them installed, you can run the following commands:

```bash
openupm add com.walletconnect.core
```

</Tab>
<Tab title="Package Manager with OpenUPM">

1. Open `Advanced Project Settings` from the gear ⚙ menu located at the top right of the Package Manager’s toolbar
2. Add a new scoped registry with the following details:
   - Name: `OpenUPM`
   - URL: `https://package.openupm.com`
   - Scope(s): `com.walletconnect`
3. Press plus ➕ and then `Save` buttons
4. In the Package Manager windows open the add ➕ menu from the toolbar
5. Select `Add package by name...`
6. Enter the package name:
   - `com.walletconnect.core`
7. Press `Add` button

</Tab>
<Tab title="Package Manager with Git URL">

1. Open the add ➕ menu in the Package Manager’s toolbar
2. Select `Add package from git URL...`
3. Enter the package URL:

**WalletConnectUnity Core**

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core
```

4. Press `Add` button

It's possible to lock the version of the package by adding `#{version}` at the end of the git URL, where `#{version}` is the git tag of the version you want to use.
For example, to install version `1.0.1` of WalletConnectUnity Modal, use the following URL:

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core#core/1.0.1
```

</Tab>
</Tabs>

#### WebGL

Due to WebGL's single-threaded nature, certain asynchronous operations like `Task.Run`, `Task.ContinueWith`, `Task.Delay`, and `ConfigureAwait(false)` are not natively supported.

To enable these operations in WebGL builds, an additional third-party package, [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher), is required. This package modifies the Unity WebGL build to delegate work to the `SynchronizationContext`, allowing these operations to be executed on the same thread without blocking the main application. Please note that all tasks are still executed on a single thread, and any blocking calls will freeze the entire application.

The [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher) package can be added via git URL:

```
https://github.com/VolodymyrBS/WebGLThreadingPatcher.git
```

#### Initialization

1. Fill in the Project ID and Metadata fields in the `Assets/WalletConnectUnity/Resources/WalletConnectProjectConfig` asset.
   - If you don’t have a Project ID, you can create one at [Reown Cloud](https://cloud.reown.com).
   - The `Redirect` fields are optional. They are used to redirect the user back to your app after they approve or reject the session.
2. Initialize `WalletConnect` and get reference to the instance of `Core`:

```csharp
// Initialize singleton
await WalletConnect.Instance.InitializeAsync();

// Or handle instancing manually
var walletConnectUnity = new WalletConnect();
await walletConnectUnity.InitializeAsync();

var core = WalletConnect.Instance.SignClient.Core;
```

</Tab>
</Tabs>

## Usage

<Tabs
	
	
>
<Tab title="Web">

The methods listed below are limited to only the public methods of the Pairing API that we recommend you interact with directly.
For an exhaustive list, please refer to the spec and/or implementation linked under [Useful Links](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-methods) above.

The keyword `sdkClient` is used here as a placeholder for any WalletConnect SDK that implements the Pairing API (e.g. `signClient`, `authClient`, etc).

```ts
 // Creates a new (inactive) pairing. Returns the URI for a peer to consume via `pair`, as well as the pairing topic.
const {topic, uri} = await sdkClient.core.pairing.create()

// Pair with a peer's proposed pairing, extracted from the provided `uri` parameter.
await sdkClient.core.pairing.pair({ uri: "wc:1b3eda3f4..." })

// Activate a previously created pairing (e.g. after the peer has paired), by providing the pairing topic.
await sdkClient.core.pairing.activate({ topic: "1b3eda3f4..." })

// Updates the expiry of an existing pairing, by providing the pairing topic and an `expiry` in seconds (e.g. `60` for one minute from now)
await sdkClient.core.pairing.updateExpiry({ topic: "1b3eda3f4...", expiry: 60 })

// Updates a pairing's metadata, by providing the pairing topic and the desired metadata.
await sdkClient.core.pairing.updateMetadata({ topic: "1b3eda3f4...", metadata: { name: "MyDapp", ... } })

// Returns an array of all existing pairings.
const pairings = sdkClient.core.pairing.getPairings()

// Pings a pairing's peer, by providing the pairing topic.
await sdkClient.core.pairing.ping({ topic: "1b3eda3f4..." })

// Disconnects/Removes a pairing, by providing the pairing topic.
await sdkClient.core.pairing.disconnect({ topic: "1b3eda3f4..." })
```

#### Listeners for pairing-related events

The Pairing API currently emits the following events:

- `pairing_ping`
- `pairing_delete`
- `pairing_expire`

Any of these events can be listened for via the standard Node [`EventEmitter` interface](https://nodejs.org/api/events.html#class-eventemitter):

```ts
sdkClient.core.pairing.events.on("pairing_delete", ({ id, topic }) => {
  // clean up after the pairing for `topic` was deleted.
});
```

</Tab>
<Tab title="iOS">

Create an AppMetadata object. It will describe your application and define its appearance in a web browser.

Starting from WalletConnect SDK version 1.9.5, the `redirect` field in the `AppMetadata` object is mandatory. Ensure that the provided value matches your app's URL scheme to prevent redirection-related issues.

Then configure the Pair instance with a metadata object you have instantiated.

```swift
let metadata = AppMetadata(name: <String>,
                           description: <String>,
                           url: <String>,
                           icons: <[String]>,
                           redirect: AppMetadata.Redirect(native: "example://", universal: nil))

Pair.configure(metadata: metadata)
```

#### Pairing Wallet Usage

In pair wallet with dapp, the user needs to scan a QR code or open a deep link generated by dapp, then instantiate `WalletConnectURI` from the scanned QR code string and call the `pair()` function as follows.

```swift
let uri WalletConnectURI(string: <String>)
try! await Pair.instance.pair(uri: uri)
```

Now wallet and a dapp have a secure communication channel that will be used by top level APIs.

#### Pairing Dapp Usage

In order to pair dapp and a wallet, dapp needs to generate and share a uri with wallet.
To generate a uri call `create()` function on Pair instance as follows.

```swift
let uri = try await Pair.instance.create()
```

Now you can share the uri with the wallet.

</Tab>
<Tab title="Android">

#### **Create Pairing**

```kotlin
val pairing: Pairing? = CoreClient.Pairing.create() { error -> }
```

When first establishing a pairing with a Peer, call `CoreClient.Pairing.create`. This will try and generate a new pairing with a URI parameter that can be used to establish a connection with the other Peer as well as other meta data related to the pairing.

#

#### **Pair Clients**

```kotlin
val pairingParams = Core.Params.Pair(pairingUri)
CoreClient.Pairing.pair(pairingParams) { error -> }
```

To pair the wallet with the Dapp, call the CoreClient.Pairing's pair function which needs a `Core.Params.Pair` parameter. `Core.Params.Pair` is where the WC Uri will be passed.

#

#### **Get List of Active Pairings**

```kotlin
val listOfActivePairings: List<Core.Model.Pairing> = CoreClient.Pairing.getPairings()
```

To get a list of the most current active pairings, call `CoreClient.Pairing.getPairings()` which will return a list of type `Core.Model.Pairing`.

#

#### **Disconnect a Pairing**

```kotlin
CoreClient.Pairing.disconnect(topic = /*Pairing topic*/") { error -> }
```

To disconnect from a pairing, just pass the topic of the pairing to disconnect from (use `getPairings()` to get a list of all active pairings and their topics).

</Tab>
<Tab title="React Native">

The methods listed below are limited to only the public methods of the Pairing API that we recommend you interact with directly.
For an exhaustive list, please refer to the spec and/or implementation linked under [Useful Links](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-methods) above.

The keyword `sdkClient` is used here as a placeholder for any WalletConnect SDK that implements the Pairing API (e.g. `signClient`, `authClient`, etc).

```ts
 // Creates a new (inactive) pairing. Returns the URI for a peer to consume via `pair`, as well as the pairing topic.
const {topic, uri} = await sdkClient.core.pairing.create()

// Pair with a peer's proposed pairing, extracted from the provided `uri` parameter.
await sdkClient.core.pairing.pair({ uri: "wc:1b3eda3f4..." })

// Activate a previously created pairing (e.g. after the peer has paired), by providing the pairing topic.
await sdkClient.core.pairing.activate({ topic: "1b3eda3f4..." })

// Updates the expiry of an existing pairing, by providing the pairing topic and an `expiry` in seconds (e.g. `60` for one minute from now)
await sdkClient.core.pairing.updateExpiry({ topic: "1b3eda3f4...", expiry: 60 })

// Updates a pairing's metadata, by providing the pairing topic and the desired metadata.
await sdkClient.core.pairing.updateMetadata({ topic: "1b3eda3f4...", metadata: { name: "MyDapp", ... } })

// Returns an array of all existing pairings.
const pairings = sdkClient.core.pairing.getPairings()

// Pings a pairing's peer, by providing the pairing topic.
await sdkClient.core.pairing.ping({ topic: "1b3eda3f4..." })

// Disconnects/Removes a pairing, by providing the pairing topic.
await sdkClient.core.pairing.disconnect({ topic: "1b3eda3f4..." })
```

#### Listeners for pairing-related events

The Pairing API currently emits the following events:

- `pairing_ping`
- `pairing_delete`
- `pairing_expire`

Any of these events can be listened for via the standard Node [`EventEmitter` interface](https://nodejs.org/api/events.html#class-eventemitter):

```ts
sdkClient.core.pairing.events.on("pairing_delete", ({ id, topic }) => {
  // clean up after the pairing for `topic` was deleted.
});
```

</Tab>
<Tab title=".NET">

#### Pairing Wallet Usage

When paring a wallet with a dapp, the user needs to scan a QR code or open a deep link generated by the dapp. Grab the string from the scanned QR code string or from the deep link and call the `Pair()` function as follows.

```csharp
var uri = "...";
PairingStruct pairingData = await core.Pairing.Pair(uri);
```

Now the wallet and a dapp have a secure communication channel that will be used by top level APIs.

#### Pairing Dapp Usage

In order to pair dapp and a wallet, dapp needs to generate and share a uri with wallet. To generate a uri call `create()` function on Pair instance as follows.

```csharp

var pairData = await core.Pairing.Create();
string topic = pairData.Topic;
string uri = pairData.Uri;
```

Now you can share the uri with the wallet either through a QR Code or by using a deep link.

#### Message Sending / Handling

Once a wallet and dapp has been paired, they can send messages securely to the pairing topic.

Requests can be received from the dapp by handling the message callback in the `MessageHandler` module.

```csharp
core.MessageHandler.MessageEventHandler<MyRequest, MyResponse>()
    .FilterRequests(r => r.Topic == pairingData.Topic)
    .OnRequest +=
		async delegate(RequestEventArgs<MyRequest, MyResponse> eventArgs)
		{
		    Console.WriteLine(eventArgs.Request);
		    eventArgs.Response = new MyResponse()
		    {
		        // ...
		    };
		};
```

A response can be sent for any request by setting the `Response` field in the `eventArgs` parameter.

Receiving responses is handled the same way, but instead of the `OnRequest` event you would use the `OnResponse` event.

Request, Responses and Errors can be sent using the `SendRequest` , `SendResult` and `SendError` functions in the `MessageHandler` module.

```csharp
long id = await core.MessageHandler.SendRequest<MyRequest, MyResponse>(pairingTopic, data);
```

</Tab>
</Tabs>
</file>

<file path="advanced/api/core/relay.mdx">
---
title: Relay Client
---

Relay client provides transport layer for Sign, Auth and Chat SDKs.
You can configure it once and every SDK will transport protocol messages via same instance of a relay client with only one opened websocket connection.
The Relay API can be accessed through the Core Client

<Tabs
	
	
>
<Tab title="iOS">

Before using Sign or Auth SDK, it is necessary to configure a shared Networking Client instance. Set a project ID generated when starting a project on Reown Cloud and SocketFactory instance.

WalletConnect Swift SDK does not depend on any websocket library. SocketFactory parameter allows you to pass your own implementation of websocket connection.

Here's an example of WebSocketFactory implementation using Starscream v3

```swift
import Starscream

extension WebSocket: WebSocketConnecting { }

struct SocketFactory: WebSocketFactory {
    func create(with url: URL) -> WebSocketConnecting {
        return WebSocket(url: url)
    }
}
```

Please note that if you have made changes to the list of **Allowed Domains** in the **Reown Cloud Dashboard**, then you may encounter an error with the connection if you use **Starscream** or any other socket client. For example, the native implementation of **Starscream** will use the `relay.walletconnect.com` as an `Origin` parameter if not provided, which will be missing from the list of **Allowed Domains**. The solution to this could be the inclusion of the `relay.walletconnect.com` in the **Allowed Domains**, corresponding changes in the socket client implementation, or following changes in the `WebSocketFactory`.

Create and register App Group Identifier in [Apple Developer Center](https://developer.apple.com/account/resources/identifiers/list/applicationGroup) if needed and provide it during Networking client configuration.

```swift
import Starscream

extension WebSocket: WebSocketConnecting { }

struct DefaultSocketFactory: WebSocketFactory {
    func create(with url: URL) -> WebSocketConnecting {
        var urlRequest = URLRequest(url: url)
        urlRequest.addValue("allowed.domain.com", forHTTPHeaderField: "Origin")
        return WebSocket(request: urlRequest)
    }
}
```

#### Networking client configuration

```swift
Networking.configure(groupIdentifier: <String>, projectId: <String>, socketFactory: SocketFactory())
```

`groupIdentifier` - App group identifier, created on [Apple Developer Center](https://developer.apple.com/account/resources/identifiers/list/applicationGrou). Enables to share keychain items between the Notify SDK and a UNNotificationServiceExtension to receive and decrypt push notifications.

#### Web Socket Connection

By default web socket connection is handled internally by the SDK. That means that Web socket will be safely disconnected when apps go to background and it will connect back when app reaches foreground. But if it is not expected for your app and you want to handle socket connection manually you can do it as follows:

1. set socketConnectionType for manual

```swift
Networking.configure(projectId: <String>, socketFactory: SocketFactory(), socketConnectionType: .manual)
```

2. control socket connection:

```swift
try Networking.instance.connect()
```

```swift
try Networking.instance.disconnect()
```

</Tab>
<Tab title="Android">

#### Web Socket connection control

There are two connection types, Automatic and Manual.

Automatic connection type enables SDK to control web socket connection internally. Meaning, web socket connection is closed when app goes to the background and is opened when app goes to the foreground.

Manual connection type enables developers to control web socket connection.

```kotlin
CoreClient.initialize(projectId = projectId, connectionType = ConnectionType.MANUAL, application = application)

CoreClient.Relay.connect() { error -> /*Error when wrong connection type is in use*/}

CoreClient.Relay.disconnect() { error -> /*Error when wrong connection type is in use*/}
```

</Tab>
</Tabs>
</file>

<file path="advanced/api/core/shared-core.mdx">
---
title: "Shared Core Instance"
---

<Info>
The following content are only available for JavaScript.
</Info>

WalletConnect's SDKs are designed to share common logic and resources via the `@walletconnect/core` package.

**If you intend to leverage multiple SDKs together (e.g. Sign + Auth), it is highly recommended to instantiate
a single `Core` instance and pass it to the relevant SDKs.** This avoids each SDK creating its own `Core` instance,
and thus duplicating computation, memory allocation, event listeners etc.

In the following example, we first instantiate a `Core` instance, and then proceed to instantiate both the Sign
and Auth SDK with this shared `Core`:

```ts
import { Core } from "@walletconnect/core";
import SignClient from "@walletconnect/sign-client";
import { AuthClient } from "@walletconnect/auth-client";

// First instantiate a separate `Core` instance.
const core = new Core({
  projectId: "<YOUR_PROJECT_ID>",
});

const metadata = {
  name: "Example Dapp",
  description: "Example Dapp",
  url: "#",
  icons: ["https://walletconnect.com/walletconnect-logo.png"],
};

// Pass `core` to the SignClient on init.
const signClient = await SignClient.init({ core, metadata });

// Pass `core` to the AuthClient on init.
const authClient = await AuthClient.init({ core, metadata });
```
</file>

<file path="advanced/api/sign/dapp-usage.mdx">
---
title: "Dapp Usage"
---

## Implementation

<Tabs

>

<Tab title="Web">
This library is compatible with Node.js, browsers and React Native applications (Node.js modules require polyfills for React Native).

Dapps will also need to install WalletConnectModal for the UI.

<CodeGroup>
  ```bash npm npm install @walletconnect/modal ``` ```bash Yarn yarn add
  @walletconnect/modal ``` ```bash Bun bun add @walletconnect/modal ``` ```bash
  pnpm pnpm add @walletconnect/modal ```
</CodeGroup>

<Note>
  For an example implementation, please refer to our `react-dapp-v2`
  [example](https://github.com/WalletConnect/web-examples/tree/main/advanced/dapps/react-dapp-v2).
</Note>

#### Install Packages

Dapps will also need to install `WalletConnectModal` for the UI.

<CodeGroup>
  ```bash npm npm install @walletconnect/modal ``` ```bash Yarn yarn add
  @walletconnect/modal ``` ```bash Bun bun add @walletconnect/modal ``` ```bash
  pnpm pnpm add @walletconnect/modal ```
</CodeGroup>

#### Create a Session

**1. Initiate your WalletConnect client with the relay server, using [your Project ID](../../cloud/relay).**

```javascript
import SignClient from "@walletconnect/sign-client";

const signClient = await SignClient.init({
  projectId: "<YOUR_PROJECT_ID>",
  // optional parameters
  relayUrl: "<YOUR RELAY URL>",
  metadata: {
    name: "Example Dapp",
    description: "Example Dapp",
    url: "#",
    icons: ["https://walletconnect.com/walletconnect-logo.png"],
  },
});
```

**2. Add listeners for desired `SignClient` events.**

<Note>
  To listen to pairing-related events, please follow the guidance for [Pairing
  API event
  listeners](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/pairing-api).
</Note>

```javascript
signClient.on("session_event", ({ event }) => {
  // Handle session events, such as "chainChanged", "accountsChanged", etc.
});

signClient.on("session_update", ({ topic, params }) => {
  const { namespaces } = params;
  const _session = signClient.session.get(topic);
  // Overwrite the `namespaces` of the existing session with the incoming one.
  const updatedSession = { ..._session, namespaces };
  // Integrate the updated session state into your dapp state.
  onSessionUpdate(updatedSession);
});

signClient.on("session_delete", () => {
  // Session was deleted -> reset the dapp state, clean up from user session, etc.
});
```

**3. Create a new WalletConnectModal instance.**

```javascript
import { WalletConnectModal } from "@walletconnect/modal";

const walletConnectModal = new WalletConnectModal({
  projectId: "<YOUR_PROJECT_ID>",
  // `standaloneChains` can also be specified when calling `walletConnectModal.openModal(...)` later on.
  standaloneChains: ["eip155:1"],
});
```

**4. Connect the application and specify session permissions.**

```javascript
try {
  const { uri, approval } = await signClient.connect({
    // Optionally: pass a known prior pairing (e.g. from `signClient.core.pairing.getPairings()`) to skip the `uri` step.
    pairingTopic: pairing?.topic,
    // Provide the namespaces and chains (e.g. `eip155` for EVM-based chains) we want to use in this session.
    requiredNamespaces: {
      eip155: {
        methods: [
          "eth_sendTransaction",
          "eth_signTransaction",
          "eth_sign",
          "personal_sign",
          "eth_signTypedData",
        ],
        chains: ["eip155:1"],
        events: ["chainChanged", "accountsChanged"],
      },
    },
  });

  // Open QRCode modal if a URI was returned (i.e. we're not connecting an existing pairing).
  if (uri) {
    walletConnectModal.openModal({ uri });
    // Await session approval from the wallet.
    const session = await approval();
    // Handle the returned session (e.g. update UI to "connected" state).
    // * You will need to create this function *
    onSessionConnect(session);
    // Close the QRCode modal in case it was open.
    walletConnectModal.closeModal();
  }
} catch (e) {
  console.error(e);
}
```

#### Session Authenticate with ReCaps

The authenticate() method enhances the WalletConnect protocol, offering EVM dApps a sophisticated mechanism to request wallet authentication and simultaneously establish a session. This innovative approach not only authenticates the user but also facilitates a seamless session creation, integrating the capabilities defined by ERC-5573, also known as ReCaps.

ReCaps extend the SIWE protocol, enabling users to give informed consent for dApps to exercise scoped capabilities on their behalf. This consent mechanism is crucial for authorizing a dApp to perform actions or access resources, thus ensuring security and trust in dApp interactions. These scoped capabilities are specified through ReCap URIs in the resources field of the AuthRequestParams, which translate to human-readable consent in the SIWE message, detailing the actions a dApp is authorized to undertake.

To initiate an authentication and authorization request, a dApp invokes the authenticate() method, passing in parameters that include desired capabilities as outlined in EIP-5573. The method generates a pairing URI for user interaction, facilitating a streamlined authentication and consent process.

Example of initiating an authentication request with ReCaps:

```typescript
const { uri, response } = await signClient.authenticate({
  chains: ['eip155:1', 'eip155:2'], // chains your dapp requests authentication for
  domain: 'localhost', // your domain
  uri: 'http://localhost/login', // uri
  nonce: '1239812982', // random nonce
  methods: ['personal_sign', 'eth_chainId', 'eth_signTypedData_v4'], // the methods you wish to use
  resources: ['https://example.com'] // any resources relevant to the connection
})

// Present the URI to users as QR code to be able to connect with a wallet
...

// wait for response
const result = await response()

// after a Wallet establishes a connection response will resolve with auths ( authentication objects ) & the established session
const { auths, session } = result;

// now you can send requests to that session
```

#### Making Requests

Once the session has been established successfully, you can start making JSON-RPC requests to be approved and signed by the wallet:

```javascript
const result = await signClient.request({
  topic: session.topic,
  chainId: "eip155:1",
  request: {
    method: "personal_sign",
    params: [
      "0x7468697320697320612074657374206d65737361676520746f206265207369676e6564",
      "0x1d85568eEAbad713fBB5293B45ea066e552A90De",
    ],
  },
});
```

> For more information on available JSON-RPC requests, see the [JSON-RPC reference](../../advanced/multichain/rpc-reference/ethereum-rpc.md).

### Restoring a Session

Sessions are saved to localstorage, meaning that even if the web page is reloaded, the session can still be retrieved, as demonstrated in the following code:

```ts
const lastKeyIndex = signClient.session.getAll().length - 1;
const lastSession = signClient.session.getAll()[lastKeyIndex];
```

#### Finding a Specific Session

If you need to find a specific session, you can do so by passing in a known `requiredNamespace` and calling `find`.

```ts
const specificSession = _client.find({
  requiredNamespaces: {
    eip155: {
      methods: [
        "eth_sendTransaction",
        "eth_signTransaction",
        "eth_sign",
        "personal_sign",
        "eth_signTypedData",
      ],
      chains: ["eip155:5"],
      events: ["chainChanged", "accountsChanged"],
    },
  },
});
```

</Tab>

<Tab title="iOS">

#### Configure Networking and Pair clients

Make sure that you properly configure Networking and Pair Clients first.

- [Networking](/advanced/api/core/relay)
- [Pairing](/advanced/api/core/pairing)

#### Configure Sign Client

In order to initialize a client, call a `configure` method on the Sign instance

```swift
Sign.configure(crypto: CryptoProvider)
```

#### Subscribe for Sign publishers

When your `Sign` instance receives requests from a peer it will publish related event. So you should set subscription to handle them.

To track sessions subscribe to `sessionsPublisher` publisher

```swift
Sign.instance.sessionsPublisher
    .receive(on: DispatchQueue.main)
    .sink { [unowned self] (sessions: [Session]) in
        // reload UI
    }.store(in: &publishers)
```

Following publishers are available to subscribe:

```swift
    public var sessionsPublisher: AnyPublisher<[Session], Never>
    public var sessionProposalPublisher: AnyPublisher<Session.Proposal, Never>
    public var sessionRequestPublisher: AnyPublisher<Request, Never>
    public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never>
    public var sessionSettlePublisher: AnyPublisher<Session, Never>
    public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never>
    public var sessionResponsePublisher: AnyPublisher<Response, Never>
    public var sessionRejectionPublisher: AnyPublisher<(Session.Proposal, Reason), Never>
    public var sessionUpdatePublisher: AnyPublisher<(sessionTopic: String, namespaces: [String : SessionNamespace]), Never>
    public var sessionEventPublisher: AnyPublisher<(event: Session.Event, sessionTopic: String, chainId: Blockchain?), Never>
    public var sessionUpdateExpiryPublisher: AnyPublisher<(sessionTopic: String, expiry: Date), Never>
```

#### Connect Clients

1. Prepare namespaces that constraints minimal requirements for your dApp:

```Swift
let methods: Set<String> = ["eth_sendTransaction", "personal_sign", "eth_signTypedData"]
let blockchains: Set<Blockchain> = [Blockchain("eip155:1")!, Blockchain("eip155:137")!]
let namespaces: [String: ProposalNamespace] = ["eip155": ProposalNamespace(chains: blockchains, methods: methods, events: []]
```

To learn more on namespaces, check out our [specs](https://specs.walletconnect.com/2.0/specs/clients/sign/namespaces).

2. Your App should generate a pairing URI and share it with a wallet. Uri can be presented as a QR code or sent via a universal link. Wallet begins subscribing for session proposals after receiving URI. In order to create a pairing and send a session proposal, you need to call the following:

```Swift
let uri = try await Sign.instance.connect(requiredNamespaces: namespaces, topic: uri.topic)
```

#### Session Authenticate with ReCaps

The authenticate() method enhances the WalletConnect protocol, offering EVM dApps a sophisticated mechanism to request wallet authentication and simultaneously establish a session. This innovative approach not only authenticates the user but also facilitates a seamless session creation, integrating the capabilities defined by ERC-5573, also known as ReCaps.

ReCaps extend the SIWE protocol, enabling users to give informed consent for dApps to exercise scoped capabilities on their behalf. This consent mechanism is crucial for authorizing a dApp to perform actions or access resources, thus ensuring security and trust in dApp interactions. These scoped capabilities are specified through ReCap URIs in the resources field of the AuthRequestParams, which translate to human-readable consent in the SIWE message, detailing the actions a dApp is authorized to undertake.

To initiate an authentication and authorization request, a dApp invokes the authenticate() method, passing in parameters that include desired capabilities as outlined in EIP-5573. The method generates a pairing URI for user interaction, facilitating a streamlined authentication and consent process.

Example of initiating an authentication request with ReCaps:

```swift
func initiateAuthentication() {
    Task {
        do {
            let authParams = AuthRequestParams.stub() // Customize your AuthRequestParams as needed
            let uri = try await Sign.instance.authenticate(authParams)
            // Present the URI to the user, e.g., show a QR code or send a deep link
            presentAuthenticationURI(uri)
        } catch {
            print("Failed to initiate authentication request: \(error)")
        }
    }
}
```

##### Subscribe to Authentication Responses

Once you have initiated an authentication request, you need to listen for responses from wallets. Responses will indicate whether the authentication request was approved or rejected. Use the authResponsePublisher to subscribe to these events.

Example subscription to authentication responses:

```swift
Sign.instance.authResponsePublisher
    .receive(on: DispatchQueue.main)
    .sink { response in
        switch response.result {
        case .success(let (session, _)):
            if let session = session {
                // Authentication successful, session established
                handleSuccessfulAuthentication(session)
            } else {
                // Authentication successful, but no session created (SIWE-only flow)
                handleSuccessfulAuthenticationWithoutSession()
            }
        case .failure(let error):
            // Authentication request was rejected or failed
            handleAuthenticationFailure(error)
        }
    }
    .store(in: &subscriptions)
```

In this setup, the authResponsePublisher notifies your dApp of the outcome of the authentication request. Your dApp can then proceed based on whether the authentication was successful, rejected, or failed due to an error.

Example of AuthRequestParams:

```swift
extension AuthRequestParams {
    static func stub(
        domain: String = "yourDappDomain.com",
        chains: [String] = ["eip155:1", "eip155:137"],
        nonce: String = "uniqueNonce",
        uri: String = "https://yourDappDomain.com/login",
        statement: String? = "I accept the Terms of Service: https://yourDappDomain.com/tos",
        resources: [String]? = nil, // here your dapp may request authorization with recaps
        methods: [String]? = ["personal_sign", "eth_sendTransaction"]
    ) -> AuthRequestParams {
        return try! AuthRequestParams(
            domain: domain,
            chains: chains,
            nonce: nonce,
            uri: uri,
            statement: statement,
            resources: resources,
            methods: methods
        )
    }
}
```

#### Send Request to the Wallet

Once the session has been established `sessionSettlePublisher` will publish an event. Your dApp can start requesting wallet now.

```Swift
let method = "personal_sign"
let walletAddress = "0x9b2055d370f73ec7d8a03e965129118dc8f5bf83" // This should match the connected address
let requestParams = AnyCodable(["0x4d7920656d61696c206973206a6f686e40646f652e636f6d202d2031363533333933373535313531", walletAddress])
let request = Request(topic: session.topic, method: method, params: requestParams, chainId: Blockchain(chainId)!)
try await Sign.instance.request(params: request)
```

When wallet respond `sessionResponsePublisher` will publish an event so you can verify the response.

#### Extending a Session

By default, session lifetime is set for 7 days and after that time user's session will expire. But if you consider that a session should be extended you can call:

```Swift
try await Sign.instance.extend(topic: session.topic)
```

Above method will extend a user's session to a week.

#### Where to go from here

- Try our [Example dApp](https://github.com/reown-com/reown-swift/tree/main/Example) that is part of [WalletConnectSwiftV2 repository](https://github.com/reown-com/reown-swift).
- Build API documentation in XCode: go to Product -> Build Documentation

</Tab>

<Tab title="Android">

#### **Initialization**

```kotlin
val projectId = "" // Get Project ID at https://cloud.reown.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val appMetaData = Core.Model.AppMetaData(
    name = "Dapp Name",
    description = "Dapp Description",
    url = "Dapp URL",
    icons = /*list of icon url strings*/,
    redirect = "kotlin-dapp-wc:/request" // Custom Redirect URI
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData)

val init = Sign.Params.Init(core = CoreClient)

SignClient.initialize(init) { error ->
    // Error will be thrown if there's an issue during initialization
}
```

The Dapp client is responsible for initiating the connection with wallets and defining the required namespaces (CAIP-2) from the Wallet and is also in charge of sending requests. To initialize the Sign client, create a `Sign.Params.Init` object in the Android Application class with the Core Client. The `Sign.Params.Init` object will then be passed to the `SignClient` initialize function.

#

# **Dapp**

#### **SignClient.DappDelegate**

```kotlin
val dappDelegate = object : SignClient.DappDelegate {
    override fun onSessionApproved(approvedSession: Sign.Model.ApprovedSession) {
        // Triggered when Dapp receives the session approval from wallet
    }

    override fun onSessionRejected(rejectedSession: Sign.Model.RejectedSession) {
        // Triggered when Dapp receives the session rejection from wallet
    }

    fun onSessionAuthenticateResponse(sessionAuthenticateResponse: Sign.Model.SessionAuthenticateResponse) {
        // Triggered when Dapp receives the session authenticate response from wallet
    }

    override fun onSessionUpdate(updatedSession: Sign.Model.UpdatedSession) {
        // Triggered when Dapp receives the session update from wallet
    }

    override fun onSessionExtend(session: Sign.Model.Session) {
        // Triggered when Dapp receives the session extend from wallet
    }

    override fun onSessionEvent(sessionEvent: Sign.Model.SessionEvent) {
        // Triggered when the peer emits events that match the list of events agreed upon session settlement
    }

    override fun onSessionDelete(deletedSession: Sign.Model.DeletedSession) {
        // Triggered when Dapp receives the session delete from wallet
    }

    override fun onSessionRequestResponse(response: Sign.Model.SessionRequestResponse) {
        // Triggered when Dapp receives the session request response from wallet
    }

    override fun onProposalExpired(proposal: Modal.Model.ExpiredProposal) {
        // Triggered when a proposal becomes expired
    }

    override fun onRequestExpired(request: Modal.Model.ExpiredRequest) {
        // Triggered when a request becomes expired
    }

    override fun onConnectionStateChange(state: Sign.Model.ConnectionState) {
        //Triggered whenever the connection state is changed
    }

    override fun onError(error: Sign.Model.Error) {
        // Triggered whenever there is an issue inside the SDK
    }
}

SignClient.setDappDelegate(dappDelegate)
```

The SignClient needs a `SignClient.DappDelegate` passed to it for it to be able to expose asynchronously updates sent from the Wallet.

#

#### **Connect**

```kotlin
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val chains: List<String> = /*List of chains that wallet will be requested for*/
val methods: List<String> = /*List of methods that wallet will be requested for*/
val events: List<String> = /*List of events that wallet will be requested for*/
val requiredNamespaces: Map<String, Sign.Model.Namespaces.Proposal> = mapOf(namespace, Sign.Model.Namespaces.Proposal(accounts, methods, events)) /*Required namespaces to setup a session*/
val optionalNamespaces: Map<String, Sign.Model.Namespaces.Proposal> = mapOf(namespace, Sign.Model.Namespaces.Proposal(accounts, methods, events)) /*Optional namespaces to setup a session*/
val pairing: Core.Model.Pairing = /*Either an active or inactive pairing*/
val connectParams = Sign.Params.Connect(requiredNamespaces, optionalNamespaces, pairing)

fun SignClient.connect(connectParams,
    { onSuccess ->
        /*callback that returns letting you know that you have successfully initiated connecting*/
    },
    { error ->
        /*callback for error while trying to initiate a connection with a peer*/
    }
)
```

More about optional and required namespaces can be found [here](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md)

#

#### **Authenticate**

The authenticate() method enhances the WalletConnect protocol, offering EVM dApps a sophisticated mechanism to request wallet authentication and simultaneously establish a session. This innovative approach not only authenticates the user but also facilitates a seamless session creation, integrating the capabilities defined by ERC-5573, also known as ReCaps.

Capabilities are specified through ReCap URIs in the resources field of the Sign.Params.Authenticate, which translate to human-readable consent in the SIWE message, detailing the actions a dApp is authorized to undertake.

To initiate an authentication and authorization request, a dApp invokes the authenticate() method, passing in parameters that include desired capabilities as outlined in EIP-5573. The method generates a pairing URI for user interaction, facilitating a streamlined authentication and consent process.

Example of initiating an authentication request with ReCaps:

```kotlin
 val authenticateParams = Sign.Params.Authenticate(
            domain = "your.domain",
            chains = listof("eip155:1", "eip155:137"),
            methods = listOf("personal_sign", "eth_signTypedData"),
            uri = "https://yourDappDomain.com/login",
            nonce = randomNonce,
            statement = "Sign in with wallet.",
            resources = null, // here your dapp may request authorization with recaps
        )

SignClient.authenticate(authenticateParams,
    onSuccess = { url ->
        //Handle authentication URI. Show as a QR code a send via deeplink
    },
    onError = { error ->
        //Handle error
    }
)
```

Once you have sent an authentication request, await for responses from wallets. Responses will indicate whether the authentication request was approved or rejected. Use the onSessionAuthenticateResponse callback to receive a response:

```kotlin
 fun onSessionAuthenticateResponse(sessionAuthenticateResponse: Sign.Model.SessionAuthenticateResponse) {
        // Triggered when Dapp receives the session authenticate response from wallet

        if (sessionAuthenticateResponse is Sign.Model.SessionAuthenticateResponse.Result) {
            if (sessionAuthenticateResponse.session != null) {
                // Authentication successful, session established
            } else {
                // Authentication successful, but no session created (SIWE-only flow)
            }
        } else {
            // Authentication request was rejected or failed
        }

}
```

#

#### **Get List of Settled Sessions**

```kotlin
SignClient.getListOfSettledSessions()
```

To get a list of the most current settled sessions, call `SignClient.getListOfSettledSessions()` which will return a list of type `Session`.

#

#### **Get list of pending session requests for a topic**

```kotlin
SignClient.getPendingRequests(topic: String)
```

To get a list of pending session requests for a topic, call `SignClient.getPendingRequests()` and pass a topic which will return
a `PendingRequest` object containing requestId, method, chainIs and params for pending request.

</Tab>

<Tab title="Flutter">

#### Initialization

To create an instance of `SignClient`, you need to pass in the core and metadata parameters.

```dart
SignClient signClient = await SignClient.createInstance(
    relayUrl: 'wss://relay.walletconnect.com', // The relay websocket URL, leave blank to use the default
    projectId: '123',
    metadata: PairingMetadata(
        name: 'dapp (Requester)',
        description: 'A dapp that can request that transactions be signed',
        url: 'https://walletconnect.com',
        icons: ['https://avatars.githubusercontent.com/u/37784886'],
    ),
);
```

#### Connection

To connect with specific parameters and display the returned URI, use `connect` with the required namespaces.

```dart
ConnectResponse response = await signClient.connect(
    requiredNamespaces: {
        'eip155': RequiredNamespace(
            chains: ['eip155:1'], // Ethereum chain
            methods: ['eth_signTransaction'], // Requestable Methods
        ),
        'kadena': RequiredNamespace(
            chains: ['kadena:mainnet01'], // Kadena chain
            methods: ['kadena_quicksign_v1'], // Requestable Methods
        ),
    }
);

Uri? uri = response.uri;
```

You will use that URI to display a QR code or handle a deep link.

We recommend not handling deep linking yourself. If you want to deep link, then use the [walletconnect_modal_flutter](https://pub.dev/packages/walletconnect_modal_flutter) package.

#### Session Data

Once you've displayed the URI you can wait for the future and hide the QR code once you've received session data.

```dart
final SessionData session = await response.session.future;
```

#### Request Signatures

Once the session had been created, you can request signatures.

```dart
final signature = await signClient.request(
    topic: session.topic,
    chainId: 'eip155:1',
    request: SessionRequestParams(
        method: 'eth_signTransaction',
        params: 'json serializable parameters',
    ),
);
```

#### Respond to Events

You can also respond to events from the wallet, like chain changed, using `onSessionEvent` and `registerEventHandler`.

```dart
signClient.onSessionEvent.subscribe((SessionEvent? session) {
    // Do something with the event
});

signClient.registerEventHandler(
    namespace: 'kadena',
    event: 'kadena_transaction_updated',
);
```

# To Test

Run tests using `flutter test`.
Expected flutter version is: >`3.3.10`

# Useful Commands

- `flutter pub run build_runner build --delete-conflicting-outputs` - Regenerates JSON Generators
- `flutter doctor -v` - get paths of everything installed.
- `flutter pub get`
- `flutter upgrade`
- `flutter clean`
- `flutter pub cache clean`
- `flutter pub deps`
- `flutter pub run dependency_validator` - show unused dependencies and more
- `dart format lib/* -l 120`
- `flutter analyze`

</Tab>

<Tab title=".NET">

#### Setup

First you must setup `SignClientOptions` which stores both the `ProjectId` and `Metadata`. You may also optionally specify the storage module to use. By default, the `FileSystemStorage` module is used if none is specified.

```csharp
var dappOptions = new SignClientOptions()
{
    ProjectId = "39f3dc0a2c604ec9885799f9fc5feb7c",
    Metadata = new Metadata()
    {
        Description = "An example dapp to showcase WalletConnectSharpv2",
        Icons = new[] { "https://walletconnect.com/meta/favicon.ico" },
        Name = "WalletConnectSharpv2 Dapp Example",
        Url = "https://walletconnect.com"
    },
    // Uncomment to disable persistent storage
    // Storage = new InMemoryStorage()
};
```

Then, you must setup the `ConnectOptions` which define what blockchain, RPC methods and events your dapp will use.

_C# Constructor_

```csharp
var dappConnectOptions = new ConnectOptions()
{
    RequiredNamespaces = new RequiredNamespaces()
    {
        {
            "eip155", new RequiredNamespace()
            {
                Methods = new[]
                {
                    "eth_sendTransaction",
                    "eth_signTransaction",
                    "eth_sign",
                    "personal_sign",
                    "eth_signTypedData",
                },
                Chains = new[]
                {
                    "eip155:1"
                },
                Events = new[]
                {
                    "chainChanged",
                    "accountsChanged",
                }
            }
        }
    }
};
```

_Builder Functions Style_

```csharp
var dappConnectOptions1 = new ConnectOptions()
    .RequireNamespace("eip155", new RequiredNamespace()
        .WithMethod("eth_sendTransaction")
        .WithMethod("eth_signTransaction")
        .WithMethod("eth_sign")
        .WithMethod("personal_sign")
        .WithMethod("eth_signTypedData")
        .WithChain("eip155:1")
        .WithEvent("chainChanged")
        .WithEvent("accountsChanged")
    );
```

With both options defined, you can initialize and connect the SDK.

```csharp
var dappClient = await WalletConnectSignClient.Init(dappOptions);
var connectData = await dappClient.Connect(dappConnectOptions);
```

You can grab the `Uri` for the connection request from `connectData`.

```csharp
ExampleShowQRCode(connectData.Uri);
```

Then await connection approval using the `Approval` Task object.

```csharp
Task<SessionStruct> sessionConnectTask = connectData.Approval;
SessionStruct sessionData = await sessionConnectTask;

// or
// SessionStruct sessionData = await connectData.Approval;
```

This `Task` will return the `SessionStruct` when the session was approved, or throw an exception when the session request has either

- Timed out
- Been Rejected

#### Connected Address

To get the currently connected address, use the following function

```csharp
public class Caip25Address
{
    public string Address;
    public string ChainId;
}

public Caip25Address GetCurrentAddress(string chain)
{
    if (string.IsNullOrWhiteSpace(chain))
        return null;

    var defaultNamespace = currentSession.Namespaces[chain];

    if (defaultNamespace.Accounts.Length == 0)
        return null;

    var fullAddress = defaultNamespace.Accounts[0];
    var addressParts = fullAddress.Split(":");

    var address = addressParts[2];
    var chainId = string.Join(':', addressParts.Take(2));

    return new Caip25Address()
    {
        Address = address,
        ChainId = chainId,
    };
}

public Caip25Address GetCurrentAddress()
{
    var currentSession = dappClient.Session.Get(dappClient.Session.Keys[0]);

    var defaultChain = currentSession.Namespaces.Keys.FirstOrDefault();

    if (string.IsNullOrWhiteSpace(defaultChain))
        return null;

    return GetCurrentAddress(defaultChain);
}
```

#### WalletConnect Methods

All sign methods require the `topic` of the session to be given. This can be found in the `SessionStruct` object given when a session has been given approval by the user.

```csharp
var sessionTopic = sessionData.Topic;
```

##### Update Session

Update a session, adding/removing additional namespaces in the given topic.

```csharp
var newNamespaces = new Namespaces(...);
var request = await dappClient.UpdateSession(sessionTopic, newNamespaces);
await request.Acknowledged();
```

##### Extend Session

Extend a session's expiry time so the session remains open

```csharp
var request = await dappClient.Extend(sessionTopic);
await request.Acknowledged();
```

##### Ping

Send a ping to the session

```csharp
var request = await dappClient.Ping(sessionTopic);
await request.Acknowledged();
```

#### Session Requests

Sending session requests as a dapp requires to build the request **and** response classes that the session request `params` will be structured. C# is a statically typed language, so these types must be given whenever you do a session request (or do any querying for session requests).

Currently, **WalletConnectSharp does not automatically assume the object type for `params` is an array**. This is very important, since most EVM RPC requests have `params` as an array type. **Use `List<T>` to workaround this**. For example, for `eth_sendTransaction`, use `List<Transaction>` instead of `Transaction`.

Newtonsoft.Json is used for JSON serialization/deserialization, therefore you can use Newtonsoft.Json attributes when defining fields in your request/response classes.

##### Building a Request type

Create a class for the request and populate it with the JSON properties the request object has. For this example, we will use `eth_sendTransaction`

The `params` field for `eth_sendTransaction` has the object type

```csharp
using Newtonsoft.Json;

public class Transaction
{
    public string from;

    // Newtonsoft.Json attributes can be used
    [JsonProperty("to")]
    public string To;

    [JsonProperty("gas", NullValueHandling = NullValueHandling.Ignore)]
    public string Gas;

    // Properties have limited support
    [JsonProperty("gasPrice", NullValueHandling = NullValueHandling.Ignore)]
    public string GasPrice { get; set; }

    [JsonProperty("value")]
    public string Value { get; set; }

    [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
    public string Data { get; set; } = "0x";
}
```

<Info>

[the `params` field is an array of this object](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)

</Info>

```json
params: [
  {
    from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
    to: "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
    gas: "0x76c0", // 30400
    gasPrice: "0x9184e72a000", // 10000000000000
    value: "0x9184e72a", // 2441406250
    data: "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",
  },
]
```

Now, let's define the actual request class we'll use in `dappClient.Request`

```csharp
[RpcMethod("eth_sendTransaction"), RpcRequestOptions(Clock.ONE_MINUTE, 99997)]
public class EthSendTransaction : List<Transaction>
{
    public EthSendTransaction(params Transaction[] transactions) : base(transactions)
    {
    }
}
```

The `RpcMethod` class attributes defines the rpc method this request uses. The `RpcRequestOptions` class attributes define the expiry time and tag attached to the request. **Both of these attributes are required**

We use `List<Transaction>` since the `params` field for `eth_sendTransaction` is actually sent as an object array. If the `params` field was a normal object, then we could use `Transaction` or define the fields directly into this class.

##### Sending a request

The response type for `eth_sendTransaction` is a `string`, so no response type is required to be made. You only need to create a response type if the response type is a custom object.

```csharp
var wallet = GetCurrentAddress();
var result = new EthSendTransaction(new Transaction()
{
    From = wallet.Address,
    To = wallet.Address,
    Value = "0"
});

// Returns the transaction hash or throws an error
string result = await dappClient.Request<EthSendTransaction, string>(sessionTopic, request, wallet.ChainId);
```

#### Disconnecting

To disconnect a session, use the `Disconnect` function. You may optional provide a reason for the disconnect

```csharp
await dappClient.Disconnect(sessionTopic);

// or

await dappClient.Disconnect(sessionTopic, Error.FromErrorType(ErrorType.USER_DISCONNECTED));
```

#### Subscribe to session events

```csharp
dappClient.SubscribeToSessionEvent("chainChanged", OnChainChanged);
```

</Tab>

<Tab title="Unity">

WalletConnectUnity is a wrapper for WalletConnectSharp. It simplifies managing a single active session, addressing a common challenge with the original library.

#### Features of WalletConnectUnity

1. **Simplified Session Management**: WalletConnectSharp is designed to support multiple sessions, requiring developers to manually track and restore the active session. WalletConnectUnity simplifies this process by focusing on a single session, making it easier to manage session restoration.

2. **Session Restoration**: WalletConnectUnity includes methods to easily access and restore the active session from storage.

3. **Deep Linking Support**: WalletConnectUnity automatically handles deep linking for mobile and desktop wallets.

4. **QR Code Generation**: WalletConnectUnity provides a utility for generating QR codes.

#### Usage

To use WalletConnectUnity in your project:

1. Fill in the Project ID and Metadata fields in the `Assets/WalletConnectUnity/Resources/WalletConnectProjectConfig` asset.
   - If you don’t have a Project ID, you can create one at [Reown Cloud](https://cloud.reown.com).
   - The `Redirect` fields are optional. They are used to redirect the user back to your app after they approve or reject the session.
2. Initialize `WalletConnect` and connect the wallet:

```csharp
// Initialize singleton
await WalletConnect.Instance.InitializeAsync();

// Or handle instancing manually
var walletConnectUnity = new WalletConnect();
await walletConnectUnity.InitializeAsync();

// Try to resume the last session
var sessionResumed = await WalletConnect.Instance.TryResumeSessionAsync();
if (!sessionResumed)
{
    var connectedData = await WalletConnect.Instance.ConnectAsync(connectOptions);

    // Create QR code texture
    var texture = WalletConnectUnity.Core.Utils.QRCode.EncodeTexture(connectedData.Uri);

    // ... Display QR code texture

    // Wait for wallet approval
    await connectedData.Approval;
}
```

All features of WalletConnectSharp are accessible in WalletConnectUnity.
For complex scenarios, the `SignClient` can be accessed directly through `WalletConnect.SignClient`.

Refer to the `.NET` documentation for details on using the Sign API within WalletConnectUnity.
The usage of the WalletConnectSharp.Sign API remains consistent with `.NET`.

</Tab>

</Tabs>
</file>

<file path="advanced/api/sign/overview.mdx">
---
title: "Introduction"
---

import CloudBanner from "/snippets/cloud-banner.mdx";

WalletConnect Sign is a remote signer protocol to communicate securely between web3 wallets and dapps. The protocol establishes a remote pairing between two apps and/or devices using a Relay server to relay payloads. These payloads are symmetrically encrypted through a shared key between the two peers. The pairing is initiated by one peer displaying a QR Code or deep link with a standard WalletConnect URI and is established when the counter-party approves this pairing request.

<CloudBanner />

## Installation

<Tabs>

<Tab title="Web">

<CodeGroup>
  ```bash npm npm install @walletconnect/sign-client ``` ```bash Yarn yarn add
  @walletconnect/sign-client ``` ```bash Bun bun add @walletconnect/sign-client
  ``` ```bash pnpm pnpm add @walletconnect/sign-client ```
</CodeGroup>

<Note>

For Node.js, the WalletConnect SignClient additionally requires `lokijs` to manage storage internally.

</Note>

<CodeGroup>
  ```bash npm npm install --save @walletconnect/sign-client lokijs@1.x ```
  ```bash Yarn yarn add @walletconnect/sign-client lokijs@1.x ``` ```bash Bun
  bun add --save @walletconnect/sign-client lokijs@1.x ``` ```bash pnpm pnpm add
  @walletconnect/sign-client lokijs@1.x ```
</CodeGroup>

</Tab>

<Tab title="iOS">
  <Tabs
queryString="ios-method"
	values={[
		{ label: 'SwiftPackageManager', value: 'spm', },
		{ label: 'Cocoapods', value: 'cocoa', },
	]}
>
<Tab title="SwiftPackageManager">

You can add a WalletConnect SDK to your project with Swift Package Manager. In order to do that:

1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub URL: https://github.com/reown-com/reown-swift
4. Tap Add Package
5. Select WalletConnect check mark

</Tab>
<Tab title="Cocoapods">

1. Update Cocoapods spec repos. Type in terminal `pod repo update`
2. Initialize Podfile if needed with `pod init`
3. Add pod to your Podfile:

```ruby
pod 'WalletConnectSwiftV2'
```

4. Install pods with `pod install`

If you encounter any problems during package installation, you can specify the exact path to the repository

```ruby
pod 'WalletConnectSwiftV2', :git => 'https://github.com/reown-com/reown-swift.git', :tag => '1.0.5'
```

</Tab>
</Tabs>
</Tab>

<Tab title="Android">
Kotlin implementation of WalletConnect v2 Sign protocol for Android applications. This SDK is developed in Kotlin and usable in both Java and Kotlin files.

- Android Core ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/android-core)
- Sign ![Maven Central](https://img.shields.io/maven-central/v/com.walletconnect/sign)

#### Requirements

- Android min SDK 23
- Java 11

#### Installation

root/build.gradle.kts:

```gradle
allprojects {
 repositories {
    mavenCentral()
    maven { url "https://jitpack.io" }
 }
}
```

app/build.gradle.kts

```gradle
implementation("com.walletconnect:android-core:release_version")
implementation("com.walletconnect:sign:release_version")
```

</Tab>

<Tab title="Flutter">
Install the WalletConnect client package.

```dart
flutter pub add walletconnect_flutter_v2
```

#### Platform Specific Setup

Depending on your platform, you will have to add different permissions to get the package to work.

#### MacOS

Add the following to your `DebugProfile.entitlements` and `Release.entitlements` files so that it can connect to the WebSocket server.

```xml
<key>com.apple.security.network.client</key>
<true/>
```

</Tab>

<Tab title=".NET">

#### Install via Packages

Install the WalletConnect Sign Client package via Nuget.

```shell
dotnet add package WalletConnect.Sign
```

</Tab>

<Tab title="Unity">

WalletConnectUnity.Core is a Unity package that provides a client implementation of the WalletConnect v2 protocol. It is built on top of the [WalletConnectSharp.Sign](https://github.com/WalletConnect/WalletConnectSharp) library, which provides the core functionality for the WalletConnect protocol.

#### Prerequisites

- Unity 2021.3 or above
- IL2CPP code stripping level: Minimal (or lower)

#### Package Installation

<Tabs>

<Tab title="OpenUPM CLI">

To install packages via OpenUPM, you need to have [Node.js](https://nodejs.org/en/) and [openupm-cli](https://openupm.com/docs/getting-started.html#installing-openupm-cli) installed. Once you have them installed, you can run the following commands:

```bash
openupm add com.walletconnect.core
```

</Tab>

<Tab title="Package Manager with OpenUPM">

1. Open `Advanced Project Settings` from the gear ⚙ menu located at the top right of the Package Manager’s toolbar
2. Add a new scoped registry with the following details:
   - Name: `OpenUPM`
   - URL: `https://package.openupm.com`
   - Scope(s): `com.walletconnect`
3. Press plus ➕ and then `Save` buttons
4. In the Package Manager windows open the add ➕ menu from the toolbar
5. Select `Add package by name...`
6. Enter the package name:
   - `com.walletconnect.core`
7. Press `Add` button

</Tab>

<Tab title="Package Manager with Git URL">

1. Open the add ➕ menu in the Package Manager’s toolbar
2. Select `Add package from git URL...`
3. Enter the package URL:

**WalletConnectUnity Core**

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core
```

4. Press `Add` button

It's possible to lock the version of the package by adding `#{version}` at the end of the git URL, where `#{version}` is the git tag of the version you want to use.
For example, to install version `1.0.1` of WalletConnectUnity Modal, use the following URL:

```
https://github.com/WalletConnect/WalletConnectUnity.git?path=Packages/com.walletconnect.core#core/1.0.1
```

</Tab>
</Tabs>

#### WebGL

Due to WebGL's single-threaded nature, certain asynchronous operations like `Task.Run`, `Task.ContinueWith`, `Task.Delay`, and `ConfigureAwait(false)` are not natively supported.

To enable these operations in WebGL builds, an additional third-party package, [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher), is required. This package modifies the Unity WebGL build to delegate work to the `SynchronizationContext`, allowing these operations to be executed on the same thread without blocking the main application. Please note that all tasks are still executed on a single thread, and any blocking calls will freeze the entire application.

The [WebGLThreadingPatcher](https://github.com/VolodymyrBS/WebGLThreadingPatcher) package can be added via git URL:

```
https://github.com/VolodymyrBS/WebGLThreadingPatcher.git
```

</Tab>

</Tabs>
</file>

<file path="advanced/api/sign/smart-contract-wallet-usage.mdx">
---
title: "Smart Contract Wallet Usage"
---

<Note>
  This section is limited to just for Web/JavaScript at the present moment
</Note>

Smart Contract wallets like [Argent](https://argent.gitbook.io/argent/wallet-connect-and-argent) are fully supported by the WalletConnect protocol.

However, there are some considerations to be taken when integrating WalletConnect in your dapp for Smart Contract wallets, regarding how the accounts are exposed in the session, message signatures are returned, and transactions are broadcasted.

<Tabs>

<Tab title="Web">

### Accounts

<Tip>
  When you connect your dapp to a smart contract wallet, you will receive the
  **smart account address** for the wallet. This is not to be confused with the
  **delegate keys** that are used to sign messages and transactions.
</Tip>

You can detect smart contract wallets by verifying on-chain if the exposed account address has any associated code deployed.

<Tabs>
<Tab title="ethers.js">

```javascript
import { providers, utils } from "ethers";

const provider = new providers.JsonRpcProvider(rpcUrl);

const bytecode = await provider.getCode(address);

const isSmartContract = bytecode && utils.hexStripZeros(bytecode) !== "0x";
```

</Tab>
<Tab title="web3.js">

```javascript
import Web3 from "web3";

const web3 = new Web3(rpcUrl);

const bytecode = await web3.eth.getCode(address);

const isSmartContract = bytecode && utils.hexStripZeros(bytecode) !== "0x";
```

</Tab>
</Tabs>

Smart contract wallets are essentially multi-signature wallets that use multiple keys to authorize operations on behalf of these smart contract accounts, so you will have to take into consideration how messages and transactions are handled by your dapp.

## Messages

Normally, when verifying signatures from "normal" accounts, which are Externally Owned Accounts (EOAs), you would use an ECDSA method called `ecrecover()` to retrieve the corresponding public key, which will then map to an address.

In the case of Smart Contract Wallets, you are not able to sign a message with the smart contract account. Therefore, the standard [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) was defined to outline a validation method which can be called on-chain, labeled `isValidSignature()`.

```text
contract ERC1271 {
  bytes4 constant internal MAGICVALUE = 0x1626ba7e;

  function isValidSignature(
    bytes32 _hash,
    bytes memory _signature
  )
    public
    view
    returns (bytes4 magicValue);
}
```

This method has a single parameter `_hash` which should be [EIP-191](https://eips.ethereum.org/EIPS/eip-191) compliant and can be computed using:

<Tabs>
<Tab title="ethers.js">

```javascript
import { utils } from "ethers";

const hash = utils.hashMessage(message);
```

</Tab>
<Tab title="web3.js">

```javascript
import Web3 from "web3";

const web3 = new Web3(rpcUrl);

const hash = web3.eth.accounts.hashMessage(message);
```

</Tab>
</Tabs>

## Transactions

Smart Contract wallets, like [Argent](https://argent.gitbook.io/argent/wallet-connect-and-argent), commonly use the concept of meta transactions. These are a specific type of transaction that is signed by one or more key pairs but is submitted to the Ethereum network by a relayer.

The relayer pays the gas fee (in ETH), and the wallet will refund the relayer (in ETH or ERC20 tokens) up to an amount signed by the wallet's owner.

From your dapp's perspective, this is managed by the mobile wallet application. Your dapp will submit a regular `{ to, value, data }` transaction to the web3 provider. This transaction will be transmitted to the mobile wallet application through WalletConnect.

The mobile wallet will transform the data into a meta transaction:

- `to` will be the `RelayerManager` contract address
- `data` will be the encoded data of the call to the `execute()` method with the relevant parameters

Your dapp will receive the transaction hash in order to monitor the status of the transaction, and events will be emitted as usual.

The relayer has the ability to replay a transaction with a higher gas price due to fluctuating network conditions. The transaction hash is modified, and the dapp will not be aware of the new transaction hash.

One solution could be for your dapp to observe a specific event being emitted instead of the transaction status. There is currently work on standardizing events for transactions replies that has been recently proposed via [EIP-2831](https://eips.ethereum.org/EIPS/eip-2831). We hope to improve our SDKs in the future to take this standard into account.

</Tab>
</Tabs>
</file>

<file path="advanced/api/sign/wallet-usage.mdx">
---
title: "Wallet Usage"
---

import CloudBanner from "/snippets/cloud-banner.mdx";

Sign API establishes a session between a wallet and a dapp in order to expose a set of blockchain accounts that can sign transactions or messages using a secure remote JSON-RPC transport with methods and events.

<CloudBanner />
<Tabs>

<Tab title="Web">

<Note>
  This library is compatible with Node.js, browsers and React Native
  applications (Node.js modules require polyfills for React Native).
</Note>

#### Migrating from v1.x

**We recommend you install v1 and v2 together for maximum compatibility.** If your wallet already uses `@walletconnect/client@1.x.x`,
you should be able to add `@walletconnect/sign-client@2.x.x` without any issues.

If you experience dependency clashes or you require both `@walletconnect/types@1.x.x` and `@walletconnect/types@2.x.x` in parallel
in your wallet's top-level dependencies, please refer to the [`legacy` packages](https://github.com/WalletConnect/walletconnect-legacy/tree/main/packages) which were published explicitly for this purpose.

In the above scenario, you would replace `@walletconnect/types@1.x.x` with `@walletconnect/legacy-types` and then install `@walletconnect/types@2.x.x`.

#### Initializing the client

Initialize client as a controller using [your Project ID](../../cloud/relay).

```js
const signClient = await SignClient.init({
  projectId: "<YOUR PROJECT ID>",
  // optional parameters
  relayUrl: "<YOUR RELAY URL>",
  metadata: {
    name: "Wallet name",
    description: "A short description for your wallet",
    url: "<YOUR WALLET'S URL>",
    icons: ["<URL TO WALLET'S LOGO/ICON>"],
  },
});
```

#### Setting up event listeners

WalletConnect v2.0 emits events related to the current session. The listeners listed in the following code snippet represent typical
events in a session's lifecycle that you can listen for to synchronise your application accordingly.

Example: when a `session_delete` event is emitted, it makes sense to change the UI from an active session state to
an inactive/disconnected state.

**1. Add listeners for desired `SignClient` events.**

<Note>
  To listen to pairing-related events, please follow the guidance for [Pairing
  API event listeners.](../core/pairing)
</Note>

```ts
signClient.on("session_proposal", (event) => {
  // Show session proposal data to the user i.e. in a modal with options to approve / reject it

  interface Event {
    id: number;
    params: {
      id: number;
      expiry: number;
      relays: Array<{
        protocol: string;
        data?: string;
      }>;
      proposer: {
        publicKey: string;
        metadata: {
          name: string;
          description: string;
          url: string;
          icons: string[];
        };
      };
      requiredNamespaces: Record<
        string,
        {
          chains: string[];
          methods: string[];
          events: string[];
        }
      >;
      pairingTopic?: string;
    };
  }
});

signClient.on("session_event", (event) => {
  // Handle session events, such as "chainChanged", "accountsChanged", etc.

  interface Event {
    id: number;
    topic: string;
    params: {
      event: {
        name: string;
        data: any;
      };
      chainId: string;
    };
  }
});

signClient.on("session_request", (event) => {
  // Handle session method requests, such as "eth_sign", "eth_sendTransaction", etc.

  interface Event {
    id: number;
    topic: string;
    params: {
      request: {
        method: string;
        params: any;
      };
      chainId: string;
    };
  }
});

signClient.on("session_ping", (event) => {
  // React to session ping event

  interface Event {
    id: number;
    topic: string;
  }
});

signClient.on("session_delete", (event) => {
  // React to session delete event

  interface Event {
    id: number;
    topic: string;
  }
});
```

# Pairing and session permissions

#### URI

The pairing proposal between a wallet and a dapp is made using an [URI](https://specs.walletconnect.com/2.0/specs/clients/core/pairing/). In WalletConnect v2.0 the session and pairing are decoupled from each other. This means that a URI is shared to construct a pairing proposal, and only after settling the pairing the dapp can propose a session using that pairing. In simpler words, the dapp generates an URI that can be used by the wallet for pairing.

#### Namespaces

The `namespaces` parameter is used to specify the namespaces and chains that are intended to be used in the session. The following is an example:

```js
namespaces: {
  eip155: {
    accounts: ["eip155:1:0x0000000000..., eip155:2:0x0000000000..."],
    methods: ["personal_sign", "eth_sendTransaction"],
    events: ["accountsChanged"]
  },
};
```

#### Pairing with `uri`

To create a pairing proposal, simply pass the `uri` received from the dapp into the `signClient.core.pairing.pair()` function.

<Warning>
As of 2.0.0 (stable), calling pairing-specific methods (such as `signClient.pair()`) directly on `signClient` will continue to work, but is considered deprecated and will be removed in a future major version.

It is recommended to instead call these methods directly via the [Pairing API.](../core//pairing), e.g.: `signClient.core.pairing.pair()`.

</Warning>

```js
// This will trigger the `session_proposal` event
await signClient.core.pairing.pair({ uri });

// Approve session proposal, use id from session proposal event and respond with namespace(s) that satisfy dapps request and contain approved accounts
const { topic, acknowledged } = await signClient.approve({
  id: 123,
  namespaces: {
    eip155: {
      accounts: ["eip155:1:0x0000000000..."],
      methods: ["personal_sign", "eth_sendTransaction"],
      events: ["accountsChanged"],
    },
  },
});

// Optionally await acknowledgement from dapp
const session = await acknowledged();

// Or reject session proposal
await signClient.reject({
  id: 123,
  reason: {
    code: 1,
    message: "rejected",
  },
});
```

#### Pairing with QR Codes

To facilitate better user experience, it is possible to pair wallets with dapps by scanning QR codes. This can be implemented by using any QR code scanning library (example, [react-qr-reader](https://www.npmjs.com/package/react-qr-reader)). After scanning the QR code, pass the obtained `uri` into the `signClient.pair()` function. A useful reference for implementing QR codes for pairing is the [react wallet example](https://github.com/WalletConnect/web-examples/blob/main/advanced/wallets/react-wallet-v2/).

## Authenticated Session

This section outlines an innovative protocol method that facilitates the initiation of a Sign session and the authentication of a wallet through a Sign-In with Ethereum (SIWE) message, enhanced by ReCaps (ReCap Capabilities). This enhancement not only offers immediate authentication for dApps, paving the way for prompt user logins, but also integrates informed consent for authorization. Through this mechanism, dApps can request the delegation of specific capabilities to perform actions on behalf of the wallet user. These capabilities, encapsulated within SIWE messages as ReCap URIs, detail the scope of actions authorized by the user in an explicit and human-readable form.

By incorporating ReCaps, this method extends the utility of SIWE messages, allowing dApps to combine authentication with a nuanced authorization model. This model specifies the actions a dApp is authorized to execute on the user's behalf, enhancing security and user autonomy by providing clear consent for each delegated capability. As a result, dApps can utilize these consent-backed messages to perform predetermined actions, significantly enriching the interaction between dApps, wallets, and users within the Ethereum ecosystem.

#### Handling Authentication Requests

To handle incoming authentication requests, subscribe to the `session_authenticate` event. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```typescript
walletKit.on("session_authenticate", async (payload) => {
  // Process the authentication request here.
  // Steps include:
  // 1. Populate the authentication payload with the supported chains and methods
  // 2. Format the authentication message using the payload and the user's account
  // 3. Present the authentication message to the user
  // 4. Sign the authentication message(s) to create a verifiable authentication object(s)
  // 5. Approve the authentication request with the authentication object(s)
});
```

#### Populate Authentication Payload

```typescript
import { populateAuthPayload } from "@walletconnect/utils";

// EVM chains that your wallet supports
const supportedChains = ["eip155:1", "eip155:2", 'eip155:137'];
// EVM methods that your wallet supports
const supportedMethods = ["personal_sign", "eth_sendTransaction", "eth_signTypedData"];
// Populate the authentication payload with the supported chains and methods
const authPayload = populateAuthPayload({
  authPayload: payload.params.authPayload,
  chains: supportedChains,
  methods: supportedMethods,
});
// Prepare the user's address in CAIP10(https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md) format
const iss = `eip155:1:0x0Df6d2a56F90e8592B4FfEd587dB3D5F5ED9d6ef`;
// Now you can use the authPayload to format the authentication message
const message = walletKit.formatAuthMessage({
  request: authPayload,
  iss
});

// Present the authentication message to the user
...
```

#### Approving Authentication Requests

<Note>
**Note**

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

</Note>

```typescript
// Approach 1
// Sign the authentication message(s) to create a verifiable authentication object(s)
const signature = await cryptoWallet.signMessage(message, privateKey);
// Build the authentication object(s)
const auth = buildAuthObject(
  authPayload,
  {
    t: "eip191",
    s: signature,
  },
  iss
);

// Approve
await walletKit.approveSessionAuthenticate({
  id: payload.id,
  auths: [auth],
});

// Approach 2
// Note that you can also sign multiple messages for every requested chain/address pair
const auths = [];
authPayload.chains.forEach(async (chain) => {
  const message = walletKit.formatAuthMessage({
    request: authPayload,
    iss: `${chain}:${cryptoWallet.address}`,
  });
  const signature = await cryptoWallet.signMessage(message);
  const auth = buildAuthObject(
    authPayload,
    {
      t: "eip191", // signature type
      s: signature,
    },
    `${chain}:${cryptoWallet.address}`
  );
  auths.push(auth);
});

// Approve
await walletKit.approveSessionAuthenticate({
  id: payload.id,
  auths,
});
```

#### Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```typescript
import { getSdkError } from "@walletconnect/utils";

await walletKit.rejectSessionAuthenticate({
  id: payload.id,
  reason: getSdkError("USER_REJECTED"), // or choose a different reason if applicable
});
```

</Tab>

<Tab title="iOS">

#### Configure Networking and Pair Clients

Confirm you have configured the Network and Pair Client first

- [Networking](/advanced/api/core/relay)
- [Pairing](/advanced/api/core/pairing)

#### Configure Sign Client

In order to initialize a client, call a `configure` method on the Sign instance

```swift
Sign.configure(crypto: CryptoProvider)
```

#### Subscribe for Sign Publishers

The following publishers are available to subscribe:

```swift
public var sessionsPublisher: AnyPublisher<[Session], Never>
public var sessionProposalPublisher: AnyPublisher<(proposal: Session.Proposal, context: VerifyContext?), Never>
public var sessionRequestPublisher: AnyPublisher<(request: Request, context: VerifyContext?), Never>
public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never>
public var sessionSettlePublisher: AnyPublisher<Session, Never>
public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never>
public var sessionResponsePublisher: AnyPublisher<Response, Never>
public var sessionRejectionPublisher: AnyPublisher<(Session.Proposal, Reason), Never>
public var sessionUpdatePublisher: AnyPublisher<(sessionTopic: String, namespaces: [String : SessionNamespace]), Never>
public var sessionEventPublisher: AnyPublisher<(event: Session.Event, sessionTopic: String, chainId: Blockchain?), Never>
public var sessionUpdateExpiryPublisher: AnyPublisher<(sessionTopic: String, expiry: Date), Never>
```

#### Connect Clients

Your Wallet should allow users to scan a QR code generated by dapps. You are responsible for implementing it on your own.
For testing, you can use our test dapp at: https://react-app.walletconnect.com/, which is v2 protocol compliant.
Once you derive a URI from the QR code call `pair` method:

```swift
try await Pair.instance.pair(uri: uri)
```

if everything goes well, you should handle following event:

```swift
Sign.instance.sessionProposalPublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] session in
        self?.verifyDapp(session.context)
        self?.showSessionProposal(session.proposal)
    }.store(in: &publishers)
```

Session proposal is a handshake sent by a dapp and it's purpose is to define a session rules. Handshake procedure is defined by [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md).
`Session.Proposal` object conveys set of required `ProposalNamespaces` that contains required blockchains methods and events. Dapp requests with methods and wallet will emit events defined in namespaces.

`VerifyContext` provides a domain verification information about `Session.Proposal` and `Request`. It consists of origin of a Dapp from where the request has been sent, validation enum that says whether origin is **unknown**, **valid** or **invalid** and verify URL server.

To enable or disable verification find the **Verify SDK** toggle in your project [cloud](https://cloud.reown.com).

```swift
public struct VerifyContext: Equatable, Hashable {
   public enum ValidationStatus {
       case unknown
       case valid
       case invalid
   }

   public let origin: String?
   public let validation: ValidationStatus
   public let verifyUrl: String
}
```

The user will either approve the session proposal (with session namespaces) or reject it. Session namespaces must at least contain requested methods, events and accounts associated with proposed blockchains.

Accounts must be provided according to [CAIP10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md) specification and be prefixed with a chain identifier. chain_id + : + account_address. You can find more on blockchain identifiers in [CAIP2](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md). Our `Account` type meets the criteria.

```
let account = Account("eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!
```

Accounts sent in session approval must at least match all requested blockchains.

Example proposal namespaces request:

```json
{
  "eip155": {
    "chains": ["eip155:137", "eip155:1"],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "chains": ["cosmos:cosmoshub-4"],
    "methods": ["cosmos_signDirect"],
    "events": ["someCosmosEvent"]
  }
}
```

Example session namespaces response:

```json
{
  "eip155": {
    "accounts": [
      "eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb",
      "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb"
    ],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "accounts": [
      "cosmos:cosmoshub-4:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0"
    ],
    "methods": ["cosmos_signDirect", "personal_sign"],
    "events": ["someCosmosEvent", "proofFinalized"]
  }
}
```

#### 💡 AutoNamespaces Builder Utility

`AutoNamespaces` is a helper utility that greatly reduces the complexity of parsing the required and optional namespaces. It accepts as parameters a session proposal along with your user's chains/methods/events/accounts and returns ready-to-use `SessionNamespace` object.

```swift
public static func build(
    sessionProposal: Session.Proposal,
    chains: [Blockchain],
    methods: [String],
    events: [String],
    accounts: [Account]
) throws -> [String: SessionNamespace]
```

Example usage

```swift
do {
    let sessionNamespaces = try AutoNamespaces.build(
        sessionProposal: proposal,
        chains: [Blockchain("eip155:1")!, Blockchain("eip155:137")!],
        methods: ["eth_sendTransaction", "personal_sign"],
        events: ["accountsChanged", "chainChanged"],
        accounts: [
            Account(blockchain: Blockchain("eip155:1")!, address: "0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!,
            Account(blockchain: Blockchain("eip155:137")!, address: "0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!
        ]
    )
    try await Sign.instance.approve(proposalId: proposal.id, namespaces: sessionNamespaces)
} catch {
    print(error)
}
```

#### Approve Session

```swift
 Sign.instance.approve(
    proposalId: "proposal_id",
    namespaces: sessionNamespaces
)
```

#### Reject Session

```swift
Sign.instance.reject(
    proposalId: "proposal_id",
    reason: .userRejected
)
```

When session is successfully approved `sessionSettlePublisher` will publish a `Session`

```swift
Sign.instance.sessionSettlePublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] _ in
        self?.reloadSessions()
    }.store(in: &publishers)
```

`Session` object represents an active session connection with a dapp. It contains dapp’s metadata (that you may want to use for displaying an active session to the user), namespaces, and expiry date. There is also a topic property that you will use for linking requests with related sessions.

You can always query settled sessions from the client later with:

```swift
Sign.instance.getSessions()
```

#### Track Sessions

When your `Sign` instance receives requests from a peer it will publish a related event. Set a subscription to handle them.

To track sessions subscribe to `sessionsPublisher` publisher

```swift
Sign.instance.sessionsPublisher
    .receive(on: DispatchQueue.main)
    .sink { [self self] (sessions: [Session]) in
        // Reload UI
    }.store(in: &publishers)
```

#### Handle Requests from Dapp

After the session is established, a dapp will request your wallet's users to sign a transaction or a message. Requests will be delivered by the following publisher.

```swift
Sign.instance.sessionRequestPublisher
    .receive(on: DispatchQueue.main)
    .sink { [weak self] session in
        self?.verifyDapp(session.context)
        self?.showSessionRequest(session.request)
    }.store(in: &publishers)
```

When a wallet receives a session request, you probably want to show it to the user. It’s method will be in scope of session namespaces. And it’s params are represented by `AnyCodable` type. An expected object can be derived as follows:

```swift
if sessionRequest.method == "personal_sign" {
    let params = try! sessionRequest.params.get([String].self)
} else if method == "eth_signTypedData" {
    let params = try! sessionRequest.params.get([String].self)
} else if method == "eth_sendTransaction" {
    let params = try! sessionRequest.params.get([EthereumTransaction].self)
}
```

Now, your wallet (as it owns your user’s private keys) is responsible for signing the transaction. After doing it, you can send a response to a dapp.

```swift
let response: AnyCodable = sign(request: sessionRequest) // Implement your signing method
try await Sign.instance.respond(topic: request.topic, requestId: request.id, response: .response(response))
```

#### Update Session

If you want to update user session's chains, accounts, methods or events you can use session update method.

```swift
try await Sign.instance.update(topic: session.topic, namespaces: newNamespaces)
```

#### Extend Session

By default, session lifetime is set for 7 days and after that time user's session will expire. But if you consider that a session should be extended you can call:

```swift
try await Sign.instance.extend(topic: session.topic)
```

above method will extend a user's session to a week.

#### Disconnect Session

For good user experience your wallet should allow users to disconnect unwanted sessions. In order to terminate a session use `disconnect` method.

```swift
try await Sign.instance.disconnect(topic: session.topic)
```

### Authenticated Session

An authenticated session represents a secure connection established between a wallet and a dApp after successful authentication.

#### Handling Authentication Requests

To handle incoming authentication requests, subscribe to the authenticateRequestPublisher. This will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```swift
Sign.instance.authenticateRequestPublisher
    .receive(on: DispatchQueue.main)
    .sink { result in
        // Process the authentication request here.
        // This involves displaying UI to the user.
    }
    .store(in: &subscriptions) // Assuming `subscriptions` is where you store your Combine subscriptions.
```

#### Building Authentication Objects

To interact with authentication requests, first build authentication objects (AuthObject). These objects are crucial for approving authentication requests. This involves:

**Creating an Authentication Payload** - Generate an authentication payload that matches your application's supported chains and methods.
**Formatting Authentication Messages** - Format the authentication message using the payload and the user's account.
**Signing the Authentication Message** - Sign the formatted message to create a verifiable authentication object.

Example Implementation:

```swift
func buildAuthObjects(request: AuthenticationRequest, account: Account, privateKey: String) throws -> [AuthObject] {
    let requestedChains = Set(request.payload.chains.compactMap { Blockchain($0) })
    let supportedChains: Set<Blockchain> = [Blockchain("eip155:1")!, Blockchain("eip155:137")!, Blockchain("eip155:69")!]
    let commonChains = requestedChains.intersection(supportedChains)
    let supportedMethods = ["personal_sign", "eth_sendTransaction"]

    var authObjects = [AuthObject]()
    for chain in commonChains {
        let accountForChain = Account(blockchain: chain, address: account.address)!
        let supportedAuthPayload = try Sign.instance.buildAuthPayload(
            payload: request.payload,
            supportedEVMChains: Array(commonChains),
            supportedMethods: supportedMethods
        )
        let formattedMessage = try Sign.instance.formatAuthMessage(payload: supportedAuthPayload, account: accountForChain)
        let signature = // Assume `signMessage` is a function you've implemented to sign messages.
            signMessage(message: formattedMessage, privateKey: privateKey)

        let authObject = try Sign.instance.buildSignedAuthObject(
            authPayload: supportedAuthPayload,
            signature: signature,
            account: accountForChain
        )
        authObjects.append(authObject)
    }
    return authObjects
}

```

#### Approving Authentication Requests

To approve an authentication request, construct AuthObject instances for each supported blockchain, sign the authentication messages, build AuthObjects and call approveSessionAuthenticate with the request ID and the authentication objects.

```swift
let session = try await Sign.instance.approveSessionAuthenticate(requestId: requestId, auths: authObjects)
```

<Note>
**Note**

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

</Note>

#### Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectSession method.

```swift
try await Sign.instance.rejectSession(requestId: requestId)
```

#### Where to go from here

- Try our example wallet implementation [here](https://github.com/reown-com/reown-swift/tree/main/Example/WalletApp).
  {/* <!-- - To dive deeper into protocol concepts check out our [documentation](https://docs.walletconnect.com/protocol/glossary) --> */}
- Build API documentation in XCode: go to Product -> Build Documentation

</Tab>

<Tab title="Android">

#### **Initialization**

```kotlin
val projectId = "" // Get Project ID at https://cloud.reown.com/
val connectionType = ConnectionType.AUTOMATIC or ConnectionType.MANUAL
val appMetaData = Core.Model.AppMetaData(
    name = "Wallet Name",
    description = "Wallet Description",
    url = "Wallet URL",
    icons = /*list of icon url strings*/,
    redirect = "kotlin-wallet-wc:/request" // Custom Redirect URI
)

CoreClient.initialize(projectId = projectId, connectionType = connectionType, application = this, metaData = appMetaData)

val init = Sign.Params.Init(core = CoreClient)

SignClient.initialize(init) { error ->
    // Error will be thrown if there's an issue during initialization
}
```

The wallet client will always be responsible for exposing accounts (CAPI10 compatible) to a Dapp and therefore is also in charge of signing.
To initialize the Sign client, create a `Sign.Params.Init` object in the Android Application class with the Core Client. The `Sign.Params.Init` object will then be passed to the `SignClient`initialize function.

# **Wallet**

#### **SignClient.WalletDelegate**

```kotlin
val walletDelegate = object : SignClient.WalletDelegate {
    override fun onSessionProposal(sessionProposal: Sign.Model.SessionProposal, verifyContext: Sign.Model.VerifyContext) {
        // Triggered when wallet receives the session proposal sent by a Dapp
    }

    val onSessionAuthenticate: ((Sign.Model.SessionAuthenticate, Sign.Model.VerifyContext) -> Unit)? get() = null
    // Triggered when wallet receives the session authenticate sent by a Dapp

    override fun onSessionRequest(sessionRequest: Sign.Model.SessionRequest, verifyContext: Sign.Model.VerifyContext) {
        // Triggered when a Dapp sends SessionRequest to sign a transaction or a message
    }

    override fun onSessionDelete(deletedSession: Sign.Model.DeletedSession) {
        // Triggered when the session is deleted by the peer
    }

    override fun onSessionSettleResponse(settleSessionResponse: Sign.Model.SettledSessionResponse) {
        // Triggered when wallet receives the session settlement response from Dapp
    }

    override fun onSessionUpdateResponse(sessionUpdateResponse: Sign.Model.SessionUpdateResponse) {
        // Triggered when wallet receives the session update response from Dapp
    }

    override fun onConnectionStateChange(state: Sign.Model.ConnectionState) {
        //Triggered whenever the connection state is changed
    }

    override fun onError(error: Sign.Model.Error) {
        // Triggered whenever there is an issue inside the SDK
    }
}
SignClient.setWalletDelegate(walletDelegate)
```

`Sign.Model.VerifyContext` provides a domain verification information about SessionProposal and SessionRequest. It consists of origin of a Dapp from where the request has been sent, validation Enum that says whether origin is VALID, INVALID or UNKNOWN and verify url server.

```kotlin
data class VerifyContext(
    val id: Long,
    val origin: String,
    val validation: Model.Validation,
    val verifyUrl: String
)

enum class Validation {
    VALID, INVALID, UNKNOWN
}
```

The SignClient needs a `SignClient.WalletDelegate` passed to it for it to be able to expose asynchronous updates sent from the Dapp.

#

#### **Session Approval**

NOTE: addresses provided in `accounts` array should follow [CAPI10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md)
semantics.

```kotlin
val proposerPublicKey: String = /*Proposer publicKey from SessionProposal object*/
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val accounts: List<String> = /*List of accounts on chains*/
val methods: List<String> = /*List of methods that wallet approves*/
val events: List<String> = /*List of events that wallet approves*/
val namespaces: Map<String, Sign.Model.Namespaces.Session> = mapOf(namespace, Sign.Model.Namespaces.Session(accounts, methods, events))

val approveParams: Sign.Params.Approve = Sign.Params.Approve(proposerPublicKey, namespaces)
SignClient.approveSession(approveParams) { error -> /*callback for error while approving a session*/ }
```

To send an approval, pass a Proposer's Public Key along with the map of namespaces to the `SignClient.approveSession` function.

#

#### **Session Rejection**

```kotlin
val proposerPublicKey: String = /*Proposer publicKey from SessionProposal object*/
val rejectionReason: String = /*The reason for rejecting the Session Proposal*/
val rejectionCode: String = /*The code for rejecting the Session Proposal*/
For reference use CAIP-25: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md

val rejectParams: Sign.Params.Reject = Reject(proposerPublicKey, rejectionReason, rejectionCode)
SignClient.rejectSession(rejectParams) { error -> /*callback for error while rejecting a session*/ }
```

To send a rejection for the Session Proposal, pass a proposerPublicKey, rejection reason and rejection code to
the `SignClient.rejectSession` function.

#

#### **Session Disconnect**

```kotlin
val disconnectionReason: String = /*The reason for disconnecting the Session*/
val disconnectionCode: String = /*The code for disconnecting the Session*/
val sessionTopic: String = /*Topic from the Session*/
For reference use CAIP-25: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md
val disconnectParams = Sign.Params.Disconnect(sessionTopic, disconnectionReason, disconnectionCode)

SignClient.disconnect(disconnectParams) { error -> /*callback for error while disconnecting a session*/ }
```

To disconnect from a settled session, pass a disconnection reason with code and the Session topic to the `SignClient.disconnect`
function.

#

#### **Respond Request**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val jsonRpcResponse: Sign.Model.JsonRpcResponse.JsonRpcResult = /*Settled Session Request ID along with request data*/
val result = Sign.Params.Response(sessionTopic = sessionTopic, jsonRpcResponse = jsonRpcResponse)

SignClient.respond(result) { error -> /*callback for error while responding session request*/ }
```

To respond to JSON-RPC method that were sent from Dapps for a session, submit a `Sign.Params.Response` with the session's topic and request
ID along with the respond data to the `SignClient.respond` function.

#### **Reject Request**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val jsonRpcResponseError: Sign.Model.JsonRpcResponse.JsonRpcError = /*Session Request ID along with error code and message*/
val result = Sign.Params.Response(sessionTopic = sessionTopic, jsonRpcResponse = jsonRpcResponseError)

SignClient.respond(result) { error -> /*callback for error while responding session request*/ }
```

To reject a JSON-RPC method that was sent from a Dapps for a session, submit a `Sign.Params.Response` with the settled session's topic and
request ID along with the rejection data to the `SignClient.respond` function.

#

#### **Session Update**

NOTE: addresses provided in `accounts` array should follow [CAIP10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md)
semantics and syntax.

```kotlin
val sessionTopic: String = /*Topic of Session*/
val namespace: String = /*Namespace identifier, see for reference: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md#syntax*/
val accounts: List<String> = /*List of accounts on authorized chains*/
val methods: List<String> = /*List of methods that wallet approves*/
val events: List<String> = /*List of events that wallet approves*/
val namespaces: Map<String, Sign.Model.Namespaces.Session> = mapOf(namespace, Sign.Model.Namespaces.Session(accounts, methods, events))
val updateParams = Sign.Params.Update(sessionTopic, namespaces)

SignClient.update(updateParams) { error -> /*callback for error while sending session update*/ }
```

To update a session with namespaces, use `SignClient.Update` to submit a `Sign.Params.Update` object with the session's topic and updated namespace objects (i.e. adding requesting new methods or events, new accounts on authorized chains, or authorizing new chainIds within a multi-chain namespace).

#

#### **Session Extend**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val extendParams = Sign.Params.Extend(sessionTopic = sessionTopic)

SignClient.extend(extendParams) { error -> /*callback for error while extending a session*/ }
```

To extend a session, create a `Sign.Params.Extend` object with the session's topic to update the session with to `Sign.Extend`. Session is
extended by 7 days.

#### **Session Ping**

```kotlin
val sessionTopic: String = /*Topic of Session*/
val pingParams = Sign.Params.Ping(sessionTopic)
val listener = object : Sign.Listeners.SessionPing {
    override fun onSuccess(pingSuccess: Model.Ping.Success) {
        // Topic being pinged
    }

    override fun onError(pingError: Model.Ping.Error) {
        // Error
    }
}

SignClient.ping(pingParams, listener)
```

To ping a peer with a session, call `SignClient.ping` with the `Sign.Params.Ping` with a session's topic. If ping is successful, topic is
echo'd in listener.

#

#### **Authenticated Session**

An authenticated session represents a secure connection established between a wallet and a dApp after successful authentication.

### Authentication Requests

To handle incoming authentication requests, set up SignClient.WalletDelegate. The onSessionAuthenticate callback will notify you of any authentication requests that need to be processed, allowing you to either approve or reject them based on your application logic.

```kotlin
override val onSessionAuthenticate: ((Wallet.Model.SessionAuthenticate, Wallet.Model.VerifyContext) -> Unit)
  get() = { sessionAuthenticate, verifyContext ->
      // Triggered when wallet receives the session authenticate sent by a Dapp
      // Process the authentication request here
      // This involves displaying UI to the user
}
```

### Responding Authentication Request

To interact with authentication requests, build authentication objects (Sign.Model.Cacao). It involves the following steps:

**Creating an Authentication Payload Params** - Generate an authentication payload params that matches your application's supported chains and methods.
**Formatting Authentication Messages** - Format the authentication message using the payload and the user's account.
**Signing the Authentication Message** - Sign the formatted message to create a verifiable authentication object.

Example:

```kotlin
override val onSessionAuthenticate: ((Wallet.Model.SessionAuthenticate, Wallet.Model.VerifyContext) -> Unit)
  get() = { sessionAuthenticate, verifyContext ->
  val auths = mutableListOf<Sign.Model.Cacao>()

  val authPayloadParams =
    generateAuthPayloadParams(
      sessionAuthenticate.payloadParams,
      supportedChains = listOf("eip155:1", "eip155:137", "eip155:56"), // Note: Only EVM chains are supported
      supportedMethods = listOf("personal_sign", "eth_signTypedData", "eth_sign")
  )

  authPayloadParams.chains.forEach { chain ->
    val issuer = "did:pkh:$chain:$address"
    val formattedMessage = formatAuthMessage(Sign.Params.FormatMessage(authPayloadParams, issuer))

    val signature = signMessage(message: formattedMessage, privateKey: privateKey) //Note: Assume `signMessage` is a function you've implemented to sign messages.
    val auth = generateAuthObject(authPayloadParams, issuer, signature)
    auths.add(auth)
  }
}
```

### Approving Authentication Requests

To approve an authentication request, construct Sign.Model.Cacao instances for each supported chain, sign the authentication messages, build AuthObjects and call approveAuthenticate with the request ID and the authentication objects.

```kotlin
 val approveAuthenticate = Sign.Params.ApproveAuthenticate(id = sessionAuthenticate.id, auths = auths)
SignClient.approveAuthenticate(approveProposal,
  onSuccess = {
    //Redirect back to the dapp if redirect is set: sessionAuthenticate.participant.metadata?.redirect
  },
  onError = { error ->
      //Handle error
  }
)
```

<Note>
**Note**

1. The recommended approach for secure authentication across multiple chains involves signing a SIWE (Sign-In with Ethereum) message for each chain and account. However, at a minimum, one SIWE message must be signed to establish a session. It is possible to create a session for multiple chains with just one issued authentication object.
2. Sometimes a dapp may want to only authenticate the user without creating a session, not every approval will result with a new session.

</Note>

### Rejecting Authentication Requests

If the authentication request cannot be approved or if the user chooses to reject it, use the rejectAuthenticate method.

```kotlin
val rejectParams = Sign.Params.RejectAuthenticate(
    id = sessionAuthenticate.id,
    reason = "Reason"
)

SignClient.rejectAuthenticate(rejectParams,
  onSuccess = {
        //Success
  },
  onError = { error ->
      //Handle error
  }
)
```

</Tab>

<Tab title=".NET">

#### Setup

First you must setup `SignClientOptions` which stores both the `ProjectId` and `Metadata`. You may also optionally specify the storage module to use. By default, the `FileSystemStorage` module is used if none is specified.

```csharp
var walletOptions = new SignClientOptions()
{
    ProjectId = "39f3dc0a2c604ec9885799f9fc5feb7c",
    Metadata = new Metadata()
    {
        Description = "An example wallet to showcase WalletConnectSharpv2",
        Icons = new[] { "https://walletconnect.com/meta/favicon.ico" },
        Name = "WalletConnectSharpv2 Wallet Example",
        Url = "https://walletconnect.com"
    },
    // Uncomment to disable persistent storage
    // Storage = new InMemoryStorage()
};
```

Once you have the options defined, you can initialize the SDK.

```csharp
var walletClient = await WalletConnectSignClient.Init(walletOptions);
```

Wallets can pair an incoming session using the session's Uri. Pairing a session lets the Wallet obtain the connection proposal which can then be approved or denied.

```csharp
ProposalStruct proposal = await walletClient.Pair(connectData.Uri);
```

The wallet can then approve or reject the proposal using either of the following:

```csharp
string addressToConnect = ...;
var approveData = await walletClient.Approve(proposal, addressToConnect);
await approveData.Acknowledged();
```

```csharp
string[] addressesToConnect = ...;
var approveData = await walletClient.Approve(proposal, addressesToConnect);
await approveData.Acknowledged();
```

```csharp
await walletClient.Reject(proposal, "User rejected");
```

#### WalletConnect Methods

All sign methods require the `topic` of the session to be given. This can be found in the `SessionStruct` object given when a session has been given approval by the user.

```csharp
var sessionTopic = sessionData.Topic;
```

##### Update Session

Update a session, adding/removing additional namespaces in the given topic.

```csharp
var newNamespaces = new Namespaces(...);
var request = await walletClient.UpdateSession(sessionTopic, newNamespaces);
await request.Acknowledged();
```

##### Extend Session

Extend a session's expiry time so the session remains open

```csharp
var request = await walletClient.Extend(sessionTopic);
await request.Acknowledged();
```

##### Ping

Send a ping to the session

```csharp
var request = await walletClient.Ping(sessionTopic);
await request.Acknowledged();
```

#### Responding to Session Requests

Responding to session requests is very similar to sending session requests. See dApp usage on how sending session requests works. All custom session requests requires a request class **and** response class to be created that matches the `params` field type in the custom session request. C# is a statically typed language, so these types must be given whenever you do a session request (or do any querying for session requests).

Currently, **WalletConnectSharp does not automatically assume the object type for `params` is an array**. This is very important, since most EVM RPC requests have `params` as an array type. **Use `List<T>` to workaround this**. For example, for `eth_sendTransaction`, use `List<Transaction>` instead of `Transaction`.

Newtonsoft.Json is used for JSON serialization/deserialization, therefore you can use Newtonsoft.Json attributes when defining fields in your request/response classes.

##### Building a Response type

Create a class for the response and populate it with the JSON properties the response object has. For this example, we will use `eth_getTransactionReceipt`

The `params` field for `eth_getTransactionReceipt` has the object type

```csharp
using Newtonsoft.Json;
using System.Numerics;

[RpcMethod("eth_getTransactionReceipt"), RpcRequestOptions(Clock.ONE_MINUTE, 99995)]
public class TransactionReceipt
{
    [JsonProperty("transactionHash")]
    public string TransactionHash;

    [JsonProperty("transactionIndex")]
    public BigInteger TransactionIndex;

    [JsonProperty("blockHash")]
    public string BlockHash;

    [JsonProperty("blockNumber")]
    public BigInteger BlockNumber;

    [JsonProperty("from")]
    public string From;

    [JsonProperty("to")]
    public string To;

    [JsonProperty("cumulativeGasUsed")]
    public BigInteger CumulativeGasUsed;

    [JsonProperty("effectiveGasPrice ")]
    public BigInteger EffectiveGasPrice ;

    [JsonProperty("gasUsed")]
    public BigInteger GasUsed;

    [JsonProperty("contractAddress")]
    public string ContractAddress;

    [JsonProperty("logs")]
    public object[] Logs;

    [JsonProperty("logsBloom")]
    public string LogBloom;

    [JsonProperty("type")]
    public BigInteger Type;

    [JsonProperty("status")]
    public BigInteger Status;
}
```

The `RpcMethod` class attributes defines the rpc method this response uses, this is optional. The `RpcResponseOptions` class attributes define the expiry time and tag attached to the response, **this is required**.

##### Sending a response

To respond to requests from a dApp, you must define the class representing the request object type. The request type for `eth_getTransactionReceipt` is the following:

```csharp
[RpcMethod("eth_getTransactionReceipt"), RpcRequestOptions(Clock.ONE_MINUTE, 99994)]
public class EthGetTransactionReceipt : List<string>
{
    public EthGetTransactionReceipt(params string[] hashes) : base(hashes)
    {
    }
}
```

We can handle the `eth_getTransactionReceipt` session request by doing the following:

```csharp
walletClient.Engine.SessionRequestEvents<EthGetTransactionReceipt, TransactionReceipt>().OnRequest += OnEthTransactionReceiptRequest;

private Task OnEthTransactionReceiptRequest(RequestEventArgs<EthGetTransactionReceipt, TransactionReceipt> e)
{
    // logic for request goes here
    // set e.Response to return a response
}
```

The callback function gets invoked whenever the wallet receives the `eth_getTransactionReceipt` request from a connected dApp. You may optionally filter further which requests are handled using the `FilterRequests` function

```csharp
walletClient.Engine.SessionRequestEvents<EthGetTransactionReceipt, TransactionReceipt>()
    .FilterRequests(r => r.Topic == sessionTopic)
    .OnRequest += OnEthTransactionReceiptRequest;
```

The callback returns a `Task`, so the callback can be made async. To return a response, **you must** set the `Response` field in `RequestEventArgs<T, TR>` with the desired response.

```csharp
private async Task OnEthTransactionReceiptRequest(RequestEventArgs<EthGetTransactionReceipt, TransactionReceipt> e)
{
    var txHash = e.Request.Params[0];
    var receipt = await EthGetTransactionReceipt(txHash);
    e.Response = receipt;
}
```

#### Disconnecting

To disconnect a session, use the `Disconnect` function. You may optional provide a reason for the disconnect

```csharp
await walletClient.Disconnect(sessionTopic);

// or

await walletClient.Disconnect(sessionTopic, Error.FromErrorType(ErrorType.USER_DISCONNECTED));
```

</Tab>

</Tabs>
</file>

<file path="advanced/faq.mdx">
---
title: "FAQs"
---

## What chains does WalletConnect support?

WalletConnect operates as a chain-agnostic protocol, adhering to the [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md) standard. While the WalletConnect protocol supports various chains, you can refer to the [list](../cloud/chains/chain-list) for the known compatible blockchains. However, please note that our SDKs have certain limitations on the chains they support.

If you intend to extend support for non-EVM chains in your wallet or dapp, it is recommended to review the cross-chain primitives supported by the WalletConnect protocol through the Chain Agnostic Standards Alliance's [Namespaces](https://namespaces.chainagnostic.org/) project. Additionally, feel free to reach out to our community team for further guidance. In the event that the desired chain lacks documentation in the Namespaces project, you can collaborate with an expert in the respective chain's tooling and submit a [namespaces PR](https://github.com/ChainAgnostic/namespaces/?tab=readme-ov-file#namespaces).

## Will the relay server `bridge.walletconnect.org` still work in v2?

No, the bridge servers are v1 only.

## How can I reconnect to the same pairing if my browser was restarted?

The `signClient` will restore & reconnect its pairings automatically after the page is reloaded. All pairings are stored on the page's `localStorage`.

For more context, feel free to check our [web examples](https://github.com/WalletConnect/web-examples).

## The default relay endpoint is blocked. How can I get around this?

When initializing `signClient`, you can set `relayUrl` to `wss://relay.walletconnect.org`.

```js
const signClient = await SignClient.init({
  projectId: "<YOUR PROJECT ID>",
  relayUrl: "wss://relay.walletconnect.org",
  metadata: {},
});
```

## How can we use a custom relay for our bridge without a WC URI parameter as the host?

You are more than welcome to utilize a custom URI parameter during testing. However, it is currently not recommended for use in a production environment.

## Why is self-hosting not an option at this time? Are there plans to make this possible in the future?

We understand the desire for developers to self-host their own relay. We share this vision, and have embarked on a decentralization roadmap in order to achieve this. By the end of this summer, we will launch a permissioned network and invite a select group of partners to participate in this crucial first phase. Our objective is to make self-hosting relay a reality with the creation of the decentralized WalletConnect Network, and we appreciate your patience as we progress in this enormous mission.

## How do I report a security issue?

Please consult our [security.txt](https://reown.com/.well-known/security.txt)
</file>

<file path="advanced/glossary.mdx">
---
title: "Glossary"
---

## Sequence

Sequences refers to a complete flow starting from a Proposal and reaching Settlement. A proposer will create a sequence proposal that will derive a Signal to share out-of-band with the responder in order to reach agreement regarding different permissions and conditions for the sequence. A Sequence establishes how the two clients will relay messages with each other, which keys they will use to encrypt and authenticate messages and additionally what are the permissions regarding the JSON-RPC requests that can be made, notifications that can be emitted and what state will be shared.

There are two types of sequences specified by the protocol called Pairing and Session.

## Pairing

Pairing is a specialized sequence which has fixed permissions to only allow a client to propose sessions through it using the method `wc_sessionPropose` which it will be used as a signal out-of-band for session proposals.

## Session

Session is a generalized sequence which has customizable permissions regarding JSON-RPC requests, notifications emitted and also what accounts are exposed based on the set of chains determined in the permissions.

## Signal

A signal is a payload that can be shared outside of the sequence (out-of-band) to communicate a proposal to another client. Each sequence has its own type of signal.

Pairing is a specialized sequence which has fixed permissions therefore the signal can be encoded as an URI using only the proposal topic, proposer's publicKey, relay protocol options and the controller flag for the proposer. This can be shared either through a qrcode or deep link between clients.

Session is a generalized sequence which has customized permissions therefore the signal is a proposal sent through a settled pairing already established between the two clients.

## Settlement

Settlement refers to the internal event which both clients will execute from a successful response of a sequence proposal.

In the case of a responder, the settlement happens before the response is published to the proposer.

In the case of a proposer, the settlement happens after receiving the response published by the responder.

Settlement will generate a shared key using the key pairs of the participants and it will determine the topic from hashing the shared key which is only known to both participants

## Controller

A client can be either a controller or non-controller. This means that all sequences responded and/or proposed by this client will be controlled by it.

A controller is not bounded by the permissions set by the sequence, meaning it can send any JSON-RPC request, emit any notification type and is the only participant that upgrade the permissions or update the state of the sequence.

The controller client will always be the "wallet" which is exposing blockchain accounts to a "dapp" and therefore is also in charge of signing.

Disconnecting is however not exclusive to the controller client and can be triggered by either participants.

## Expiry

Expiry refers to the timestamp when the sequence is deleted.

Whenever the responder settles the sequence it calculates the expiry by adding the TTL to the current timestamp. The proposer would then use the expiry calculated by the responder.

Expiry times are always represented in seconds.

## Time to Live (TTL)

Time to live (TTL) refers to the maximum duration for a sequence to live.

TTL plus the current timestamp is used to calculate the expiry timestamp.

TTL times are always represented in seconds.

## Shared Key

Shared key is the key derived using both participants key pairs using the elliptic curve Diffie-Hellman (ECDH) key agreement scheme.

The chosen elliptic curve was Curve25519 offering 128 bits of security (256 bits key size) which was specifically designed for ECDH and it's widely supported by many different platforms natively. The name of its DH function is X25519

## Authenticated Encryption

Authenticated Encryption refers to a form of encryption which simultaneously assures the confidentiality and authenticity of data.

The chosen approach was to encrypt-then-mac which produces a MAC based on the resulting ciphertext. The encryption uses AES-256-CBC with a random Initialization Vector (IV) and authentication uses HMAC-SHA256. The encrypted payloads are serialized in the following order: iv, publicKey, mac and cipherText.

To derive the encryption and authentication keys it uses a SHA512 hash of the shared key using the first 32bytes for encryption and the last 32 bytes for authentication

## JSON-RPC

JSON-RPC is a stateless, light weight remote procedure call (RPC) protocol which uses JSON (RFC 4627) as data format. You can read more about JSON-RPC specification [here](https://www.jsonrpc.org/specification)

## Relay

Relay refers to the system, network and/or mechanism used to send and receives messages between the two clients.

## Publish-Subscribe pattern

Publish-Subscribe (also known as PubSub) is a messaging pattern where senders of messages (publishers) do not send messages directly to receivers but instead label messages with a topic that can be listened to by subscribers. Subscribers only receive messages matching the topics that have expressed interest on.

## Topics

Topics are 32 bytes hexadecimal strings which are used to identify messages sent between two clients regarding either proposed sequences or settled sequences. Proposed sequences use a randomly generated topic while Settled sequences use a SHA256 hash of the sharedKey.

## Namespaces

Namespaces are used to specify the chains, methods and events that are intended to be used in a particular session. They establish the minimal requirement for a wallet and a dapp to get paired. There are two types of namespaces,

### Proposal namespaces

A dapp sends a proposal namespace to the wallet for pairing. The proposal namespace contains the list of chains, methods and events that are required for the dapp. The wallet validates if the received proposal namespaces are valid and returns a session namespace as a response if it is valid. If the requested proposal namespaces are not valid, the session cannot be established and the wallet rejects it with an error code that tells the dapp if the proposal namespaces have invalid chains, methods, events or if it was rejected by the user

**Example :** If a dapp wants access to Ethereum Mainnet, Polygon and Cosmos Mainnet - the required chains, methods and events should be mentioned in the proposal namespaces request as follows :

```js
{
  "eip155": {
    "chains": ["eip155:137", "eip155:1"],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "chains": ["cosmos:cosmoshub-4"],
    "methods": ["cosmos_signDirect"],
    "events": ["someCosmosEvent"]
  }
}
```

### Session namespaces

The dapp validates if the received proposal namespaces comply with the session namespaces. If they comply, a session is established successfully and pairing is completed. If not, the session is not established and all the cached data related to the namespaces are deleted. The session namespace can also choose to provide access to more chains, methods or events that were not a part of the proposal namespaces.

**Example :** The following is an example for a session namespace which complies with the requested proposal namespace example,

```js
{
  "eip155": {
    "accounts": [
      "eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb",
      "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb"
    ],
    "methods": ["eth_sign"],
    "events": ["accountsChanged"]
  },
  "cosmos": {
    "accounts": [
      "cosmos:cosmoshub-4:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0"
    ],
    "methods": ["cosmos_signDirect", "personal_sign"],
    "events": ["someCosmosEvent", "proofFinalized"]
  }
}
```

You can also see that `personal_sign` method and `proofFinalized` event are not requested by the proposal namespaces but is still granted by the session namespaces. Hence, session namespaces can grant additional access to more chains, methods and events which were not requested by the proposal namespaces.
</file>

<file path="components/Tabs/styles.module.css">
.tabList {
  margin-bottom: var(--ifm-leading);
}

.tabItem {
  margin-top: 0 !important;
}
</file>

<file path="docs/walletkit/flutter/early-access/chain-abstraction.mdx">
import ChainAbstractionIntro from '../../shared/chain-abstraction-intro.mdx'

# Chain Abstraction

<ChainAbstractionIntro />

## Methods

The following methods from WalletKit are used in implementing chain abstraction.

:::note
💡 Chain abstraction is currently in the early access phase, use it carefully
:::

### Prepare 

This method is used to check if chain abstraction is needed. If it is, it will return a response with the necessary transactions. 
If it is not, it will return a response with the original transaction. 

```swift
Future<PrepareDetailedResponseCompat> prepare({
  required String chainId,
  required String from,
  required CallCompat call,
  Currency? localCurrency,
});
```

### Execute

This method is used to execute the chain abstraction operation. The method will handle broadcasting all transactions in the correct order and monitor the cross-chain transfer process. It returns an `ExecuteDetails` object with the transaction status and results.

```swift
Future<ExecuteDetailsCompat> execute({
  required UiFieldsCompat uiFields,
  required List<String> routeTxnSigs,
  required String initialTxnSig,
})
```

## Usage

When sending a transaction, first check if chain abstraction is needed using the `prepare` method. Call the `execute` method to broadcast the routing and initial transactions and wait for it to be completed. 

If the operation is successful, you need to broadcast the initial transaction and await the transaction hash and receipt. 
If the operation is not successful, send a JsonRpcError to the dapp and display the error to the user. 

```swift
final response = await _walletKit.prepare(
  chainId: chainId, // selected chain id
  from: from, // sender address
  call: CallCompat(
    to: to, // contract address
    input: input, // calldata
  ),
);
response.when(
  success: (PrepareDetailedResponseSuccessCompat deatailResponse) {
    deatailResponse.when(
      available: (UiFieldsCompat uiFieldsCompat) {
        // If the route is available, present a CA transaction UX flow and sign hashes when approved
        final TxnDetailsCompat initial = uiFieldsCompat.initial;
        final List<TxnDetailsCompat> route = uiFieldsCompat.route;
        
        final String initialSignature = signHashMethod(initial.transactionHashToSign);
        final List<String> routeSignatures = route.map((route) {
          final String rSignature = signHashMethod(route.transactionHashToSign);
          return rSignature;
        }).toList();

        await _walletKit.execute(
          uiFields: uiFields,
          initialTxnSig: initialSignature,
          routeTxnSigs: routeSignatures,
        );
      },
      notRequired: (PrepareResponseNotRequiredCompat notRequired) {
        // user does not need to move funds from other chains
        // proceeds as normal transaction with notRequired.initialTransaction
      },
    );
  },
  error: (PrepareResponseError prepareError) {
    // Show an error
    // contains prepareError.error as BridgingError and could be either:
    // noRoutesAvailable, insufficientFunds, insufficientGasFunds
  },
);
```

### Implementation during Session Request

If you are looking to trigger Chain Abstraction during a eth_sendTransaction Session Request you should do it inside the session request handler as explained in [Responding to Session requests](../usage.mdx#responding-to-session-requests) section.

```swift
Future<void> _ethSendTransactionHandler(String topic, dynamic params) async {
  final SessionRequest pendingRequest = _walletKit.pendingRequests.getAll().last;
  final int requestId = pendingRequest.id;
  final String chainId = pendingRequest.chainId;

  final transaction = (params as List<dynamic>).first as Map<String, dynamic>;

  // Intercept to check if Chain Abstraction is required
  if (transaction.containsKey('input') || transaction.containsKey('data')) {
    final inputData = transaction.containsKey('input') ?? transaction.containsKey('data');
    final response = await _walletKit.prepare(
      chainId: chainId,
      from: transaction['from'],
      call: CallCompat(
        to: transaction['to'],
        input: inputData,
      ),
    );
    response.when(
      success: (PrepareDetailedResponseSuccessCompat deatailResponse) {
        deatailResponse.when(
          available: (UiFieldsCompat uiFieldsCompat) {
            // Only if the route is available, present a Chain Abstraction approval modal 
            // and proceed with execute() method
            if (approved) {
              final TxnDetailsCompat initial = uiFieldsCompat.initial;
              final List<TxnDetailsCompat> route = uiFieldsCompat.route;
              
              final String initialSignature = signHashMethod(initial.transactionHashToSign);
              final List<String> routeSignatures = route.map((route) {
                final String rSignature = signHashMethod(route.transactionHashToSign);
                return rSignature;
              }).toList();

              final executeResponse = await _walletKit.execute(
                uiFields: uiFields,
                initialTxnSig: initialSignature,
                routeTxnSigs: routeSignatures,
              );

              // Respond to the session request. Flow shouldn't end here as the transaction was processed
              return await _walletKit.respondSessionRequest(
                topic: topic,
                response: JsonRpcResponse(
                  id: requestId, 
                  jsonrpc: '2.0', 
                  result: executeResponse.initialTxnReceipt,
                ),
              );
            }
          },
          // If deatailResponse is not `available` type
          // then let the flow to continue to regular send transacrion
        );
      },
    );
  }

  // display a prompt for the user to approve or reject the request
  // if approved
  if (approved) {
    final signedTx = await sendTransaction(transaction, int.parse(chainId));
    // respond to requester
    await _walletKit.respondSessionRequest(
      topic: topic,
      response: JsonRpcResponse(
        id: requestId, 
        jsonrpc: '2.0', 
        result: signedTx,
      ),
    );
  }

  // if rejected
  return _walletKit.respondSessionRequest(
    topic: topic,
    response: JsonRpcResponse(
      id: id,
      jsonrpc: '2.0',
      error: const JsonRpcError(code: 5001, message: 'User rejected method'),
    ),
  );
}

```

For example, check out implementation of chain abstraction in [sample wallet](https://github.com/reown-com/reown_flutter/blob/develop/packages/reown_walletkit/example/lib/dependencies/chain_services/evm_service.dart) with Flutter.

### Token Balance

You can use this method to query the token balance of the given address

```swift
Future<String> erc20TokenBalance({
  required String chainId, // chain id
  required String token, // token address
  required String owner, // user address
})
```

## Android

In your android (project's) build.gradle file add support for Jitpack:

```
allprojects {
    repositories {
        google()
        mavenCentral()
        maven { url 'https://jitpack.io' } // <- add jipack url
    }
}
```

It shouldn't happen but if you encounter issues with minification, add the below rules to your application:

```
-keepattributes *Annotation*

-keep class com.sun.jna.** { *; }
-keepclassmembers class com.sun.jna.** {
    native <methods>;
    *;
}

-keep class uniffi.** { *; }

# Preserve all public and protected fields and methods
-keepclassmembers class ** {
    public *;
    protected *;
}

-dontwarn uniffi.**
-dontwarn com.sun.jna.**
```

## Testing 

Best way to test Chain Abstraction is to use our Sample wallet.
- [Sample Wallet for iOS](https://testflight.apple.com/join/Uv0XoBuD)
- [Sample Wallet for Android](https://appdistribution.firebase.dev/i/2b8b3dce9e2831cd)

You can also use the [AppKit laboratory](https://appkit-lab.reown.com/library/wagmi/) and try sending [USDC/USDT](../../../walletkit/features/early-access/chain-abstraction.mdx#what-are-the-supported-tokens-and-networks) with any chain abstraction-supported wallet. 

<video controls width="100%" height="100%" style={{ borderRadius: '10px' }}>
  <source src="/assets/chain-abstraction-demo.mp4" type="video/mp4" />
</video>
</file>

<file path="images/assets/home/dotnet.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="456" height="456" fill="none" xmlns:v="https://vecta.io/nano"><path fill="#512bd4" d="M0 0h456v456H0z"/><path d="M81.274 291.333c-3.224 0-5.965-1.074-8.222-3.223-2.257-2.204-3.386-4.821-3.386-7.851 0-3.086 1.129-5.73 3.386-7.934s4.998-3.306 8.222-3.306c3.278 0 6.046 1.102 8.303 3.306 2.311 2.204 3.466 4.848 3.466 7.934 0 3.03-1.155 5.647-3.466 7.851-2.257 2.149-5.025 3.223-8.303 3.223zm128.893-1.818h-20.958l-55.215-87.109c-1.397-2.204-2.553-4.491-3.466-6.86h-.484c.43 2.535.645 7.962.645 16.281v77.688h-18.54V171h22.328l53.362 85.043c2.257 3.527 3.708 5.951 4.353 7.273h.322c-.537-3.14-.806-8.457-.806-15.951V171h18.459v118.515zm90.282 0h-64.888V171h62.309v16.695h-43.124v33.554h39.739v16.612h-39.739v35.042h45.703v16.612zm92.218-101.82h-33.21v101.82h-19.185v-101.82h-33.129V171h85.524v16.695z" fill="#fff"/></svg>
</file>

<file path="images/assets/home/family.svg">
<svg width="400" height="400" viewBox="0 0 400 400" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_2453_12901)">
<path d="M400 67.2214C399.995 49.482 392.946 32.4706 380.402 19.9269C367.859 7.38321 350.847 0.334041 333.108 0.329055C300.663 -9.31323e-05 273.861 23.1814 267.212 53.6417H265.557C262.472 38.5604 254.283 25.0035 242.369 15.2553C230.456 5.50702 215.546 0.163361 200.153 0.124706C184.759 0.0860515 169.823 5.35476 157.861 15.0431C145.898 24.7314 137.641 38.247 134.481 53.3125H132.826C130.364 41.4247 124.722 30.4276 116.503 21.4935C108.283 12.5593 97.7934 6.02281 86.1515 2.58075C74.5096 -0.861307 62.1519 -1.07995 50.3955 1.94812C38.6392 4.97619 27.9247 11.1375 19.3942 19.7753C10.8637 28.4131 4.83689 39.2038 1.95605 50.9971C-0.924786 62.7904 -0.551646 75.1444 3.0357 86.7423C6.62305 98.3403 13.2902 108.747 22.3264 116.855C31.3627 124.962 42.4294 130.465 54.3471 132.778V134.104C39.0594 137.086 25.284 145.29 15.3803 157.311C5.4766 169.333 0.0609582 184.424 0.0609582 200C0.0609582 215.576 5.4766 230.667 15.3803 242.688C25.284 254.71 39.0594 262.914 54.3471 265.895V267.212C42.4173 269.479 31.328 274.946 22.2654 283.028C13.2027 291.111 6.50753 301.505 2.89594 313.098C-0.71565 324.692 -1.1078 337.049 1.76143 348.849C4.63066 360.648 10.6533 371.446 19.1853 380.087C27.7173 388.727 38.4376 394.886 50.1997 397.905C61.9618 400.923 74.3231 400.688 85.9617 397.224C97.6003 393.759 108.078 387.196 116.275 378.237C124.472 369.277 130.079 358.258 132.496 346.358H134.152C140.443 376.818 167.593 399.962 199.718 399.962C215.171 400.033 230.166 394.722 242.129 384.94C254.091 375.159 262.275 361.517 265.275 346.358H266.93C273.221 376.818 300.371 399.962 332.496 399.962C349.146 399.923 365.184 393.687 377.487 382.469C389.789 371.25 397.475 355.853 399.045 339.278C400.616 322.703 395.959 306.137 385.983 292.807C376.007 279.478 361.425 270.34 345.079 267.174V265.858C360.367 262.876 374.142 254.672 384.046 242.651C393.95 230.629 399.365 215.538 399.365 199.962C399.365 184.387 393.95 169.295 384.046 157.274C374.142 145.252 360.367 137.048 345.079 134.067V132.741C360.479 130.026 374.428 121.968 384.473 109.984C394.518 98.0004 400.016 82.8584 400 67.2214ZM307.613 292.049C307.616 294.094 307.216 296.119 306.436 298.009C305.655 299.899 304.508 301.616 303.062 303.062C301.616 304.508 299.899 305.655 298.009 306.435C296.119 307.216 294.094 307.616 292.049 307.613H108.28C106.235 307.616 104.21 307.216 102.32 306.435C100.43 305.655 98.7127 304.508 97.2667 303.062C95.8207 301.616 94.6744 299.899 93.8936 298.009C93.1127 296.119 92.7127 294.094 92.7164 292.049V108.28C92.7127 106.235 93.1127 104.21 93.8936 102.32C94.6744 100.43 95.8207 98.7126 97.2667 97.2666C98.7127 95.8206 100.43 94.6743 102.32 93.8935C104.21 93.1126 106.235 92.7126 108.28 92.7163H292.049C294.094 92.7126 296.119 93.1126 298.009 93.8935C299.899 94.6743 301.616 95.8206 303.062 97.2666C304.508 98.7126 305.655 100.43 306.436 102.32C307.216 104.21 307.616 106.235 307.613 108.28V292.049Z" fill="#343433"/>
</g>
<defs>
<clipPath id="clip0_2453_12901">
<rect width="400" height="400" fill="white"/>
</clipPath>
</defs>
</svg>
</file>

<file path="images/assets/home/rainbow.svg">
<svg width="120" height="120" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="120" height="120" fill="url(#paint0_linear_62_329)"/>
<path d="M20 38H26C56.9279 38 82 63.0721 82 94V100H94C97.3137 100 100 97.3137 100 94C100 53.1309 66.8691 20 26 20C22.6863 20 20 22.6863 20 26V38Z" fill="url(#paint1_radial_62_329)"/>
<path d="M84 94H100C100 97.3137 97.3137 100 94 100H84V94Z" fill="url(#paint2_linear_62_329)"/>
<path d="M26 20L26 36H20L20 26C20 22.6863 22.6863 20 26 20Z" fill="url(#paint3_linear_62_329)"/>
<path d="M20 36H26C58.0325 36 84 61.9675 84 94V100H66V94C66 71.9086 48.0914 54 26 54H20V36Z" fill="url(#paint4_radial_62_329)"/>
<path d="M68 94H84V100H68V94Z" fill="url(#paint5_linear_62_329)"/>
<path d="M20 52L20 36L26 36L26 52H20Z" fill="url(#paint6_linear_62_329)"/>
<path d="M20 62C20 65.3137 22.6863 68 26 68C40.3594 68 52 79.6406 52 94C52 97.3137 54.6863 100 58 100H68V94C68 70.804 49.196 52 26 52H20V62Z" fill="url(#paint7_radial_62_329)"/>
<path d="M52 94H68V100H58C54.6863 100 52 97.3137 52 94Z" fill="url(#paint8_radial_62_329)"/>
<path d="M26 68C22.6863 68 20 65.3137 20 62L20 52L26 52L26 68Z" fill="url(#paint9_radial_62_329)"/>
<defs>
<linearGradient id="paint0_linear_62_329" x1="60" y1="0" x2="60" y2="120" gradientUnits="userSpaceOnUse">
<stop stop-color="#174299"/>
<stop offset="1" stop-color="#001E59"/>
</linearGradient>
<radialGradient id="paint1_radial_62_329" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(26 94) rotate(-90) scale(74)">
<stop offset="0.770277" stop-color="#FF4000"/>
<stop offset="1" stop-color="#8754C9"/>
</radialGradient>
<linearGradient id="paint2_linear_62_329" x1="83" y1="97" x2="100" y2="97" gradientUnits="userSpaceOnUse">
<stop stop-color="#FF4000"/>
<stop offset="1" stop-color="#8754C9"/>
</linearGradient>
<linearGradient id="paint3_linear_62_329" x1="23" y1="20" x2="23" y2="37" gradientUnits="userSpaceOnUse">
<stop stop-color="#8754C9"/>
<stop offset="1" stop-color="#FF4000"/>
</linearGradient>
<radialGradient id="paint4_radial_62_329" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(26 94) rotate(-90) scale(58)">
<stop offset="0.723929" stop-color="#FFF700"/>
<stop offset="1" stop-color="#FF9901"/>
</radialGradient>
<linearGradient id="paint5_linear_62_329" x1="68" y1="97" x2="84" y2="97" gradientUnits="userSpaceOnUse">
<stop stop-color="#FFF700"/>
<stop offset="1" stop-color="#FF9901"/>
</linearGradient>
<linearGradient id="paint6_linear_62_329" x1="23" y1="52" x2="23" y2="36" gradientUnits="userSpaceOnUse">
<stop stop-color="#FFF700"/>
<stop offset="1" stop-color="#FF9901"/>
</linearGradient>
<radialGradient id="paint7_radial_62_329" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(26 94) rotate(-90) scale(42)">
<stop offset="0.59513" stop-color="#00AAFF"/>
<stop offset="1" stop-color="#01DA40"/>
</radialGradient>
<radialGradient id="paint8_radial_62_329" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(51 97) scale(17 45.3333)">
<stop stop-color="#00AAFF"/>
<stop offset="1" stop-color="#01DA40"/>
</radialGradient>
<radialGradient id="paint9_radial_62_329" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(23 69) rotate(-90) scale(17 322.37)">
<stop stop-color="#00AAFF"/>
<stop offset="1" stop-color="#01DA40"/>
</radialGradient>
</defs>
</svg>
</file>

<file path="images/assets/github.svg">
<svg width="1024" height="1024" viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.39 6.01 13.72C4 14.09 3.48 13.23 3.32 12.78C3.23 12.55 2.84 11.84 2.5 11.65C2.22 11.5 1.82 11.13 2.49 11.12C3.12 11.11 3.57 11.7 3.72 11.94C4.44 13.15 5.59 12.81 6.05 12.6C6.12 12.08 6.33 11.73 6.56 11.53C4.78 11.33 2.92 10.64 2.92 7.58C2.92 6.71 3.23 5.99 3.74 5.43C3.66 5.23 3.38 4.41 3.82 3.31C3.82 3.31 4.49 3.1 6.02 4.13C6.66 3.95 7.34 3.86 8.02 3.86C8.7 3.86 9.38 3.95 10.02 4.13C11.55 3.09 12.22 3.31 12.22 3.31C12.66 4.41 12.38 5.23 12.3 5.43C12.81 5.99 13.12 6.7 13.12 7.58C13.12 10.65 11.25 11.33 9.47 11.53C9.76 11.78 10.01 12.26 10.01 13.01C10.01 14.08 10 14.94 10 15.21C10 15.42 10.15 15.67 10.55 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z" transform="scale(64)" fill="#1B1F23"/>
</svg>
</file>

<file path="images/reown/appkit-logo.svg">
<svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="56" height="56" rx="16.3333" fill="#FF573B"/>
<path d="M11.6667 33.8333H44.3334V38.5C44.3334 39.7886 43.2501 40.8333 41.9137 40.8333H14.0865C12.7501 40.8333 11.6667 39.7886 11.6667 38.5V33.8333Z" fill="#202020"/>
<path d="M11.6667 24.5H44.3334V31.5H11.6667V24.5Z" fill="#202020"/>
<path d="M11.6667 17.5C11.6667 16.2113 12.7501 15.1666 14.0865 15.1666H41.9137C43.2501 15.1666 44.3334 16.2113 44.3334 17.5V22.1666H11.6667V17.5Z" fill="#202020"/>
</svg>
</file>

<file path="images/reown/banner-image-light.svg">
<svg width="203" height="199" viewBox="0 0 203 199" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="149.356" y="146.047" width="51.9457" height="51.9457" rx="8.49563" stroke="#FFB800" stroke-width="0.983518"/>
<rect x="0.491759" y="146.047" width="145.895" height="51.9457" rx="25.9728" stroke="#C1C1C1" stroke-width="0.983518"/>
<rect x="0.491759" y="0.491759" width="55.6157" height="55.6157" rx="16.3073" stroke="#6C6C6C" stroke-width="0.983518"/>
<rect x="59.921" y="0.491759" width="141.458" height="141.458" rx="18.8558" stroke="#FF573B" stroke-width="0.983518"/>
<rect x="64.6378" y="5.20831" width="132.025" height="132.025" rx="60.8241" stroke="#6C6C6C" stroke-width="0.983518"/>
</svg>
</file>

<file path="images/reown/banner-image.svg">
<svg width="204" height="200" viewBox="0 0 204 200" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="150.158" y="146.558" width="51.9457" height="51.9457" rx="8.49563" stroke="#FFB800" stroke-width="0.983518"/>
<rect x="1.29401" y="146.558" width="145.895" height="51.9457" rx="25.9728" stroke="#6C6C6C" stroke-width="0.983518"/>
<rect x="1.29401" y="1.00323" width="55.6157" height="55.6157" rx="16.3073" stroke="#F6F6F6" stroke-width="0.983518"/>
<rect x="60.7232" y="1.00323" width="141.458" height="141.458" rx="18.8558" stroke="#FF573B" stroke-width="0.983518"/>
<rect x="65.44" y="5.71979" width="132.025" height="132.025" rx="60.8241" stroke="#F6F6F6" stroke-width="0.983518"/>
</svg>
</file>

<file path="images/reown/browse.svg">
<svg width="41" height="40" viewBox="0 0 41 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M19.25 12.5C19.25 13.7361 18.8834 14.9445 18.1967 15.9723C17.5099 17.0001 16.5338 17.8012 15.3918 18.2743C14.2497 18.7473 12.9931 18.8711 11.7807 18.6299C10.5683 18.3888 9.45466 17.7935 8.58059 16.9194C7.70651 16.0453 7.11125 14.9317 6.87009 13.7193C6.62894 12.5069 6.75271 11.2503 7.22576 10.1082C7.6988 8.96619 8.49988 7.99008 9.52769 7.30332C10.5555 6.61656 11.7639 6.25 13 6.25C14.6576 6.25 16.2473 6.90848 17.4194 8.08059C18.5915 9.25269 19.25 10.8424 19.25 12.5ZM28 18.75C29.2361 18.75 30.4445 18.3834 31.4723 17.6967C32.5001 17.0099 33.3012 16.0338 33.7743 14.8918C34.2473 13.7497 34.3711 12.4931 34.1299 11.2807C33.8888 10.0683 33.2935 8.95466 32.4194 8.08059C31.5453 7.20651 30.4317 6.61125 29.2193 6.37009C28.0069 6.12894 26.7503 6.25271 25.6082 6.72576C24.4662 7.1988 23.4901 7.99988 22.8033 9.02769C22.1166 10.0555 21.75 11.2639 21.75 12.5C21.75 14.1576 22.4085 15.7473 23.5806 16.9194C24.7527 18.0915 26.3424 18.75 28 18.75ZM13 21.25C11.7639 21.25 10.5555 21.6166 9.52769 22.3033C8.49988 22.9901 7.6988 23.9662 7.22576 25.1082C6.75271 26.2503 6.62894 27.5069 6.87009 28.7193C7.11125 29.9317 7.70651 31.0453 8.58059 31.9194C9.45466 32.7935 10.5683 33.3888 11.7807 33.6299C12.9931 33.8711 14.2497 33.7473 15.3918 33.2743C16.5338 32.8012 17.5099 32.0001 18.1967 30.9723C18.8834 29.9445 19.25 28.7361 19.25 27.5C19.25 25.8424 18.5915 24.2527 17.4194 23.0806C16.2473 21.9085 14.6576 21.25 13 21.25ZM28 21.25C26.7639 21.25 25.5555 21.6166 24.5277 22.3033C23.4999 22.9901 22.6988 23.9662 22.2258 25.1082C21.7527 26.2503 21.6289 27.5069 21.8701 28.7193C22.1113 29.9317 22.7065 31.0453 23.5806 31.9194C24.4547 32.7935 25.5683 33.3888 26.7807 33.6299C27.9931 33.8711 29.2497 33.7473 30.3918 33.2743C31.5338 32.8012 32.5099 32.0001 33.1967 30.9723C33.8834 29.9445 34.25 28.7361 34.25 27.5C34.25 25.8424 33.5915 24.2527 32.4194 23.0806C31.2473 21.9085 29.6576 21.25 28 21.25Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/demo.svg">
<svg width="41" height="40" viewBox="0 0 41 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M31.8703 8.42032C28.8448 5.42436 24.7578 3.74564 20.5 3.75001H20.3328C16.0521 3.79405 11.9617 5.52553 8.95025 8.56823C5.93885 11.6109 4.24977 15.7191 4.25 20C4.25 26.7188 8.40312 32.3531 15.0875 34.7141C15.8414 34.9799 16.6481 35.061 17.4398 34.9507C18.2316 34.8404 18.9854 34.5419 19.638 34.0802C20.2905 33.6185 20.8229 33.007 21.1904 32.297C21.5579 31.5871 21.7498 30.7994 21.75 30C21.75 29.337 22.0134 28.7011 22.4822 28.2322C22.9511 27.7634 23.587 27.5 24.25 27.5H31.4703C32.6045 27.5055 33.7064 27.1229 34.5932 26.4158C35.48 25.7086 36.0982 24.7195 36.3453 23.6125C36.6247 22.3824 36.7605 21.124 36.75 19.8625C36.7341 17.7273 36.2946 15.6165 35.4569 13.6523C34.6193 11.6882 33.4002 9.90987 31.8703 8.42032ZM13.625 26.25C13.2542 26.25 12.8916 26.14 12.5833 25.934C12.275 25.728 12.0346 25.4352 11.8927 25.0925C11.7508 24.7499 11.7137 24.3729 11.786 24.0092C11.8584 23.6455 12.037 23.3114 12.2992 23.0492C12.5614 22.787 12.8955 22.6084 13.2592 22.536C13.6229 22.4637 13.9999 22.5008 14.3425 22.6427C14.6851 22.7847 14.978 23.025 15.184 23.3333C15.39 23.6417 15.5 24.0042 15.5 24.375C15.5 24.8723 15.3025 25.3492 14.9508 25.7008C14.5992 26.0525 14.1223 26.25 13.625 26.25ZM13.625 17.5C13.2542 17.5 12.8916 17.39 12.5833 17.184C12.275 16.978 12.0346 16.6852 11.8927 16.3425C11.7508 15.9999 11.7137 15.6229 11.786 15.2592C11.8584 14.8955 12.037 14.5614 12.2992 14.2992C12.5614 14.037 12.8955 13.8584 13.2592 13.786C13.6229 13.7137 13.9999 13.7508 14.3425 13.8927C14.6851 14.0346 14.978 14.275 15.184 14.5833C15.39 14.8917 15.5 15.2542 15.5 15.625C15.5 16.1223 15.3025 16.5992 14.9508 16.9508C14.5992 17.3025 14.1223 17.5 13.625 17.5ZM20.5 13.75C20.1292 13.75 19.7666 13.64 19.4583 13.434C19.15 13.228 18.9096 12.9352 18.7677 12.5925C18.6258 12.2499 18.5887 11.8729 18.661 11.5092C18.7334 11.1455 18.912 10.8114 19.1742 10.5492C19.4364 10.287 19.7705 10.1084 20.1342 10.036C20.4979 9.96369 20.8749 10.0008 21.2175 10.1427C21.5601 10.2846 21.853 10.525 22.059 10.8333C22.265 11.1417 22.375 11.5042 22.375 11.875C22.375 12.3723 22.1775 12.8492 21.8258 13.2008C21.4742 13.5525 20.9973 13.75 20.5 13.75ZM27.375 17.5C27.0042 17.5 26.6416 17.39 26.3333 17.184C26.025 16.978 25.7846 16.6852 25.6427 16.3425C25.5008 15.9999 25.4637 15.6229 25.536 15.2592C25.6084 14.8955 25.787 14.5614 26.0492 14.2992C26.3114 14.037 26.6455 13.8584 27.0092 13.786C27.3729 13.7137 27.7499 13.7508 28.0925 13.8927C28.4351 14.0346 28.728 14.275 28.934 14.5833C29.14 14.8917 29.25 15.2542 29.25 15.625C29.25 16.1223 29.0525 16.5992 28.7008 16.9508C28.3492 17.3025 27.8723 17.5 27.375 17.5Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/features.svg">
<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
<g filter="url(#filter0_d_2240_126561)">
<path d="M38.3755 26.4198L24.0005 34.8026L9.62549 26.4198C9.34087 26.2781 9.01295 26.2501 8.70847 26.3417C8.40399 26.4332 8.14583 26.6374 7.98654 26.9125C7.82726 27.1877 7.77881 27.5132 7.85107 27.8228C7.92333 28.1325 8.11086 28.4029 8.37549 28.5792L23.3755 37.3292C23.5666 37.4406 23.7839 37.4993 24.0052 37.4993C24.2264 37.4993 24.4437 37.4406 24.6349 37.3292L39.6349 28.5792C39.7789 28.4976 39.9054 28.3883 40.0069 28.2576C40.1084 28.1268 40.1828 27.9772 40.226 27.8174C40.2692 27.6576 40.2803 27.4908 40.2585 27.3267C40.2367 27.1626 40.1825 27.0045 40.0991 26.8615C40.0157 26.7185 39.9048 26.5935 39.7727 26.4937C39.6406 26.394 39.49 26.3214 39.3296 26.2803C39.1693 26.2392 39.0024 26.2304 38.8386 26.2543C38.6748 26.2783 38.5174 26.3345 38.3755 26.4198Z" fill="#9A9A9A"/>
<path d="M38.3755 18.9198L24.0005 27.3026L9.62549 18.9198C9.34087 18.7781 9.01295 18.7501 8.70847 18.8417C8.40399 18.9332 8.14583 19.1374 7.98654 19.4125C7.82726 19.6877 7.77881 20.0132 7.85107 20.3228C7.92333 20.6325 8.11086 20.9029 8.37549 21.0792L23.3755 29.8292C23.5666 29.9406 23.7839 29.9993 24.0052 29.9993C24.2264 29.9993 24.4437 29.9406 24.6349 29.8292L39.6349 21.0792C39.7789 20.9976 39.9054 20.8883 40.0069 20.7576C40.1084 20.6268 40.1828 20.4772 40.226 20.3174C40.2692 20.1576 40.2803 19.9908 40.2585 19.8267C40.2367 19.6626 40.1825 19.5045 40.0991 19.3615C40.0157 19.2185 39.9048 19.0935 39.7727 18.9937C39.6406 18.894 39.49 18.8214 39.3296 18.7803C39.1693 18.7392 39.0024 18.7304 38.8386 18.7543C38.6748 18.7783 38.5174 18.8345 38.3755 18.9198Z" fill="#9A9A9A"/>
<path d="M8.37498 13.5796L23.375 22.3296C23.5661 22.441 23.7834 22.4998 24.0047 22.4998C24.2259 22.4998 24.4432 22.441 24.6344 22.3296L39.6344 13.5796C39.8231 13.4695 39.9796 13.3119 40.0884 13.1224C40.1972 12.933 40.2545 12.7183 40.2545 12.4999C40.2545 12.2814 40.1972 12.0668 40.0884 11.8773C39.9796 11.6879 39.8231 11.5303 39.6344 11.4202L24.6344 2.67019C24.4432 2.55873 24.2259 2.5 24.0047 2.5C23.7834 2.5 23.5661 2.55873 23.375 2.67019L8.37498 11.4202C8.18629 11.5303 8.02974 11.6879 7.92094 11.8773C7.81214 12.0668 7.75488 12.2814 7.75488 12.4999C7.75488 12.7183 7.81214 12.933 7.92094 13.1224C8.02974 13.3119 8.18629 13.4695 8.37498 13.5796Z" fill="#9A9A9A"/>
</g>
<defs>
<filter id="filter0_d_2240_126561" x="0" y="0" width="48" height="48" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dy="4"/>
<feGaussianBlur stdDeviation="2"/>
<feComposite in2="hardAlpha" operator="out"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_2240_126561"/>
<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_2240_126561" result="shape"/>
</filter>
</defs>
</svg>
</file>

<file path="images/reown/get-started.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M32.5005 22.5C32.5037 23.0097 32.3488 23.5078 32.0572 23.9258C31.7657 24.3439 31.3517 24.6613 30.8724 24.8344L22.813 27.8125L19.8442 35.8781C19.6684 36.3557 19.3504 36.7679 18.9329 37.0591C18.5155 37.3502 18.0188 37.5064 17.5099 37.5064C17.0009 37.5064 16.5042 37.3502 16.0868 37.0591C15.6694 36.7679 15.3513 36.3557 15.1755 35.8781L12.188 27.8125L4.12237 24.8438C3.64476 24.6679 3.23257 24.3499 2.94141 23.9324C2.65025 23.515 2.49414 23.0183 2.49414 22.5094C2.49414 22.0004 2.65025 21.5037 2.94141 21.0863C3.23257 20.6689 3.64476 20.3508 4.12237 20.175L12.188 17.1875L15.1567 9.12188C15.3326 8.64426 15.6506 8.23207 16.0681 7.94092C16.4855 7.64976 16.9822 7.49365 17.4911 7.49365C18.0001 7.49365 18.4968 7.64976 18.9142 7.94092C19.3316 8.23207 19.6497 8.64426 19.8255 9.12188L22.813 17.1875L30.8786 20.1562C31.3583 20.3309 31.772 20.6502 32.0625 21.07C32.353 21.4898 32.5061 21.9895 32.5005 22.5ZM23.7505 7.5H26.2505V10C26.2505 10.3315 26.3822 10.6495 26.6166 10.8839C26.851 11.1183 27.169 11.25 27.5005 11.25C27.832 11.25 28.15 11.1183 28.3844 10.8839C28.6188 10.6495 28.7505 10.3315 28.7505 10V7.5H31.2505C31.582 7.5 31.9 7.3683 32.1344 7.13388C32.3688 6.89946 32.5005 6.58152 32.5005 6.25C32.5005 5.91848 32.3688 5.60054 32.1344 5.36612C31.9 5.1317 31.582 5 31.2505 5H28.7505V2.5C28.7505 2.16848 28.6188 1.85054 28.3844 1.61612C28.15 1.3817 27.832 1.25 27.5005 1.25C27.169 1.25 26.851 1.3817 26.6166 1.61612C26.3822 1.85054 26.2505 2.16848 26.2505 2.5V5H23.7505C23.419 5 23.101 5.1317 22.8666 5.36612C22.6322 5.60054 22.5005 5.91848 22.5005 6.25C22.5005 6.58152 22.6322 6.89946 22.8666 7.13388C23.101 7.3683 23.419 7.5 23.7505 7.5ZM37.5005 12.5H36.2505V11.25C36.2505 10.9185 36.1188 10.6005 35.8844 10.3661C35.65 10.1317 35.332 10 35.0005 10C34.669 10 34.351 10.1317 34.1166 10.3661C33.8822 10.6005 33.7505 10.9185 33.7505 11.25V12.5H32.5005C32.169 12.5 31.851 12.6317 31.6166 12.8661C31.3822 13.1005 31.2505 13.4185 31.2505 13.75C31.2505 14.0815 31.3822 14.3995 31.6166 14.6339C31.851 14.8683 32.169 15 32.5005 15H33.7505V16.25C33.7505 16.5815 33.8822 16.8995 34.1166 17.1339C34.351 17.3683 34.669 17.5 35.0005 17.5C35.332 17.5 35.65 17.3683 35.8844 17.1339C36.1188 16.8995 36.2505 16.5815 36.2505 16.25V15H37.5005C37.832 15 38.15 14.8683 38.3844 14.6339C38.6188 14.3995 38.7505 14.0815 38.7505 13.75C38.7505 13.4185 38.6188 13.1005 38.3844 12.8661C38.15 12.6317 37.832 12.5 37.5005 12.5Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/Icon.svg">
<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M29.7071 9.70757L25.4133 14.0001L28.7071 17.2926C28.8 17.3855 28.8737 17.4958 28.924 17.6172C28.9743 17.7386 29.0001 17.8687 29.0001 18.0001C29.0001 18.1315 28.9743 18.2616 28.924 18.383C28.8737 18.5044 28.8 18.6147 28.7071 18.7076C28.6142 18.8005 28.5039 18.8742 28.3825 18.9245C28.2611 18.9747 28.131 19.0006 27.9996 19.0006C27.8682 19.0006 27.7381 18.9747 27.6167 18.9245C27.4953 18.8742 27.385 18.8005 27.2921 18.7076L26.4996 17.9138L19.8746 24.5388C19.4103 25.0031 18.8591 25.3715 18.2524 25.6227C17.6458 25.874 16.9956 26.0034 16.339 26.0034C15.6823 26.0034 15.0321 25.874 14.4255 25.6227C13.8188 25.3715 13.2676 25.0031 12.8033 24.5388L10.8433 22.5713L4.70708 28.7076C4.61417 28.8005 4.50387 28.8742 4.38248 28.9245C4.26108 28.9747 4.13097 29.0006 3.99958 29.0006C3.86818 29.0006 3.73808 28.9747 3.61668 28.9245C3.49529 28.8742 3.38499 28.8005 3.29208 28.7076C3.19917 28.6147 3.12547 28.5044 3.07519 28.383C3.0249 28.2616 2.99902 28.1315 2.99902 28.0001C2.99902 27.8687 3.0249 27.7386 3.07519 27.6172C3.12547 27.4958 3.19917 27.3855 3.29208 27.2926L9.42833 21.1563L7.46458 19.1926C7.00026 18.7283 6.63194 18.1771 6.38065 17.5704C6.12936 16.9638 6.00002 16.3136 6.00002 15.6569C6.00002 15.0003 6.12936 14.3501 6.38065 13.7435C6.63194 13.1368 7.00026 12.5856 7.46458 12.1213L14.0896 5.49632L13.2958 4.70382C13.1082 4.51618 13.0028 4.26168 13.0028 3.99632C13.0028 3.73095 13.1082 3.47646 13.2958 3.28882C13.4835 3.10118 13.738 2.99576 14.0033 2.99576C14.2687 2.99576 14.5232 3.10118 14.7108 3.28882L17.9996 6.58632L22.2921 2.29257C22.4797 2.10493 22.7342 1.99951 22.9996 1.99951C23.2649 1.99951 23.5194 2.10493 23.7071 2.29257C23.8947 2.48021 24.0001 2.7347 24.0001 3.00007C24.0001 3.26543 23.8947 3.51993 23.7071 3.70757L19.4133 8.00007L23.9996 12.5863L28.2921 8.29257C28.4797 8.10493 28.7342 7.99951 28.9996 7.99951C29.2649 7.99951 29.5194 8.10493 29.7071 8.29257C29.8947 8.48021 30.0001 8.7347 30.0001 9.00007C30.0001 9.26543 29.8947 9.51993 29.7071 9.70757Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/migrate.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M33.75 5H13.75C13.4185 5 13.1005 5.1317 12.8661 5.36612C12.6317 5.60054 12.5 5.91848 12.5 6.25V12.5H6.25C5.91848 12.5 5.60054 12.6317 5.36612 12.8661C5.1317 13.1005 5 13.4185 5 13.75V33.75C5 34.0815 5.1317 34.3995 5.36612 34.6339C5.60054 34.8683 5.91848 35 6.25 35H26.25C26.5815 35 26.8995 34.8683 27.1339 34.6339C27.3683 34.3995 27.5 34.0815 27.5 33.75V27.5H33.75C34.0815 27.5 34.3995 27.3683 34.6339 27.1339C34.8683 26.8995 35 26.5815 35 26.25V6.25C35 5.91848 34.8683 5.60054 34.6339 5.36612C34.3995 5.1317 34.0815 5 33.75 5ZM32.5 25H27.5V13.75C27.5 13.4185 27.3683 13.1005 27.1339 12.8661C26.8995 12.6317 26.5815 12.5 26.25 12.5H15V7.5H32.5V25Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/recipes.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M33.7071 13.7076L29.4133 18.0001L32.7071 21.2926C32.8 21.3855 32.8737 21.4958 32.924 21.6172C32.9743 21.7386 33.0001 21.8687 33.0001 22.0001C33.0001 22.1315 32.9743 22.2616 32.924 22.383C32.8737 22.5044 32.8 22.6147 32.7071 22.7076C32.6142 22.8005 32.5039 22.8742 32.3825 22.9245C32.2611 22.9747 32.131 23.0006 31.9996 23.0006C31.8682 23.0006 31.7381 22.9747 31.6167 22.9245C31.4953 22.8742 31.385 22.8005 31.2921 22.7076L30.4996 21.9138L23.8746 28.5388C23.4103 29.0031 22.8591 29.3715 22.2524 29.6227C21.6458 29.874 20.9956 30.0034 20.339 30.0034C19.6823 30.0034 19.0321 29.874 18.4255 29.6227C17.8188 29.3715 17.2676 29.0031 16.8033 28.5388L14.8433 26.5713L8.70708 32.7076C8.61417 32.8005 8.50387 32.8742 8.38248 32.9245C8.26108 32.9747 8.13097 33.0006 7.99958 33.0006C7.86818 33.0006 7.73808 32.9747 7.61668 32.9245C7.49529 32.8742 7.38499 32.8005 7.29208 32.7076C7.19917 32.6147 7.12547 32.5044 7.07519 32.383C7.0249 32.2616 6.99902 32.1315 6.99902 32.0001C6.99902 31.8687 7.0249 31.7386 7.07519 31.6172C7.12547 31.4958 7.19917 31.3855 7.29208 31.2926L13.4283 25.1563L11.4646 23.1926C11.0003 22.7283 10.6319 22.1771 10.3806 21.5704C10.1294 20.9638 10 20.3136 10 19.6569C10 19.0003 10.1294 18.3501 10.3806 17.7435C10.6319 17.1368 11.0003 16.5856 11.4646 16.1213L18.0896 9.49632L17.2958 8.70382C17.1082 8.51618 17.0028 8.26168 17.0028 7.99632C17.0028 7.73095 17.1082 7.47646 17.2958 7.28882C17.4835 7.10118 17.738 6.99576 18.0033 6.99576C18.2687 6.99576 18.5232 7.10118 18.7108 7.28882L21.9996 10.5863L26.2921 6.29257C26.4797 6.10493 26.7342 5.99951 26.9996 5.99951C27.2649 5.99951 27.5194 6.10493 27.7071 6.29257C27.8947 6.48021 28.0001 6.7347 28.0001 7.00007C28.0001 7.26543 27.8947 7.51993 27.7071 7.70757L23.4133 12.0001L27.9996 16.5863L32.2921 12.2926C32.4797 12.1049 32.7342 11.9995 32.9996 11.9995C33.2649 11.9995 33.5194 12.1049 33.7071 12.2926C33.8947 12.4802 34.0001 12.7347 34.0001 13.0001C34.0001 13.2654 33.8947 13.5199 33.7071 13.7076Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/support.svg">
<svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M19.9996 3.75C17.1941 3.74939 14.4362 4.47514 11.9944 5.85661C9.55259 7.23808 7.51003 9.22821 6.06553 11.6333C4.62104 14.0384 3.82383 16.7764 3.7515 19.581C3.67916 22.3856 4.33417 25.1612 5.65277 27.6375L3.87933 32.9578C3.73243 33.3983 3.71111 33.871 3.81776 34.3229C3.92441 34.7749 4.15482 35.1881 4.48316 35.5165C4.8115 35.8448 5.22479 36.0752 5.67671 36.1819C6.12864 36.2885 6.60134 36.2672 7.04183 36.1203L12.3621 34.3469C14.5415 35.506 16.9562 36.1534 19.4231 36.24C21.89 36.3266 24.3442 35.85 26.5994 34.8465C28.8546 33.8429 30.8516 32.3388 32.4387 30.4483C34.0258 28.5577 35.1614 26.3304 35.7592 23.9355C36.357 21.5406 36.4014 19.0409 35.8889 16.6263C35.3764 14.2117 34.3206 11.9455 32.8016 9.99987C31.2825 8.05421 29.3402 6.48019 27.122 5.39727C24.9038 4.31436 22.4681 3.75101 19.9996 3.75ZM13.1246 21.875C12.7538 21.875 12.3913 21.765 12.0829 21.559C11.7746 21.353 11.5343 21.0601 11.3924 20.7175C11.2505 20.3749 11.2133 19.9979 11.2857 19.6342C11.358 19.2705 11.5366 18.9364 11.7988 18.6742C12.061 18.412 12.3951 18.2334 12.7588 18.161C13.1226 18.0887 13.4996 18.1258 13.8422 18.2677C14.1848 18.4096 14.4776 18.65 14.6836 18.9583C14.8897 19.2666 14.9996 19.6292 14.9996 20C14.9996 20.4973 14.8021 20.9742 14.4505 21.3258C14.0988 21.6775 13.6219 21.875 13.1246 21.875ZM19.9996 21.875C19.6288 21.875 19.2663 21.765 18.9579 21.559C18.6496 21.353 18.4093 21.0601 18.2674 20.7175C18.1255 20.3749 18.0883 19.9979 18.1607 19.6342C18.233 19.2705 18.4116 18.9364 18.6738 18.6742C18.936 18.412 19.2701 18.2334 19.6338 18.161C19.9976 18.0887 20.3746 18.1258 20.7172 18.2677C21.0598 18.4096 21.3526 18.65 21.5586 18.9583C21.7647 19.2666 21.8746 19.6292 21.8746 20C21.8746 20.4973 21.6771 20.9742 21.3255 21.3258C20.9738 21.6775 20.4969 21.875 19.9996 21.875ZM26.8746 21.875C26.5038 21.875 26.1413 21.765 25.833 21.559C25.5246 21.353 25.2843 21.0601 25.1424 20.7175C25.0005 20.3749 24.9633 19.9979 25.0357 19.6342C25.108 19.2705 25.2866 18.9364 25.5488 18.6742C25.811 18.412 26.1451 18.2334 26.5089 18.161C26.8726 18.0887 27.2496 18.1258 27.5922 18.2677C27.9348 18.4096 28.2276 18.65 28.4336 18.9583C28.6397 19.2666 28.7496 19.6292 28.7496 20C28.7496 20.4973 28.5521 20.9742 28.2005 21.3258C27.8488 21.6775 27.3719 21.875 26.8746 21.875Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/upgrade.svg">
<svg width="41" height="40" viewBox="0 0 41 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M34.25 6.25H6.75C6.08696 6.25 5.45107 6.51339 4.98223 6.98223C4.51339 7.45107 4.25 8.08696 4.25 8.75V31.25C4.25 31.913 4.51339 32.5489 4.98223 33.0178C5.45107 33.4866 6.08696 33.75 6.75 33.75H34.25C34.913 33.75 35.5489 33.4866 36.0178 33.0178C36.4866 32.5489 36.75 31.913 36.75 31.25V8.75C36.75 8.08696 36.4866 7.45107 36.0178 6.98223C35.5489 6.51339 34.913 6.25 34.25 6.25ZM32.6344 13.3844L17.6344 28.3844C17.5183 28.5006 17.3804 28.5928 17.2287 28.6557C17.0769 28.7186 16.9143 28.751 16.75 28.751C16.5857 28.751 16.4231 28.7186 16.2713 28.6557C16.1196 28.5928 15.9817 28.5006 15.8656 28.3844L9.61562 22.1344C9.38107 21.8998 9.2493 21.5817 9.2493 21.25C9.2493 20.9183 9.38107 20.6002 9.61562 20.3656C9.85018 20.1311 10.1683 19.9993 10.5 19.9993C10.8317 19.9993 11.1498 20.1311 11.3844 20.3656L16.75 25.7328L30.8656 11.6156C31.1002 11.3811 31.4183 11.2493 31.75 11.2493C32.0817 11.2493 32.3998 11.3811 32.6344 11.6156C32.8689 11.8502 33.0007 12.1683 33.0007 12.5C33.0007 12.8317 32.8689 13.1498 32.6344 13.3844Z" fill="#9A9A9A"/>
</svg>
</file>

<file path="images/reown/walletkit-logo.svg">
<svg width="56" height="56" viewBox="0 0 56 56" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect width="56" height="56" rx="16.3333" fill="#FFB800"/>
<path d="M11.6667 16.3333C11.6667 15.0447 12.7114 14 14.0001 14H35.0001C36.2887 14 37.3334 15.0447 37.3334 16.3333V21H11.6667V16.3333Z" fill="#202020"/>
<path d="M11.6667 23.3333H43.1667C43.8111 23.3333 44.3334 23.8557 44.3334 24.5V39.6667C44.3334 40.9553 43.2887 42 42.0001 42H14.0001C12.7114 42 11.6667 40.9553 11.6667 39.6667V23.3333Z" fill="#202020"/>
</svg>
</file>

<file path="images/docs-logo.svg">
<svg width="217" height="48" viewBox="0 0 217 48" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M28 14C28 6.26801 34.268 0 42 0H62C69.732 0 76 6.26801 76 14V34C76 41.732 69.732 48 62 48H42C34.268 48 28 41.732 28 34V14Z" fill="#008847"/>
<path d="M46.8164 33L53.8341 14H55.8946L48.8769 33H46.8164Z" fill="#202020"/>
<path d="M0 13C0 5.8203 5.8203 0 13 0C20.1797 0 26 5.8203 26 13V35C26 42.1797 20.1797 48 13 48C5.8203 48 0 42.1797 0 35V13Z" fill="#008847"/>
<path d="M11.75 29.9991V27.4991H14.25V29.9991H11.75Z" fill="#202020"/>
<path d="M78 24C78 10.7452 88.7452 0 102 0H143C156.255 0 167 10.7452 167 24C167 37.2548 156.255 48 143 48H102C88.7452 48 78 37.2548 78 24Z" fill="#008847"/>
<path d="M99.606 31.5V16.1H103.83C108.032 16.1 110.628 19.334 110.628 23.8C110.628 28.266 108.032 31.5 103.83 31.5H99.606ZM103.72 29.806C106.756 29.806 108.516 27.408 108.516 23.8C108.516 20.192 106.756 17.794 103.72 17.794H101.608V29.806H103.72Z" fill="#202020"/>
<path d="M116.813 31.786C113.447 31.786 111.467 29.278 111.467 25.956C111.467 22.656 113.447 20.126 116.813 20.126C120.179 20.126 122.159 22.656 122.159 25.956C122.159 29.278 120.179 31.786 116.813 31.786ZM116.813 30.158C119.233 30.158 120.157 28.09 120.157 25.934C120.157 23.8 119.233 21.754 116.813 21.754C114.393 21.754 113.469 23.8 113.469 25.934C113.469 28.09 114.393 30.158 116.813 30.158Z" fill="#202020"/>
<path d="M129.091 31.786C125.857 31.786 123.745 29.278 123.745 25.956C123.745 22.656 125.857 20.126 129.113 20.126C131.643 20.126 133.513 21.666 133.865 24.218H131.885C131.577 22.656 130.499 21.754 129.091 21.754C126.781 21.754 125.769 23.734 125.769 25.934C125.769 28.156 126.781 30.158 129.091 30.158C130.521 30.158 131.489 29.41 131.885 27.98H133.843C133.425 30.246 131.731 31.786 129.091 31.786Z" fill="#202020"/>
<path d="M140.798 31.786C137.894 31.786 136.09 30.378 135.892 28.024H137.872C138.136 29.498 139.126 30.202 140.842 30.202C142.338 30.202 143.262 29.52 143.262 28.464C143.262 27.65 142.668 27.078 141.524 26.88L139.346 26.44C137.762 26.132 136.2 25.384 136.2 23.36C136.2 21.512 137.938 20.126 140.534 20.126C143.042 20.126 144.868 21.182 145.088 23.602H143.108C142.91 22.37 141.986 21.71 140.512 21.71C139.104 21.71 138.158 22.37 138.158 23.294C138.158 24.174 138.928 24.592 139.808 24.768L142.118 25.208C143.68 25.516 145.264 26.374 145.264 28.354C145.264 30.422 143.438 31.786 140.798 31.786Z" fill="#202020"/>
<path d="M169 14C169 6.26801 175.268 0 183 0H203C210.732 0 217 6.26801 217 14V34C217 41.732 210.732 48 203 48H183C175.268 48 169 41.732 169 34V14Z" fill="#008847"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M193 11H185C183.895 11 183 11.8954 183 13V34C183 35.1046 183.895 36 185 36H201C202.105 36 203 35.1046 203 34V21H195C193.895 21 193 20.1046 193 19V11ZM203 19L195 11V19H203Z" fill="#202020"/>
</svg>
</file>

<file path="images/v.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="136" height="20" role="img" aria-label="maven-central: v1.3.0"><title>maven-central: v1.3.0</title><linearGradient id="s" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="r"><rect width="136" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#r)"><rect width="91" height="20" fill="#555"/><rect x="91" width="45" height="20" fill="#007ec6"/><rect width="136" height="20" fill="url(#s)"/></g><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110"><text aria-hidden="true" x="465" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="810">maven-central</text><text x="465" y="140" transform="scale(.1)" fill="#fff" textLength="810">maven-central</text><text aria-hidden="true" x="1125" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="350">v1.3.0</text><text x="1125" y="140" transform="scale(.1)" fill="#fff" textLength="350">v1.3.0</text></g></svg>
</file>

<file path="images/walletconnect-logo-black.svg">
<svg width="218" height="48" viewBox="0 0 218 48" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M28.25 14C28.25 6.26801 34.518 0 42.25 0H62.25C69.982 0 76.25 6.26801 76.25 14V34C76.25 41.732 69.982 48 62.25 48H42.25C34.518 48 28.25 41.732 28.25 34V14Z" fill="#008847"/>
<path d="M47.0664 33L54.0841 14H56.1446L49.1269 33H47.0664Z" fill="#202020"/>
<path d="M0.25 13C0.25 5.8203 6.0703 0 13.25 0C20.4297 0 26.25 5.8203 26.25 13V35C26.25 42.1797 20.4297 48 13.25 48C6.0703 48 0.25 42.1797 0.25 35V13Z" fill="#008847"/>
<path d="M12 29.999V27.499H14.5V29.999H12Z" fill="#202020"/>
<rect x="78.25" width="89" height="48" rx="24" fill="#008847"/>
<path d="M100.253 29.8701V14.4701H104.477C108.679 14.4701 111.275 17.7041 111.275 22.1701C111.275 26.6361 108.679 29.8701 104.477 29.8701H100.253ZM102.255 28.1761H104.367C107.403 28.1761 109.163 25.7781 109.163 22.1701C109.163 18.5621 107.403 16.1641 104.367 16.1641H102.255V28.1761ZM117.459 30.1561C114.093 30.1561 112.113 27.6481 112.113 24.3261C112.113 21.0261 114.093 18.4961 117.459 18.4961C120.825 18.4961 122.805 21.0261 122.805 24.3261C122.805 27.6481 120.825 30.1561 117.459 30.1561ZM114.115 24.3041C114.115 26.4601 115.039 28.5281 117.459 28.5281C119.879 28.5281 120.803 26.4601 120.803 24.3041C120.803 22.1701 119.879 20.1241 117.459 20.1241C115.039 20.1241 114.115 22.1701 114.115 24.3041ZM129.738 30.1561C126.504 30.1561 124.392 27.6481 124.392 24.3261C124.392 21.0261 126.504 18.4961 129.76 18.4961C132.29 18.4961 134.16 20.0361 134.512 22.5881H132.532C132.224 21.0261 131.146 20.1241 129.738 20.1241C127.428 20.1241 126.416 22.1041 126.416 24.3041C126.416 26.5261 127.428 28.5281 129.738 28.5281C131.168 28.5281 132.136 27.7801 132.532 26.3501H134.49C134.072 28.6161 132.378 30.1561 129.738 30.1561ZM141.444 30.1561C138.54 30.1561 136.736 28.7481 136.538 26.3941H138.518C138.782 27.8681 139.772 28.5721 141.488 28.5721C142.984 28.5721 143.908 27.8901 143.908 26.8341C143.908 26.0201 143.314 25.4481 142.17 25.2501L139.992 24.8101C138.408 24.5021 136.846 23.7541 136.846 21.7301C136.846 19.8821 138.584 18.4961 141.18 18.4961C143.688 18.4961 145.514 19.5521 145.734 21.9721H143.754C143.556 20.7401 142.632 20.0801 141.158 20.0801C139.75 20.0801 138.804 20.7401 138.804 21.6641C138.804 22.5441 139.574 22.9621 140.454 23.1381L142.764 23.5781C144.326 23.8861 145.91 24.7441 145.91 26.7241C145.91 28.7921 144.084 30.1561 141.444 30.1561Z" fill="#202020"/>
<rect x="169.25" width="48" height="48" rx="14" fill="#008847"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M193.25 11H185.25C184.145 11 183.25 11.8954 183.25 13V34C183.25 35.1046 184.145 36 185.25 36H201.25C202.355 36 203.25 35.1046 203.25 34V21H195.25C194.145 21 193.25 20.1046 193.25 19V11ZM203.25 19L195.25 11V19H203.25Z" fill="#202020"/>
</svg>
</file>

<file path="images/walletconnect-logo-white.svg">
<svg height="185" viewBox="0 0 300 185" width="300" xmlns="http://www.w3.org/2000/svg"><path d="m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z" fill="#fff"/></svg>
</file>

<file path="images/walletconnect-logo.svg">
<svg height="185" viewBox="0 0 300 185" width="300" xmlns="http://www.w3.org/2000/svg"><path d="m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z" fill="#3b99fc"/></svg>
</file>

<file path="snippets/appkit/javascript/bitcoin/about/implementation.mdx">
import BitcoinProviderInterface from "/snippets/appkit/shared/bitcoin-provider.mdx";

AppKit Bitcoin is built on top of the AppKit library and provides a set of components and actions to easily connect Bitcoin wallets with your decentralized application.

On top of your app set up the following configuration.

```tsx
// App.tsx
import { createAppKit } from '@reown/appkit'
import { BitcoinAdapter } from '@reown/appkit-adapter-bitcoin'
import { bitcoin } from '@reown/appkit/networks'

// 1. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set the networks
const networks = [bitcoin]

// 3. Set up Bitcoin Adapter
const bitcoinAdapter = new BitcoinAdapter({
  projectId
})

// 4. Create a metadata object - optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Bitcoin Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 5. Create modal
const modal = createAppKit({
  adapters: [bitcoinAdapter],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true // Optional - defaults to your Cloud configuration,
    email: false,
    socials: []
  }
})

// 6. Trigger modal programaticaly
const openConnectModalBtn = document.getElementById('open-connect-modal')
const openNetworkModalBtn = document.getElementById('open-network-modal')

openConnectModalBtn.addEventListener('click', () => modal.open())
openNetworkModalBtn.addEventListener('click', () => modal.open({ view: 'Networks' }))
```


<BitcoinProviderInterface />
</file>

<file path="snippets/appkit/javascript/bitcoin/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**actions**](../../core/actions.mdx#open-and-close-the-modal).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```tsx
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HTML AppKit Example</title>
  </head>
  <body>
    <appkit-button />
    <script type="module" src="main.js"></script>
  </body>
</html>
```
</file>

<file path="snippets/appkit/javascript/ethers/about/implementation.mdx">
In your `main.js` file set up the following configuration.

```ts
import { createAppKit } from "@reown/appkit";
import { EthersAdapter } from "@reown/appkit-adapter-ethers";
import { mainnet, arbitrum } from "@reown/appkit/networks";

// 1. Get projectId from https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create your application's metadata object
const metadata = {
  name: "AppKit",
  description: "AppKit Example",
  url: "https://reown.com/appkit", // origin must match your domain & subdomain
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
};

// 3. Create a AppKit instance
const modal = createAppKit({
  adapters: [new EthersAdapter()],
  networks: [mainnet, arbitrum],
  metadata,
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/javascript/ethers/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**actions**](../../core/actions.mdx#open-and-close-the-modal).

<Tabs>
<Tab title="Web Component">

```html {3,4}
  <body>
    <div id="app">
      <appkit-button />
      <appkit-network-button />
    </div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
```

Learn more about the AppKit web components [here](../../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="actions">

You can trigger the modal by calling the `open` function from a modal instance returned by `createAppKit`.

Let's first add two html button elements into our `index.html` file:

```html {9,10}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HTML Example</title>
  </head>
  <body>
    <div id="app">
      <button id="open-connect-modal">Open Modal</button>
      <button id="open-network-modal">Open Networks</button>
    </div>
    <script type="module" src="main.js"></script>
  </body>
</html>
```

Following with our `main.js` file, we can now add the needed logic to open the modal:

```ts
// Trigger modal programaticaly
// Add this code inside `main.js` file at the end of the code file
const openConnectModalBtn = document.getElementById("open-connect-modal");
const openNetworkModalBtn = document.getElementById("open-network-modal");

openConnectModalBtn.addEventListener("click", () => modal.open());
openNetworkModalBtn.addEventListener("click", () =>
  modal.open({ view: "Networks" })
);
```

Learn more about the AppKit actions [here](../../core/actions)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/javascript/ethers/actions.mdx">
You can use the following methods to get data and subscribe to changes:

### getAddress

```ts
const address = modal.getAddress();
```

### getError

```ts
const error = modal.getError();
```

### getChainId

```ts
const chainId = modal.getChainId();
```

### switchNetwork

```ts
import { createAppKit } from "@reown/appkit";
import { mainnet, arbitrum, polygon } from "@reown/appkit/networks";

const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    analytics: true,
  },
});

modal.switchNetwork(polygon);
```

### getIsConnected

```ts
const isConnected = modal.getIsConnected();
```

### getWalletProvider

The wallet provider.

```ts
const walletProvider = modal.getWalletProvider();
```

### getWalletProviderType

```ts
const walletProviderType = modal.getWalletProviderType();
```

### subscribeProvider

```ts
function handleChange({
  provider,
  providerType,
  address,
  error,
  chainId,
  isConnected,
}) {
  //...
}

modal.subscribeProvider(handleChange);
```

<Card
  title="Learn More"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/javascript/ethers5/implementation.mdx">
In your `main.js` file set up the following configuration.

```ts
import { createAppKit } from "@reown/appkit";
import { Ethers5Adapter } from "@reown/appkit-adapter-ethers5";
import { mainnet, arbitrum } from "@reown/appkit/networks";

// 1. Get projectId at https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create your application's metadata object
const metadata = {
  name: "My Website",
  description: "My Website description",
  url: "https://mywebsite.com", // url must match your domain & subdomain
  icons: ["https://avatars.mywebsite.com/"],
};

// 3. Create a AppKit instance
const modal = createAppKit({
  adapters: [new Ethers5Adapter()],
  metadata: metadata,
  networks: [mainnet, arbitrum],
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/javascript/solana/about/implementation.mdx">
AppKit Solana is built on top of the AppKit library and provides a set of components and actions to easily connect Solana wallets with your application.

On top of your app set up the following configuration.

```tsx
import { createAppKit } from "@reown/appkit";
import { SolanaAdapter } from "@reown/appkit-adapter-solana";
import { solana, solanaTestnet, solanaDevnet } from "@reown/appkit/networks";

// 0. Set up Solana Adapter
const solanaWeb3JsAdapter = new SolanaAdapter();

// 1. Get projectId from https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create a metadata object - optional
const metadata = {
  name: "AppKit",
  description: "AppKit Solana Example",
  url: "https://example.com", // origin must match your domain & subdomain
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
};

// 3. Create modal
createAppKit({
  adapters: [solanaWeb3JsAdapter],
  networks: [solana, solanaTestnet, solanaDevnet],
  metadata: metadata,
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});
```
</file>

<file path="snippets/appkit/javascript/solana/about/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to our [lab dApp](https://appkit-lab.reown.com/library/solana/).

```js
import { PublicKey, LAMPORTS_PER_SOL, Transaction, SystemProgram } from "@solana/web3.js";

import type { Provider } from '@reown/appkit-adapter-solana'

const solanaProvider = {};
const solanaConnection = {};
modal.subscribeProviders(state => {
    solanaProvider = state['solana'];
    const url = solanaProvider.getActiveChain().rpcUrls.default.http[0];
    const solanaConnection = new Connection(url);
})

const addressFrom = await modal.subscribeAccount(state => {
  return state;
})

const sendTransaction = async () => {
  if (!addressFrom || !solanaConnection) throw Error('user is disconnected');

  const wallet = new PublicKey(addressFrom);
  if (!wallet) throw Error('wallet provider is not available');

  const latestBlockhash = await solanaConnection.getLatestBlockhash();

  const transaction = new Transaction({
    feePayer: wallet,
    recentBlockhash: latestBlockhash?.blockhash,
  }).add(
    SystemProgram.transfer({
      fromPubkey: wallet,
      toPubkey: new PublicKey(address), // destination address
      lamports: 1000,
    })
  );

  return await provider.sendTransaction(transaction, solanaConnection);
}

const getBalance = async () => {
  if (!addressFrom || !solanaConnection) throw Error('user is disconnected');

  const wallet = new PublicKey(addressFrom);
  const balance = await solanaConnection?.getBalance(wallet);
  if (balance !== undefined) {
    return `${balance / LAMPORTS_PER_SOL}`;
  } else {
    return '-';
  }
}
```
</file>

<file path="snippets/appkit/javascript/solana/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**actions**](../../core/actions.mdx#open-and-close-the-modal).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```html {8}
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HTML Example</title>
  </head>
  <body>
    <appkit-button />
    <script type="module" src="main.js"></script>
  </body>
</html>
```

Learn more about the AppKit web components [here](../../core/components)
</file>

<file path="snippets/appkit/javascript/solana/actions.mdx">
You can use the following methods to get data and subscribe to changes:

### getAddress

```ts
const address = modal.getAddress();
```

### getError

```ts
const error = modal.getError();
```

### getChainId

```ts
const chainId = modal.getChainId();
```

### getIsConnected

```ts
const isConnected = modal.getIsConnected();
```

### getWalletProvider

The wallet provider.

```ts
const walletProvider = modal.getWalletProvider();
```

// TODO - add sign message example

### getWalletProviderType

The wallet or protocol of the walletProvider.

```ts
const walletProviderType = modal.getWalletProviderType();
```

### subscribeProvider

subscribe to chainId, address, provider changes.

```ts
function handleChange({
  provider,
  providerType,
  address,
  error,
  chainId,
  isConnected,
}) {
  //...
}

modal.subscribeProvider(handleChange);
```

<Card
  title="Learn More"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/javascript/wagmi/about/implementation.mdx">
For a quick integration, you can use the `createAppKit` function with a unified configuration. This automatically applies the predefined configurations for different adapters like Wagmi, Ethers, or Solana, so you no longer need to manually configure each one individually. Simply pass the common parameters such as `projectId`, `chains`, `metadata`, etc., and the function will handle the adapter-specific configurations under the hood.

This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

In your `main.js` file set up the following configuration.

```ts
import { createAppKit } from '@reown/appkit'
import { mainnet, arbitrum } from '@reown/appkit/networks'
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'

// 1. Get a project ID at https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

export const networks = [mainnet, arbitrum]

// 2. Set up Wagmi adapter
const wagmiAdapter = new WagmiAdapter({
  projectId,
  networks
})

// 3. Configure the metadata
const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 3. Create the modal
const modal = createAppKit({
  adapters: [wagmiAdapter],
  networks: [mainnet, arbitrum],
  metadata,
  projectId,
  features: {
    analytics: true // Optional - defaults to your Cloud configuration
  }
})

// 4. Trigger modal programaticaly
const openConnectModalBtn = document.getElementById('open-connect-modal')
const openNetworkModalBtn = document.getElementById('open-network-modal')

openConnectModalBtn.addEventListener('click', () => modal.open())
openNetworkModalBtn.addEventListener('click', () => modal.open({ view: 'Networks' }))

// 5. Alternatively use w3m component buttons within the index.html file
```

## Importing networks

Reown AppKit use [Viem](https://viem.sh/) networks under the hood, which provide a wide variety of networks for EVM chains. You can find all the networks supported by Viem within the `@reown/appkit/networks` path.

```js {2}
import { createAppKit } from '@reown/appkit'
import { mainnet, arbitrum, base, scroll, polygon } from '@reown/appkit/networks'
```

<Note>
Looking to add a custom network? Check out the [custom networks](../../core/custom-networks) section.
</Note>
</file>

<file path="snippets/appkit/javascript/wagmi/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**actions**](../../core/actions.mdx#open-and-close-the-modal).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```html {11,12}
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>HTML Example</title>
  </head>
  <body>
    <div id="app">
      <button id="open-connect-modal">Open Modal</button>
      <button id="open-network-modal">Open Networks</button>
      <appkit-button />
      <appkit-network-button />
    </div>
    <script type="module" src="main.js"></script>
  </body>
</html>
```

Learn more about the AppKit web components [here](../../core/components)
</file>

<file path="snippets/appkit/javascript/wagmi/actions.mdx">
You can use [Wagmi actions](https://wagmi.sh/core/actions/getAccount) to sign messages, interact with smart contracts, and much more.

### getAccount

Action for accessing account data and connection status.

```tsx
import { getAccount } from "@wagmi/core";
import { wagmiConfig } from "./main";

const account = getAccount(wagmiConfig);
```

### signMessage

Action for signing messages with connected account.

```ts
import { signMessage } from "@wagmi/core";
import { wagmiConfig } from "./main";

await signMessage(wagmiConfig, { message: "hello world" });
```

<Card title="Learn More" href="https://wagmi.sh/core/actions/readContract" />
</file>

<file path="snippets/appkit/next/bitcoin/about/implementation.mdx">
import BitcoinProviderInterface from "/snippets/appkit/shared/bitcoin-provider.mdx";

AppKit Bitcoin provides a set of React components and hooks to easily connect Bitcoin wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
// App.tsx
import { createAppKit } from '@reown/appkit/react'
import { BitcoinAdapter } from '@reown/appkit-adapter-bitcoin'
import { bitcoin  } from '@reown/appkit/networks'

// 1. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set the networks
const networks = [bitcoin]

// 3. Set up Bitcoin Adapter
const bitcoinAdapter = new BitcoinAdapter({
  projectId
})

// 4. Create a metadata object - optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Bitcoin Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 5. Create modal
createAppKit({
  adapters: [bitcoinAdapter],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true // Optional - defaults to your Cloud configuration,
    email: false,
    socials: []
  }
})

export default function App() {
  return <YourApp />
}
```

<BitcoinProviderInterface />
</file>

<file path="snippets/appkit/next/bitcoin/about/triggermodal.mdx">
To open AppKit you can use our default [web components](../../core/components) or build your own logic using [AppKit hooks](../../core/hooks).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <appkit-button />
}
```
</file>

<file path="snippets/appkit/next/core/open.mdx">
You can also select the modal's view when calling the `open` function

```ts
open({ view: "Account" });

// to connect and show multi wallets view
open({ view: "Connect" });

// to connect and show only solana wallets
open({ view: "Connect", namespace: "solana" });

// to connect and show only bitcoin wallets
open({ view: "Connect", namespace: "bip122" });

// to connect and show only ethereum wallets
open({ view: "Connect", namespace: "eip155" });

// to open swap with arguments
open({
  view: 'Swap',
  arguments: {
    amount: '321.123',
    fromToken: 'USDC',
    toToken: 'ETH'
  }
})
```

List of views you can select

<Table
  headers={["Variable", "Description"]}
  data={[
    {
      variable: { code: "Connect" },
      description:
        "Principal view of the modal - default view when disconnected. A `namespace` can be selected to connect to a specific network (solana, bip122 or eip155)",
    },
    {
      variable: { code: "Account" },
      description: "User profile - default view when connected",
    },
    {
      variable: { code: "AllWallets" },
      description: "Shows the list of all available wallets",
    },
    {
      variable: { code: "Networks" },
      description:
        "List of available networks - you can select and target a specific network before connecting",
    },
    {
      variable: { code: "WhatIsANetwork" },
      description: '"What is a network" onboarding view',
    },
    {
      variable: { code: "WhatIsAWallet" },
      description: '"What is a wallet" onboarding view',
    },
    {
      variable: { code: "OnRampProviders" },
      description: "On-Ramp main view",
    },
    {
      variable: { code: "Swap" },
      description: "Swap main view",
    },
  ]}
/>
</file>

<file path="snippets/appkit/next/ethers/about/implementation.mdx">
In this example we will create a new file called `context/appkit.tsx` outside our app directory and set up the following configuration

```tsx
"use client";

import { createAppKit } from "@reown/appkit/react";
import { EthersAdapter } from "@reown/appkit-adapter-ethers";
import { mainnet, arbitrum } from "@reown/appkit/networks";

// 1. Get projectId at https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create a metadata object
const metadata = {
  name: "My Website",
  description: "My Website description",
  url: "https://mywebsite.com", // origin must match your domain & subdomain
  icons: ["https://avatars.mywebsite.com/"],
};

// 3. Create the AppKit instance
createAppKit({
  adapters: [new EthersAdapter()],
  metadata,
  networks: [mainnet, arbitrum],
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});

export function AppKit() {
  return (
    <YourApp /> //make sure you have configured the <appkit-button> inside
  );
}
```

Next, in your `app/layout.tsx` or `app/layout.jsx` file, import the custom AppKit component.

```tsx
import "./globals.css";

import { AppKit } from "../context/appkit";

export const metadata = {
  title: "AppKit",
  description: "AppKit Example",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <AppKit>{children}</AppKit>
      </body>
    </html>
  );
}
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/next/ethers/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useAppKit).

<Tabs>
<Tab title="Web Component">

```tsx
export default function ConnectButton() {
  return <appkit-button />;
}
```

Learn more about the AppKit web components [here](../../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { useAppKit } from "@reown/appkit/react";

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useAppKit();

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: "Networks" })}>
        Open Network Modal
      </button>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/next/ethers/hooks.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/react";

function Components() {
  const { address, caipAddress, isConnected } = useAppKitAccount();

  //...
}
```

### switchNetwork

```tsx
import { createAppKit } from "@reown/appkit/react";
import { mainnet, arbitrum, polygon } from "@reown/appkit/networks";

const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    analytics: true,
  },
});

modal.switchNetwork(polygon);
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from "ethers";
import { useAppKitProvider } from "@reown/appkit/react";

function Components() {
  const { walletProvider } = useAppKitProvider("eip155");

  async function onSignMessage() {
    const provider = new BrowserProvider(walletProvider);
    const signer = await provider.getSigner();
    const signature = await signer?.signMessage("Hello AppKit Ethers");
    console.log(signature);
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

### getError

```ts
function Components() {
  const error = modal.getError();
  //...
}
```

<Card
  title="Learn More About Ethers"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/next/ethers5/hooks.mdx">
### switchNetwork

```tsx
import { createAppKit } from "@reown/appkit/react";
import { mainnet, arbitrum, polygon } from "@reown/appkit/networks";

const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    analytics: true,
  },
});

modal.switchNetwork(polygon);
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import {
  useAppKitAccount,
  useAppKitProvider,
  useAppKitNetwork,
} from "@reown/appkit/react";
import { ethers } from "ethers";
import { useAppKitProvider } from "@reown/appkit/react";

function Components() {
  const { walletProvider } = useAppKitProvider("eip155");
  const { address } = useAppKitAccount();
  const { chainId } = useAppKitNetwork();

  async function onSignMessage() {
    const provider = new ethers.providers.Web3Provider(walletProvider, chainId);
    const signer = provider.getSigner(address);
    const signature = await signer?.signMessage("Hello AppKit Ethers");
    console.log(signature);
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

### getError

```ts
function Components() {
  const error = modal.getError();
  //...
}
```

<Card
  title="Learn More About Ethers"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/next/ethers5/implementation.mdx">
In this example we will create a new file called `context/appkit.tsx` outside our app directory and set up the following configuration

```tsx
"use client";

import { createAppKit } from "@reown/appkit/react";
import { Ethers5Adapter } from "@reown/appkit-adapter-ethers5";
import { mainnet, arbitrum } from "@reown/appkit/networks";

// 1. Get projectId at https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create a metadata object
const metadata = {
  name: "My Website",
  description: "My Website description",
  url: "https://mywebsite.com", // origin must match your domain & subdomain
  icons: ["https://avatars.mywebsite.com/"],
};

// 3. Create the AppKit instance
createAppKit({
  adapters: [new Ethers5Adapter()],
  metadata: metadata,
  networks: [mainnet, arbitrum],
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});

export function AppKit() {
  return (
    <YourApp /> //make sure you have configured the <appkit-button> inside
  );
}
```

Next, in your `app/layout.tsx` or `app/layout.jsx` file, import the custom AppKit component.

```tsx
import "./globals.css";

import { AppKit } from "../context/appkit";

export const metadata = {
  title: "AppKit",
  description: "AppKit Example",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <AppKit>{children}</AppKit>
      </body>
    </html>
  );
}
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/next/ethers5/triggermodal.mdx">
To open AppKit you can use our [**web component**](../core/components) or build your own button with AppKit [**hooks**](../core/hooks.mdx#useAppKit).

<Tabs>
<Tab title="Web Component">

```tsx
export default function ConnectButton() {
  return <appkit-button />;
}
```

Learn more about the AppKit web components [here](../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { useAppKit } from "@reown/appkit/react";

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useAppKit();

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: "Networks" })}>
        Open Network Modal
      </button>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/next/solana/about/implementation.mdx">
AppKit Solana provides a set of React components and hooks to easily connect Solana wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
// App.tsx
import { createAppKit } from "@reown/appkit/react";
import { SolanaAdapter } from "@reown/appkit-adapter-solana/react";
import { solana, solanaTestnet, solanaDevnet } from "@reown/appkit/networks";
import {
  PhantomWalletAdapter,
  SolflareWalletAdapter,
} from "@solana/wallet-adapter-wallets";

// 0. Set up Solana Adapter
const solanaWeb3JsAdapter = new SolanaAdapter({
  wallets: [new PhantomWalletAdapter(), new SolflareWalletAdapter()],
});

// 1. Get projectId from https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create a metadata object - optional
const metadata = {
  name: "AppKit",
  description: "AppKit Solana Example",
  url: "https://example.com", // origin must match your domain & subdomain
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
};

// 3. Create modal
createAppKit({
  adapters: [solanaWeb3JsAdapter],
  networks: [solana, solanaTestnet, solanaDevnet],
  metadata: metadata,
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});

export default function App() {
  return <YourApp />;
}
```
</file>

<file path="snippets/appkit/next/solana/about/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to our [lab dApp](https://appkit-lab.reown.com/library/solana/).

```tsx
import {
  SystemProgram,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  LAMPORTS_PER_SOL
} from '@solana/web3.js'
import { useAppKitAccount, useAppKitProvider } from '@reown/appkit/react'
import { useAppKitConnection, type Provider } from '@reown/appkit-adapter-solana/react'

function deserializeCounterAccount(data?: Buffer): { count: number } {
  if (data?.byteLength !== 8) {
    throw Error('Need exactly 8 bytes to deserialize counter')
  }

  return {
    count: Number(data[0])
  }
}

const { address } = useAppKitAccount()
const { connection } = useAppKitConnection()
const { walletProvider } = useAppKitProvider<Provider>('solana')

async function onIncrementCounter() {
  const PROGRAM_ID = new PublicKey('Cb5aXEgXptKqHHWLifvXu5BeAuVLjojQ5ypq6CfQj1hy')

  const counterKeypair = Keypair.generate()
  const counter = counterKeypair.publicKey

  const balance = await connection.getBalance(walletProvider.publicKey)
  if (balance < LAMPORTS_PER_SOL / 100) {
    throw Error('Not enough SOL in wallet')
  }

  const COUNTER_ACCOUNT_SIZE = 8
  const allocIx: TransactionInstruction = SystemProgram.createAccount({
    fromPubkey: walletProvider.publicKey,
    newAccountPubkey: counter,
    lamports: await connection.getMinimumBalanceForRentExemption(COUNTER_ACCOUNT_SIZE),
    space: COUNTER_ACCOUNT_SIZE,
    programId: PROGRAM_ID
  })

  const incrementIx: TransactionInstruction = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      {
        pubkey: counter,
        isSigner: false,
        isWritable: true
      }
    ],
    data: Buffer.from([0x0])
  })

  const tx = new Transaction().add(allocIx).add(incrementIx)

  tx.feePayer = walletProvider.publicKey
  tx.recentBlockhash = (await connection.getLatestBlockhash('confirmed')).blockhash

  await walletProvider.signAndSendTransaction(tx, [counterKeypair])

  const counterAccountInfo = await connection.getAccountInfo(counter, {
    commitment: 'confirmed'
  })

  if (!counterAccountInfo) {
    throw new Error('Expected counter account to have been created')
  }

  const counterAccount = deserializeCounterAccount(counterAccountInfo?.data)

  if (counterAccount.count !== 1) {
    throw new Error('Expected count to have been 1')
  }

  console.log(`[alloc+increment] count is: ${counterAccount.count}`);
}
```
</file>

<file path="snippets/appkit/next/solana/about/triggermodal.mdx">
To open AppKit you can use our default web components or build your own logic using AppKit hooks.

<Tabs>
<Tab title="Components">

```tsx
export default function ConnectButton() {
  return <appkit-button />;
}
```

Learn more about the AppKit web components [here](../../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { useAppKit } from "@reown/appkit/react";

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useAppKit();

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: "Networks" })}>
        Open Network Modal
      </button>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/next/solana/hooks.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/react";

function Components() {
  const { address, caipAddress, isConnected } = useAppKitAccount();

  //...
}
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { useAppKitAccount, useAppKitProvider } from "@reown/appkit/react";
import type { Provider } from "@reown/appkit-adapter-solana";

function SignMessage() {
  // 0. Get account and provider
  const { address } = useAppKitAccount();
  const { walletProvider } = useAppKitProvider<Provider>("solana");

  // 1. Create a function to sign a message
  async function onSignMessage() {
    try {
      if (!walletProvider || !address) {
        throw Error("user is disconnected");
      }

      // 2. Encode message and sign it
      const encodedMessage = new TextEncoder().encode("Hello from AppKit");
      const signature = await walletProvider.signMessage(encodedMessage);

      console.log(signature);
    } catch (err) {
      // Handle Error Here
    }
  }

  // 3. Create a button to trigger the function
  return <button onClick={onSignMessage}>Sign Message</button>;
}
```

## useAppKitConnection

Hook that returns the connection object. More info about [Connection Class](https://solana-labs.github.io/solana-web3.js/classes/Connection.html)

```tsx
import { useAppKitConnection } from '@reown/appkit-adapter-solana/react'

...

const { connection } = useAppKitConnection()
```
</file>

<file path="snippets/appkit/next/wagmi/about/implementation.mdx">
For a quick integration, you can use the `createAppKit` function with a unified configuration. This automatically applies the predefined configurations for different adapters like Wagmi, Ethers, or Solana, so you no longer need to manually configure each one individually. Simply pass the common parameters such as projectId, chains, metadata, etc., and the function will handle the adapter-specific configurations under the hood.

This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

### Wagmi config

Create a new file for your Wagmi configuration, since we are going to be calling this function on the client and the server it cannot live inside a file with the 'use client' directive.

For this example we will create a file called `config/index.tsx` outside our app directory and set up the following configuration

```tsx
import { cookieStorage, createStorage, http } from '@wagmi/core'
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'
import { mainnet, arbitrum } from '@reown/appkit/networks'

// Get projectId from https://cloud.reown.com
export const projectId = process.env.NEXT_PUBLIC_PROJECT_ID

if (!projectId) {
  throw new Error('Project ID is not defined')
}

export const networks = [mainnet, arbitrum]

//Set up the Wagmi Adapter (Config)
export const wagmiAdapter = new WagmiAdapter({
  storage: createStorage({
    storage: cookieStorage
  }),
  ssr: true,
  projectId,
  networks
})

export const config = wagmiAdapter.wagmiConfig
```

## Importing networks

Reown AppKit use [Viem](https://viem.sh/) networks under the hood, which provide a wide variety of networks for EVM chains. You can find all the networks supported by Viem within the `@reown/appkit/networks` path.

```js {2}
import { createAppKit } from '@reown/appkit'
import { mainnet, arbitrum, base, scroll, polygon } from '@reown/appkit/networks'
```

<Note>
Looking to add a custom network? Check out the [custom networks](../../core/custom-networks) section.
</Note>

## SSR and Hydration

:::info

- Using cookies is completely optional and by default Wagmi will use `localStorage` instead if the `storage` param is not defined.
- The `ssr` flag will delay the hydration of the Wagmi's store to avoid hydration mismatch errors.
- AppKit don't fully support the `ssr` flag.
  :::

<br />

### Context Provider

Let's create now a context provider that will wrap our application and initialized AppKit (`createAppKit` needs to be called inside a Next Client Component file).

In this example we will create a file called `context/index.tsx` outside our app directory and set up the following configuration

```tsx
'use client'

import { wagmiAdapter, projectId } from '@/config'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { createAppKit } from '@reown/appkit/react'
import { mainnet, arbitrum } from '@reown/appkit/networks'
import React, { type ReactNode } from 'react'
import { cookieToInitialState, WagmiProvider, type Config } from 'wagmi'

// Set up queryClient
const queryClient = new QueryClient()

if (!projectId) {
  throw new Error('Project ID is not defined')
}

// Set up metadata
const metadata = {
  name: 'appkit-example',
  description: 'AppKit Example',
  url: 'https://appkitexampleapp.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// Create the modal
const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  defaultNetwork: mainnet,
  metadata: metadata,
  features: {
    analytics: true // Optional - defaults to your Cloud configuration
  }
})

function ContextProvider({ children, cookies }: { children: ReactNode; cookies: string | null }) {
  const initialState = cookieToInitialState(wagmiAdapter.wagmiConfig as Config, cookies)

  return (
    <WagmiProvider config={wagmiAdapter.wagmiConfig as Config} initialState={initialState}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  )
}

export default ContextProvider
```

### Layout

Next, in our `app/layout.tsx` file, we will import our `ContextProvider` component and call [the Wagmi's function `cookieToInitialState`.](https://wagmi.sh/react/guides/ssr#_2-hydrate-the-cookie)

The `initialState` returned by `cookieToInitialState`, contains the optimistic values that will populate the Wagmi's store both on the server and client.

```tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

import { headers } from 'next/headers' // added
import ContextProvider from '@/context'

export const metadata: Metadata = {
  title: 'AppKit Example App',
  description: 'Powered by Reown'
}

export default function RootLayout({
  children
}: Readonly<{
  children: React.ReactNode
}>) {

  const headersObj = await headers();
  const cookies = headersObj.get('cookie')

  return (
    <html lang="en">
      <body className={inter.className}>
        <ContextProvider cookies={cookies}>{children}</ContextProvider>
      </body>
    </html>
  )
}
```
</file>

<file path="snippets/appkit/next/wagmi/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useAppKit).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <appkit-button />
}
```

Learn more about the AppKit web components [here](../../core/components)
</file>

<file path="snippets/appkit/next/wagmi/hooks.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/react";

function Components() {
  const { address, caipAddress, isConnected } = useAppKitAccount();

  //...
}
```

### useSignMessage

Hook for signing messages with connected account.

```tsx
import { useSignMessage } from "wagmi";

function App() {
  const { signMessage } = useSignMessage();

  return (
    <button onClick={() => signMessage({ message: "hello world" })}>
      Sign message
    </button>
  );
}
```

<Card title="Learn More" href="https://wagmi.sh/react/hooks/useReadContract" />
</file>

<file path="snippets/appkit/react/bitcoin/about/implementation.mdx">
import BitcoinProviderInterface from "/snippets/appkit/shared/bitcoin-provider.mdx";

AppKit Bitcoin provides a set of React components and hooks to easily connect Bitcoin wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
// App.tsx
import { createAppKit } from '@reown/appkit/react'
import { BitcoinAdapter } from '@reown/appkit-adapter-bitcoin'
import { bitcoin } from '@reown/appkit/networks'

// 1. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set the networks
const networks = [bitcoin]

// 3. Set up Bitcoin Adapter
const bitcoinAdapter = new BitcoinAdapter({
  projectId
})

// 4. Create a metadata object - optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Bitcoin Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 5. Create modal
createAppKit({
  adapters: [bitcoinAdapter],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true // Optional - defaults to your Cloud configuration,
    email: false,
    socials: []
  }
})

export default function App() {
  return <YourApp />
}
```

<BitcoinProviderInterface />
</file>

<file path="snippets/appkit/react/bitcoin/about/triggermodal.mdx">
To open AppKit you can use our default [web components](../../core/components) or build your own logic using [AppKit hooks](../../core/hooks).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <appkit-button />
}
```
</file>

<file path="snippets/appkit/react/core/open.mdx">
You can also select the modal's view when calling the `open` function

```ts
open({ view: "Account" });

// to connect and show multi wallets view
open({ view: "Connect" });

// to connect and show only solana wallets
open({ view: "Connect", namespace: "solana" });

// to connect and show only bitcoin wallets
open({ view: "Connect", namespace: "bip122" });

// to connect and show only ethereum wallets
open({ view: "Connect", namespace: "eip155" });

// to open swap with arguments
open({
  view: 'Swap',
  arguments: {
    amount: '321.123',
    fromToken: 'USDC',
    toToken: 'ETH'
  }
})
```

List of views you can select

| Variable        | Description                                                                                                                                             |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Connect         | Principal view of the modal - default view when disconnected. A `namespace` can be selected to connect to a specific network (solana, bip122 or eip155) |
| Account         | User profile - default view when connected                                                                                                              |
| AllWallets      | Shows the list of all available wallets                                                                                                                 |
| Networks        | List of available networks - you can select and target a specific network before connecting                                                             |
| WhatIsANetwork  | "What is a network" onboarding view                                                                                                                     |
| WhatIsAWallet   | "What is a wallet" onboarding view                                                                                                                      |
| OnRampProviders | On-Ramp main view                                                                                                                                       |
| Swap            | Swap main view                                                                                                                                          |
</file>

<file path="snippets/appkit/react/ethers/about/implementation.mdx">
On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
import { createAppKit } from "@reown/appkit/react";
import { EthersAdapter } from "@reown/appkit-adapter-ethers";
import { arbitrum, mainnet } from "@reown/appkit/networks";

// 1. Get projectId
const projectId = "YOUR_PROJECT_ID";

// 2. Set the networks
const networks = [arbitrum, mainnet];

// 3. Create a metadata object - optional
const metadata = {
  name: "My Website",
  description: "My Website description",
  url: "https://mywebsite.com", // origin must match your domain & subdomain
  icons: ["https://avatars.mywebsite.com/"],
};

// 4. Create a AppKit instance
createAppKit({
  adapters: [new EthersAdapter()],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});

export default function App() {
  return <YourApp />; // Configure the <appkit-button> or a similar button inside
}
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/react/ethers/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useAppKit).

<Tabs>
<Tab title="Web Component">

```tsx
export default function ConnectButton() {
  return <appkit-button />;
}
```

Learn more about the AppKit web components [here](../../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { useAppKit } from "@reown/appkit/react";

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useAppKit();

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: "Networks" })}>
        Open Network Modal
      </button>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/react/ethers/hooks.mdx">
### switchNetwork

```tsx
import { createAppKit } from "@reown/appkit/react";
import { mainnet, arbitrum, polygon } from "@reown/appkit/networks";

const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    analytics: true,
  },
});

modal.switchNetwork(polygon);
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from "ethers";
import { useAppKitProvider } from "@reown/appkit/react";

function Components() {
  const { walletProvider } = useAppKitProvider("eip155");

  async function onSignMessage() {
    const provider = new BrowserProvider(walletProvider);
    const signer = await provider.getSigner();
    const signature = await signer?.signMessage("Hello AppKit Ethers");
    console.log(signature);
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

### getError

```ts
function Components() {
  const error = modal.getError();
  //...
}
```

<Card
  title="Learn More About Ethers"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/react/ethers5/hooks.mdx">
### switchNetwork

```tsx
import { createAppKit } from "@reown/appkit/react";
import { mainnet, arbitrum, polygon } from "@reown/appkit/networks";

const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    analytics: true,
  },
});

modal.switchNetwork(polygon);
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import {
  useAppKitAccount,
  useAppKitProvider,
  useAppKitNetwork,
} from "@reown/appkit/react";
import { ethers } from "ethers";
import { useAppKitProvider } from "@reown/appkit/react";

function Components() {
  const { walletProvider } = useAppKitProvider("eip155");
  const { address } = useAppKitAccount();
  const { chainId } = useAppKitNetwork();

  async function onSignMessage() {
    const provider = new ethers.providers.Web3Provider(walletProvider, chainId);
    const signer = provider.getSigner(address);
    const signature = await signer?.signMessage("Hello AppKit Ethers");
    console.log(signature);
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

### getError

```ts
function Components() {
  const error = modal.getError();
  //...
}
```

<Card
  title="Learn More About Ethers"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/react/ethers5/implementation.mdx">
On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
import { createAppKit } from "@reown/appkit/react";
import { Ethers5Adapter } from "@reown/appkit-adapter-ethers5";
import { mainnet, arbitrum } from "@reown/appkit/networks";

// 1. Get projectId
const projectId = "YOUR_PROJECT_ID";

// 2. Create a metadata object - optional
const metadata = {
  name: "My Website",
  description: "My Website description",
  url: "https://mywebsite.com", // origin must match your domain & subdomain
  icons: ["https://avatars.mywebsite.com/"],
};

// 3. Create the AppKit instance
createAppKit({
  adapters: [new Ethers5Adapter()],
  metadata: metadata,
  networks: [mainnet, arbitrum],
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});

export default function App() {
  return <YourApp />; //make sure you have configured the <appkit-button> inside
}
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/react/ethers5/triggermodal.mdx">
To open AppKit you can use our [**web component**](../core/components) or build your own button with AppKit [**hooks**](../core/hooks.mdx#useAppKit).

<Tabs>
<Tab title="Web Component">

```tsx
export default function ConnectButton() {
  return <appkit-button />;
}
```

Learn more about the AppKit web components [here](../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { useAppKit } from "@reown/appkit/react";

export default function ConnectButton() {
  // 4. Use modal hook
  const { open } = useAppKit();

  return (
    <>
      <button onClick={() => open()}>Open Connect Modal</button>
      <button onClick={() => open({ view: "Networks" })}>
        Open Network Modal
      </button>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/react/solana/about/implementation.mdx">
AppKit Solana provides a set of React components and hooks to easily connect Solana wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

```tsx
// App.tsx
import { createAppKit } from "@reown/appkit/react";
import { SolanaAdapter } from "@reown/appkit-adapter-solana/react";
import { solana, solanaTestnet, solanaDevnet } from "@reown/appkit/networks";
import {
  PhantomWalletAdapter,
  SolflareWalletAdapter,
} from "@solana/wallet-adapter-wallets";

// 0. Set up Solana Adapter
const solanaWeb3JsAdapter = new SolanaAdapter({
  wallets: [new PhantomWalletAdapter(), new SolflareWalletAdapter()],
});

// 1. Get projectId from https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create a metadata object - optional
const metadata = {
  name: "AppKit",
  description: "AppKit Solana Example",
  url: "https://example.com", // origin must match your domain & subdomain
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
};

// 3. Create modal
createAppKit({
  adapters: [solanaWeb3JsAdapter],
  networks: [solana, solanaTestnet, solanaDevnet],
  metadata: metadata,
  projectId,
  features: {
    analytics: true, // Optional - defaults to your Cloud configuration
  },
});

export default function App() {
  return <YourApp />;
}
```
</file>

<file path="snippets/appkit/react/solana/about/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to our [lab dApp](https://appkit-lab.reown.com/library/solana/).

```tsx
import {
  SystemProgram,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  LAMPORTS_PER_SOL
} from '@solana/web3.js'
import { useAppKitAccount, useAppKitProvider } from '@reown/appkit/react'
import { useAppKitConnection, type Provider } from '@reown/appkit-adapter-solana/react'

function deserializeCounterAccount(data?: Buffer): { count: number } {
  if (data?.byteLength !== 8) {
    throw Error('Need exactly 8 bytes to deserialize counter')
  }

  return {
    count: Number(data[0])
  }
}

const { address } = useAppKitAccount()
const { connection } = useAppKitConnection()
const { walletProvider } = useAppKitProvider<Provider>('solana')

async function onIncrementCounter() {
  const PROGRAM_ID = new PublicKey('Cb5aXEgXptKqHHWLifvXu5BeAuVLjojQ5ypq6CfQj1hy')

  const counterKeypair = Keypair.generate()
  const counter = counterKeypair.publicKey

  const balance = await connection.getBalance(walletProvider.publicKey)
  if (balance < LAMPORTS_PER_SOL / 100) {
    throw Error('Not enough SOL in wallet')
  }

  const COUNTER_ACCOUNT_SIZE = 8
  const allocIx: TransactionInstruction = SystemProgram.createAccount({
    fromPubkey: walletProvider.publicKey,
    newAccountPubkey: counter,
    lamports: await connection.getMinimumBalanceForRentExemption(COUNTER_ACCOUNT_SIZE),
    space: COUNTER_ACCOUNT_SIZE,
    programId: PROGRAM_ID
  })

  const incrementIx: TransactionInstruction = new TransactionInstruction({
    programId: PROGRAM_ID,
    keys: [
      {
        pubkey: counter,
        isSigner: false,
        isWritable: true
      }
    ],
    data: Buffer.from([0x0])
  })

  const tx = new Transaction().add(allocIx).add(incrementIx)

  tx.feePayer = walletProvider.publicKey
  tx.recentBlockhash = (await connection.getLatestBlockhash('confirmed')).blockhash

  await walletProvider.signAndSendTransaction(tx, [counterKeypair])

  const counterAccountInfo = await connection.getAccountInfo(counter, {
    commitment: 'confirmed'
  })

  if (!counterAccountInfo) {
    throw new Error('Expected counter account to have been created')
  }

  const counterAccount = deserializeCounterAccount(counterAccountInfo?.data)

  if (counterAccount.count !== 1) {
    throw new Error('Expected count to have been 1')
  }

  console.log(`[alloc+increment] count is: ${counterAccount.count}`);
}
```
</file>

<file path="snippets/appkit/react/solana/about/triggermodal.mdx">
To open AppKit you can use our default [web components](../../core/components) or build your own logic using [AppKit hooks](../../core/hooks).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <appkit-button />
}
```
</file>

<file path="snippets/appkit/react/solana/hooks.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/react";

function Components() {
  const { address, caipAddress, isConnected } = useAppKitAccount();

  //...
}
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { useAppKitAccount, useAppKitProvider } from "@reown/appkit/react";
import type { Provider } from "@reown/appkit-adapter-solana";

function SignMessage() {
  // 0. Get account and provider
  const { address } = useAppKitAccount();
  const { walletProvider } = useAppKitProvider<Provider>("solana");

  // 1. Create a function to sign a message
  async function onSignMessage() {
    try {
      if (!walletProvider || !address) {
        throw Error("user is disconnected");
      }

      // 2. Encode message and sign it
      const encodedMessage = new TextEncoder().encode("Hello from AppKit");
      const signature = await walletProvider.signMessage(encodedMessage);

      console.log(signature);
    } catch (err) {
      // Handle Error Here
    }
  }

  // 3. Create a button to trigger the function
  return <button onClick={onSignMessage}>Sign Message</button>;
}
```

## useAppKitConnection

Hook that returns the connection object. More info about [Connection Class](https://solana-labs.github.io/solana-web3.js/classes/Connection.html)

```tsx
import { useAppKitConnection } from '@reown/appkit-adapter-solana/react'

...

const { connection } = useAppKitConnection()
```
</file>

<file path="snippets/appkit/react/wagmi/about/implementation.mdx">
For a quick integration, you can use the `createAppKit` function with a unified configuration. This automatically applies the predefined configurations for different adapters like Wagmi, Ethers, or Solana, so you no longer need to manually configure each one individually. Simply pass the common parameters such as `projectId`, `chains`, `metadata`, etc., and the function will handle the adapter-specific configurations under the hood.

This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

On top of your app set up the following configuration, making sure that all functions are called **outside** any React component to avoid unwanted rerenders.

```tsx
import { createAppKit } from '@reown/appkit/react'

import { WagmiProvider } from 'wagmi'
import { arbitrum, mainnet } from '@reown/appkit/networks'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'

// 0. Setup queryClient
const queryClient = new QueryClient()

// 1. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Create a metadata object - optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 3. Set the networks
const networks = [mainnet, arbitrum]

// 4. Create Wagmi Adapter
const wagmiAdapter = new WagmiAdapter({
  networks,
  projectId,
  ssr: true
})

// 5. Create modal
createAppKit({
  adapters: [wagmiAdapter],
  networks,
  projectId,
  metadata,
  features: {
    analytics: true // Optional - defaults to your Cloud configuration
  }
})

export function AppKitProvider({ children }) {
  return (
    <WagmiProvider config={wagmiAdapter.wagmiConfig}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </WagmiProvider>
  )
}
```

## Importing networks

Reown AppKit use [Viem](https://viem.sh/) networks under the hood, which provide a wide variety of networks for EVM chains. You can find all the networks supported by Viem within the `@reown/appkit/networks` path.

```js {2}
import { createAppKit } from '@reown/appkit'
import { mainnet, arbitrum, base, scroll, polygon } from '@reown/appkit/networks'
```

<Note>
Looking to add a custom network? Check out the [custom networks](../../core/custom-networks) section.
</Note>
</file>

<file path="snippets/appkit/react/wagmi/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**hooks**](../../core/hooks.mdx#useAppKit).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```tsx
export default function ConnectButton() {
  return <appkit-button />
}
```

Learn more about the AppKit web components [here](../../core/components)
</file>

<file path="snippets/appkit/react/wagmi/hooks.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/react";

function Components() {
  const { address, caipAddress, isConnected } = useAppKitAccount();

  //...
}
```

### useSignMessage

Hook for signing messages with connected account.

```tsx
import { useSignMessage } from "wagmi";

function App() {
  const { signMessage } = useSignMessage();

  return (
    <button onClick={() => signMessage({ message: "hello world" })}>
      Sign message
    </button>
  );
}
```

<Card
  title="Learn More"
  href="https://wagmi.sh/react/api/hooks/useSignMessage"
/>
</file>

<file path="snippets/appkit/react-native/ethers/about/coinbase.mdx">
8. Initialize `CoinbaseProvider` and add it in the default config

```tsx
import { CoinbaseProvider } from '@reown/appkit-coinbase-ethers-react-native'

const coinbaseProvider = new CoinbaseProvider({
  redirect: 'https://your-app-universal-link.com' || 'YOUR_APP_SCHEME://'
  rpcUrl: mainnet.rpcUrl
})

const config = defaultConfig({
  metadata,
  coinbase: coinbaseProvider
})
```

* Prefer universal links over custom schemes to avoid an app verification warning on Coinbase Wallet
</file>

<file path="snippets/appkit/react-native/ethers/about/implementation.mdx">
Start by importing `createAppKit` and create your configs as shown below.
Finally, pass your configuration to `createAppKit`.

<Note>

Make sure you import `@walletconnect/react-native-compat` before using our package to avoid any issues.

</Note>

```tsx
import "@walletconnect/react-native-compat";

import {
  createAppKit,
  defaultConfig,
  AppKit,
} from "@reown/appkit-ethers-react-native";

// 1. Get projectId from https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create config
const metadata = {
  name: "AppKit RN",
  description: "AppKit RN Example",
  url: "https://reown.com/appkit",
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
  redirect: {
    native: "YOUR_APP_SCHEME://",
  },
};

const config = defaultConfig({ metadata });

// 3. Define your chains
const mainnet = {
  chainId: 1,
  name: "Ethereum",
  currency: "ETH",
  explorerUrl: "https://etherscan.io",
  rpcUrl: "https://cloudflare-eth.com",
};

const polygon = {
  chainId: 137,
  name: "Polygon",
  currency: "MATIC",
  explorerUrl: "https://polygonscan.com",
  rpcUrl: "https://polygon-rpc.com",
};

const chains = [mainnet, polygon];

// 4. Create modal
createAppKit({
  projectId,
  chains,
  config,
  enableAnalytics: true, // Optional - defaults to your Cloud configuration
});

export default function App() {
  return (
    <>
      // Rest of your app...
      <AppKit />
    </>
  );
}
```

#### Trigger the modal

To open AppKit modal you can use our **default** button component or build your own logic using our hooks.

<Tabs>
<Tab title="Components">
You can use our components to open the modal

```tsx
import { AppKitButton } from "@reown/appkit-ethers-react-native";

export default function ConnectView() {
  return (
    <>
      ...rest of your view
      <AppKitButton />
    </>
  );
}
```

Learn more about the AppKit components [here](../../core/components)

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { Pressable, Text } from "react-native";
import { useAppKit } from "@reown/appkit-ethers-react-native";

export default function ConnectView() {
  const { open } = useAppKit();

  return (
    <>
      <Pressable onClick={() => open()}>
        <Text>Open Connect Modal</Text>
      </Pressable>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/react-native/ethers/about/installation-expo.mdx">
import AdditionalExpo from "/snippets/appkit/react-native/expo/additional-expo48.mdx";

```
npx expo install @reown/appkit-ethers-react-native ethers
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
npx expo install @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat expo-application
```

<AdditionalExpo />
</file>

<file path="snippets/appkit/react-native/ethers/about/installation.mdx">
```
yarn add @reown/appkit-ethers-react-native ethers
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
yarn add @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```
</file>

<file path="snippets/appkit/react-native/ethers/email.mdx">
### Install packages

```
yarn add react-native-webview @reown/appkit-auth-ethers-react-native
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```

### Add the auth connector in `defaultConfig`

```ts {1-4, 8-9}
// Add the following code lines
import { AuthProvider } from "@reown/appkit-auth-ethers-react-native";

const authProvider = new AuthProvider({ projectId, metadata });

const config = defaultConfig({
  metadata,
  // Add the following code line
  extraConnectors: [authProvider],
});
```

### Enable features in `createAppKit`

```ts {5-9}
createAppKit({
  projectId,
  chains,
  config,
  features: {
    email: true, // default to true
    socials: ["x", "discord", "apple"], // default value
    emailShowWallets: true, // default to true
  },
});
```
</file>

<file path="snippets/appkit/react-native/ethers/hooks.mdx">
#### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit-ethers-react-native";

function Components() {
  const { address, chainId, isConnected } = useAppKitAccount();

  //...
}
```

#### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from "ethers";
import { useAppKitProvider } from "@reown/appkit-ethers-react-native";

function Components() {
  const { walletProvider } = useAppKitProvider();

  async function onSignMessage() {
    const ethersProvider = new BrowserProvider(walletProvider);
    const signer = await ethersProvider.getSigner();
    const message = "hello appkit rn + ethers";
    const signature = await signer.signMessage(message);
    console.log(signature.toString());
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

#### useAppKitError

```ts
import { useAppKitError } from "@reown/appkit-ethers-react-native";

function Components() {
  const { error } = useAppKitError();

  //...
}
```

<Card
  title="Learn More About Ethers"
  href="https://docs.ethers.org/v6/getting-started/#getting-started--contracts"
/>
</file>

<file path="snippets/appkit/react-native/ethers5/about/coinbase.mdx">
8. Initialize `CoinbaseProvider` and add it in the default config

```tsx
import { CoinbaseProvider } from '@reown/appkit-coinbase-ethers-react-native'

const coinbaseProvider = new CoinbaseProvider({
  redirect: 'https://your-app-universal-link.com' || 'YOUR_APP_SCHEME://'
  rpcUrl: mainnet.rpcUrl
})

const config = defaultConfig({
  metadata,
  coinbase: coinbaseProvider
})
```

* Prefer universal links over custom schemes to avoid an app verification warning on Coinbase Wallet
</file>

<file path="snippets/appkit/react-native/ethers5/about/implementation.mdx">
Start by importing `createAppKit` and create your configs as shown below.
Finally, pass your configuration to `createAppKit`.

<Note>

Make sure you import `@walletconnect/react-native-compat` and `@ethersproject/shims` before using our package to avoid any issues.

</Note>

```tsx
import "@walletconnect/react-native-compat";
import "@ethersproject/shims";

import {
  createAppKit,
  defaultConfig,
  AppKit,
} from "@reown/appkit-ethers5-react-native";

// 1. Get projectId from https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create config
const metadata = {
  name: "AppKit RN",
  description: "AppKit RN Example",
  url: "https://reown.com/appkit",
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
  redirect: {
    native: "YOUR_APP_SCHEME://",
  },
};

const config = defaultConfig({ metadata });

// 3. Define your chains
const mainnet = {
  chainId: 1,
  name: "Ethereum",
  currency: "ETH",
  explorerUrl: "https://etherscan.io",
  rpcUrl: "https://cloudflare-eth.com",
};

const polygon = {
  chainId: 137,
  name: "Polygon",
  currency: "MATIC",
  explorerUrl: "https://polygonscan.com",
  rpcUrl: "https://polygon-rpc.com",
};

const chains = [mainnet, polygon];

// 4. Create modal
createAppKit({
  projectId,
  chains,
  config,
  enableAnalytics: true, // Optional - defaults to your Cloud configuration
});

export default function App() {
  return (
    <>
      // Rest of your app...
      <AppKit />
    </>
  );
}
```

#### Trigger the modal

To open AppKit modal you can use our **default** button component or build your own logic using our hooks.

<Tabs>
<Tab title="Components">
You can use our components to open the modal

```tsx
import { AppKitButton } from "@reown/appkit-ethers5-react-native";

export default function ConnectView() {
  return (
    <>
      ...rest of your view
      <AppKitButton />
    </>
  );
}
```

Learn more about the AppKit components [here](../../core/components)

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { Pressable, Text } from "react-native";
import { useAppKit } from "@reown/appkit-ethers5-react-native";

export default function ConnectView() {
  const { open } = useAppKit();

  return (
    <>
      <Pressable onClick={() => open()}>
        <Text>Open Connect Modal</Text>
      </Pressable>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/react-native/ethers5/about/installation-expo.mdx">
import AdditionalExpo from "/snippets/appkit/react-native/expo/additional-expo48.mdx";

```
npx expo install @reown/appkit-ethers5-react-native ethers@5.7.2
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
npx expo install @ethersproject/shims@5.7.0 @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat expo-application
```

<AdditionalExpo />
</file>

<file path="snippets/appkit/react-native/ethers5/about/installation.mdx">
```
yarn add @reown/appkit-ethers5-react-native ethers@5.7.2
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
yarn add @ethersproject/shims@5.7.0 @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```
</file>

<file path="snippets/appkit/react-native/ethers5/hooks.mdx">
#### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit-ethers5-react-native";

function Components() {
  const { address, chainId, isConnected } = useAppKitAccount();

  //...
}
```

#### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { ethers } from "ethers";
import { useAppKitProvider } from "@reown/appkit-ethers5-react-native";

function Components() {
  const { walletProvider } = useAppKitProvider();

  async function onSignMessage() {
    const provider = new ethers.providers.Web3Provider(walletProvider);
    const signer = provider.getSigner();
    const signature = await signer?.signMessage("Hello AppKit Ethers");
    console.log(signature);
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

#### useAppKitError

```ts
import { useAppKitError } from "@reown/appkit-ethers5-react-native";

function Components() {
  const { error } = useAppKitError();

  //...
}
```

<Card
  title="Learn More About Ethers v5"
  href="https://docs.ethers.org/v5/getting-started/#getting-started--contracts"
/>
</file>

<file path="snippets/appkit/react-native/expo/additional-expo48.mdx">
<details>
<summary>Additional setup for Expo SDK 48 only</summary>
<div>

If you are using Expo SDK 48, you also need to polyfill `crypto` with expo-crypto library.

1. Add `expo-crypto`

```
npx expo install expo-crypto
```

2. Create a file named `crypto-polyfill.js`

```js
// src/crypto-polyfill.js

// Apply only with Expo SDK 48
import { getRandomValues as expoCryptoGetRandomValues } from "expo-crypto";

class Crypto {
  getRandomValues = expoCryptoGetRandomValues;
}

// eslint-disable-next-line no-undef
const webCrypto = typeof crypto !== "undefined" ? crypto : new Crypto();

(() => {
  if (typeof crypto === "undefined") {
    Object.defineProperty(window, "crypto", {
      configurable: true,
      enumerable: true,
      get: () => webCrypto,
    });
  }
})();
```

3. Import `crypto-polyfill.js` in your App root file

```js
// src/App.js

import './crypto-polyfill.js'
import '@walletconnect/react-native-compat';
...
import { createAppKit } from '@reown/appkit-...'
```

</div>
</details>
</file>

<file path="snippets/appkit/react-native/wagmi/about/coinbase.mdx">
8. Initialize `coinbaseConnector` and add it in `extraConnectors`

```tsx
import { coinbaseConnector } from '@reown/appkit-coinbase-wagmi-react-native'

const coinbase = coinbaseConnector({
  redirect: 'https://your-app-universal-link.com' || 'YOUR_APP_SCHEME://'
})

const wagmiConfig = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
  extraConnectors: [coinbase]
})
```

* Prefer universal links over custom schemes to avoid an app verification warning on Coinbase Wallet
</file>

<file path="snippets/appkit/react-native/wagmi/about/implementation.mdx">
Start by importing `createAppKit`, and wagmi packages, then create your configs as shown below.
Finally, pass your configuration to `createAppKit`.

<Note>

Make sure you import `@walletconnect/react-native-compat` before `wagmi` to avoid any issues.

</Note>

```tsx
import "@walletconnect/react-native-compat";
import { WagmiProvider } from "wagmi";
import { mainnet, polygon, arbitrum } from "@wagmi/core/chains";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import {
  createAppKit,
  defaultWagmiConfig,
  AppKit,
} from "@reown/appkit-wagmi-react-native";

// 0. Setup queryClient
const queryClient = new QueryClient();

// 1. Get projectId at https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Create config
const metadata = {
  name: "AppKit RN",
  description: "AppKit RN Example",
  url: "https://reown.com/appkit",
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
  redirect: {
    native: "YOUR_APP_SCHEME://",
    universal: "YOUR_APP_UNIVERSAL_LINK.com",
  },
};

const chains = [mainnet, polygon, arbitrum] as const;

const wagmiConfig = defaultWagmiConfig({ chains, projectId, metadata });

// 3. Create modal
createAppKit({
  projectId,
  wagmiConfig,
  defaultChain: mainnet, // Optional
  enableAnalytics: true, // Optional - defaults to your Cloud configuration
});

export default function App() {
  return (
    <WagmiProvider config={wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        // Rest of your app...
        <AppKit />
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

#### Trigger the modal

To open AppKit modal you can use our **default** button component or build your own logic using our hooks.

<Tabs>
<Tab title="Components">
You can use our components to open the modal

```tsx
import { AppKitButton } from "@reown/appkit-wagmi-react-native";

export default function ConnectView() {
  return (
    <>
      ...rest of your view
      <AppKitButton />
    </>
  );
}
```

Learn more about the AppKit components [here](../../core/components)

</Tab>
<Tab title="Hooks">

You can trigger the modal by calling the `open` function from `useAppKit` hook.

```tsx
import { Pressable, Text } from "react-native";
import { useAppKit } from "@reown/appkit-wagmi-react-native";

export default function ConnectView() {
  const { open } = useAppKit();

  return (
    <>
      <Pressable onClick={() => open()}>
        <Text>Open Connect Modal</Text>
      </Pressable>
    </>
  );
}
```

Learn more about the AppKit hooks [here](../../core/hooks)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/react-native/wagmi/about/installation-expo.mdx">
import AdditionalExpo from "/snippets/appkit/react-native/expo/additional-expo48.mdx";

```
npx expo install @reown/appkit-wagmi-react-native wagmi viem @tanstack/react-query
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
npx expo install @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat expo-application
```

<AdditionalExpo />
</file>

<file path="snippets/appkit/react-native/wagmi/about/installation.mdx">
```
yarn add @reown/appkit-wagmi-react-native wagmi viem @tanstack/react-query
```

Additionally add these extra packages to help with async storage, polyfills, and SVG's.

```
yarn add @react-native-async-storage/async-storage react-native-get-random-values react-native-svg react-native-modal @react-native-community/netinfo @walletconnect/react-native-compat
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```
</file>

<file path="snippets/appkit/react-native/wagmi/email.mdx">
### Install packages

```
yarn add @reown/appkit-auth-wagmi-react-native react-native-webview
```

On iOS, use CocoaPods to add the native modules to your project:

```
npx pod-install
```

### Add the auth connector in `defaultWagmiConfig`

```ts {1-4, 10-11}
// Add the following code lines
import { authConnector } from "@reown/appkit-auth-wagmi-react-native";

const auth = authConnector({ projectId, metadata });

const wagmiConfig = defaultWagmiConfig({
  chains,
  projectId,
  metadata,
  // Add the following code line
  extraConnectors: [auth],
});
```

### Enable features in `createAppKit`

```ts {4-9}
createAppKit({
  projectId,
  wagmiConfig,
  // Add the following code line
  features: {
    email: true, // default to true
    socials: ["x", "discord", "apple"], // default value
    emailShowWallets: true, // default to true
  },
});
```
</file>

<file path="snippets/appkit/react-native/wagmi/hooks.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/react";

function Components() {
  const { address, caipAddress, isConnected } = useAppKitAccount();

  //...
}
```

#### useSignMessage

Hook for signing messages with connected account.

```tsx
import { View, Text, Pressable } from "react-native";
import { useSignMessage } from "wagmi";

function App() {
  const { data, isError, isPending, isSuccess, signMessage } = useSignMessage();

  return (
    <View>
      <Pressable
        disabled={isPending}
        onPress={() => signMessage({ message: "hello world" })}
      >
        <Text>Sign message</Text>
      </Pressable>
      {isSuccess && <Text>Signature: {data}</Text>}
      {isError && <Text>Error signing message</Text>}
    </View>
  );
}
```

#### useReadContract

Hook for calling a read method on a Contract.

```tsx
import { View, Text } from "react-native";
import { useReadContract } from "./abi";

function App() {
  const { data, isError, isPending, isSuccess } = useReadContract({
    abi,
    address: "0x6b175474e89094c44da98b954eedeac495271d0f",
    functionName: "totalSupply",
  });

  return (
    <View>
      {isPending && <Text>Loading</Text>}
      {isSuccess && <Text>Response: {data?.toString()}</Text>}
      {isError && <Text>Error reading contract</Text>}
    </View>
  );
}
```

<Card title="Learn More" href="https://wagmi.sh/react/api/hooks" />
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/events/javascript.mdx">
This can be used to listen to, for example, messages received in realtime.

```ts
client.on('notify_message', ({ notification }) => {
  console.log(notification.title)
})
```

#### References

- `message`: Notification of type:

```ts
interface NotifyNotification {
  title: string
  sentAt: number
  body: string
  id: string
  url: string | null
  type: string
}
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/events/react.mdx">
This can be used to listen to, for example, messages received in realtime.

```ts
const { data: client } = useWeb3InboxClient()

client.on('notify_message', ({ message }) => {
  console.log(notification.title)
})
```

#### References

- `message`: Notification of type:

```ts
interface NotifyNotification {
  title: string
  sentAt: number
  body: string
  id: string
  url: string | null
  type: string
}
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/initialization/javascript.mdx">
To setup the client you need to configure it with your `projectId` which you can obtain from [Reown Cloud](https://cloud.reown.com).

Furthermore you may need to configure the `domain` and `isLimited` parameters:

- `domain` defaults to `window.location.host` and must be set to the domain setup in Cloud Setup. For example `app.example.com`. Do not add the scheme (`https://`).
- `allApps` determines if your app has access to all of the user's subscriptions, or only the ones that the app is hosted on. By setting it to `true`, it enables setting `domain` to a value other than `window.location.host`. Setting `allApps: true` can be useful during development to allow your localhost-deployed app to access the subscriptions for the domain you setup. Note that most apps do not need to set this in production environments, as they only need access to their own subscriptions. When enabled, the user has to sign a SIWE message granting your app more permissions, and this requires additional consideration from the user.

```ts
const client = await Web3InboxClient.init({ projectId, domain, allApps })
```

#### References

- **projectId:** Your WalletConnect project ID
- **domain _(Optional)_:** Your app's domain. Defaults to `window.location.host`.
- **allApps _(Optional)_:** Set to `false` to request access to all of the user's notification subscriptions for all apps, instead of only `domain`. Defaults to `true`.
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/initialization/react.mdx">
To setup the client you need to configure it with your `projectId` which you can obtain from [Reown Cloud](https://cloud.reown.com).

Furthermore you may need to configure the `domain` and `isLimited` parameters:

- `domain` defaults to `window.location.host` and must be set to the domain setup in Cloud Setup. For example `app.example.com`. Do not add the scheme (`https://`).
- `allApps` determines if your app has access to all of the user's subscriptions, or only the ones that the app is hosted on. By setting it to `true`, it enables setting `domain` to a value other than `window.location.host`. Setting `allApps: true` can be useful during development to allow your localhost-deployed app to access the subscriptions for the domain you setup. Note that most apps do not need to set this in production environments, as they only need access to their own subscriptions. When enabled, the user has to sign a SIWE message granting your app more permissions, and this requires additional consideration from the user.

```ts
initWeb3inboxClient({ projectId, domain, allApps, logLevel })
```

#### References

- **projectId:** Your WalletConnect project ID
- **domain _(Optional)_:** Your app's domain. Defaults to `window.location.host`.
- **allApps _(Optional)_:** Set to `true` to request access to all of the user's notification subscriptions for all apps, instead of only `domain`. Defaults to `false`.
- **logLevel _(Optional)_:** Increase verbosity of console logging. Defaults to `error`. Can be set to `error`, `info`, or `debug`.
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/managing-notifications/javascript.mdx">
You can retrieve notifications using pagination. One approach is to provide the last notification's ID as the starting point:

```ts
const notificationsPage = client.getNotificationHistory({
  limit: 3,
  // The `id` of the last notification, for example:
  startingAfter: 'some-notification-id'
})

const notificationsPerPage = 5
const isInfiniteScroll = true
const unreadFirst = true

let notifications = []

const onUpdate = ({notifications: fetchedNotifications}: GetNotificationsReturn) => {
  notifications = fetchedNotifications
}

const {
  nextPage,
  markNotificationAsRead,
  markAllNotificationsAsRead
} = client.pageNotifications(
  notificationsPerPage,
  isInfiniteScroll,
  specifiedAccount // OR undefined,
  specifiedDomain // OR undefined,
  unreadFirst
)(onUpdate)


// marking a single notification as read
await notifications[0].markAsRead();

// mark specific notifications as read
await markNotificationsAsRead(notifications.slice(2).map(n => n.id));

// mark all notifications as read
await markAllNotificationsAsRead();
```

#### References

- **pageNotifications:**
  - **notificationsPerPage:** Number representing how many notifications to get per fetch
  - **isInfiniteScroll:** Whether or not to keep already fetched notifications when getting next page
  - \*_params:_ (optional) Additional parameters
  - **unreadFirst:** (optional, default `true`, since 1.3.0) Whether or not unread messages should be sorted at the top, regardless of timestamp
- **onUpdate:**: A callback that will be called whenever notifications get updated
- **nextPage:**: A function to be called to fetch the next page of notifications
- **notifications:** Array of notifications, of type
- **notification.markAsRead:** Mark the notification as read
- **markNotificationsAsRead**: Takes an array of notification IDs and marks them as read. Max 1000 IDs
- **markAllNotificationsAsRead**: Mark all notifications as read.

```ts
{
  title: string
  sentAt: number
  body: string
  id: string
  isRead: boolean // since 1.3.0
  url: string | null
  type: string
  read: () => Promise<void> // since 1.3.0
}
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/managing-notifications/react.mdx">
```ts
// watch notifications of current account's subscription to current dapp
const notificationsPerPage = 5
const isInfiniteScroll = true
const unreadFirst = true

const {
  data: notifications,
  nextPage,
  markNotificationsAsRead,
  markAllNotificationsAsRead
} = useNotifications(
  notificationsPerPage,
  isInfiniteScroll,
  account,
  domain,
  unreadFirst,
  onRead // optional function to run whenever messages are read
)

// marking a single notification as read
await notifications[0].markAsRead()

// mark specific notifications as read for default account and under default domain
await markNotificationsAsRead(notifications.slice(2).map(n => n.id))

// mark specific notifications as read for specified account under default domain
await markNotificationsAsRead(
  notifications.slice(2).map(n => n.id),
  differentAccount
)

// mark specific notifications as read for default account under specified domain
await markNotificationsAsRead(
  notifications.slice(2).map(n => n.id),
  undefined,
  differentDomain
)

// mark specific notifications as read for specified account under specified domain
await markNotificationsAsRead(
  notifications.slice(2).map(n => n.id),
  differentAccount,
  differentDomain
)

// mark all notifications as read for default account under default domain
await markAllNotificationsAsRead()

// mark all notifications as read for specified account under default domain
await markAllNotificationsAsRead(differentAccount)

// mark all notifications as read for default account under specified domain
await markAllNotificationsAsRead(undefined, differentDomain)

// mark all notifications as read for specified account under specified domain
await markAllNotificationsAsRead(differentAccount, differentDomain)
```

#### References

- **useNotifications()**
  - **notificationsPerPage:** Number representing how many notifications to get per fetch
  - **isInfiniteScroll:** Whether or not to keep already fetched notifications when getting next page
  - **params:** (optional) Additional parameters
  - **unreadFirst:** (optional, default `true`, since 1.3.0) Whether or not unread messages should be sorted at the top, regardless of timestamp
- **nextPage:** A function to be called to fetch the next page of notifications
- **notifications:** Array of notifications, of type
- **notification.read:** Mark the notification as read
- **markNotificationsAsRead**: Takes an array of notification IDs and marks them as read. Max 1000 IDs
- **markAllNotificationsAsRead**: Mark all notifications as read.

```ts
{
  title: string
  sentAt: number
  body: string
  id: string
  isRead: boolean
  url: string | null
  type: string
  markAsRead: () => Promise<void>
}
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/managing-subscription/javascript.mdx">
Subscribe, Unsubscribe, Get Subscription, Check if Subscribed.

<Info>
When using `differentAccount`, the passed account needs to be previously registered.
This use case is for Dapps that have multiple active accounts or wallets with multiple active accounts.
`differentAccount` can be used for all the below hooks and functions that accept `account`
</Info>

```ts
// check if current account is subscribed to current dapp
const isSubscribed = client.isSubscribedToDapp()

// watch if current account is subscribed to current dapp
client.watchIsSubscribed(isSubbed => console.log({ isSubbed }))

// subscribe to current dapp with current account
await client.subscribeToDapp()

// subscribe to same dapp with different account
await client.subscribeToDapp(differentAccount)

// subscribe to different dapp with current account
await client.subscribeToDapp(undefined, differentDomain)

// subscribe to different dapp with different account
await client.subscribeToDapp(differentAccount, differentDomain)

// unsubscribe from current dapp with current account
await client.unsubscribeFromDapp()

// get current account's subscription to current dapp
const subscription = client.getSubscription()

// watch current account's subscription to current dapp
client.watchSubscription(subscription => console.log({ subscription }))

// get current account's subscriptions
const subscriptions = client.getSubscriptions()

// watch current account's subscriptions
client.watchSubscriptions(subscriptions => console.log({ subscriptions }))
```

#### References

- **account _(Optional)_:** CAIP-10 account
- **domain _(Optional)_:** dapp domain
- **subscription:** _Non-Reactive_ state, returning current subscription information, of type:

```ts
{
  topic: string
  account: string
  relay: relayertypes.protocoloptions
  metadata: Metadata
  scope: ScopeMap
  expiry: number
  symkey: string
  unreadCount: number
}
```

- **subscription:** _Non-Reactive_ state, returning array of current subscriptions
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/managing-subscription/react.mdx">
Subscribe, Unsubscribe, Get Subscription, Check if Subscribed.

<Info>
When using `differentAccount`, the passed account needs to be previously registered.
This use case is for Dapps that have multiple active accounts or wallets with multiple active accounts.
`differentAccount` can be used for all the below hooks and functions that accept `account`
</Info>

```ts
const { subscribe, isLoading: isSubscribing } = useSubscribe()
const { unsubscribe, isLoading: isUnsubscribing } = useUnsubscribe()

// get subscription of current user to current dapp
const { data: subscription, getSubscription } = useSubscription()

// getSubscription can be used to get information about different dapps programmatically
const subscriptionToSameDappFromDifferentAccount = getSubscription(differentAccount)
const subscriptionToDifferentDappFromSameAccount = getSubscription(undefined, differentDappDomain)
const subscriptionToDifferentDappFromDifferentAccount = getSubscription(
  differentAccount,
  differentDappDomain
)

// subscribe to current dapp from current user
subscribe()
// subscribe to current dapp from different user
subscribe(differentAccount)
// subscribe to different dapp from current user
subscribe(undefined, differentDappDomain)
// subscribe to different dapp from different user
subscribe(differentAccount, differentDappDomain)

// unsubscribe from current dapp
unsubscribe()

// get all subscriptions for current account
const subscriptions = useAllSubscriptions()

const isSubscribed = Boolean(subscription)
```

#### References

- **account _(Optional)_:** CAIP-10 account
- **domain _(Optional)_:** dapp domain
- **subscribe:** Function to subscribe to current dApp `() => void`
- **unsubscribe:** Function to unsubscribe to current dApp `() => void`
- **isSubscribed:** Reactive state, checking if subscribed to dApp `Boolean`
- **isSubscribing:** If `subscribe()` is in-progress and has not finished yet
- **isUnsubscribing:** If `unsubscribe()` is in-progress and has not finished yet
- **subscription:** Reactive state, returning current subscription information, of type:

```ts
{
  topic: string
  account: string
  relay: relayertypes.protocoloptions
  metadata: Metadata
  scope: ScopeMap
  expiry: number
  symkey: string
  unreadCount: number
}
```

- **subscriptions:** Reactive state, returning array of current subscriptions
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/registering-accounts/javascript.mdx">
**Note**: [EIP-1271 signatures](https://eips.ethereum.org/EIPS/eip-1271) coming from smart wallets are supported in version `1.1.0` and above.

```ts
import { signMessageAsync } from '@wagmi/core'

const { registerParams, signature } = await client.prepareRegistration({
  account
})
const isRegistered = await client.getAccountIsRegistered(account)
const signature = await signMessageAsync({ message })
await register({ registerParams, signature })
```

#### References

- **prepareRegistration:** Prepare registration params
- **register:** Register using a signature and register params
- **getAccountIsRegistered:** Returns if account is registered

Some suggested methods of signing the message:

- Ethers.js [`Wallet.signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage)
- `@wagmi/core` [`signMessage` method](https://wagmi.sh/core/api/actions/signMessage)
- The [`useSignMessage` hook](https://wagmi.sh/react/hooks/useSignMessage) in `@wagmi`
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/registering-accounts/react.mdx">
**Note**: [EIP-1271 signatures](https://eips.ethereum.org/EIPS/eip-1271) coming from smart wallets are supported in version `1.1.0` and above.

```ts
import { useSignMessage } from '@wagmi'
const { signMessageAsync } = useSignMessage()

const { isRegistered } = useW3iAccount('eip155:1:0x9A...')

const { prepareRegistration } = usePrepareRegistration()
const { register, isLoading: isRegistering } = useRegister()

const handleRegistration = async () => {
  try {
    const { message, registerParams } = await prepareRegistration()
    const signature = await signMessageAsync({ message: message })
    await register({ registerParams, signature })
  } catch (registerIdentityError: any) {
    console.error(registerIdentityError)
  }
}
```

#### References

- **isRegistered:** A boolean of whether or not the account currently set is registered
- **prepareRegistration:** Prepare registration params
- **register:** Register using a signature and register params
- **isLoading:** A boolean, representing if an account is being registered

Some suggested methods of signing the message:

- `@wagmi/core` [`signMessage` method](https://wagmi.sh/core/api/actions/signMessage)
- The [`useSignMessage` hook](https://wagmi.sh/react/hooks/useSignMessage) in `@wagmi`
- Ethers.js [`Wallet.signMessage` method](https://docs.ethers.org/v5/api/signer/#Signer-signMessage)
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/registering-push/javascript.mdx">
If you wish to receive live push notifications to your React Native or Web app, you must integrate with Firebase Messaging. More information about how to integrate with Firebase can be found [here](https://firebase.google.com/docs/cloud-messaging).

Your integration will obtain a token from Firebase and you will need to pass this token to the Web3Inbox SDK using the `registerWithPushServer()` function.

```ts
import { getToken } from 'firebase/messaging

// initialize Firebase's messaging object via Firebase's `getMessaging` function

const firebaseToken = getToken(firebaseMessaging, {
  vapidKey: "YOUR_FIREBASE_VAPID_KEY"
})

// The Client ID that registered with this token, can be used for debugging purposes or logs
const clientId = client.registerWithPushServer(firebaseToken)
```

#### References

- `registerWithPushServer`: `(token: string, platform: 'fcm' | 'apns') => string`

Either APNS or FCM can be used to receive push notifications. Token here is the respective platform's token.
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/registering-push/react.mdx">
If you wish to receive live push notifications to your React Native or Web app, you must integrate with Firebase Messaging. More information about how to integrate with Firebase can be found [here](https://firebase.google.com/docs/cloud-messaging).

Your integration will obtain a token from Firebase and you will need to pass this token to the Web3Inbox SDK using the `registerWithPushServer()` function.

```ts
import { getToken } from 'firebase/messaging'

const { data: client } = useWeb3InboxClient()

// initialize Firebase's messaging object via Firebase's `getMessaging` function

const firebaseToken = getToken(firebaseMessaging, {
  vapidKey: 'YOUR_FIREBASE_VAPID_KEY'
})

client.registerWithPushServer(firebaseToken)
```

#### References

- `registerWithPushServer`: `(token: string, platform: 'fcm' | 'apns' = 'fcm') => void`

Either APNs or FCM can be used to receive push notifications to the device. The `token` you provide may be a token from either platform, provided the `platform` argument matches.
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/setting-account/javascript.mdx">
```ts
await client.setAccount('eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029')

const account = client.getAccount() // eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029

client.watchAccount(account => {
  console.log({ account }) // eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029
})
```

### References

- **account:** CAIP-10 account currently active in Web3Inbox
- **setAccount:** Change actively managed account in Web3Inbox
- **watchAccount:** Watcher ticks whenever the account updates
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/setting-account/react.mdx">
```ts
const {
  data: account,
  isRegistered,
  identityKey,
  setAccount,
  error,
  isLoading
} = useW3iAccount('eip155:1:0x9A...')
```

### References

- **data:** CAIP-10 account currently active in Web3Inbox
- **setAccount:** Change actively managed account in Web3Inbox. Does not need to be used as you can set the account directly in the params.
- **isRegistered:** A boolean of whether or not the account currently set is registered
- **identityKey:** Currently set account's identity key
- **error:** A string, representing possible error of setting an account.
- **isLoading:** A boolean, representing if an account is being set
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/types/javascript.mdx">
```ts
// get scopes of current account's subscription to current dapp
const types = client.getNotificationTypes()

// watch scopes of specific account's subscription to specific dapp
client.watchNotificationTypes(scp => {
  console.log(scp)
})

client.update(['enabledType-1', 'enabledType-2'])
```

#### References

- **update:** `(enabledScopeNames: string[]) -> void`
- **types:** Map of scopes (Notification types)

```ts
type ScopeMap = Record<
  string,
  {
    name: string
    description: string
    enabled: boolean
  }
>
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/api/types/react.mdx">
```ts
const { data: types, update } = useNotificationTypes()
```

#### References

- **update:** `(enabledScopeNames: string[]) -> void`
- **types:** Map of scopes (Notification types)

```ts
type ScopeMap = Record<
  string,
  {
    name: string
    description: string
    enabled: boolean
  }
>
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/migration/javascript.mdx">
For developers using `@web3inbox/core` without the hooks, there are far less breaking changes.

#### Managing registration

Registration is now split into 2 steps to avoid the opinionated approach of passing `onSign` callback.

```typescript {3-5}
import { useSignMessage } from '@wagmi'
const { signMessageAsync } = useSignMessage()

client.register(signMessageAsync)
+ const { registerParams, message } = client.prepareRegistration({ account: 'eip155:1:0x..' })
+ const signature = await signMessageAsync(message)
+ client.register({ registerParams, signature })
```

#### Managing Notifications

- `deleteMessage` has been removed.
- `pageNotifications` has been added to allow paging notifications
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/migration/react.mdx">
There are numerous breaking changes in the stable release.

#### Package rename

`@web3inbox/widget-react` has been renamed to `@web3inbox/react`

`@web3inbox/core` is still named the same.

#### Initializing the client

Previously, a use of hook was required to init the client and a separate hook was required to check for ready status.
Now, there is only a hook for checking ready status which is **recommended** to be used to be sure if web3inbox functionality is ready to use.
However, initiating the client is now done with a simple function call.

```typescript {2, 4}
import { useInitWeb3InboxClient } from '@web3inbox/widget-react'
import { initWeb3InboxClient } from '@web3inbox/react'

useInitWeb3inboxClient({ projectId, domain, isLimited })
initWeb3inboxClient({ projectId, domain, allApps })

```

#### Checking for client ready status

```typescript
import { useWeb3InboxClient } from '@web3inbox/react'

const { isLoading: w3iClientIsLoading } = useWeb3InboxClient()
```

#### Managing Accounts

Previously, the account needed to be set using `setAccount` and still had to be passed down to hooks like `useManageSubscriptions`. This is no longer
the case. Also, registration management was included in the same hook. Now they all follow single responsibility principle.

- **Setting accounts**

```typescript {2, 6}
- import { useW3iAccount } from "@web3inbox/widget-react"
+ import { useWeb3InboxAccount } from "@web3inbox/react"
- const { setAccount } = useW3iAccount()

setAccount(`eip155:1:0x...`)
+ const { data: account } = useWeb3InboxAccount(`eip155:1:0x...`)
```

- **Handling registration**

```typescript {4-13}
- const handleRegistration = () => {
-   register(signMessageAsync)
- }
+ const { prepareRegistration } = usePrepareRegistration();
+ const { register, isLoading: isLoadingRegister } = useRegister();
+ const handleRegistration = async () => {
+   try {
+     const { message, registerParams } = await prepareRegistration();
+     const signature = await signMessageAsync({ message: message });
+     await register({ registerParams, signature });
+   } catch (registerIdentityError: any) {
+     console.error(registerIdentityError)
+   }
+ };
```

#### Managing notifications

Messages (notifications) function a little differently now. One of the big changes is that you can no longer delete messages.
Furthermore, messages can now be paged. For convenience, "infinite scroll" paging functionality is available, as in keeping older pages in the
returned array.

- **Retrieving notifications**

```typescript {2, 5-15}
- import { useMessages } from "@web3inbox/widget-react"
+ import { useNotifications } from "@web3inbox/react"

- const { messages } = useMessages()
+ const notificationsPerPage = 5
+ const isInfiniteScroll = true
+
+ const { data: notifications, nextPage } = useNotifications(
+   notificationsPerPage,
+   isInfiniteScroll
+ )
+
+ const getMoreNotifications = () => {
+   nextPage()
+ }
```

- **Retrieving notification types**

<Note>

Notification images are retrieved from notification types now.

</Note>

Sizes of images available are: `sm`, `md` and `lg` for small, medium and large respectively.

```typescript {2, 5-6}
- import { useSubscriptionScopes } from "@web3inbox/widget-react"
+ import { useNotificationTypes } from "@web3inbox/react"

- const { scopes } = useSubscriptionScopes()
+ const { data: notificationTypes } = useNotificationTypes()
+ const notificationImageUrl = notificationTypes[notification.type].imageUrls.md;
```

#### Managing Subscriptions

Managing subscriptions has changed considerably. Previously there was a single hook and now there are numerous single responsibility hooks.

```typescript {2, 5-7, 9}
- import { useManageSubscription } from "@web3inbox/widget-react"
+ import { useSubscribe, useUnsubscribe, useSubscription } from "@web3inbox/react"

- const { subscribe, unsubscribe, isSubscribed } = useManageSubscription()
+ const { subscribe } = useSubscribe()
+ const { unsubscribe } = useUnsubscribe()
+ const { data: subscription } = useSubscription()
- const { subscriptions } = useSubscriptions()
+ const { data: subscriptions } = useSubscriptions()
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/usage/example/javascript.mdx">
```ts
import { Web3InboxClient } from '@web3inbox/core'
import { signMessage } from '@wagmi/core'

const client = await Web3InboxClient.init({ projectId: '...' })

const account = 'eip155:1:0x9AfEaC202C837df470b5A145e0EfD6a574B21029'

// Set the account to a CAIP-10 account ID
await client.setAccount(account)

const { message, registerParams } = await client.prepareRegistration({ account })
const { signature } = await signMessage(message)
await client.register({ signature, registerParams })

// Get the current notification subscription or watch for updates
const subscription = client.getSubscription()
client.watchSubscription(subscription => console.log({ subscription }))

// Subscribe to the app
await client.subscribeToDapp()

// Get notification history
const notificationsPerPage = 5
const isInfiniteScroll = true

client.pageNotifications(
  notificationsPerPage,
  isInfiniteScroll
)(notifications => {
  // add logic to display notifications here.
  // if isInfiniteScroll is true, notifications will contain all notifications fetched so far, else it will only fetch current page
  // See API docs for more information on `pageNotifications()` and how to use `notifications`
})
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/usage/example/react.mdx">
Below is an example of adding the Web3Inbox SDK to a React project with wagmi. Wagmi is not required to use the Web3Inbox React hooks.

We have separated it so the initialization can be done executed once in the app, and the hooks can be used anywhere in the app.

```tsx
//App.tsx
import { initWeb3InboxClient } from "@web3inbox/react";

...
// The project ID and domain you setup in the Domain Setup section
const projectId = process.env.NEXT_PUBLIC_PROJECT_ID!;
const appDomain = process.env.NEXT_PUBLIC_APP_DOMAIN!;

initWeb3InboxClient({
  projectId,
  domain: appDomain,
  allApps: process.env.NODE_ENV !== "production",
});

```

```tsx
// Index.tsx
import {
  useNotifications,
  usePrepareRegistration,
  useRegister,
  useSubscribe,
  useSubscription,
  useUnsubscribe,
  useWeb3InboxAccount,
  useWeb3InboxClient
} from '@web3inbox/react'
import { useCallback, useEffect } from 'react'
import { useSignMessage, useAccount } from 'wagmi'

import Notifications from './Notifications'

export default function App() {
  // Wagmi Hooks
  const { address } = useAccount()
  const { signMessageAsync } = useSignMessage()

  // W3I Hooks
  const { prepareRegistration } = usePrepareRegistration()
  const { register, isLoading: isRegistering } = useRegister()
  const { data: w3iClient, isLoading: w3iClientIsLoading } = useWeb3InboxClient()
  const { isRegistered } = useWeb3InboxAccount(`eip155:1:${address}`)

  // Registration of your address to allow notifications
  // This is done via a signature of a message (SIWE) and the
  // signMessageAsync function from wagmi
  const handleRegistration = async () => {
    try {
      const { message, registerParams } = await prepareRegistration()
      const signature = await signMessageAsync({ message: message })
      await register({ registerParams, signature })
    } catch (registerIdentityError: any) {
      console.error(registerIdentityError)
    }
  }

  // Subscription to dapp notifications
  // Subscribe can be called as a function post registration
  // Can be moved above but shown for example clarity
  const { subscribe, isLoading: isSubscribing } = useSubscribe()
  const { unsubscribe, isLoading: isUnsubscribing } = useUnsubscribe()
  const { data: subscription } = useSubscription()
  const isSubscribed = Boolean(subscription)

  // Note: We are using AppKit for the dapp <> wallet connection.
  // The <appkit-button /> module is from AppKit. Check AppKit Docs for further info.
  return (
    <>
      <main className={styles.main}>
        {w3iClientIsLoading ? (
          <div>Loading W3I Client</div>
        ) : (
          <div>
            <h1>W3I QuickStart</h1>
            <appkit-button />
            <div className={styles.flexColumn}>
              <button onClick={handleRegistration} disabled={isRegistered}>
                {isRegistered ? 'Registered' : 'Register'}
              </button>
              <button
                onClick={isSubscribed ? unsubscribe : subscribe}
                disabled={isSubscribing || isUnsubscribing}
              >
                {isSubscribed ? 'Unsubscribe' : 'Subscribe'}
              </button>
              <hr />
              {isSubscribed ? <Notifications /> : null}
            </div>
          </div>
        )}
      </main>
    </>
  )
}
```

```tsx
// Notifications.tsx
import { useNotifications } from '@web3inbox/react'
import React from 'react'
import styles from '@/styles/Notifications.module.css'

function Notifications() {
  const { data: subscription } = useSubscription()
  const { data: notifications } = useNotifications(5)

  return (
    <div>
      <h2 className={styles.heading}>Notifications</h2>
      <p>You have {subscription.unreadCount} unread notifications.</p>
      <div className={styles.notificationsContainer}>
        {!notifications?.length ? (
          <p className={styles.fallbackText}>No notifications yet.</p>
        ) : (
          notifications.map(({ id, ...message }) => (
            <div key={id} className={styles.message}>
              <h3>{message.title}</h3>
              <p>{message.body}</p>
              <p>{message.isRead ? 'Read' : 'Unread'}</p>
              <button onClick={message.markAsRead}>Mark as read</button>
            </div>
          ))
        )}
      </div>
      <button onClick={nextPage}>Next page</button>
    </div>
  )
}

export default Notifications
```
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/usage/installation/javascript.mdx">
<CodeGroup>

```bash npm
npm install @web3inbox/core
```

```bash Yarn
yarn add @web3inbox/core
```

```bash Bun
bun a @web3inbox/core
```

```bash pnpm
pnpm add @web3inbox/core
```
</CodeGroup>
</file>

<file path="snippets/appkit/shared/notifications/frontend-integration/usage/installation/react.mdx">
<CodeGroup>

```bash npm
npm install @web3inbox/core @web3inbox/react
```

```bash Yarn
yarn add @web3inbox/core @web3inbox/react
```

```bash Bun
bun a @web3inbox/core @web3inbox/react
```

```bash pnpm
pnpm add @web3inbox/core @web3inbox/react
```
</CodeGroup>
</file>

<file path="snippets/appkit/shared/siwe/code.mdx">
<Tabs>
<Tab title="One-Click Auth">

<Note>

If you are not using our library on the server-side, please normalize the address with eip-55 in the createMessage function. You can check our example for that Functionality.

</Note>

```ts
import { SiweMessage } from "siwe";
import {
  type SIWESession,
  type SIWEVerifyMessageArgs,
  type SIWECreateMessageArgs,
  createSIWEConfig,
  formatMessage,
} from "@reown/appkit-siwe";

const BASE_URL = "http://localhost:8080";

/* Function that returns the user's session - this should come from your SIWE backend */
async function getSession() {
  const res = await fetch(BASE_URL + "/session", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
    credentials: "include",
  });
  if (!res.ok) {
    throw new Error("Network response was not ok");
  }

  const data = await res.json();

  const isValidData =
    typeof data === "object" &&
    typeof data.address === "string" &&
    typeof data.chainId === "number";

  return isValidData ? (data as SIWESession) : null;
}

/* Use your SIWE server to verify if the message and the signature are valid */
const verifyMessage = async ({ message, signature }: SIWEVerifyMessageArgs) => {
  try {
    const response = await fetch(BASE_URL + "/verify", {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
      mode: "cors",
      body: JSON.stringify({ message, signature }),
      credentials: "include",
    });

    if (!response.ok) {
      return false;
    }

    const result = await response.json();
    return result === true;
  } catch (error) {
    return false;
  }
};

// Check the full example for signOut and getNonce functions ...

/* Create a SIWE configuration object */
export const siweConfig = createSIWEConfig({
  getMessageParams: async () => ({
    domain: window.location.host,
    uri: window.location.origin,
    chains: [1, 2020],
    statement: "Please sign with your account",
  }),
  createMessage: ({ address, ...args }: SIWECreateMessageArgs) =>
    formatMessage(args, address),

  getNonce: async () => {
    //This is only an example, substitute it with your actual nonce getter.
    const nonce = "YOUR_NONCE_GETTER";
    if (!nonce) {
      throw new Error("Failed to get nonce!");
    }
    return nonce;
  },
  getSession,
  verifyMessage,
  signOut: async () => {
    //Example
    // Implement your Sign out function
  },
});
```

## Server Side

Setting up a backend server using Express for a web application that interacts with the Siwe protocol.

### Routes:

- GET '/nonce': Generates and returns a nonce (single-use random number).
- POST '/verify': Uses the Siwe protocol to verify the message, requiring a signature (the one you are going to approve throw the UX) and a nonce stored in the session.
- GET '/session': Retrieves the stored Siwe object from the session.
- GET '/signout': Clears the session.

```ts
import cors from "cors";
import express from "express";
import Session from "express-session";
import { generateNonce } from "siwe";
import {
  /*verifySignature,*/
  getAddressFromMessage,
  getChainIdFromMessage,
} from "@reown/appkit-siwe";
import { createPublicClient, http } from "viem";

const app = express();

const projectId = "YOUR_PROJECT_ID";

// configure cors and sessions
app.use(
  cors({
    origin: "http://localhost:5173", // frontend URL
    credentials: true,
  })
);
app.use(express.json());
app.use(
  Session({
    name: "siwe-quickstart",
    secret: "siwe-quickstart-secret",
    resave: true,
    saveUninitialized: true,
    cookie: { secure: false, sameSite: true },
  })
);

app.get("/nonce", function (_, res) {
  res.setHeader("Content-Type", "text/plain");
  res.send(generateNonce());
});

// verify the message
app.post("/verify", async (req, res) => {
  try {
    if (!req.body.message) {
      return res.status(400).json({ error: "SiweMessage is undefined" });
    }

    // save the session with the address and chainId (SIWESession)
    req.session.siwe = { address, chainId };
    req.session.save(() => res.status(200).send(true));

    const message = req.body.message;
    const signature = req.body.signature;
    const address = getAddressFromMessage(message);
    let chainId = getChainIdFromMessage(message);

    // for the moment, the verifySignature is not working with social logins and emails  with non deployed smart accounts
    // for this reason we recommend using the viem to verify the signature
    const publicClient = createPublicClient({
      transport: http(
        `https://rpc.walletconnect.org/v1/?chainId=${chainId}&projectId=${projectId}`
      ),
    });
    const isValid = await publicClient.verifyMessage({
      message,
      address,
      signature,
    });
    if (!isValid) {
      // throw an error if the signature is invalid
      throw new Error("Invalid signature");
    }
    if (chainId.includes(":")) {
      chainId = chainId.split(":")[1];
    }

    // Convert chainId to a number
    chainId = Number(chainId);

    if (isNaN(chainId)) {
      throw new Error("Invalid chainId");
    }

    // save the session with the address and chainId (SIWESession)
    req.session.siwe = { address, chainId };
    req.session.save(() => res.status(200).send(true));
  } catch (e) {
    // clean the session
    req.session.siwe = null;
    req.session.nonce = null;
    req.session.save(() => res.status(500).json({ message: e.message }));
  }
});

/// ... check the github repository for the others endpoints

// get the session
app.get("/session", (req, res) => {
  res.setHeader("Content-Type", "application/json");
  res.send(req.session.siwe);
});
```

Check the github full example to see the full flow working: [siwe-quickstart](https://github.com/WalletConnect/web-examples/tree/main/dapps/appkit-siwe/react/)

### `verifySignature`

Verify a SIWE signature.

```ts
import { createPublicClient, http } from "viem";

const publicClient = createPublicClient({
  transport: http(
    `https://rpc.walletconnect.org/v1/?chainId=${chainId}&projectId=${projectId}`
  ),
});
const isValid = await publicClient.verifyMessage({
  message,
  address: address as `0x${string}`,
  signature: signature as `0x${string}`,
});

// The verifySignature is not working with social logins and emails with non deployed smart accounts
// for this reason we recommend using the viem to verify the signature
// import { verifySignature } from '@reown/appkit-siwe'
// const isValid = await verifySignature({ address, message, signature, chainId, projectId })
```

</Tab>
<Tab title="Legacy">

With help of the [siwe package](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-frontend) we will create the required configuration for AppKit.

<Info>
The nonce and verification process will be implemented in your backend. [Read more.](https://docs.login.xyz/sign-in-with-ethereum/quickstart-guide/implement-the-backend)
</Info>

```ts
import { SiweMessage } from 'siwe'
import type { SIWECreateMessageArgs, SIWEVerifyMessageArgs } from '@reown/appkit-siwe'

/* Function that creates a SIWE message */
function createMessage({ nonce, address, chainId }: SIWECreateMessageArgs){
  const message = new SiweMessage({
    version: '1',
    domain: window.location.host,
    uri: window.location.origin,
    address,
    chainId,
    nonce,
    statement: 'Sign in With Ethereum.'
  })

  return message.prepareMessage()
}

/* Function that returns the user's session */
async function getSession(){
  //...
}

/* Use your SIWE server to verify if the message and the signature are valid */
async function verifyMessage({ message, signature }: SIWEVerifyMessageArgs){
  try {
    const isValid = await validateMessage({ message, signature })

    return isValid
  } catch (error) {
    return false
  }
},

/* Create a SIWE configuration object */
export const siweConfig = createSIWEConfig({
  createMessage,
  getNonce: async () => { //This is only an example, substitute it with your actual nonce getter.
    const nonce = "YOUR_NONCE_GETTER"
    if (!nonce) {
      throw new Error('Failed to get nonce!')
    }
    return nonce
  },
  getSession,
  verifyMessage,
  signOut: async () => { //Example
    // Implement your Sign out function
  }
})
```

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/shared/siwe/parameters.mdx">
<Tabs >
<Tab title="One-Click Auth">

#### getMessageParams `() => Promise<{ domain: string, uri: string, chains: number[], statement: string }>`

Parameters to create the SIWE message internally.

#### getNonce `() => Promise<string>`

The getNonce method functions as a safeguard against spoofing, akin to a CSRF token. The siwe package provides a generateNonce() helper, or you can utilize an existing CSRF token from your backend if available.

#### createMessage `(args: SIWECreateMessageArgs) => string`

The official siwe package offers a straightforward method for generating an EIP-4361-compatible message, which can subsequently be authenticated using the same package. The nonce parameter is derived from your getNonce endpoint, while the address and chainId variables are sourced from the presently connected wallet.

#### verifyMessage `(args: SIWEVerifyMessageArgs) => Promise<boolean>`

The function to ensure the message is valid, has not been tampered with, and has been appropriately signed by the wallet address.

#### getSession `() => Promise<SIWESession | null>`

The backend session should store the associated address and chainId and return it via the `getSession` method.

#### signOut `() => Promise<boolean>`

The users session can be destroyed calling `signOut`.

#### onSignIn `(session?: SIWESession) => void`

Callback when user signs in (Optional).

#### onSignOut `() => void`

Callback when user signs out (Optional).

#### signOutOnDisconnect `boolean`

- defaults to `true`

Whether or not to sign out when the user disconnects their wallet (Optional).

</Tab>
<Tab title="Legacy">

#### getNonce `() => Promise<string>`

The getNonce method functions as a safeguard against spoofing, akin to a CSRF token. The siwe package provides a generateNonce() helper, or you can utilize an existing CSRF token from your backend if available.

#### createMessage `(args: SIWECreateMessageArgs) => string`

The official siwe package offers a straightforward method for generating an EIP-4361-compatible message, which can subsequently be authenticated using the same package. The nonce parameter is derived from your getNonce endpoint, while the address and chainId variables are sourced from the presently connected wallet.

#### verifyMessage `(args: SIWEVerifyMessageArgs) => Promise<boolean>`

The `verifyMessage` method should lean on the siwe package's new

```js
SiweMessage(message).validate(signature);
```

to ensure the message is valid, has not been tampered with, and has been appropriately signed by the wallet address.

#### getSession `() => Promise<SIWESession | null>`

The backend session should store the associated address and chainId and return it via the `getSession` method.

#### signOut `() => Promise<boolean>`

The users session can be destroyed calling `signOut`.

#### onSignIn `(session?: SIWESession) => void`

Callback when user signs in (Optional).

#### onSignOut `() => void`

Callback when user signs out (Optional).

#### signOutOnDisconnect `boolean`

- defaults to `true`

Whether or not to sign out when the user disconnects their wallet (Optional).

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/shared/siwx/index.mdx">
## Introduction

The **Sign In With X** feature enables decentralized applications (Dapps) to authenticate users seamlessly across multiple blockchain networks, such as Ethereum, Polygon or Solana. This feature allows developers using our SDK to implement authentication by having users sign a unique string message with their blockchain wallets. The **Sign In With X** feature is designed in accordance with the [CAIP-122](https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-122.md) standard, which establishes a chain-agnostic framework for blockchain-based authentication and authorization on off-chain services.

<Frame>
  <img src="/images/assets/siwe-connect.gif" />
</Frame>
<br />

<Card
  title="Try Demo"
  href="https://appkit-lab.reown.com/library/siwx-default/"
/>
<br />

## Getting Started

**SIWX** works as a plugin system for AppKit and you are going to add the plugin in the AppKit configuration. There are some ways to implement the **SIWX** feature:

- Use the default implementation provided by AppKit
- Use Cloud Auth SIWX to manage the sessions in the Cloud Dashboard
- Create a custom implementation to suit your specific requirements.

To initialize the **SIWX** feature, you need to add the `siwx` parameter to the `createAppKit` function.

### Default Implementation

By using the default implementation, you can quickly integrate the **SIWX** feature into your Dapp. The default implementation provides a set of pre-built components that allow you to have the feature up and running in no time.

Read more about the [Default Implementation](./siwx-default).

### Cloud Auth Implementation

The Cloud Auth SIWX is a predefined implementation of the SIWX configuration plugin that uses the Cloud service to create and manage SIWX messages and sessions. With Cloud Auth SIWX, you will be able to see and control the sessions of your users using the [User Management Dashboard](/cloud/user-management).

Read more about the [Cloud Auth Implementation](./siwx-cloud-auth).

### Custom Implementation

The `siwx` param expects to receive a defined interface from which you are able to create your own implementation. This is what allows you to customize the feature to suit your specific requirements.

The defined interface must follow specific rules to make sure that AppKit can interact with it correctly. Read more about how to have your [Custom Implementation](./siwx-custom).

## SIWX Expected Behavior

- **SIWX** will prompt to get the user signature and verify his identity every time a connection happen;
- In case a SIWX session is already stored, the user will be automatically signed in and the prompt step will be skipped;
- If the user changes the connected network, **SIWX** will prompt to get the user signature and verify his identity again;
- If the user disconnects from the Dapp, **SIWX** will revoke the session and the user will need to sign in again.

## Migrating from SIWE to SIWX

If you are currently already using **SIWE** from `@reown/appkit-siwe`, after AppKit version 1.5.0, you will be migrated into **SIWX**. The migration process is automatic and your `siweConfig` from `createAppKit` function will be mapped internally.

<Warning>
It is important to note that if you cannot use `siweConfig` and `siwx` at the same time, `createAppKit` will throw an error in case this happens.

You may replace `siweConfig` with your own `siwx` configuration manually if you would like to do so.
</Warning>
</file>

<file path="snippets/appkit/shared/siwx/siwx-cloud-auth.mdx">
Cloud Auth SIWX is a predefined implementation of the SIWX configuration plugin that uses the Cloud service to create and manage SIWX messages and sessions.

With Cloud Auth SIWX you will be able to see and control the sessions of your users using the [User Management Dashboard](#user-management).

<Warning>

For now, Cloud Auth SIWX will only work for `eip155` compatible networks.

</Warning>

### Installation

<CodeGroup>

```bash npm
npm install @reown/appkit-siwx
```

```bash Yarn
yarn add @reown/appkit-siwx
```

```bash Bun
bun a @reown/appkit-siwx
```

```bash pnpm
pnpm add @reown/appkit-siwx
```
</CodeGroup>

### Usage

```ts {2-3, 9-10}
import { createAppKit } from '@reown/appkit'
// Add the following code line
import { CloudAuthSIWX } from '@reown/appkit-siwx'

const appkit = createAppKit({
  projectId,
  networks,
  metadata,
  // Add the following code line
  siwx: new CloudAuthSIWX()
})
```

Now you are ready to use the **SIWX** feature in your Dapp.

## User Management

Easily view and manage all authenticated users through AppKit [Cloud Auth SIWX](/appkit/authentication/siwx/siwx-cloud-auth), a drop-in hosted SIWX server that provides key insights into your user base.


### Dashboard

The dashboard provides a list of all accounts (chain + address) connected to your dapp, including the country they connected from, the last connection time, and the authentication method (wallet or social login).

<Frame caption="User Management">
    <img src="/images/assets/user-management.png" />
</Frame>

### Insights

We plan to add more insights over time. Currently, it includes:

- **Connections**: Authenticated users over time  
- **Geographic Distribution**: User distribution by country  
- **Wallet Analytics**: Which wallets are most commonly used  
- **30-Day History**: Historical data for the past 30 days  

<Frame caption="User Management">
    <img src="/images/assets/insights.png" />
</Frame>
</file>

<file path="snippets/appkit/shared/siwx/siwx-custom.mdx">
Alternatively from the [Default Implementation](./siwx-default), you can create your own implementation of the **SIWX** feature to suit your specific requirements.

**SIWX** is developed to work as a plugin system for AppKit and to enable correctly it you need to fulfill the expected interface within the `createAppKit` function.

## SIWXConfig interface

This is the interface that you need to implement to create your own **SIWX** feature.

```ts
interface SIWXConfig {
  createMessage: (input: SIWXMessage.Input) => Promise<SIWXMessage>
  addSession: (session: SIWXSession) => Promise<void>
  revokeSession: (chainId: CaipNetworkId, address: string) => Promise<void>
  setSessions: (sessions: SIWXSession[]) => Promise<void>
  getSessions: (chainId: CaipNetworkId, address: string) => Promise<SIWXSession[]>
}
```

All the typings used are exposed by `@reown/appkit-core` package. You may check the source code [here](https://github.com/reown-com/appkit/blob/main/packages/core/src/utils/SIWXUtil.ts).

<Accordion title="Full Detailed Interfaces">
````ts
/**
 * This interface represents the SIWX configuration plugin, which is used to create and manage SIWX messages and sessions.
 * AppKit provides predefined implementations for this interface through `@reown/appkit-siwx`.
 * You may use it to create a custom implementation following your needs, but watch close for the methods requirements.
 */
export interface SIWXConfig {
  /**
   * This method will be called to create a new message to be signed by the user.
   *
   * Constraints:
   * - The message MUST be unique and contain all the necessary information to verify the user's identity.
   * - SIWXMessage.toString() method MUST be implemented to return the message string.
   *
   * @param input SIWXMessage.Input
   * @returns SIWXMessage
   */
  createMessage: (input: SIWXMessage.Input) => Promise<SIWXMessage>

  /**
   * This method will be called to store a new single session.
   *
   * Constraints:
   * - This method MUST verify if the session is valid and store it in the storage successfully.
   *
   * @param session SIWXSession
   */
  addSession: (session: SIWXSession) => Promise<void>

  /**
   * This method will be called to revoke all the sessions stored for a specific chain and address.
   *
   * Constraints:
   * - This method MUST delete all the sessions stored for the specific chain and address successfully.
   *
   * @param chainId CaipNetworkId
   * @param address string
   */
  revokeSession: (chainId: CaipNetworkId, address: string) => Promise<void>

  /**
   * This method will be called to replace all the sessions in the storage with the new ones.
   *
   * Constraints:
   * - This method MUST verify all the sessions before storing them in the storage;
   * - This method MUST replace all the sessions in the storage with the new ones successfully otherwise it MUST throw an error.
   *
   * @param sessions SIWXSession[]
   */
  setSessions: (sessions: SIWXSession[]) => Promise<void>

  /**
   * This method will be called to get all the sessions stored for a specific chain and address.
   *
   * Constraints:
   * - This method MUST return only sessions that are verified and valid;
   * - This method MUST NOT return expired sessions.
   *
   * @param chainId CaipNetworkId
   * @param address string
   * @returns
   */
  getSessions: (chainId: CaipNetworkId, address: string) => Promise<SIWXSession[]>
}

/**
 * This interface represents a SIWX session, which is used to store the user's identity information.
 */
export interface SIWXSession {
  data: SIWXMessage.Data
  message: string
  signature: string
  cacao?: Cacao
}

/**
 * This interface represents a SIWX message, which is used to create a message to be signed by the user.
 * This must contain the necessary information to verify the user's identity and how to generate the string message.
 */
export interface SIWXMessage extends SIWXMessage.Data, SIWXMessage.Methods {}

export namespace SIWXMessage {
  /**
   * This interface represents the SIWX message data, which is used to create a message to be signed by the user.
   */
  export interface Data extends Input, Metadata, Identifier {}

  /**
   * This interface represents the SIWX message input.
   * Here must contain what is different for each user of the application.
   */
  export interface Input {
    accountAddress: string
    chainId: CaipNetworkId
    notBefore?: Timestamp
  }

  /**
   * This interface represents the SIWX message metadata.
   * Here must contain the main data related to the app.
   */
  export interface Metadata {
    domain: string
    uri: string
    version: string
    nonce: string
    statement?: string
    resources?: string[]
  }

  /**
   * This interface represents the SIWX message identifier.
   * Here must contain the request id and the timestamps.
   */
  export interface Identifier {
    requestId?: string
    issuedAt?: Timestamp
    expirationTime?: Timestamp
  }

  /**
   * This interface represents the SIWX message methods.
   * Here must contain the method to generate the message string and any other method performed by the SIWX message.
   */
  export interface Methods {
    toString: () => string
  }

  /**
   * The timestamp is a UTC string representing the time in ISO 8601 format.
   */
  export type Timestamp = string
}

/**
 * The Cacao interface is a reference of CAIP-74 and represents a chain-agnostic Object Capability (OCAP).
 * https://chainagnostic.org/CAIPs/caip-74
 */
export interface Cacao {
  h: Cacao.Header
  p: Cacao.Payload
  s: {
    t: 'eip191' | 'eip1271'
    s: string
    m?: string
  }
}

export namespace Cacao {
  export interface Header {
    t: 'caip122'
  }

  export interface Payload {
    domain: string
    aud: string
    nonce: string
    iss: string
    version?: string
    iat?: string
    nbf?: string
    exp?: string
    statement?: string
    requestId?: string
    resources?: string[]
    type?: string
  }
}
````
</Accordion>

## Constraints

You are able to implement the `SIWXConfig` in the way you would like, but some constraints MUST be followed to make sure that AppKit can interact with it correctly and it will work as expected:

### `createMessage`

This method will be called to create a new message to be signed by the user.

- The message MUST be unique and contain all the necessary information to verify the user's identity.

### `addSession`

This method will be called to store a new single session.

- This method MUST verify if the session is valid and store it in the storage successfully.

### `revokeSession`

This method will be called to revoke all the sessions stored for a specific chain and address.

- This method MUST delete all the sessions stored for the specific chain and address successfully.

### `setSessions`

This method will be called to replace all the sessions in the storage with the new ones.

- This method MUST verify all the sessions before storing them in the storage;
- This method MUST replace all the sessions in the storage with the new ones successfully otherwise it MUST throw an error.

### `getSessions`

This method will be called to get all the sessions stored for a specific chain and address.

- This method MUST return only sessions that are verified and valid;
- This method MUST NOT return expired sessions.

## Example

Here is an example of how you can implement use your `SWIXConfig` interface:

```ts
import { createAppKit, type SIWXConfig } from '@reown/appkit'

const siwx: SIWXConfig = {
  createMessage: async (input) => {
    // Implement your logic to create a message
    return 'my message'
  }
  addSession: async (session) => {
    // Implement your logic to add a session
  },
  revokeSession: async (chainId, address) => {
    // Implement your logic to revoke a session
  },
  setSessions: async (sessions) => {
    // Implement your logic to set sessions
  },
  getSessions: async (chainId, address) => {
    // Implement your logic to get sessions
    return []
  }
}

createAppKit({
  // ... your configuration
  siwx
})
````
</file>

<file path="snippets/appkit/shared/siwx/siwx-default.mdx">
The Sign In With X feature enables decentralized applications (Dapps) to authenticate users seamlessly across multiple blockchain networks, such as Ethereum, Polygon or Solana. The user can connect and then sign a message with their account to prove ownership of the account.

## Quick Start

Here is a quick guide to get started with the **SIWX** feature using the default implementation.

### Example

<Card
  title="Next.js MultiChain SIWX Default Example"
  icon="github"
  href="https://github.com/reown-com/appkit-web-examples/blob/main/nextjs/next-siwx-multichain/"
>
  Check the Next.js example using DefaultSIWX in a multi-chain environment
</Card>

### Installation

<CodeGroup>

```bash npm
npm install @reown/appkit-siwx
```

```bash Yarn
yarn add @reown/appkit-siwx
```

```bash Bun
bun a @reown/appkit-siwx
```

```bash pnpm
pnpm add @reown/appkit-siwx
```
</CodeGroup>

### Usage

```ts {2-3, 9-10}
import { createAppKit } from "@reown/appkit";
// Add the following code line
import { DefaultSIWX } from "@reown/appkit-siwx";

const appkit = createAppKit({
  projectId,
  networks,
  metadata,
  // Add the following code line
  siwx: new DefaultSIWX(), // add this line to enable SIWX
});
```

You should now have the **SIWX** feature up and running in your Dapp.

The `DefaultSIWX` configuration will use the predefined components to handle the message generation, verification and storage of the sessions. You can customize the default implementation by providing your own components as in the following sections.

## Customizing the Default Implementation

The default implementation of **SIWX** is divided in three main components: `SIWXMessenger`, `SIWXVerifier` and `SIWXStorage`. The `@reown/appkit-siwx` package have defined options to fulfill the parts when initializing the `DefaultSIWX` configuration and you are also able to setup your own parts as required.

### Predefined Components

The `@reown/appkit-siwx` package provides some predefined components that you can use to quickly setup the `DefaultSIWX` configuration.

Check the latest components over the [SIWX repository](https://github.com/reown-com/appkit/tree/main/packages/siwx)

#### Customizing components

You may provide the parts to the `DefaultSIWX` configuration using the predefined components exposed by `@reown/appkit-siwx` package and customize the component params as needed.

```ts
import {
  DefaultSIWX,
  InformalMessenger,
  EIP155Verifier,
  SolanaVerifier,
  LocalStorage,
} from "@reown/appkit-siwx";

const siwx = new DefaultSIWX({
  messenger: new InformalMessenger({
    domain: "reown.com",
    uri: "https://reown.com",
    getNonce: async () => Math.round(Math.random() * 10000).toString(),
  }),
  verifiers: [new EIP155Verifier(), new SolanaVerifier()],
  storage: new LocalStorage({ key: "@appkit/siwx" }),
});
```

### Custom Components

You may create your own components to handle the message generation, verification and storage of the sessions. The following sections will guide you through the process of creating your own components.

#### `SIWXMessenger`

The [`SIWXMessenger`](https://github.com/reown-com/appkit/blob/main/packages/siwx/src/core/SIWXMessenger.ts) is an abstract class which holds methods for generating the message to be signed.

##### Creating a Custom Messenger:

You may extend the `SIWXMessenger` class adding the public attributes:

- `version`: a string that represents the version of the messenger;
- `stringify`: a method that receives the message data and returns a string to be signed.

```ts
import { SIWXMessenger } from "@reown/appkit-siwx";
import type { SIWXMessage } from "@reown/appkit-core";

export class MyMessenger extends SIWXMessenger {
  protected readonly version = "1";

  protected override stringify(params: SIWXMessage.Data): string {
    // Implement your message format here
    return `My message for ${params.accountAddress} on ${params.chainId}`;
  }
}
```

#### `SIWXVerifier`

The [`SIWXVerifier`](https://github.com/reown-com/appkit/blob/main/packages/siwx/src/core/SIWXVerifier.ts) is an abstract class that defines the verification logic for the signed message.

##### Creating a Custom Verifier:

You may extend the `SIWXVerifier` class adding the public attributes:

- `chainNamespace`: a string that represents the chain namespace for the verifier;
- `verify`: a method that receives the session data and returns a boolean indicating if the session is valid.

```ts
import { SIWXVerifier } from "@reown/appkit-siwx";
import type { SIWXSession } from "@reown/appkit-core";

export class MyVerifier extends SIWXVerifier {
  public readonly chainNamespace = "eip155"; // set the chain namespace for your verifier

  public async verify(session: SIWXSession): Promise<boolean> {
    // Implement your verification logic here
    return true;
  }
}
```

#### `SIWXStorage`

<Card
  title="Next.js SIWX Default Example with supabase storage"
  icon="github"
  href="https://github.com/reown-com/appkit-web-examples/tree/main/nextjs/next-siwx-multichain-supabase-storage"
>
  Check the Next.js example using DefaultSIWX and supabase as default storage
</Card>

[`SIWXStorage`](https://github.com/reown-com/appkit/blob/main/packages/siwx/src/core/SIWXStorage.ts) is a interface that defines how the session data will be stored.

##### Creating a Custom Storage:

You may implement the `SIWXStorage` interface with the following methods:

- `add`: This method will be called to store a new single session that is verified;
- `set`: This method must replace all the sessions in the storage with the new ones;
- `get`: This method must return all the sessions stored for a specific chain and address. Is expected that the sessions are already verified;
- `delete`: This method must delete all the sessions stored for a specific chain and address.

```ts
import type { SIWXSession } from "@reown/appkit-core";
import type { SIWXStorage } from "@reown/appkit-siwx";

export class MyStorage implements SIWXStorage {
  add(session: SIWXSession): Promise<void> {
    // Implement your logic to add a session
  }

  set(sessions: SIWXSession[]): Promise<void> {
    // Implement your logic to set sessions
  }

  get(chainId: CaipNetworkId, address: string): Promise<SIWXSession[]> {
    // Implement your logic to get sessions
    return [];
  }

  delete(chainId: string, address: string): Promise<void> {
    // Implement your logic to delete a session
  }
}
```

#### Using custom components

You may provide your custom components to the `DefaultSIWX` configuration.

If you omit any of the components, the default implementation will be used. Check [here](https://github.com/reown-com/appkit/blob/main/packages/siwx/src/configs/DefaultSIWX.ts) the default components.

```ts
import { DefaultSIWX, type SIWXStorage } from "@reown/appkit-siwx";

class MyDatabaseStorage implements SIWXStorage {
  // ...
}

const siwx = new DefaultSIWX({
  storage: new MyDatabaseStorage(),
});
```
</file>

<file path="snippets/appkit/shared/bitcoin-provider.mdx">
## Bitcoin Provider Interface

```ts
export interface BitcoinConnector extends ChainAdapterConnector, Provider {
  getAccountAddresses(): Promise<BitcoinConnector.AccountAddress[]>;
  signMessage(params: BitcoinConnector.SignMessageParams): Promise<string>;
  sendTransfer(params: BitcoinConnector.SendTransferParams): Promise<string>;
  signPSBT(
    params: BitcoinConnector.SignPSBTParams
  ): Promise<BitcoinConnector.SignPSBTResponse>;
}
```

### Parameters

<Tabs>
<Tab title="SignMessageParams">
```ts
  export type SignMessageParams = {
    /**
     * The message to be signed
     */
    message: string
    /**
     * The address to sign the message with
     */
    address: string
  }
```
</Tab>
<Tab title="SignMessageParams">
```ts
  export type SendTransferParams = {
    /**
     * The amount to be sent in satoshis
     */
    amount: string
    /**
     * The address to send the transfer to
     */
    recipient: string
  }
```
</Tab>
<Tab title="SignPSBTParams">
```ts
  export type SignPSBTParams = {
    /**
     * The PSBT to be signed, string base64 encoded
     */
    psbt: string
    signInputs: {
      /**
       * The address whose private key to use for signing.
       */
      address: string
      /**
       * Specifies which input to sign
       */
      index: number
      /**
       * Specifies which part(s) of the transaction the signature commits to
       */
      sighashTypes: number[]
    }[]

    /**
     * If `true`, the PSBT will be broadcasted after signing. Default is `false`.
     */
    broadcast?: boolean

}

````
</Tab>
</Tabs>

### Responses

<Tabs>
<Tab title="AccountAddress">
```ts
  export type AccountAddress = {
    /**
     * Public address belonging to the account.
     */
    address: string
    /**
     * Public key for the derivation path in hex, without 0x prefix
     */
    publicKey?: string
    /**
     * The derivation path of the address e.g. "m/84'/0'/0'/0/0"
     */
    path?: string
    /**
     * The purpose of the address
     */
    purpose: 'payment' | 'ordinal' | 'stx'
  }
````

</Tab>
<Tab title="SignPSBTResponse">
```ts
  export type SignPSBTResponse = {
    /**
     * The signed PSBT, string base64 encoded
     */
    psbt: string
    /**
     * The `string` transaction id of the broadcasted transaction or `undefined` if not broadcasted
     */
    txid?: string
  }
```
</Tab>
</Tabs>
</file>

<file path="snippets/appkit/shared/chain-abstraction.mdx">
## Overview

<Info>
💡 Support for Chain Abstraction is currently in early access phase.
</Info>

Chain abstraction simplifies interactions across different blockchains, allowing users to transact seamlessly without worrying about network-specific tokens.

To fully leverage chain abstraction, wallets need to support its implementation, and minor adjustments are required on the Dapp side.

Dapps may not always be aware of the balances across different chains or accounts that wallets can access. Therefore, it’s crucial to ensure that the call does not fail on the Dapp side.

This guide focuses on the most common ways Dapps interact with wallets using the Wagmi library.

## Implementations

<Info>
To ensure compatibility and optimal performance with the Chain Abstraction feature, please use Wagmi 2.13.0 or later.
</Info>

### useSendTransaction

<Tabs>
<Tab title="Wagmi">

The `useSendTransaction` hook attempts to estimate gas on the Dapp side before forwarding the call to the wallet. However, gas estimation might fail because the Dapp may not account for all the funds available to the wallet across different chains.

To ensure the call is sent successfully, the wallet must handle gas estimation. You need to pass `gas: null` to the sendTransaction method.

```tsx
import { useSendTransaction } from "wagmi";
import { parseEther } from "viem";

function App() {
  const { sendTransaction } = useSendTransaction();

  return (
    <button
      onClick={() =>
        sendTransaction({
          to: "0xd2135CfB216b74109775236E36d4b433F1DF507B",
          value: parseEther("0.01"),
          gas: null, // <- Add this
        })
      }
    >
      Send transaction
    </button>
  );
}
```

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/shared/components.mdx">
AppKit's [web components](https://www.webcomponents.org/) are custom and reusable HTML tags. They will work across modern browsers, and can be used with any JavaScript library or framework that works with HTML.

<Note>
  Web components are global html elements that don't require importing.
</Note>

### List of optional properties for AppKit web components

### `<appkit-button />`

| Variable       | Description                                                                                            | Type                               |
| -------------- | ------------------------------------------------------------------------------------------------------ | ---------------------------------- |
| `disabled`     | Enable or disable the button.                                                                          | `boolean`                          |
| `balance`      | Show or hide the user's balance.                                                                       | `'show'   \| 'hide'`               |
| `size`         | Default size for the button.                                                                           | `'md'     \| 'sm'`                 |
| `label`        | The text shown in the button.                                                                          | `string`                           |
| `loadingLabel` | The text shown in the button when the modal is open.                                                   | `string`                           |
| `namespace`    | Option to show specific namespace account info. Note: `eip155` is for EVM and `bip122` is for Bitcoin. | `'eip155' \| 'solana' \| 'bip122'` |

### `<appkit-account-button />`

| Variable   | Description                      | Type                 |
| ---------- | -------------------------------- | -------------------- |
| `disabled` | Enable or disable the button.    | `boolean`            |
| `balance`  | Show or hide the user's balance. | `'show'   \| 'hide'` |

### `<appkit-connect-button />`

| Variable       | Description                                          | Type              |
| -------------- | ---------------------------------------------------- | ----------------- |
| `size`         | Default size for the button.                         | `'md'    \| 'sm'` |
| `label`        | The text shown in the button.                        | `string`          |
| `loadingLabel` | The text shown in the button when the modal is open. | `string`          |

### `<appkit-network-button />`

| Variable   | Description                   | Type      |
| ---------- | ----------------------------- | --------- |
| `disabled` | Enable or disable the button. | `boolean` |
</file>

<file path="snippets/appkit/shared/multichain.mdx">
---
title: Multichain
---

AppKit is now multichain. The architecture is designed to support both EVM and non-EVM blockchains. This will allow developers and projects to choose and configure multiple blockchain networks within their instance of AppKit, extending beyond just Ethereum-based (EVM) networks.

Currently, AppKit supports two non-EVM networks, they are, **Solana** and **Bitcoin**. Soon, AppKit will support Polkadot and Cosmos, allowing projects to tap into users from these different blockchain ecosystems. This will enable developers and projects to reach a broader audience and interact with multiple blockchain networks, all through a single wallet provider.

## Installation

<Tabs>
<Tab title="Wagmi + Solana">

<CodeGroup>

```bash npm
npm install @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-solana
```

```bash Yarn
yarn add @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-solana
```

```bash Bun
bun a @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-solana
```

```bash pnpm
pnpm add @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-solana
```

</CodeGroup>

</Tab>
<Tab title="Wagmi + Bitcoin">

<CodeGroup>

```bash npm
npm install @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-bitcoin
```

```bash Yarn
yarn add @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-bitcoin
```

```bash Bun
bun a @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-bitcoin
```

```bash pnpm
pnpm add @reown/appkit @reown/appkit-adapter-wagmi @reown/appkit-adapter-bitcoin
```

</CodeGroup>

</Tab>
<Tab title="Ethers5 + Solana">

<CodeGroup>

```bash npm
npm install @reown/appkit @reown/appkit-adapter-ethers5 @reown/appkit-adapter-solana
```

```bash Yarn
yarn add @reown/appkit @reown/appkit-adapter-ethers5 @reown/appkit-adapter-solana
```

```bash Bun
bun a @reown/appkit @reown/appkit-adapter-ethers5 @reown/appkit-adapter-solana
```

```bash pnpm
pnpm add @reown/appkit @reown/appkit-adapter-ethers5 @reown/appkit-adapter-solana
```

</CodeGroup>

</Tab>
<Tab title="Ethers + Solana">

<CodeGroup>

```bash npm
npm install @reown/appkit @reown/appkit-adapter-ethers @reown/appkit-adapter-solana
```

```bash Yarn
yarn add @reown/appkit @reown/appkit-adapter-ethers @reown/appkit-adapter-solana
```

```bash Bun
bun a @reown/appkit @reown/appkit-adapter-ethers @reown/appkit-adapter-solana
```

```bash pnpm
pnpm add @reown/appkit @reown/appkit-adapter-ethers @reown/appkit-adapter-solana
```

</CodeGroup>

</Tab>

<Tab title="Basic">

<CodeGroup>

```bash npm
npm install @reown/appkit
```

```bash Yarn
yarn add @reown/appkit
```

```bash Bun
bun a @reown/appkit
```

```bash pnpm
pnpm add @reown/appkit
```

</CodeGroup>

</Tab>
</Tabs>

## Integration

The AppKit instance allows you to support multiple chains by importing the respective chains, creating the respective network adapters and passing these within the `createAppKit()` function.

Depending on the network adapter of your preference (`Wagmi`, `Ethers`, `Ethers5`), the integration may vary. Let's look at what the integration will look like.

<Tabs>
<Tab title="Wagmi + Solana">
```ts
import { createAppKit } from '@reown/appkit'
import { SolanaAdapter } from '@reown/appkit-adapter-solana'
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'

import {
  mainnet,
  arbitrum,
  sepolia,
  solana,
  solanaTestnet,
  solanaDevnet,
} from "@reown/appkit/networks";
import type { AppKitNetwork } from "@reown/appkit/types";

const networks: [AppKitNetwork, ...AppKitNetwork[]] = [mainnet, arbitrum, sepolia, solana, solanaTestnet, solanaDevnet]

// 0. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 1. Create the Wagmi adapter
export const wagmiAdapter = new WagmiAdapter({
  ssr: true,
  projectId,
  networks
})

// 2. Create Solana adapter
const solanaWeb3JsAdapter = new SolanaAdapter()

// 3. Set up the metadata - Optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 4. Create the AppKit instance
const modal = createAppKit({
  adapters: [wagmiAdapter, solanaWeb3JsAdapter],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true,
  }
})
```
</Tab>

<Tab title="Wagmi + Bitcoin">
```ts
import { createAppKit } from '@reown/appkit'
import { BitcoinAdapter } from '@reown/appkit-adapter-bitcoin'
import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'

import { mainnet, arbitrum, sepolia, bitcoin } from '@reown/appkit/networks'

const networks: [AppKitNetwork, ...AppKitNetwork[]] = [mainnet, arbitrum, sepolia, bitcoin]

// 0. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 1. Create the Wagmi adapter
export const wagmiAdapter = new WagmiAdapter({
  ssr: true,
  projectId,
  networks
})

// 2. Set up Bitcoin Adapter
const bitcoinAdapter = new BitcoinAdapter({
  projectId
})

// 3. Set up the metadata - Optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 4. Create the AppKit instance
const modal = createAppKit({
  adapters: [wagmiAdapter, bitcoinAdapter],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true,
  }
})
```

</Tab>

<Tab title="Ethers + Solana">
```ts
import { createAppKit } from '@reown/appkit'
import { SolanaAdapter } from '@reown/appkit-adapter-solana'
import { EthersAdapter } from '@reown/appkit-adapter-ethers'

import { solana, solanaTestnet, solanaDevnet } from '@reown/appkit/networks';
import { mainnet, arbitrum, sepolia } from "@reown/appkit/networks";

import {
  SolflareWalletAdapter,
  PhantomWalletAdapter,
} from "@solana/wallet-adapter-wallets";

const networks: [AppKitNetwork, ...AppKitNetwork[]] = [mainnet, arbitrum, sepolia, solana, solanaTestnet, solanaDevnet]

// 0. Create the Ethers adapter
export const ethersAdapter = new EthersAdapter()

// 1. Create Solana adapter
const solanaWeb3JsAdapter = new SolanaAdapter({
wallets: [new PhantomWalletAdapter(), new SolflareWalletAdapter()]
})

// 2. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 3. Set up the metadata - Optional
const metadata = {
name: 'AppKit',
description: 'AppKit Example',
url: 'https://example.com', // origin must match your domain & subdomain
icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 4. Create the AppKit instance
const modal = createAppKit({
adapters: [ethersAdapter, solanaWeb3JsAdapter],
networks,
metadata,
projectId,
features: {
analytics: true,
}
})

```
</Tab>

<Tab title="Ethers5 + Solana">
```ts
import { createAppKit } from '@reown/appkit'
import { SolanaAdapter } from '@reown/appkit-adapter-solana'
import { EthersAdapter } from '@reown/appkit-adapter-ethers'

import { solana, solanaTestnet, solanaDevnet } from '@reown/appkit/networks'
import { mainnet, arbitrum, sepolia } from '@reown/appkit/networks'

import { SolflareWalletAdapter, PhantomWalletAdapter } from '@solana/wallet-adapter-wallets'

// 0. Create the Ethers adapter
export const ethersAdapter = new EthersAdapter()

// 1. Create Solana adapter
const solanaWeb3JsAdapter = new SolanaAdapter({
  wallets: [new PhantomWalletAdapter(), new SolflareWalletAdapter()]
})

// 2. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 3. Set up the metadata - Optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 4. Create the AppKit instance
const modal = createAppKit({
  adapters: [ethersAdapter, solanaWeb3JsAdapter],
  networks: [mainnet, arbitrum, sepolia, solana, solanaTestnet, solanaDevnet],
  metadata,
  projectId,
  features: {
    analytics: true,
  }
})
```

</Tab>

<Tab title="Basic">

```ts
import { createAppKit } from "@reown/appkit";
import { solana, solanaTestnet, solanaDevnet } from "@reown/appkit/networks";
import { mainnet, arbitrum, sepolia } from "@reown/appkit/networks";

// 1. Get projectId from https://cloud.reown.com
const projectId = "YOUR_PROJECT_ID";

// 2. Set up the metadata - Optional
const metadata = {
  name: "AppKit",
  description: "AppKit Example",
  url: "https://example.com", // origin must match your domain & subdomain
  icons: ["https://avatars.githubusercontent.com/u/179229932"],
};

// 3. Create the AppKit instance
const modal = createAppKit({
  networks: [mainnet, arbitrum, sepolia, solana, solanaTestnet, solanaDevnet],
  metadata: metadata,
  projectId,
  features: {
    analytics: true,
  },
});
```

</Tab>

</Tabs>
</file>

<file path="snippets/appkit/shared/onramp.mdx">
---
title: On-Ramp
---

AppKit seamlessly incorporates Coinbase Pay, enabling users to sign in to their Coinbase accounts and utilize fiat payment methods for purchasing cryptocurrencies.

<Note>
On-Ramp is supported in the latest version of AppKit. If you are using an older version, make sure you upgrade.
</Note>

## Integration

The On-Ramp feature is enabled by default, so no additional configuration is required. 

If you prefer to disable it, set the `onramp` flag to `false` in the configuration of the `createAppKit` function.

<Note>
On-Ramp is now available on **Solana**. The configuration for On-Ramp on both EVM and Solana is the same. Please refer to the code snippet below.
</Note>

```ts {7}
const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    onramp: false // Optional - true by default
  }
})
```
</file>

<file path="snippets/appkit/shared/options.mdx">
---
title: Options
---

The following options can be passed to the `createAppKit` function:

```ts
createAppKit({ adapters, projectId, networks, ...options });
```

## networks

Array of networks that can be chosen from the `@reown/appkit/networks` library. This library retrieves the list of EVM networks from Viem and also includes the Solana networks.

```ts
import { mainnet, solana } from "@reown/appkit/networks";

createAppKit({
  // ...
  networks: [mainnet, solana],
});
```

For custom networks, refer to this [doc page](/appkit/react/core/custom-networks).

## metadata

Metadata for your AppKit. The `name`, `description`, `icons`, and `url` are used at certain places like the wallet connection, sign message, etc screens. If not provided, they will be fetched from the metadata of your website's document object.

```ts
createAppKit({
  // ...
  metadata: {
    name: "My App",
    description: "My App Description",
    icons: ["https://myapp.com/icon.png"],
    url: "https://myapp.com",
  },
});
```

For custom networks, refer to this [doc page](/appkit/react/core/custom-networks).

## defaultNetwork

Desired network for the initial connection as default:

<Tabs>
<Tab title="Wagmi">

```ts
import { mainnet } from "@reown/appkit/networks";

createAppKit({
  //...
  defaultNetwork: mainnet,
});
```

</Tab>
<Tab title="Ethers">

```ts
const mainnet = {
  chainId: 1,
  name: "Ethereum",
  currency: "ETH",
  explorerUrl: "https://etherscan.io",
  rpcUrl: "https://cloudflare-eth.com",
};

createAppKit({
  //...
  defaultNetwork: mainnet,
});
```

</Tab>
<Tab title="Solana">

```ts
import { solana } from "@reown/appkit/networks";

createAppKit({
  //...
  defaultNetwork: solana,
});
```

</Tab>
</Tabs>

## defaultAccountTypes

It allows you to configure the default account selected for the specified networks in AppKit. For example, if you want your EVM networks to use an EOA account by default, you can configure it as shown in the code below.

```ts
createAppKit({
  //...
  defaultAccountTypes: { eip155: "eoa" },
});
```

Here are all the options you have for each network identifier or networks. Network identifier or networks available are `eip155` for EVM chains, `solana` for Solana, `bip122` for Bitcoin, and `polkadot` for Polkadot.

```ts
type DefaultAccountTypes = {
  eip155: "eoa" | "smartAccount";
  solana: "eoa";
  bip122: "payment" | "ordinal" | "stx";
  polkadot: "eoa";
};
```

## featuredWalletIds

Select wallets that are going to be shown on the modal's main view. Default wallets are MetaMask and Trust Wallet.
Array of wallet ids defined will be prioritized (order is respected).
These wallets will also show up first in `All Wallets` view.
You can find the wallets IDs in [Wallets List](/cloud/wallets/wallet-list) or in [WalletGuide](https://walletguide.walletconnect.network/)

```ts
createAppKit({
  //...
  featuredWalletIds: [
    "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
  ],
});
```

## chainImages

Add or override the modal's network images.

```ts
createAppKit({
  // ...
  chainImages: {
    1: "https://my.images.com/eth.png",
  },
});
```

## connectorImages

<Tabs>
<Tab title="Wagmi">

Set or override the images of any [connector](https://wagmi.sh/core/connectors/injected). The key of each property must match the id of the connector.

```ts
createAppKit({
  connectorImages: {
    coinbaseWallet: "https://images.mydapp.com/coinbase.png",
    metaMask: "https://images.mydapp.com/metamask.png",
  },
});
```

</Tab>
<Tab title="Ethers">

Set or override the images of any connector.

```ts
createAppKit({
  connectorImages: {
    coinbaseWallet: "https://images.mydapp.com/coinbase.png",
    walletConnect: "https://images.mydapp.com/walletconnect.png",
  },
});
```

</Tab>
<Tab title="Solana">

Set or override the images of any connector.

```ts
createAppKit({
  connectorImages: {
    coinbaseWallet: "https://images.mydapp.com/coinbase.png",
    phantom: "https://images.mydapp.com/phantom.png",
    walletConnect: "https://images.mydapp.com/walletconnect.png",
  },
});
```

</Tab>
</Tabs>

## enableWalletConnect

Enable or disable WalletConnect QR feature. Default is `true`.

```ts
enableWalletConnect: false;
```

## enableNetworkSwitch

Enables or disables the network switching functionality in the modal. The default is `true`.

```ts
createAppKit({
  //...
  enableNetworkSwitch: false,
});
```

## debug

Enable or disable debug mode in your AppKit. This is useful if you want to see UI alerts when debugging. Default is `false`.

```ts
debug: true;
```

## enableWalletGuide

Enable or disable the wallet guide text, is useful for people that don't have a wallet yet. Default is `true`.

```ts
createAppKit({
  //...
  enableWalletGuide: false,
});
```

## termsConditionsUrl

You can add an url for the _terms and conditions_ link.

```ts
createAppKit({
  //...
  termsConditionsUrl: "https://www.mytermsandconditions.com",
});
```

## privacyPolicyUrl

A URL for the _privacy policy_ link.

```ts
createAppKit({
  //...
  privacyPolicyUrl: "https://www.myprivacypolicy.com",
});
```

## features

Allows you to toggle (enable or disable) additional features provided by AppKit. Features such as analytics, email and social logins, On-ramp, swaps, etc., can be enabled using this parameter.

### analytics

Enable analytics to get more insights on your users activity within your [Reown Cloud's dashboard](https://cloud.reown.com)

```ts
createAppKit({
  //...
  features: {
    analytics: true,
  },
});
```

<Card title="Learn More" href="/cloud/analytics" />

### swaps

Enable or disable the swap feature in your AppKit. [Swaps](/appkit/react/transactions/swaps) feature is enabled by default.

```ts
createAppKit({
  //...
  features: {
    swaps: true,
  },
});
```

### onramp

Enable or disable the onramp feature in your AppKit. [Onramp](/appkit/react/transactions/onramp) feature is enabled by default.

```ts
createAppKit({
  //...
  features: {
    onramp: true,
  },
});
```

### connectMethodsOrder

Order of the connection methods in the modal. The default order is `['wallet', 'email', 'social']`.

<Frame>
  <img src="/images/assets/connectMethodsOrder.jpg" />
</Frame>

```ts
createAppKit({
  //...
  features: {
    connectMethodsOrder: ["social", "email", "wallet"],
  },
});
```

### legalCheckbox

Enable or disable the terms of service and/or privacy policy checkbox.

```ts
createAppKit({
  //...
  features: {
    legalCheckbox: true,
  },
});
```

<Frame>
  <img src="/images/w3m/features/legal-checkbox.png" />
</Frame>

## customWallets

Adds custom wallets to the modal. `customWallets` is an array of objects, where each object contains specific information of a custom wallet.

```ts
createAppKit({
  //...
  customWallets: [
    {
      id: "myCustomWallet",
      name: "My Custom Wallet",
      homepage: "www.mycustomwallet.com", // Optional
      image_url: "my_custom_wallet_image", // Optional
      mobile_link: "mobile_link", // Optional - Deeplink or universal
      desktop_link: "desktop_link", // Optional - Deeplink
      webapp_link: "webapp_link", // Optional
      app_store: "app_store", // Optional
      play_store: "play_store", // Optional
    },
  ],
});
```

## AllWallets

<Warning>

If the "All Wallets" button is removed on mobile, all the mobile wallets that were not added on the main view of the modal **won't** be able to connect to your website via WalletConnect protocol.

</Warning>

The `allWallets` parameter allows you to add or remove the "All Wallets" button on the modal.

| Value         | Description                                              |
| ------------- | -------------------------------------------------------- |
| `SHOW`        | Shows the "All Wallets" button on AppKit.                |
| `HIDE`        | Removes the "All Wallets" button from AppKit.            |
| `ONLY_MOBILE` | Shows the "All Wallets" button on AppKit only on mobile. |

```ts
createAppKit({
  //...
  allWallets: "ONLY_MOBILE",
});
```

## includeWalletIds & excludeWalletIds

<Warning>

Wallets that are either not included or excluded **won't** be able to connect to your website on mobile via WalletConnect protocol.

</Warning>

### includeWalletIds

Override default recommended wallets that are fetched from [WalletGuide](https://walletguide.walletconnect.network/).
Array of wallet ids defined will be shown (order is respected).
Unlike `featuredWalletIds`, these wallets will be the **only** ones shown in `All Wallets` view and as recommended wallets.
You can find the wallets IDs in our [Wallets List](/cloud/wallets/wallet-list).

```ts
createAppKit({
  //...
  includeWalletIds: [
    "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
  ],
});
```

### excludeWalletIds

Exclude wallets that are fetched from [WalletGuide](https://walletguide.walletconnect.network/).
Array of wallet ids defined will be excluded. All other wallets will be shown in respective places.
You can find the wallets IDs in our [Wallets List](/cloud/wallets/wallet-list).

```ts
createAppKit({
  //...
  excludeWalletIds: [
    "1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369",
    "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
  ],
});
```

### Coinbase Smart Wallet

The Coinbase connector now includes a new flag to customize the Smart Wallet behavior.

<Note>
  To enable the Coinbase Smart Wallet feature, ensure that AppKit is updated to
  version 4.2.3 or higher. Additionally, if you are using Wagmi, verify that it
  is on the latest version.
</Note>

The `preference` (or `coinbasePreference`) flag accepts one of the following string values:

- `eoaOnly`: Uses EOA Browser Extension or Mobile Coinbase Wallet.
- `smartWalletOnly`: Displays Smart Wallet popup.
- `all` (default): Supports both `eoaOnly` and `smartWalletOnly` based on context.

<Tabs>
<Tab title="Wagmi">

AppKit can be configured in **two** different ways: **Default** or **Custom**

Select your preferred configuration mode below:

Learn more about the Coinbase connector in the [Wagmi documentation](https://wagmi.sh/react/api/connectors/coinbaseWallet#preference).

<CodeGroup >

```ts Default {4}
createAppKit({
  //...
  enableCoinbase: true, // true by default
  coinbasePreference: "smartWalletOnly",
});
```

```ts Custom {8}
import { WagmiAdapter } from "@reown/appkit-adapter-wagmi";

const adapter = new WagmiAdapter({
  //...
  connectors: [
    coinbaseWallet({
      //...
      preference: "smartWalletOnly",
    }),
    projectId,
    networks,
  ],
});

export const config = wagmiAdapter.wagmiConfig;
```

</CodeGroup>

</Tab>
<Tab title="Ethers">

```ts {4}
createAppKit({
  //...
  enableCoinbase: true, // true by default
  coinbasePreference: "smartWalletOnly",
});
```
</Tab>
</Tabs>

## customRpcUrls

This function allows you to add custom RPC URLs to override the default network RPC URLs for native RPC calls. This is useful when you want to use your own RPC endpoints instead of the defaults.

```ts
type CustomRpcUrl = {
  url: string
  config?: HttpTransportConfig // Optional transport configuration
}

type CustomRpcUrlMap = Record<CaipNetworkId, CustomRpcUrl[]>

createAppKit({
  //...
  customRpcUrls: {
    'eip155:1': [
      {
        url: 'https://your-custom-mainnet-url.com',
        config: {
          // Optional HTTP transport configuration
        }
      }
    ],
    'eip155:137': [
      {
        url: 'https://your-custom-polygon-url.com'
      }
    ]
  }
})
```

If you are using the Wagmi adapter, you need to pass the same `customRpcUrls` configuration to both the `WagmiAdapter` and `createAppKit`.

```ts
const customRpcUrls: CustomRpcUrlMap = {
  'eip155:1': [{ url: 'https://your-custom-mainnet-url.com' }],
  'eip155:137': [{ url: 'https://your-custom-polygon-url.com' }]
}

const wagmiAdapter = new WagmiAdapter({
  networks: [...],
  projectId: "project-id",
  customRpcUrls
})

const modal = createAppKit({
  adapters: [...],
  networks: [...],
  projectId: "project-id",
  customRpcUrls
})
```

<Note>

When using the Wagmi adapter, you don't need to configure [`transports`](https://wagmi.sh/core/api/createConfig#transports) separately. The WagmiAdapter will automatically configure them based on your `customRpcUrls`.

However, if you use both `customRpcUrls` and Wagmi's `transports` property, be aware that `transports` will take precedence and override any conflicting RPC URLs defined in `customRpcUrls`.

```ts
const wagmiAdapter = new WagmiAdapter({
  //...
  customRpcUrls: {
    'eip155:1': [{ url: 'https://custom-rpc-1.com' }] // This will be overridden
  },
  transports: {
    [mainnet.id]: http('https://transport-rpc-1.com') // This takes precedence
  }
})
```

</Note>

## universalProviderConfigOverride

Lets you customize specific aspects of the provider's behavior.

```ts
createAppKit({
  //...
  universalProviderConfigOverride: {
    methods: { eip155: ['eth_sendTransaction', 'personal_sign'] },
    chains: { eip155: ['1', '137'] },
    events: { eip155: ['chainChanged', 'accountsChanged'] },
    rpcMap: { eip155:1: 'https://ethereum.publicnode.com' },
    defaultChain: 'eip155:1'
  },
});
```

You can override any of the following properties:
- `methods`: Custom RPC methods for each namespace
- `chains`: Supported chains for each namespace
- `events`: Events to subscribe to for each namespace
- `rpcMap`: Custom RPC URLs for specific chains
- `defaultChain`: The default chain to connect to
</file>

<file path="snippets/appkit/shared/resources.mdx">
Main links for AppKit related content.

- [Examples](https://github.com/reown-com/appkit/tree/main/examples)
- [Web Examples](https://github.com/reown-com/appkit-web-examples)
- [GitHub Repository](https://github.com/reown-com/appkit/)
- [Issue tracker](https://github.com/reown-com/appkit/issues)
- [Website Laboratory](https://appkit-lab.reown.com/)
</file>

<file path="snippets/appkit/shared/smart-accounts.mdx">
## Overview

<Info>
💡 Ensure you update AppKit to the latest version for optimal compatibility.
</Info>

Smart Accounts (SAs) are enabled by default within AppKit. These accounts enhance functionality by emitting 1271 and 6492 signatures, which should be taken into account for signature verification processes, such as Sign-In with Ethereum (SIWE).

### Deployment

Smart Accounts are deployed alongside the first transaction. Until deployment, a precalculated address, known as the counterfactual address, is displayed. Despite not being deployed, the account can still sign using 6492 signatures.

### Supported Networks

Smart Accounts are available on the following networks:

- Base Sepolia
- BSC (Binance Smart Chain)
- Fraximal
- Linea
- Mode
- Optimism
- Polygon
- Polygon Mumbai
- Sepolia

### User Eligibility

Smart Accounts are exclusively available for embedded wallet users (email and social login)

## FAQ

### What is a Smart Account?

A Smart Account improves the traditional account experience by replacing Externally Owned Accounts (EOAs) with a Smart Contract that follows the [ERC-4337 standard](https://eips.ethereum.org/EIPS/eip-4337). This opens up many use cases that were previously unavailable. 

Smart Accounts do no require Private Keys or Seed Phrases, instead they rely on a key or multiple keys from designated signers to access the smart account and perform actions on chain. The keys can take multiple forms including passkeys and EOA signatures.

### What can I do with a Smart Account?

Smart accounts unlock a host of use cases that were previously unavailable with EOAs. Essentially anything that can be programmed into a smart contract can be used by Smart Accounts.

- **Automated Transactions:** Set up recurring payments or conditional transfers.
- **Multi-Signature Authorization:** Require multiple approvals for a transaction to increase security.
- **Delegated Transactions:** Allow a third party to execute transactions on your behalf under specific conditions.
- **Enhanced Security:** Implement complex security mechanisms such as time-locked transactions and withdrawal limits.
- **Interoperability:** Interact seamlessly with decentralized applications (dApps) and decentralized finance (DeFi) protocols.
- **Custom Logic:** Create custom transaction rules and workflows that align with personal or business requirements.

### How do I get a Smart Account?

Existing AppKit Universal Wallet Users will be given the option to upgrade their account to a smart account. Once you upgrade you will still be able to access your EOA and self-custody your account. 

New AppKit Universal Wallet Users will be given smart accounts by default when they login for the first time.

### Does it cost anything?

There is a small additional cost for activating your smart account. The activation fee is added to the first transaction and covers the network fees required for deploying the new smart contract onchain.

### Can I export my Smart Account?

No, you cannot export your Smart Account. The Smart Account (SA) is deployed by the EOA and is owned by the EOA. Your EOA account will always be exportable.
Also is good to know that SA don't have seedphrases.

### Can I withdraw all my funds from my Smart Account?

Yes, you can withdraw all your funds from your Smart Account.

### What are account names?

Smart account addresses start with ’0x’ followed by 42 characters, this is the unique address of your smart account on the network. ‘0x’ addresses like this are long, unwieldy and unmemorable. AppKit allows you to assign a more memorable name for your smart account using [ENS Resolvers](https://docs.ens.domains/resolvers/ccip-read). 

You can assign a name to your account and this will act as an alias for your account that can be shared publicly and provide a better user experience. AppKit account names are followed by the "reown.id" domain. 

### What can I do with my account name?

As AppKit smart account addresses are the same across the supported networks by [Pimlico](https://docs.pimlico.io/infra/platform/supported-chains), you only need one account name which can then be used across the networks. 

For example if you want someone to send you USDC on Polygon they can send it to “johnsmith.reown.id”. If you want someone wants to send you USDC on Optimism they can also use “johnsmith.reown.id”.
</file>

<file path="snippets/appkit/shared/smart-sessions.mdx">
## Overview

<Info>
💡 The support for smart-session is included in the Appkit SDK in the `experimental` package.
</Info>

Smart Sessions allow developers to easily integrate session-based permission handling within their decentralized applications (dApps). Using the `grantPermissions` method, can send permission requests to wallets.

For users, this means a simpler experience. Instead of approving every action individually, they can allow access for a single session, making it faster and easier to use apps without dealing with constant pop-ups or interruptions.

With Smart Sessions, approved actions are carried out by the app's backend during the session. This allows transactions to be processed automatically, making the experience even more seamless while ensuring that everything stays within the permissions set by the user.

This guide will walk you through on how to use the `grantPermissions` method, including the basic setup and an example of how to request permissions from a wallet.

## Implementations

The `grantPermissions` method provides an easy way to interact with the smart wallet to request permissions.

### Step 1 | Install the library

<CodeGroup>

```bash npm
npm install @reown/appkit-experimental
```

```bash Yarn
yarn add @reown/appkit-experimental
```

```bash Bun
bun a @reown/appkit-experimental
```

```bash pnpm
pnpm add @reown/appkit-experimental
```
</CodeGroup>

### Step 2 | Import the method

First, import the grantPermissions method from the `@reown/appkit-experimental/smart-session` package.

```javascript
import {
  grantPermissions,
  type SmartSessionGrantPermissionsRequest,
} from "@reown/appkit-experimental/smart-session";
```

### Step 3 | Define the Permission Request

Create an object adhering to the `SmartSessionGrantPermissionsRequest` type. This object specifies details like the `address`, `chainID`, `signer`, `policies`, `permissions`, and `expiry` time.

Example request object:

```tsx
const request: SmartSessionGrantPermissionsRequest = {
  expiry: Math.floor(Date.now() / 1000) + 24 * 60 * 60, // 24 hours
  chainId: toHex(baseSepolia.id),
  address: address,
  signer: {
    type: "keys",
    data: {
      keys: [
        {
          type: "secp256k1",
          publicKey: "0x...", //public key of dapp signer
        },
      ],
    },
  },
  permissions: [
    {
      type: "contract-call",
      data: {
        address: "0x2E65BAfA07238666c3b239E94F32DaD3cDD6498D", // sample donut contract address
        abi: [
          {
            inputs: [
              { internalType: "uint256", name: "amount", type: "uint256" },
            ],
            name: "purchase",
            outputs: [],
            stateMutability: "payable",
            type: "function",
          },
        ],
        functions: [
          {
            functionName: "purchase",
          },
        ],
      },
    },
  ],
  policies: [],
};
```

### Step 4 | Invoke the Method

Call the `grantPermissions` function, passing the request object. This will trigger the permission request via the connected wallet.

```tsx
const response = await grantPermissions(request);
```

### Step 5 | Handle the Response

Upon successful execution, the response will include the granted permissions and the session context. So the response can be handled as needed.

#### Response Format

```tsx
{
  chainId: `0x14a34`
  address: `0x...`
  expiry: 1727824386
  permissions: [
    {
      type: 'contract-call',
      data: {
        address: '0x2E65BAfA07238666c3b239E94F32DaD3cDD6498D', // sample donut contract address
        abi: [
          {
            inputs: [{ internalType: 'uint256', name: 'amount', type: 'uint256' }],
            name: 'purchase',
            outputs: [],
            stateMutability: 'payable',
            type: 'function'
          }
        ],
        functions: [ {
          functionName: 'purchase'
        } ]
      }
    }
  ],
  context: '...'  // Context identifier for the session
}
```

## How to use the permissions

The dApp must call the following two endpoints from the wallet services API to use these permissions.

    1. `https://rpc.walletconnect.org/v1/wallets/prepareCalls` - Accepts an EIP-5792 `wallet_sendCalls` request.
    Responds with the prepared calls (in the case of Appkit Embedded Wallet, an Entrypoint v0.7 user operation), some context, and a signature request.
    2. `https://rpc.walletconnect.org/v1/wallets/sendPreparedCalls` - Accepts prepared calls, a signature, and the context returned from prepareCalls if present. Returns an EIP-5792 calls ID.

### Steps to follow for executing any async action by the dApp backend.

<Frame>
  <img src="/images/assets/smart-sessions.jpg" />
</Frame>

1. Dapp makes the `wallet_prepareCalls` JSON RPC call to the wallet service API. Accepts an EIP-5792 `wallet_sendCalls` request, and returns the prepared calls according to the account's implementation.

   #### Parameter

  <Tabs>

  <Tab title="Parameter">
          ```tsx
          type PrepareCallsParams = [{
          from: `0x${string}`
          chainId: `0x${string}`
          calls: {
              to: `0x${string}`
              data: `0x${string}`
              value: `0x${string}`
          }[];
          capabilities: Record<string, any>
          }]
          ```
  </Tab>
  <Tab title="Example Value">
          ```tsx
          wallet_prepareCalls([{
              from: '0x...',
              chainId: '0x...',
              calls: [{
                  to: '0x...'
                  data: '0x...'
                  value: '0x...'
              }],
              capabilities: {
                  permissions: {
                  context: '...' // Importantly for session keys, wallets will likely need the ERC-7715 (https://eip.tools/eip/7715) permissions context for userOp construction
                  }
              }
          }])
          ```
  </Tab>
  </Tabs>

#### Return value

  <Tabs>
  <Tab title="Return value">
          ```tsx
          type PrepareCallsReturnValue = [{
              preparedCalls: {
                  type: string
                  data: any
                  chainId: `0x${string}`
              }
              signatureRequest: {  
                  hash: `0x${string}`
              }
              context: `0x${string}`
          }]
          ```
  </Tab>
  <Tab title="Return value Example">
          ```tsx
          [{
              preparedCalls: {
                  type: 'user-operation-v07', type
                  data: { // ...userOp
                  sender: '0x...',
                  ...
                  },
                  chainId: '0x01'
              },
              signatureRequest: {  
                  hash: '0x...' // user op hash in our case
              },
              context: '...' // params.capabilities.permissions.context in our case
          }]
          ```
  </Tab>
  </Tabs>

2. App developers are expected to Sign the `signatureRequest.hash` returned from `wallet_prepareCalls` call using the dApp key (secp256k1 or secp256r1)

3. dApps makes the `wallet_sendPreparedCalls` JSON RPC call to wallet service API. The RPC accepts the prepared response from `wallet_prepareCalls` request along with a signature, and returns an [EIP-5792](https://eip.tools/eip/5792) call bundle ID.

## Examples dApp

<Frame>
  <img src="/images/assets/tictactoe.jpg" />
</Frame>

- Tic Tac Toe | [Demo](https://smart-sessions-demo.reown.com/demo/tictactoe) | [Video](https://x.com/cyberdrk/status/1830109996841054208)
- Dollar Cost Average | [Demo](https://smart-sessions-demo.reown.com/demo/dca) | [Explanation](https://x.com/lukaisailovic/status/1871571013319684274) | [Video](https://x.com/cyberdrk/status/1854148190842610124)
- [Github examples repository](https://github.com/reown-com/web-examples/tree/main/advanced/dapps/smart-sessions-demo)

## Reference

- ERC-7715: Grant Permissions from Wallets | https://eip.tools/eip/7715
- EIP-5792: Wallet Call API | https://eip.tools/eip/5792
- ERC-4337 Entry Point | https://github.com/ethereum/ercs/blob/master/ERCS/erc-4337.md#entrypoint-definition

## Currently supported Permission types

#### ContractCallPermission

    ```jsx
    export enum ParamOperator {
      EQUAL = 'EQUAL',
      GREATER_THAN = 'GREATER_THAN',
      LESS_THAN = 'LESS_THAN'
    }

    export enum Operation {
      Call = 'Call',
      DelegateCall = 'DelegateCall'
    }

    export type ArgumentCondition = {
      operator: ParamOperator
      value: `0x${string}`
    }

    export type FunctionPermission = {
      functionName: string
      args?: ArgumentCondition[]
      valueLimit?: `0x${string}`
      operation?: Operation
    }
    export type ContractCallPermission = {
      type: 'contract-call'
      data: {
        address: `0x${string}`
        abi: Record<string, unknown>[]
        functions: FunctionPermission[]
      }
    }
    ```
</file>

<file path="snippets/appkit/shared/socials.mdx">
To allow users to authenticate using their email or social accounts, you need to configure the `features` parameter in the `createAppKit` function.

<Tabs>
<Tab title="Wagmi">

```ts {6-20}
const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata,
  features: {
    email: true, // default to true
    socials: [
      "google",
      "x",
      "github",
      "discord",
      "apple",
      "facebook",
      "farcaster",
    ],
    emailShowWallets: true, // default to true
  },
  allWallets: "SHOW", // default to SHOW
});
```

</Tab>
<Tab title="Ethers">

```ts {6-20}
const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata,
  features: {
    email: true, // default to true
    socials: [
      "google",
      "x",
      "github",
      "discord",
      "apple",
      "facebook",
      "farcaster",
    ],
    emailShowWallets: true, // default to true
  },
  allWallets: "SHOW", // default to SHOW
});
```

<Note>

AppKit with ethers v5 does not support the `auth` parameter and social logins. If you're using ethers v5, please consider upgrading to ethers v6 following this [ethers migration guide](https://docs.ethers.org/v6/migrating/) and [AppKit Docs](https://docs.walletconnect.com/appkit/overview)
</Note>

</Tab>

<Tab title="Solana">

```ts {6-20}
const modal = createAppKit({
  adapters: [solanaWeb3JsAdapter],
  projectId,
  networks: [solana, solanaTestnet, solanaDevnet],
  metadata,
  features: {
    email: true, // default to true
    socials: [
      "google",
      "x",
      "discord",
      "farcaster",
      "github",
      "apple",
      "facebook",
    ],
    emailShowWallets: true, // default to true
  },
  allWallets: "SHOW", // default to SHOW
});
```

</Tab>
</Tabs>

## Options

- **_email [boolean]_** : This boolean defines whether you want to enable email login. Default `true`
- **_socials [array]_** : This array contains the list of social platforms that you want to enable for user authentication. The platforms in the example include Google, X, GitHub, Discord, Apple, Facebook and Farcaster. The default value of `undefined` displays everything. Set it to `false` to disable this feature. You can also pass an empty array to disable it.
- **_emailShowWallets [boolean]_** : This boolean defines whether you want to show the wallet options on the first connect screen. If this is false and `socials` are enabled, it will show a button that directs you to a new screen displaying the wallet options. Default `true`

## User flow

1. Users will be able to connect to you application by simply using an email address. AppKit will send to them a One Time Password (OTP) to copy and paste in the modal, which will help to
   verify the user's authenticity. This will create a non-custodial wallet for your user which will be available in any application that integrates AppKit and email login.

2. Eventually the user can optionally choose to move from a non-custodial wallet to a self-custodial one by pressing "Upgrade Wallet" on AppKit.
   This will open the _([WalletConnect secure website](https://secure.walletconnect.com/dashboard))_ that will walk your user through the upgrading process.

## UI Variants

AppKit SDK offers multiple UI variants to customize the user experience for the authentication process.

By configuring the `emailShowWallets` option in the `features` parameter, you can control the initial connect screen behavior:

- **`emailShowWallets: true`**: When this option is enabled, the initial connect screen will display the available wallet options directly to the user. This allows users to choose their preferred wallet immediately.

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/modal_wallets.webp" />
</Frame>

- **`emailShowWallets: false`**: If this option is disabled, the initial connect screen will show a button instead. When the user clicks this button, they will be directed to a new screen that lists all the available wallet options. This can help simplify the initial interface and reduce visual clutter.

<Frame>
  <img height="400" width="300"src="/images/w3m/auth/modal_no_wallets.webp" />
</Frame>

By configuring the `socials` option in the `features` parameter, you can control the amount of social providers you want to show on the connect screen:

- **`socials: ['google']`**: When you only set one social provider, it will give you a button with `connect with provider.

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/modal_one_social.webp" />
</Frame>

- **`socials: ['google', 'discord']`**: When you set 2 social provider, it will give you 2 buttons next to each other with the logo of the social provider

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/modal_two_social.webp" />
</Frame>

- **` socials: ['google', 'x', 'discord', 'apple', 'github']`**: When you set more than 2 social providers, the first provider in the array will get a button with `connect with provider`. The other providers will get a button with the logo of the social provider next to each other.

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/modal_wallets.webp" />
</Frame>

- **`socials: []` or `socials: false`**: When you want to disable social logins.

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/modal_wallets_nosocial.webp" />
</Frame>

- **` email: false`**: When you want to disable email login.

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/modal_wallets_noemail.webp" />
</Frame>

By configuring the `allWallets` option inside the `createAppKit` function, you can control whether if and when you want to display all wallets.

- **`allWallets: 'HIDE'`**: When you do not want to display all wallets.

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/allWallets_Hide.png" />
</Frame>

- **`allWallets: 'SHOW'`**: When you want to display all wallets.

<Frame>
  <img height="400" width="300" src="/images/w3m/auth/allWallets_Show.png" />
</Frame>

- **`allWallets: 'ONLY_MOBILE'`**: When you want to display all wallets only on a mobile device.
</file>

<file path="snippets/appkit/shared/sponsored-transactions.mdx">
Sponsored transactions is an umbrella term for multiple methods of utilizing
[ERC 7677](https://eips.ethereum.org/EIPS/eip-7677) paymasters. There are 2
types of paymasters that AppKit supports:
- ERC 20 Paymasters
- Verifying Paymasters

This approach simplifies blockchain interactions by enabling users to perform
actions without directly handling transaction fees, which are instead paid by
the dApp. This concept is particularly beneficial for attracting new users, as
it removes the need to understand complex wallet mechanics or hold
cryptocurrency for gas fees, making the overall experience more intuitive and
accessible.

By absorbing these costs, dApps can offer a smoother onboarding experience.

## ERC 20 Paymasters

ERC 20 paymasters allow end users (smart account wallets) to cover transaction fees without
using a network's native gas token. In essence, this gives the ability to 
cover transaction fees using ERC 20 tokens like USDC.

## Verifying Paymasters 

Verifying Paymasters are more involved, in that they are typically used
alongside some policies that determine whether or not a transaction's 
entire gas fee will be covered by the paymaster. For example, only sponsor
transactions that interact with a specific smart account, accessing a particular
method. 

### Using A Paymaster URL

Using a paymaster as a dapp involves leveraging the `capabilities`
field present in [EIP 5792](https://eips.ethereum.org/EIPS/eip-5792) calls.
Setting a field like so:

```ts
sendCalls({
  calls: ...callsToSend,
  capabilities: {
    paymasterService: {
      url: paymasterServiceUrl,
      context?: {
        // Any additional context
      }
    }
  }
})
```

Where `calls` is an array of 5792 calls to send, `paymasterServiceUrl` is a
string containing the paymaster URL and `context` is an optional configuration object for the paymaster.

The `context` field is paymaster specific and it might be required depending on the Paymaster implementation.

<Note>
Naturally, since interacting with paymasters requires using `sendCalls` as
opposed to `writeContractAsync` or similar, this will require code changes. 

A general guide on adapting existing code can be found
[here](/appkit/recipes/switching-to-send-calls)
</Note>

---

As a Dapp, that is all that is required to take advantage of verifying
paymasters. The rest would be handled wallet side. If the calls match the
criteria set in the paymaster's policy, then the calls' gas would be sponsored.
However, if it does not, then the transaction would be cancelled. 

Example implementation can be found [here](https://github.com/reown-com/appkit/blob/main/apps/laboratory/src/components/Wagmi/WagmiSendCallsWithPaymasterServiceTest.tsx#L137). 


### A Note on ERC20 Paymaster integration

As of right now, ERC20 paymasters would require to provide a context on the tokens to use for gas payment.
How to get this context is not yet standardized and is up to the dapp to integrate with their provider in order to fetch available tokens
and other required implementation-specific context data.

### A Note on Wallets 

As of right now, not many smart account wallets support paymasters, however
AppKit's embedded smart account covers full compatibility with ERC7677 paymasters.

### A Note on Paymasters 

Reown is developing a paymaster service (currently in beta) which will allow
very flexible policy management, reducing the need for writing complex code to
verify whether or not a sponsorship should go through.

Read more about it [here](../../../cloud/paymaster).
</file>

<file path="snippets/appkit/shared/swaps.mdx">
The Swap feature allows users to exchange one cryptocurrency for another directly within the AppKit modal.
This feature is designed to provide a seamless and efficient swapping experience, leveraging our collaboration with [1inch](https://1inch.io/) as the swap provider.

## Availability

- **Requirement**: The Swap feature is available only to users who log in via email or social login. This is consistent with other wallet features such as sending tokens.
- **Transaction Fee**: Reown charges a 0.85% transaction fee on all swaps.
- **Supported Tokens**: The tokens available for swapping are limited to those supported by 1Inch. Note that the availability of tokens may vary depending on the network.
- **Network Availability**: The Swap feature is not available on Sepolia or other testnets at this time.

## How to Use

1. **Connect**: Ensure you are logged in via email or social login.
2. **Access Swap**: Navigate to the Swap feature within the account view.
3. **Select Tokens**: Choose the tokens you wish to swap from the available options.
4. **Type amount**: Enter your desired swap values. You can use the Max button to swap your all tokens or enter any specific number.
5. **See swap details**: Once you type amount value. You'll see the available quote details as received amount, network fee, maximum slippage, or price impact. 
6. **Confirm Swap**: Review the swap details, including the transaction fee, and confirm the swap.

## Integration

The Swaps feature is enabled by default, so no additional configuration is required. 

If you prefer to disable it, set the `swaps` flag to `false` in the configuration of the `createAppKit` function.

```ts {7}
const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    swaps: false // Optional - true by default
  }
})
```
</file>

<file path="snippets/appkit/shared/theming.mdx">
The theme for the AppKit integration in your dApp can be fully customized. Below are some examples:

- [**Wormfare**](https://dashboard.wormfare.com/purchase)

## ThemeMode

By default `themeMode` option will be set to user system settings 'light' or 'dark'. But you can override it like this:

```ts
createAppKit({
  //...
  themeMode: "light",
});
```

## themeVariables

By default `themeVariables` are undefined. You can set them like this:

```ts
createAppKit({
  //...
  themeVariables: {
    "--w3m-color-mix": "#00BB7F",
    "--w3m-color-mix-strength": 40,
  },
});
```

The following list shows the theme variables you can override:

| Variable                     | Description                                                  | Type     |
| ---------------------------- | ------------------------------------------------------------ | -------- |
| `--w3m-font-family`          | Base font family                                             | `string` |
| `--w3m-accent`               | Color used for buttons, icons, labels, etc.                  | `string` |
| `--w3m-color-mix`            | The color that blends in with the default colors             | `string` |
| `--w3m-color-mix-strength`   | The percentage on how much "--w3m-color-mix" should blend in | `number` |
| `--w3m-font-size-master`     | The base pixel size for fonts.                               | `string` |
| `--w3m-border-radius-master` | The base border radius in pixels.                            | `string` |
| `--w3m-z-index`              | The z-index of the modal.                                    | `number` |
</file>

<file path="snippets/appkit/vue/bitcoin/about/implementation.mdx">
import BitcoinProviderInterface from "/snippets/appkit/shared/bitcoin-provider.mdx";

AppKit Bitcoin provides a set of React components and hooks to easily connect Bitcoin wallets with your application.

On top of your app set up the following configuration, making sure that all functions are called outside any React component to avoid unwanted rerenders.

In your `App.vue` file set up the following configuration.

```tsx
<script setup lang="ts">

import { createAppKit } from '@reown/appkit/react'
import { BitcoinAdapter } from '@reown/appkit-adapter-bitcoin'
import { bitcoin } from '@reown/appkit/networks'

// 1. Get projectId from https://cloud.reown.com
const projectId = 'YOUR_PROJECT_ID'

// 2. Set the networks
const networks = [bitcoin]

// 3. Set up Bitcoin Adapter
const bitcoinAdapter = new BitcoinAdapter({
  projectId
})

// 4. Create a metadata object - optional
const metadata = {
  name: 'AppKit',
  description: 'AppKit Bitcoin Example',
  url: 'https://example.com', // origin must match your domain & subdomain
  icons: ['https://avatars.githubusercontent.com/u/179229932']
}

// 5. Create modal
createAppKit({
  adapters: [bitcoinAdapter],
  networks,
  metadata,
  projectId,
  features: {
    analytics: true // Optional - defaults to your Cloud configuration,
    email: false,
    socials: []
  }
})
</script>

<template> // Rest of your app ... </template>
```

<BitcoinProviderInterface />
</file>

<file path="snippets/appkit/vue/bitcoin/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**composables**](../../core/composables.mdx#useAppKit).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```tsx
<template>
  <appkit-button />
</template>
```
</file>

<file path="snippets/appkit/vue/core/open.mdx">
You can also select the modal's view when calling the `open` function

```ts
open({ view: "Account" });

// to connect and show multi wallets view
open({ view: "Connect" });

// to connect and show only solana wallets
open({ view: "Connect", namespace: "solana" });

// to connect and show only bitcoin wallets
open({ view: "Connect", namespace: "bip122" });

// to connect and show only ethereum wallets
open({ view: "Connect", namespace: "eip155" });

// to open swap with arguments
open({
  view: 'Swap',
  arguments: {
    amount: '321.123',
    fromToken: 'USDC',
    toToken: 'ETH'
  }
})
```

List of views you can select

<Table
  headers={["Variable", "Description"]}
  data={[
    {
      variable: { code: "Connect" },
      description:
        "Principal view of the modal - default view when disconnected. A `namespace` can be selected to connect to a specific network (solana, bip122 or eip155)",
    },
    {
      variable: { code: "Account" },
      description: "User profile - default view when connected",
    },
    {
      variable: { code: "AllWallets" },
      description: "Shows the list of all available wallets",
    },
    {
      variable: { code: "Networks" },
      description:
        "List of available networks - you can select and target a specific network before connecting",
    },
    {
      variable: { code: "WhatIsANetwork" },
      description: '"What is a network" onboarding view',
    },
    {
      variable: { code: "WhatIsAWallet" },
      description: '"What is a wallet" onboarding view',
    },
    {
      variable: { code: "OnRampProviders" },
      description: "On-Ramp main view",
    },
    {
      variable: { code: "Swap" },
      description: "Swap main view",
    },
  ]}
/>
</file>

<file path="snippets/appkit/vue/ethers/about/implementation.mdx">
In your `App.vue` file set up the following configuration.

```html
<script setup lang="ts">
  import { createAppKit, useAppKit } from "@reown/appkit/vue";
  import { EthersAdapter } from "@reown/appkit-adapter-ethers";
  import { mainnet, arbitrum } from "@reown/appkit/networks";

  // 1. Get projectId from https://cloud.reown.com
  const projectId = "YOUR_PROJECT_ID";

  // 2. Create your application's metadata object
  const metadata = {
    name: "My Website",
    description: "My Website description",
    url: "https://mywebsite.com", // url must match your domain & subdomain
    icons: ["https://avatars.mywebsite.com/"],
  };

  // 3. Create a AppKit instance
  createAppKit({
    adapters: [new EthersAdapter()],
    networks: [mainnet, arbitrum],
    metadata,
    projectId,
    features: {
      analytics: true, // Optional - defaults to your Cloud configuration
    },
  });

  // 4. Use modal composable
  const modal = useAppKit();
</script>

<template> // Rest of your app ... </template>
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/vue/ethers/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with the AppKit [**composables**](../../core/composables.mdx#useAppKit).

<Tabs>
<Tab title="Web Components">

```html
<template>
  <appkit-button />
</template>
```

Learn more about the AppKit web components [here](../../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="Composables">

You can trigger the modal by calling the `open` method from `useAppKit` composable.

```html
<template>
  <button @click="modal.open()">Open Connect Modal</button>
  <button @click="modal.open({ view: 'Networks' })">Open Network Modal</button>
</template>
```

Learn more about the AppKit composables [here](../../core/composables)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/vue/ethers/composables.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/vue";

const { address, status, isConnected } = useAppKitAccount();
```

### switchNetwork

```tsx
import { createAppKit } from "@reown/appkit/vue";
import { mainnet, arbitrum, polygon } from "@reown/appkit/networks";

const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    analytics: true,
  },
});

modal.switchNetwork(polygon);
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { BrowserProvider } from "ethers";
import { useAppKitProvider } from "@reown/appkit/vue";

function Components() {
  const { walletProvider } = useAppKitProvider("eip155");

  async function onSignMessage() {
    const provider = new BrowserProvider(walletProvider);
    const signer = await provider.getSigner();
    const signature = await signer?.signMessage("Hello AppKit Ethers");
    console.log(signature);
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

### getError

```ts
function Components() {
  const error = modal.getError();
  //...
}
```

<Card
  title="Learn More About Ethers"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/vue/ethers5/composables.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/vue";

const { address, status, isConnected } = useAppKitAccount();
```

### switchNetwork

```tsx
import { createAppKit } from "@reown/appkit/vue";
import { mainnet, arbitrum, polygon } from "@reown/appkit/networks";

const modal = createAppKit({
  adapters: [wagmiAdapter],
  projectId,
  networks: [mainnet, arbitrum],
  metadata: metadata,
  features: {
    analytics: true,
  },
});

modal.switchNetwork(polygon);
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import {
  useAppKitAccount,
  useAppKitProvider,
  useAppKitNetwork,
} from "@reown/appkit/vue";
import { ethers } from "ethers";
import { useAppKitProvider } from "@reown/appkit/vue";

function Components() {
  const { walletProvider } = useAppKitProvider("eip155");
  const { address } = useAppKitAccount();
  const { chainId } = useAppKitNetwork();

  async function onSignMessage() {
    const provider = new ethers.providers.Web3Provider(walletProvider, chainId);
    const signer = provider.getSigner(address);
    const signature = await signer?.signMessage("Hello AppKit Ethers");
    console.log(signature);
  }

  return <button onClick={() => onSignMessage()}>Sign Message</button>;
}
```

### getError

```ts
function Components() {
  const error = modal.getError();
  //...
}
```

<Card
  title="Learn More About Ethers"
  href="https://docs.ethers.org/v6/getting-started/#starting-blockchain"
/>
</file>

<file path="snippets/appkit/vue/ethers5/implementation.mdx">
In your `App.vue` file set up the following configuration.

```html
<script setup lang="ts">
  import { createAppKit, useAppKit } from "@reown/appkit/vue";
  import { Ethers5Adapter } from "@reown/appkit-adapter-ethers5";
  import { mainnet, arbitrum } from "@reown/appkit/networks";

  // 1. Get projectId at https://cloud.reown.com
  const projectId = "YOUR_PROJECT_ID";

  function getBlockchainApiRpcUrl(chainId) {
    return `https://rpc.walletconnect.org/v1/?chainId=eip155:${chainId}&projectId=${projectId}`;
  }

  // 2. Create your application's metadata object
  const metadata = {
    name: "My Website",
    description: "My Website description",
    url: "https://mywebsite.com", // url must match your domain & subdomain
    icons: ["https://avatars.mywebsite.com/"],
  };

  // 3. Create a AppKit instance
  createAppKit({
    adapters: [new Ethers5Adapter()],
    networks: [mainnet, arbitrum],
    projectId,
    features: {
      analytics: true, // Optional - defaults to your Cloud configuration
    },
  });

  // 4. Use modal composable
  const modal = useAppKit();
</script>

<template> // Rest of your app ... </template>
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/vue/solana/composables.mdx">
### useAppKitAccount

Hook that returns the client's information.

```tsx
import { useAppKitAccount } from "@reown/appkit/vue";

function Components() {
  const { address, caipAddress, isConnected } = useAppKitAccount();

  //...
}
```

### useAppKitProvider

Hook that returns the `walletProvider` and the `WalletProviderType`.

```tsx
import { useAppKitAccount, useAppKitProvider } from "@reown/appkit/vue";
import type { Provider } from "@reown/appkit-adapter-solana";

function SignMessage() {
  // 0. Get account and provider
  const { address } = useAppKitAccount();
  const { walletProvider } = useAppKitProvider<Provider>("solana");

  // 1. Create a function to sign a message
  async function onSignMessage() {
    try {
      if (!walletProvider || !address) {
        throw Error("user is disconnected");
      }

      // 2. Encode message and sign it
      const encodedMessage = new TextEncoder().encode("Hello from AppKit");
      const signature = await walletProvider.signMessage(encodedMessage);

      console.log(signature);
    } catch (err) {
      // Handle Error Here
    }
  }

  // 3. Create a button to trigger the function
  return <button onClick={onSignMessage}>Sign Message</button>;
}
```

## useAppKitConnection

Hook that returns the connection object. More info about [Connection Class](https://solana-labs.github.io/solana-web3.js/classes/Connection.html)

```tsx
import { useAppKitConnection } from '@reown/appkit-adapter-solana/vue'

...

const { connection } = useAppKitConnection()
```
</file>

<file path="snippets/appkit/vue/solana/implementation.mdx">
In your `App.vue` file set up the following configuration.

```html
<script setup lang="ts">
  import { createAppKit, useAppKit } from "@reown/appkit-solana/vue";
  import {
    PhantomWalletAdapter,
    SolflareWalletAdapter,
  } from "@solana/wallet-adapter-wallets";
  import { SolanaAdapter } from "@reown/appkit-adapter-solana/vue";
  import { solana, solanaTestnet, solanaDevnet } from "@reown/appkit/networks";

  // 1. Get projectId from https://cloud.reown.com
  const projectId = "YOUR_PROJECT_ID";

  // 2. Set up metadata
  const metadata = {
    name: "AppKit",
    description: "AppKit Solana Example",
    url: "https://example.com", // origin must match your domain & subdomain
    icons: ["https://avatars.githubusercontent.com/u/179229932"],
  };

  // 3. Set up Solana Adapter
  const solanaWeb3JsAdapter = new SolanaAdapter({
    wallets: [new PhantomWalletAdapter(), new SolflareWalletAdapter()],
  });

  // 4. Create modal
  createAppKit({
    adapters: [solanaWeb3JsAdapter],
    metadata,
    networks: [solana, solanaTestnet, solanaDevnet],
    projectId,
    wallets: [new PhantomWalletAdapter(), new SolflareWalletAdapter()],
  });
</script>

<template> // Rest of your app ... </template>
```

<Warning>
Make sure that the `url` from the `metadata` matches your domain and subdomain. This will later be used by the [Verify API](../../../cloud/verify) to tell wallets if your application has been verified or not.
</Warning>
</file>

<file path="snippets/appkit/vue/solana/programs.mdx">
[@Solana/web3.js](https://solana.com/docs/clients/javascript) library allows for seamless interaction with wallets and smart contracts on the Solana blockchain.

For a practical example of how it works, you can refer to our [lab dApp](https://appkit-lab.reown.com/library/solana/).

```tsx
import { ref } from 'vue';
import {
  SystemProgram,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  LAMPORTS_PER_SOL
} from '@solana/web3.js';
import { useAppKitAccount, useAppKitProvider } from '@reown/appkit/vue'
import { useAppKitConnection, type Provider } from '@reown/appkit-adapter-solana/vue'

export default {
  setup() {
    const counterMessage = ref('');
    const { address } = useAppKitAccount();
    const { connection } = useAppKitConnection()
    const { walletProvider } = useAppKitProvider<Provider>('solana')

    function deserializeCounterAccount(data) {
      if (data?.byteLength !== 8) {
        throw Error('Need exactly 8 bytes to deserialize counter');
      }

      return {
        count: Number(data[0])
      };
    }

    async function onIncrementCounter() {
      try {
        const PROGRAM_ID = new PublicKey('Cb5aXEgXptKqHHWLifvXu5BeAuVLjojQ5ypq6CfQj1hy');

        const counterKeypair = Keypair.generate();
        const counter = counterKeypair.publicKey;

        const balance = await connection.getBalance(walletProvider.publicKey);
        if (balance < LAMPORTS_PER_SOL / 100) {
          throw Error('Not enough SOL in wallet');
        }

        const COUNTER_ACCOUNT_SIZE = 8;
        const allocIx = SystemProgram.createAccount({
          fromPubkey: walletProvider.publicKey,
          newAccountPubkey: counter,
          lamports: await connection.getMinimumBalanceForRentExemption(COUNTER_ACCOUNT_SIZE),
          space: COUNTER_ACCOUNT_SIZE,
          programId: PROGRAM_ID
        });

        const incrementIx = new TransactionInstruction({
          programId: PROGRAM_ID,
          keys: [
            {
              pubkey: counter,
              isSigner: false,
              isWritable: true
            }
          ],
          data: Buffer.from([0x0])
        });

        const tx = new Transaction().add(allocIx).add(incrementIx);

        tx.feePayer = walletProvider.publicKey;
        tx.recentBlockhash = (await connection.getLatestBlockhash('confirmed')).blockhash;

        await walletProvider.signAndSendTransaction(tx, [counterKeypair]);

        const counterAccountInfo = await connection.getAccountInfo(counter, {
          commitment: 'confirmed'
        });

        if (!counterAccountInfo) {
          throw new Error('Expected counter account to have been created');
        }

        const counterAccount = deserializeCounterAccount(counterAccountInfo?.data);

        if (counterAccount.count !== 1) {
          throw new Error('Expected count to have been 1');
        }

        counterMessage.value = `[alloc+increment] count is: ${counterAccount.count}`;
      } catch (error) {
        console.error(error);
        counterMessage.value = `Error: ${error.message}`;
      }
    }

    return {
      onIncrementCounter,
      counterMessage
    };
  }
};
```
</file>

<file path="snippets/appkit/vue/solana/triggermodal.mdx">
To open AppKit you can use our [**web component**](../core/components) or build your own button with the AppKit [**composables**](../core/composables.mdx#useAppKit).

<Tabs>
<Tab title="Web Components">

```html
<template>
  <appkit-button />
</template>
```

Learn more about the Appkit web components [here](../core/components)

<Info>
Web components are global html elements that don't require importing.
</Info>

</Tab>
<Tab title="Composables">

You can trigger the modal by calling the `open` method from `useAppKit` composable.

```html
<template>
  <button @click="modal.open()">Open Connect Modal</button>
  <button @click="modal.open({ view: 'Networks' })">Open Network Modal</button>
</template>
```

Learn more about the AppKit composables [here](../core/composables)

</Tab>
</Tabs>
</file>

<file path="snippets/appkit/vue/wagmi/about/implementation.mdx">
For a quick integration, you can use the `createAppKit` function with a unified configuration. This automatically applies the predefined configurations for different adapters like Wagmi, Ethers, or Solana, so you no longer need to manually configure each one individually. Simply pass the common parameters such as `projectId`, `chains`, `metadata`, etc., and the function will handle the adapter-specific configurations under the hood.

This includes WalletConnect, Coinbase and Injected connectors, and the [Blockchain API](../../../../cloud/blockchain-api) as a [transport](https://wagmi.sh/core/api/createConfig#transports)

<Note>
If you're using Nuxt, you can set wagmi's `ssr` option to true and call the `reconnect` function after your application mounts.
</Note>

In your `App.vue` file set up the following configuration

```html
<script lang="ts" setup>
  import { createAppKit } from '@reown/appkit/vue'
  import { arbitrum, mainnet, type AppKitNetwork } from '@reown/appkit/networks'
  import { WagmiAdapter } from '@reown/appkit-adapter-wagmi'

  // 1. Get projectId from https://cloud.reown.com
  const projectId = 'YOUR_PROJECT_ID'

  // 2. Create a metadata object
  const metadata = {
    name: 'AppKit',
    description: 'AppKit Example',
    url: 'https://example.com', // origin must match your domain & subdomain
    icons: ['https://avatars.githubusercontent.com/u/179229932']
  }

  // 3. Set the networks
  const networks: [AppKitNetwork, ...AppKitNetwork[]] = [mainnet, polygon, base]

  // 4. Create Wagmi Adapter
  const wagmiAdapter = new WagmiAdapter({
    networks,
    projectId
  })

  // 5. Create the modal
  const modal = createAppKit({
    adapters: [wagmiAdapter],
    networks,
    projectId,
    metadata,
    features: {
      analytics: true // Optional - defaults to your Cloud configuration
    }
  })
</script>

<template> // Rest of your app ... </template>
```

## Importing networks

Reown AppKit use [Viem](https://viem.sh/) networks under the hood, which provide a wide variety of networks for EVM chains. You can find all the networks supported by Viem within the `@reown/appkit/networks` path.

```js {2}
import { createAppKit } from '@reown/appkit/vue'
import { mainnet, arbitrum, base, scroll, polygon } from '@reown/appkit/networks'
```

<Note>
Looking to add a custom network? Check out the [custom networks](../../core/custom-networks) section.
</Note>
</file>

<file path="snippets/appkit/vue/wagmi/about/triggermodal.mdx">
To open AppKit you can use our [**web component**](../../core/components) or build your own button with AppKit [**composables**](../../core/composables.mdx#useAppKit).
In this example we are going to use the `<appkit-button>` component.

Web components are global html elements that don't require importing.

```html
<template>
  <appkit-button />
</template>
```

Learn more about the AppKit web components [here](../../core/components)
</file>

<file path="snippets/appkit/vue/wagmi/composables.mdx">
You can use [Wagmi actions](https://wagmi.sh/core/actions/getAccount) to sign messages, interact with smart contracts, and much more.

### getAccount

Action for accessing account data and connection status.

```tsx
import { getAccount } from "@wagmi/core";

const account = getAccount();
```

### signMessage

Action for signing messages with connected account.

```ts
import { signMessage } from "@wagmi/core";

const signature = await signMessage({
  message: "gm wagmi frens",
});
```

<Card title="Learn More" href="https://wagmi.sh/core/actions/readContract" />
</file>

<file path="snippets/cloud/analytics.mdx">
---
title: Analytics
---

## Accessing Reown Analytics

To access Reown Analytics and explore these insightful features, follow these simple steps:

1. Log In to your Cloud Account [here](https://cloud.reown.com/sign-in).
2. Click on your Project.
3. Click the Analytics Tab.
4. Select the Analytics section of your choice.

By following these steps, you can easily access and leverage Reown Analytics to track your project's progress and make informed decisions to take your project to the next level.

## Understanding Reown Analytics

Reown Cloud now includes Analytics to help you better understand your project's performance. Let's break down some terms and explore the new analytics sections in a simple manner.

## Analytics Sections

<Info>
**Definitions**

Refer to [Definitions](#definitions) for the meaning of terms used in Reown Analytics.

</Info>

### Relay

#### Overview - Wallet/Dapp Sessions

Displays the total count of established connections between your project and Reown SDK.

<Frame>
  <img src="/images/analytics/relay/1.png" />
</Frame>

#### Overview - Clients

Indicates the total number of connections established from clients (device or browser if connecting on the web).

<Frame>
  <img src="/images/analytics/relay/2.png" />
</Frame>

#### Overview - Messages

Shows the total messages exchanged between the configured Reown SDK and the Relay Server.

<Frame>
  <img src="/images/analytics/relay/3.png" />
</Frame>

#### Wallet/Dapp Sessions

Shows the daily trend of established sessions over a 30 day period.

<Frame>
  <img src="/images/analytics/relay/4.png" />
</Frame>

#### Clients

Shows the daily trend of client connections over a 30 day period.

<Frame>
  <img src="/images/analytics/relay/5.png" />
</Frame>

#### All Messages

Shows the daily trend of messages connections over a 30 day period.

<Frame>
  <img src="/images/analytics/relay/6.png" />
</Frame>

#### Projects

Lists the top ranked wallets/Dapps connected to your project.

<Frame>
  <img src="/images/analytics/relay/7.png" />
</Frame>

#### Countries and Continents

Provides insights into user connections by displaying the countries and continents with the most connections.

<Frame>
  <img src="/images/analytics/relay/8.png" />
</Frame>

Learn more about the Relay [here](./relay)

### RPC

#### Overview RPC Requests

Represents the total count of remote procedure calls (RPC) made to the blockchain API for the last 30 days.

<Frame>
  <img src="/images/analytics/rpc/1.png" />
</Frame>

#### RPC Request Volumes

Displays the daily trend of API requests made to the blockchain API.

<Frame>
  <img src="/images/analytics/rpc/2.png" />
</Frame>

#### RPC Chain

Shows the top chain requests made by Chain ID.

<Frame>
  <img src="/images/analytics/rpc/3.png" />
</Frame>

#### RPC Method

Highlights the top-ranked methods called by your users.

<Frame>
  <img src="/images/analytics/rpc/4.png" />
</Frame>

#### Countries

Illustrates user connections by displaying the countries with the most connections.

<Frame>
  <img src="/images/analytics/rpc/5.png" />
</Frame>

Learn more about the Blockchain API [here](./blockchain-api)

### AppKit

#### Avg. Daily Visitors

Indicates the daily average of unique visitors to your app’s AppKit.

<Frame>
  <img src="/images/analytics/web3modal/1.png" />
</Frame>

#### Avg. Daily Sessions

Indicates the daily average of sessions.

<Frame>
  <img src="/images/analytics/web3modal/2.png" />
</Frame>

#### Avg. Daily Connections

Indicates the daily average of connections made through AppKit.

<Frame>
  <img src="/images/analytics/web3modal/3.png" />
</Frame>

#### Sessions

Indicates the total count of sessions.

<Frame>
  <img src="/images/analytics/web3modal/4.png" />
</Frame>

#### Successful connections

Total count of all connections made between a wallet and your app.

<Frame>
  <img src="/images/analytics/web3modal/5.png" />
</Frame>

#### Countries

Ranks the top countries with the highest user connections.

<Frame>
  <img src="/images/analytics/web3modal/6.png" />
</Frame>

#### Wallets Breakdown

Ranks the top wallets that your users are connecting from.

<Frame>
  <img src="/images/analytics/web3modal/7.png" />
</Frame>

#### All Events

This table and chart shows the count of various events that are triggered as the users interact with AppKit.

<Frame>
  <img src="/images/analytics/web3modal/8.png" />
</Frame>

#### Platform Sessions

Provides a breakdown of sessions that have been created by device platform.

<Frame>
  <img src="/images/analytics/web3modal/9.png" />
</Frame>

#### Visitors

Shows the daily trend of unique visitors to your app’s AppKit.

<Frame>
  <img src="/images/analytics/web3modal/10.png" />
</Frame>

#### Sessions

Shows the daily trend of sessions created when the user signs a message with their connected wallet.

<Frame>
  <img src="/images/analytics/web3modal/11.png" />
</Frame>

#### Successful connections

Shows the daily trend of successful connections to your app.

<Frame>
  <img src="/images/analytics/web3modal/12.png" />
</Frame>

### Web3Inbox

#### Subscribers - All Time

Total count of all subscribers to your project.

<Frame>
  <img src="/images/analytics/web3inbox/1.png" />
</Frame>

#### Notifications - All Time

Total count of all notifications sent from your project.

<Frame>
  <img src="/images/analytics/web3inbox/2.png" />
</Frame>

#### Subscribers

Daily trend chart illustrating the growth of subscribers.

<Frame>
  <img src="/images/analytics/web3inbox/3.png" />
</Frame>

#### Notifications

Daily trend chart of total notifications received by your subscribers.

<Frame>
  <img src="/images/analytics/web3inbox/4.png" />
</Frame>

#### Messaged Accounts

Daily trend chart of unique wallets that received the notification.

<Frame>
  <img src="/images/analytics/web3inbox/5.png" />
</Frame>

#### Subscribers by notification type

This table shows the total count of subscribers by notification type over a 30 day period.

<Frame>
  <img src="/images/analytics/web3inbox/6.png" />
</Frame>

### Definitions

Definitions of terms used in Reown Analytics.

| Term               | Description                                                                                                                                                                                                                                                                                                                         |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Relay:Session**  | A session within the context of Relay analytics denotes meaningful user actions, like signing transactions for NFT sales or trades, within a wallet or dapp. It emphasizes core SDK functionality.                                                                                                                                  |
| **AppKit:Session** | A session within the context of AppKit analytics represents the connection established between your project and your user’s device (includes browsers). Sessions are created when the user interacts with AppKit on your app. If user events are tracked within a 30-minute range, they will be considered within the same session. |
| **Message**        | Messages are data exchanges between the Reown SDK and the Relay Server, facilitating communication between your project and connected clients.                                                                                                                                                                                      |
| **Client**         | A client is a device or browser connected to your project.                                                                                                                                                                                                                                                                          |
| **Blockchain API** | The interface that allows your project to interact with the blockchain. Remote Procedure Calls (RPC) are used to request information or execute operations on the blockchain through this API.                                                                                                                                      |
| **Chain ID**       | Chain ID identifies a specific blockchain network. Different blockchain networks, such as Ethereum Mainnet or a testnet, have unique Chain IDs.                                                                                                                                                                                     |
</file>

<file path="snippets/cloud/blockchain-api.mdx">
---
title: Blockchain API
---

The Blockchain API is the RPC service that powers AppKit's blockchain functions such as account balances, ENS resolution, transaction history, and more.

<Note>
Blockchain API is not the same as the WalletConnect protocol. WalletConnect protocol supports wallets on all chains using the [CAIP-25](https://chainagnostic.org/CAIPs/caip-25) standard. We do not accept requests for new chains to be added to our Blockchain API. Please see your SDK's relevant documentation on how to add RPC URLs for chains you want to use that Blockchain API does not.
</Note>

## Features

- AppKit built-in integration
- Multi-chain mainnet and testnets
- HTTP RPC support
- Cloud metrics and reporting
- The Identity API with near-instant ENS resolution
- Transaction history

## Supported Chains

The Blockchain API supports popular chains such as Ethereum, Binance Smart Chain, Solana, and more. See the full list of [supported chains](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md).

## Using the Blockchain API

No config or setup is needed for AppKit integrations. For other usage, see the [Usage](https://github.com/walletconnect/blockchain-api#usage) section.

## Limits

The Blockchain API is free for 2.5 million requests per 30 days. If you wish to increase your limits, please contact sales@reown.com.

## Links

- [Supported chains](https://github.com/WalletConnect/blockchain-api/blob/master/SUPPORTED_CHAINS.md)
- [The Blockchain API GitHub repo](https://github.com/WalletConnect/blockchain-api)
</file>

<file path="snippets/cloud/explorer-submission.mdx">
---
title: Explorer Submission
---

<Note>
**Note**

Submitting a project to the Reown Cloud Explorer is recommended but optional. You can still use Reown services without submitting your project.
However, doing so ensures that your project is listed under [WalletGuide](https://walletguide.walletconnect.network/?utm_source=walletconnect-docs&utm_medium=cloud&utm_campaign=explorer-submission) and [Cloud Explorer API](./explorer.md).
</Note>

## Creating a New Project

- Head over to [cloud.reown.com](https://cloud.reown.com/) and create a new project by clicking the "New Project" button in top right corner of the dashboard.
- Give a suitable name to your project, select whether its an App or Wallet and click the "Create" button. (You can change this later)

  <Frame>
    <img src="/images/cloud/1.png" />
  </Frame>

## Project Details

- Go to the "Explorer" tab and fill in the details of your project.

  <Frame>
    <img src="/images/cloud/2.png" />
  </Frame>

| Field                        | Description                                                                                                             | Required |
|------------------------------|-------------------------------------------------------------------------------------------------------------------------|----------|
| **Name**                     | The name to display in the explorer                                                                                    | Yes      |
| **Description**              | A short description explaining your project (dapp/wallet)                                                              | Yes      |
| **Type**                     | Whether your project is a dapp or a wallet                                                                             | Yes      |
| **Category**                 | Appropriate category for your project. This field is dependent on the type of your project                             | Yes      |
| **Homepage**                 | The URL of your project                                                                                                 | Yes      |
| **Web App**                  | The URL of your web app. This field is only applicable for dapps                                                        | Yes      |
| **Chains**                   | Chains supported by your project                                                                                         | Yes      |
| **Logo**                     | The logo of your project. Further requirements are provided in the explorer submission form                            | Yes      |
| **Testing Instructions**      | Instructions on how to test your Reown Integration                                                                    | Yes      |
| **Download Links**           | Links to download your project (if applicable)                                                                        | No       |
| **Mobile Linking**           | Required for mobile wallets targeting AppKit. Deep Link is recommended over Universal Link                            | No       |
| **Desktop Linking**          | Required for desktop wallets targeting AppKit.                                                                        | No       |
| **Injected Wallet Identifiers** | Required for injected wallets targeting AppKit. RDNS (from EIP-6963 metadata) is recommended over Provider Flags (Legacy) | No       |
| **Metadata**                 | User-facing UI metadata for your project. Only Short Name is required.                                                 | No       |


## Project Submission

- Once you've filled the applicable fields, click the "Submit" button to submit your project for review. Alternatively, you can save your changes and submit later. Additional information will be visible in the modal that appears after clicking the "Submit" button.

  <Frame>
    <img src="/images/cloud/3.png" />
  </Frame>

## How do we test wallets?

In order to offer a great user experience in our APIs and SDKs every Cloud submission goes through a QA process to make sure that the integration of the WalletConnect protocol is working correctly.

The following list details our QA flow and how to reproduce it:

| Test Case | Steps | Expected Results |
|-----------|-------|-----------------|
| **Set Up** | 1. Download the wallet<br/>2. Install the wallet app<br/>3. Sign up for an account with the wallet app<br/>4. Create one or more accounts | 1. N/A<br/>2. The app is installed<br/>3. I have an account<br/>4. I have one or more accounts |
| **Connect to dapp via web browser** | 1. Open the Reown connection page [https://appkit-lab.reown.com/](https://appkit-lab.reown.com/) from a PC<br/>2. Press on the “Connect Wallet” button and select the Reown option.<br/>3. Open the wallet app and use the scan QR option to connect.<br/>4. Accept on the wallet the connection request | 1. The app has been correctly set-up<br/>2. A modal with wallet options is opened<br/>3. A QR code is shown on the website and the wallet is able to scan it.<br/>4. The connection is successfully established. The wallet data is now shown on the website. |
| **Connect to dapp via mobile browser (Deep-link)** | 1. Open [https://appkit-lab.reown.com/](https://appkit-lab.reown.com/) in your mobile device.<br/>2. Select one of the default options (e.g. Wagmi for EVM chains). Press the "Custom Wallet" button from the navbar. Fill in the wallet’s name and its deeplink (Mobile Link) in the “Add a Custom Wallet” form. Press “Add Wallet”. After the website reloads, press the “Connect Wallet” button and select the newly created wallet.<br/>3. Accept the connection request in the wallet application. | 1. N/A<br/>2. A form should show up on the website to fill in the wallet’s data. After the changes are applied, the modal should show the newly created wallet on the main view.<br/>3. The user should be redirected to the wallet application and a modal with a connection request should show up on the wallet application. The wallet should connect successfully. On Android devices, the user should be redirected back to the website after accepting the connection request. |
| **Switch chains - dapp side** | 1. Once the wallet is connected, press on the modal button on the top right of the website.<br/>2. Press the first button of the modal to switch the chain.<br/>3. Select any available chain, close the modal, and press the “Send Transaction” button | 1. A modal with the account information should pop up on the website.<br/>2. A new view with supported chains should show up.<br/>3. The transaction request that pops up on the wallet should show in their information the correct chain that was previously selected. |
| **Switch Chains - wallet side (if supported)** | 1. Check if the wallet supports chain switching. If so, select a different chain from the connected one. | 1. The chain change should be reflected on the website. The first card shows the current chain ID. |
| **Accounts Switching - wallet side** | 1. In the wallet app, switch from one account to another. | 1. The account switch event should be reflected in the modal’s account view on the website. |
| **Disconnect a wallet** | 1. Select the "Disconnect" button from the Wallet App (Ideally, wallets should have a section where users can see all their existing dApp connections and manage/disconnect from dApps in one spot—this is not always true, so if not possible, just skip this).<br/>2. Repeat the above steps and press the "Disconnect" button from the dApp (this should always be available). | 1. The related session should disappear from the dApp and the Wallet App.<br/>2. The related session should disappear from the dApp and the Wallet App. |
| **Verify API** | 1. Open [https://malicious-app-verify-simulation.vercel.app/](https://malicious-app-verify-simulation.vercel.app/)<br/>2. Select a supported chain by the wallet (some wallets don’t support testnets) and press the “Connect” button.<br/>3. Scan with the wallet the generated QR code. | 1. N/A<br/>2. A modal should show up with a QR code to scan.<br/>3. The connection request in the wallet should flag the website as malicious. |


### Chain Specific

The following test cases only apply for wallets supporting a particular set of chains.

<Tabs>
<Tab title="EVM">

| Test Case | Steps | Expected Results |
|-----------|-------|-----------------|
| **Supporting personal_sign** | 1. Connect the wallet.<br/>2. Press the “Sign Message” button.<br/>3. Accept the signature request on the wallet. | 1. N/A<br/>2. A modal should pop up on the wallet app requesting a signature.<br/>3. Once accepted and signed, the hash should show up on the website. |
| **Supporting eth_signTypedData_v4** | 1. Connect the wallet.<br/>2. Press the “Sign Typed Data” button.<br/>3. Accept the signature request on the wallet. | 1. N/A<br/>2. A modal should pop up on the wallet app requesting a signature.<br/>3. Once accepted and signed, the hash should show up on the website. |
| **Supporting eth_sendTransaction** | 1. Connect the wallet.<br/>2. Press the “Send Transaction” button. | 1. N/A<br/>2. A modal should pop up on the wallet app requesting a signature. |


</Tab>

<Tab title="Solana">

| Test Case | Steps | Expected Results |
|-----------|-------|-----------------|
| **Supporting solana_signMessage** | 1. Connect the wallet to [AppKit Lab](https://appkit-lab.reown.com/library/solana)<br/>2. Press the “Sign Message” button.<br/>3. Accept the signature request on the wallet. | 1. N/A<br/>2. A modal should pop up on the wallet app requesting a signature.<br/>3. Once accepted and signed, the hash should show up on the website. |
| **Supporting solana_signTransaction** | 1. Connect the wallet to [AppKit Lab](https://appkit-lab.reown.com/library/solana)<br/>2. Press the “Sign Transaction” button.<br/>3. Accept the signature request on the wallet. | 1. N/A<br/>2. A modal should pop up on the wallet app requesting a signature.<br/>3. Once accepted and signed, the hash should show up on the website. |
| **Supporting v0 Transactions** | 1. Connect the wallet to [AppKit Lab](https://appkit-lab.reown.com/library/solana)<br/>2. Press the “Sign Versioned Transaction” button.<br/>3. Accept the signature request on the wallet. | 1. N/A<br/>2. A modal should pop up on the wallet app requesting a signature.<br/>3. Once accepted and signed, the hash should show up on the website. |


</Tab>
</Tabs>

## What's Next?

Now depending on whether or not your submission met all parameters, you will receive an email from the Reown team with the status of your submission. This change will also be reflected with more directions in the "Explorer" tab of your project.
If your submission was not accepted, you can make the necessary changes and resubmit your project for review. The reason for rejection will be mentioned in the email and in the "Explorer" tab of your project.

In case of any questions, feel free to ask on [Github Discussions](https://github.com/orgs/WalletConnect/discussions/categories/explorer-support)
</file>

<file path="snippets/cloud/relay.mdx">
---
title: Relay
---

## Project ID

The Project ID is consumed through URL parameters.

URL parameters used:

- `projectId`: Your Project ID can be obtained from [cloud.reown.com](https://cloud.reown.com)

Example URL:

`https://relay.walletconnect.com/?projectId=c4f79cc821944d9680842e34466bfbd`

This can be instantiated from the client with the `projectId` in the `SignClient` constructor.

```javascript
import SignClient from '@walletconnect/sign-client'
const signClient = await SignClient.init({
  projectId: 'c4f79cc821944d9680842e34466bfb'
})
```

## Allowlist

To help prevent malicious use of your project ID you are strongly encouraged to set an allowlist of [origins](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) or application/bundle ids for mobile applications where the project ID is used. Requests from other origins will be denied.

- Allowlist supports a list of origins in the format `[scheme://]<hostname[:port]`.
- [Application ID](https://developer.android.com/build/configure-app-module#set-application-id)/[Bundle IDs](https://developer.apple.com/documentation/appstoreconnectapi/bundle_ids) typically are defined using the [reverse domain name notation](https://en.wikipedia.org/wiki/Reverse_domain_name_notation)

Using `localhost` (or `127.0.0.1`) is always permitted, and if empty all origins are allowed. Updates take 15 minutes to apply.

If scheme or port is specified, it must match exactly. Hostname must also match exactly, but wildcards can be used for individual labels within the hostname.

Example of possible origins in the allowlist:

- `example.com` - allows `https://example.com` or `http://example.com` but not `https://www.example.com`
- `https://example.com` - allows `https://example.com` but not `http://example.com`
- `https://www.example.com` - allows `https://www.example.com` but not `https://example.com`
- `https://example.com:8080` - allows `https://example.com:8080` but not `https://example.com`
- `https://*.example.com` - allows `https://www.example.com` but not `https://example.com`
- `https://*.*.example.com` - allows `https://www.subdomain.example.com` but not `https://www.example.com` or `https://example.com`
- `https://www.*.example.com` - allows `https://www.subdomain.example.com` but not `https://www.example.com`
- `https://www-*.example.com` - invalid; `*` must be the full label

## Error Codes

| Reason                                     | Error Code |
| ------------------------------------------ | ---------- |
| Project ID doesn't exist OR JWT is expired | 401        |
| Exists and is invalid                      | 403        |
| Too many requests                          | 1013       |

## Websocket Close Codes

| Code | Description                                                                  | Reconnect   |
| ---- | ---------------------------------------------------------------------------- | ----------- |
| 1001 | Server terminating                                                           | Yes         |
| 4008 | Client stale: connected without a prior subscription and is not sending data | When needed |
| 4010 | Load Rebalancing                                                             | Yes         |

## Best Practices

- Create a new `projectId` for each project. This allows for more granular control, dedicated explorer listings, and project metrics.
- Don't reuse a `projectId`.
- Use the AllowList to limit unauthorized usage.
- Avoid committing projects keys to the repo. Use env variables instead.
</file>

<file path="snippets/cloud/verify.mdx">
---
title: Verify
---

Verify API is a security-focused feature that allows wallets to notify end-users when they may be connecting to a suspicious or malicious domain, helping to prevent phishing attacks across the industry.

Once a wallet knows whether an end-user is on uniswap.com or eviluniswap.com, it can help them to detect potentially harmful connections through Verify's combined offering of Reown's domain registry.

## Cloud Verification

In order to verify your app domain in Reown Cloud follow these steps:

1. Head over to [Reown Cloud](https://cloud.reown.com)

2. Create a new project or click on the project you would like to verify.

3. On the settings tab, head over to the 'Domain verification' section and fill in the website URL that you wish to verify.

{/* <!-- <Frame caption="create-push-url">
    <img src="/images/assets/verify/tab.png" />
</Frame> --> */}

<Frame>
  <img src="/images/assets/verify/verify-domain.png" />
</Frame>

4. Click on the copy button and head over to your domain Name Registrar/Provider to edit your DNS records.
   Alternatively, if you can't manage DNS records for your project (eg: ENS or vercel.app) you can host a static file
   under `/.well-known/walletconnect.txt` which contains the entire verification code that you copied. If you are using the static file method, you can jump over step 7.

5. Under `Type`, select `TXT`. In the “Answer” section, paste the text you copied from the cloud dashboard. This field may vary across DNS dashboards. If you’re trying to register a subdomain, add it under `Host`. Feel free to leave TTL at its default value.

{/* <!-- <Frame caption="create-push-url">
    <img src="/images/assets/verify/dns-record.png" />
</Frame> --> */}

<Frame>
  <img src="/images/assets/verify/dns-record.png" />
</Frame>

6. Depending on your DNS settings, this might take a while to reflect. You can check out DNS settings for your website with CLI tools like Dig or with websites like [MXToolbox](https://mxtoolbox.com/SuperTool.aspx?action=txt)

7. Once this is done and you have confirmed this change is reflected, head on back to your Cloud Dashboard and click on Verify.

<Frame>
  <img src="/images/assets/verify/verify-btn.png" />
</Frame>

8. You should see a toast pop up in the bottom right section of your screen and the domain verification section should have a green tick next to it.

<Frame>
  <img src="/images/assets/verify/verified.png" />
</Frame>
</file>

<file path="snippets/walletkit/shared/chain-abstraction/error-handling.mdx">
## Error Handling

When implementing Chain Abstraction, you may encounter different types of errors. Here's how to handle them effectively:

### Application-Level Errors

These errors (`PrepareError`) indicate specific issues that need to be addressed and typically require user action:

- **Insufficient Gas Fees**: User needs to add more gas tokens to their wallet
- **Malformed Transaction Requests**: Transaction parameters are invalid or incomplete
- **Minimum Bridging Amount Not Met**: Currently set at $0.60
- **Invalid Token or Network Selection**: Selected token or network is not supported

When handling these errors, you should display clear, user-friendly error messages that provide specific guidance on how to resolve the issue. Allow users to modify their transaction parameters and consider implementing validation checks before initiating transactions.

### Retryable Errors

These errors (`Result::Err`) indicate temporary issues that may be resolved by retrying the operation. 
Examples of these types of issues include network connection timeouts, TLS negotiation issues, service outages, or other transient errors.

For retryable errors, show a generic "oops" message to users and provide a retry button. Log detailed error information to your error tracking service, but avoid displaying technical details to end users.

<Note>
For errors in the `execute()` method, a retry may not resolve the issue. In such cases, allow users to cancel the transaction, return them to the application, and let the application initiate a new transaction.
</Note>

### Critical Errors

Critical errors indicate bugs or implementation issues that should be treated as high-priority incidents: incorrect usage of WalletKit API, wrong data encoding or wrong fields passed to WalletKit, or WalletKit internal bugs.
</file>

<file path="snippets/walletkit/shared/chain-abstraction/intro.mdx">
<Info>
💡 Chain Abstraction is in early access.
</Info>

Chain Abstraction in WalletKit enables users with stablecoins on any network to spend them on-the-fly on a different network. Our Chain Abstraction solution provides a toolkit for wallet developers to integrate this complex functionality using WalletKit.

For example, when an app requests a 100 USDC payment on Base network but the user only has USDC on Arbitrum, WalletKit offers methods to detect this mismatch, generate necessary transactions, track the cross-chain transfer, and complete the original transaction after bridging finishes.

## How It Works

<Info>
Apps need to pass `gas` as null, while sending a transaction to allow proper gas estimation by the wallet. Refer to this [guide](../../../appkit/next/early-access/chain-abstraction) for more details.
</Info>

When sending a transaction, you need to:
1. Check if the required chain has enough funds to complete the transaction
2. If not, use the `prepare` method to generate necessary bridging transactions
3. Sign routing and initial transaction hashes, prepared by the prepare method
4. Use `execute` method to broadcast routing and initial transactions and wait for it to be completed

The following sequence diagram illustrates the complete flow of a chain abstraction operation, from the initial dapp request to the final transaction confirmation

<Frame caption="Chain Abstraction Flow">
    <img src="/images/assets/chain-abstraction-sequence.png" />
</Frame>
</file>

<file path="snippets/walletkit/shared/mobile-linking.mdx">
### How to test

Before submitting your project to the Cloud Explorer you can test mobile linking in our sample Dapp:

1. On your mobile device, visit the appropriate link:
- For EVM: https://appkit-lab.reown.com/library/wagmi/
- For Solana: https://appkit-lab.reown.com/library/solana/

2. Click the "Custom Wallet" button and fill in the form with your wallet information. The website will reload and your wallet will be stored locally.
3. Click the "Connect Wallet" button and choose your mobile wallet. It _should_ automatically open and redirect to your wallet.

Learn more about mobile linking in the [Best Practices section](../best-practices#2-mobile-linking).
</file>

<file path="snippets/web3modal/v2/_partials/options/chains.mdx">
Array of [CAIP-2](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md) compliant chains modal should work with.

```ts
chains: [
  'eip155:1',
  'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',
  'cosmos:cosmoshub-4',
  'polkadot:91b171bb158e2d3848fa23a9f1c25182'
]
```
</file>

<file path="snippets/web3modal/v2/_partials/options/desktopWallets.mdx">
You can define an array of custom desktop or web based wallets. Note: you will also need to add appropriate wallet images in `walletImages`. Native link represents deeplinking URL like `ledgerlive://` and Universal link represents webpage link that can redirect to the app or fallback page. Defaults to `undefined`.

```ts
desktopWallets: [
  {
    id: string,
    name: string,
    links: {
      native: string
      universal: string,
    },
  },
];
```
</file>

<file path="snippets/web3modal/v2/_partials/options/enableAuthMode.mdx">
Option to enable auth only mode for modal, will adjust which wallets are fetched from explorer. Defaults to `false`.

```ts
enableAuthMode: true
```
</file>

<file path="snippets/web3modal/v2/_partials/options/enableExplorer.mdx">
Option to enable or disable wallet fetching from [WalletGuide](https://walletguide.walletconnect.network/). Defaults to `true`.

```ts
enableExplorer: false
```
</file>

<file path="snippets/web3modal/v2/_partials/options/explorerExcludedWalletIds.mdx">
Allows to exclude wallets that are fetched from [WalletGuide](https://walletguide.walletconnect.network/). You can define an array of wallet ids you'd like to exclude. You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. If you want to exclude all wallets, you can set this option to `ALL`, however if `explorerRecommendedWalletIds` were defined, they will still be fetched. Defaults to `undefined`.

```ts
explorerExcludedWalletIds: [
  '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
]
// -- or -- //
explorerExcludedWalletIds: 'ALL'
```
</file>

<file path="snippets/web3modal/v2/_partials/options/explorerRecommendedWalletIds.mdx">
Allows to override default recommended wallets that are fetched from [WalletGuide](https://walletguide.walletconnect.network/). You can define an array of wallet ids you'd like to prioritise (order is respected). You can get these ids from the explorer link mentioned before by clicking on a copy icon of desired wallet card. If you want to completely disable recommended wallets, you can set this option to `NONE`. Defaults to `undefined`.

```ts
explorerRecommendedWalletIds: [
  '1ae92b26df02f0abca6304df07debccd18262fdf5fe82daa81593582dac9a369',
  '4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0'
]
// -- or -- //
explorerRecommendedWalletIds: 'NONE'
```
</file>

<file path="snippets/web3modal/v2/_partials/options/mobileWallets.mdx">
You can define an array of custom mobile wallets. Note: you will also need to add appropriate wallet images in `walletImages`. Native link represents deeplinking URL like `rainbow://` and Universal link represent webpage link that can redirect to the app or fallback page. Defaults to `undefined`.

```ts
mobileWallets: [
  {
    id: string,
    name: string,
    links: {
      native: string
      universal: string,
    },
  },
];
```
</file>

<file path="snippets/web3modal/v2/_partials/options/privacyPolicyUrl.mdx">
String URL to your privacy policy page, if specified will append special "legal info" footer to the modal. Defaults to `undefined`.

```ts
privacyPolicyUrl: 'https://example.com/privacy-policy'
```
</file>

<file path="snippets/web3modal/v2/_partials/options/projectId.mdx">
Your project's unique identifier that can be obtained at [cloud.reown.com](https://cloud.reown.com). Enables following functionalities within AppKit: wallet and chain logos, optional WalletConnect RPC, support for all wallets from [WalletGuide](https://walletguide.walletconnect.network/) and WalletConnect v2 support. Defaults to `undefined`.

```ts
projectId: string
```
</file>

<file path="snippets/web3modal/v2/_partials/options/termsOfServiceUrl.mdx">
String URL to your terms of service page, if specified will append special "legal info" footer to the modal. Defaults to `undefined`.

```ts
termsOfServiceUrl: 'https://example.com/terms-and-conditions'
```
</file>

<file path="snippets/web3modal/v2/_partials/options/themeMode.mdx">
Puts AppKit into dark or light mode. Defaults to user's system preference.

```ts
themeMode: 'dark' | 'light'
```
</file>

<file path="snippets/web3modal/v2/_partials/options/themeVariables.mdx">
Allows to override AppKit's css styles. See theming section for all available options.

```ts
themeVariables: {
  "--w3m-font-family": "Roboto, sans-serif",
  "--w3m-accent-color": "#F5841F",
  // ...
};
```
</file>

<file path="snippets/web3modal/v2/_partials/options/walletImages.mdx">
Array of wallet id's and their logo mappings. This will override default logos. Id's in this case can be: [WalletGuide](https://walletguide.walletconnect.network/) id's, wallet id's you provided in `mobileWallets` or `desktopWallets` and [wagmi](https://wagmi.sh) connector id's. Defaults to `undefined`.

```ts
walletImages: {
  rainbow: "/images/rainbow.webp",
  metaMask: "/images/metamask.webp",
};
```
</file>

<file path="snippets/web3modal/v2/_partials/themeMode.mdx">
By default `themeMode` option will be set to user system settings i.e. 'light' or 'dark',
however you can easily override it to match design of your dapp.
</file>

<file path="snippets/web3modal/v2/_partials/themeVariables.mdx">
AppKit's theming is done via css variables. You can override any of them to match your dapp's design via `themeVariables` option.
</file>

<file path="snippets/web3modal/v2/_partials/wcModalThemeVariablesTable.mdx">
#### General style variables

| Variable                                      | Description                                                          | Example                    |
|-----------------------------------------------|----------------------------------------------------------------------|----------------------------|
| `--wcm-font-family`                           | Base font family                                                    | `Roboto, sans-serif`       |
| `--wcm-font-feature-settings`                 | Base font features settings                                         | `tnum`                     |
| `--wcm-overlay-background-color`              | Modal overlay background color                                      | `rgba(0, 0, 0, 0.3)`       |
| `--wcm-overlay-backdrop-filter`               | Modal overlay backdrop filter                                       | `blur(5px)`                |
| `--wcm-z-index`                               | Z-index position                                                    | `10`                       |
| `--wcm-accent-color`                          | Color used for buttons, icons, labels, etc.                         | `#FFFFFF`                  |
| `--wcm-accent-fill-color`                     | Color used for text and icons inside elements with accent color     | `#000000`                  |
| `--wcm-background-color`                      | Background color instead of default animated gradient               | `#CECECE`                  |
| `--wcm-background-border-radius`              | Border radius applied to the modal background                       | `12px`                     |
| `--wcm-container-border-radius`               | Border radius applied to main modal content area                    | `24px`                     |
| `--wcm-wallet-icon-border-radius`             | Border radius applied to wallet icons                               | `2em`                      |
| `--wcm-wallet-icon-large-border-radius`       | Border radius applied to large wallet icons                         | `3em`                      |
| `--wcm-wallet-icon-small-border-radius`       | Border radius applied to small wallet icons                         | `1em`                      |
| `--wcm-input-border-radius`                   | Border radius applied to text inputs                                | `50%`                      |
| `--wcm-notification-border-radius`            | Border radius applied to toast notification                         | `2rem`                     |
| `--wcm-button-border-radius`                  | Border radius applied to primary buttons                            | `8px`                      |
| `--wcm-secondary-button-border-radius`        | Border radius applied to secondary buttons inside modal views       | `8px`                      |
| `--wcm-icon-button-border-radius`             | Border radius applied to icon-only buttons                          | `50%`                      |
| `--wcm-button-hover-highlight-border-radius`  | Border radius applied to hover highlight on wallet or chain buttons | `2rem`                     |

#### Text style variables

Granular text style variables for when `--wcm-font-family` is not enough.

| Variable                                      | Description                                                          | Example                    |
|-----------------------------------------------|----------------------------------------------------------------------|----------------------------|
| `--wcm-text-big-bold-size`                    | Font size of big-bold text variant (modal and page titles)           | `2rem`                     |
| `--wcm-text-big-bold-weight`                  | Font weight of big-bold text variant (modal and page titles)         | `bold`                     |
| `--wcm-text-big-bold-line-height`             | Line height of big-bold text variant (modal and page titles)         | `14px`                     |
| `--wcm-text-big-bold-letter-spacing`          | Letter spacing of big-bold text variant (modal and page titles)      | `1px`                      |
| `--wcm-text-big-bold-text-transform`          | Text transform of big-bold text variant (modal and page titles)      | `uppercase`                |
| `--wcm-text-big-bold-font-family`             | Font family of big-bold text variant (modal and page titles)         | `Helvetica, sans-serif`    |
| `--wcm-text-medium-regular-size`              | Font size of medium-regular text variant (button and data labels)    | `1rem`                     |
| `--wcm-text-medium-regular-weight`            | Font weight of medium-regular text variant (button and data labels)  | `normal`                   |
| `--wcm-text-medium-regular-line-height`       | Line height of medium-regular text variant (button and data labels)  | `14px`                     |
| `--wcm-text-medium-regular-letter-spacing`    | Letter spacing of medium-regular text variant (button and data labels) | `1px`                     |
| `--wcm-text-medium-regular-text-transform`    | Text transform of medium-regular text variant (button and data labels) | `capitalize`             |
| `--wcm-text-medium-regular-font-family`       | Font family of medium-regular text variant (button and data labels)  | `Arial, sans-serif`        |
| `--wcm-text-small-regular-size`               | Font size of small-regular text variant (secondary buttons, toast notifications, and labels) | `0.75rem`  |
| `--wcm-text-small-regular-weight`             | Font weight of small-regular text variant                           | `normal`                   |
| `--wcm-text-small-regular-line-height`        | Line height of small-regular text variant                          | `14px`                     |
| `--wcm-text-small-regular-letter-spacing`     | Letter spacing of small-regular text variant                       | `1px`                      |
| `--wcm-text-small-regular-text-transform`     | Text transform of small-regular text variant                       | `capitalize`               |
| `--wcm-text-small-regular-font-family`        | Font family of small-regular text variant                         | `Helvetica, sans-serif`    |
| `--wcm-text-small-thin-size`                  | Font size of small-thin text variant (input placeholder, help text) | `0.65rem`                  |
| `--wcm-text-small-thin-weight`                | Font weight of small-thin text variant                            | `lighter`                  |
| `--wcm-text-small-thin-line-height`           | Line height of small-thin text variant                           | `0.8rem`                   |
| `--wcm-text-small-thin-letter-spacing`        | Letter spacing of small
</file>

<file path="snippets/chainlist.mdx">
export const ChainList = () => {
  let chains = [];
  let filteredChains = [];

  if (typeof document !== "undefined") {
    fetch(
      "https://explorer-api.walletconnect.com/v3/chains?projectId=8e998cd112127e42dce5e2bf74122539"
    )
      .then((response) => response.json())
      .then((data) => {
        chains = Object.keys(data.chains).map((key) => ({
          name: data.chains[key].name, 
          namespace: key, 
        }));
        filteredChains = [...chains];
        renderChains(filteredChains);

        const searchInput = document.querySelector(".search-bar");
        if (searchInput) {
          searchInput.addEventListener("input", (event) => {
            const query = event.target.value.toLowerCase();
            filteredChains = chains.filter((chain) =>
              chain.name.toLowerCase().includes(query)
            );
            renderChains(filteredChains);
          });
        }
      })
      .catch((error) => console.error(error));
  }

  const renderChains = (chains) => {
    const container = document.querySelector(".chain-card-container");
    if (container) {
      container.innerHTML = "";
      chains.forEach((chain) => {
        const card = document.createElement("button");
        card.className = `
          flex items-center justify-center 
          border border-gray-500 p-2 text-center 
          w-full dark:bg-gray-600 dark:text-white h-20
        `;
        card.innerText = chain.name;
        card.onclick = () => {
          navigator.clipboard.writeText(chain.namespace);
          card.innerText = "Chain ID copied!";
          setTimeout(() => {
            card.innerText = chain.name;
          }, 3000);
        };
        container.appendChild(card);
      });
    }
  };

  return (
    <div className="chain-list">
      <input
        type="text"
        className="search-bar"
        placeholder="Search for a chain..."
        style={{
          width: "100%",
          padding: "8px",
          marginBottom: "20px",
          marginTop: "20px",
          boxSizing: "border-box",
        }}
      />
      <div
        className="chain-card-container"
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fill, minmax(200px, 1fr))",
          gap: "8px",
        }}
      ></div>
    </div>
  );
};
</file>

<file path="snippets/cloud-banner.mdx">
<Info>

**Don't have a project ID?**

Head over to Reown Cloud and create a new project now!

<Card
  title="Get started"
  href="https://cloud.reown.com/?utm_source=cloud_banner&utm_medium=docs&utm_campaign=backlinks"
/>

</Info>
</file>

<file path="snippets/walletlist.mdx">
export const WalletList = () => {
  let wallets = [];
  let originalWalletsArray = [];

  if (typeof document !== "undefined") {
    fetch(
      "https://explorer-api.walletconnect.com/v3/wallets?projectId=8e998cd112127e42dce5e2bf74122539"
    )
      .then((response) => response.json())
      .then((data) => {
        wallets = data.listings;
        originalWalletsArray = Object.keys(data.listings).map((key) => ({
          ...data.listings[key],
          namespace: key,
        }));
        renderWallets(wallets);

        const searchInput = document.querySelector(".search-bar");
        if (searchInput) {
          searchInput.addEventListener("input", (event) => {
            const query = event.target.value.toLowerCase();
            const filteredwallets = Object.fromEntries(
              Object.entries(wallets).filter(([_, wallet]) =>
                wallet.name.toLowerCase().includes(query)
              )
            );
            renderWallets(filteredwallets);
          });
        }
      })
      .catch((error) => console.error(error));
  }

  const renderWallets = (wallets) => {
    const container = document.querySelector(".wallet-card-container");
    if (container) {
      container.innerHTML = "";
      Object.keys(wallets).forEach((key) => {
        const wallet = wallets[key];
        const card = document.createElement("button");
        card.className = `
          flex flex-col items-center justify-center 
          border border-gray-500 p-2 text-center 
          w-full dark:bg-gray-600 dark:text-white h-20
        `;
        card.innerHTML = `
          <img src="${wallet.image_url.sm}" width="40" height="40" class="p-0 m-0" alt="${wallet.name}" />
          <span>${wallet.name}</span>
        `;
        card.onclick = () => {
          navigator.clipboard.writeText(wallet.id);
          card.innerHTML = "Wallet ID copied!";
          setTimeout(() => {
            card.innerHTML = `
              <img src="${wallet.image_url.sm}" width="40" height="40" class="p-0 m-0" alt="${wallet.name}" />
              <span>${wallet.name}</span>
            `;
          }, 3000);
        };
        container.appendChild(card);
      });
    }
  };

  return (
    <div className="wallet-list">
      <input
        type="text"
        className="search-bar"
        placeholder="Search for a wallet..."
        style={{
          width: "100%",
          padding: "8px",
          marginBottom: "20px",
          marginTop: "20px",
          boxSizing: "border-box",
        }}
      />
      <div
        className="wallet-card-container"
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fill, minmax(200px, 1fr))",
          gap: "8px",
        }}
      ></div>
    </div>
  );
};
</file>

<file path="web3modal/v2/_partials/customisation/customChainImages.mdx">
AppKit tries to provide default images for most wagmi chain defaults,
but if image for your chain is missing or you want to override it, you can use `chainImages` options:
</file>

<file path="web3modal/v2/_partials/customisation/customChainProviders.mdx">
Wagmi requires that one or more providers (RPCs) are configured that support all your target chains. AppKit provides WalletConnect RPC via `w3mProvider` helper.
WalletConnect RPC `https://rpc.walletconnect.com` is free to use (rate limit may be applied to specific users if abuse is detected). WalletConnect RPC currently supports following chains:

```
1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 280, 324, 420, 42161, 42220, 43114, 80001, 421611, 421613, 1313161554, 1313161555
```

Please refer to [wagmi providers](https://wagmi.sh/react/providers/configuring-chains) documentation to see how to configure alternative providers, combine or prioritize them.

Below is a simplified example of how to combine WalletConnect RPC and Infura one:
</file>

<file path="web3modal/v2/_partials/customisation/customDefaultChain.mdx">
By default AppKit will connect to the chain that was set by user's wallet.
If you want user to be connected to a specific chain by default, you can set it via `defaultChain` option:
</file>

<file path="web3modal/v2/_partials/customisation/customExplorerWallets.mdx">
You can manage wallets fetched from explorer via `explorerRecommendedWalletIds` and `explorerExcludedWalletIds` options to prioritize, include or exclude them.
To fully disable explorer wallets, use `enableExplorer` options.

You can get all wallet id's from [WalletGuide](https://walletguide.walletconnect.network/) (click copy icon on chosen wallets).

Below is an example of how to prioritize MetaMask, Rainbow and TrustWallet in that specific order:
</file>

<file path="web3modal/v2/_partials/customisation/customManualWallets.mdx">
If your WalletConnect enabled wallet is not present in [WalletGuide](https://walletguide.walletconnect.network/) or is still pending approval,
you can add it manually via `mobileWallets` and `desktopWallets` options.
</file>

<file path="web3modal/v2/_partials/customisation/customWagmiChains.mdx">
AppKit's chain configuration happens entirely via wagmi.
Please refer to [wagmi chains](https://wagmi.sh/react/chains) documentation to see which defaults are available and how to create your own chain.

Below is a simplified example that sets up mainnet, avalanche and arbitrum chains:
</file>

<file path="web3modal/v2/_partials/customisation/customWagmiConnectors.mdx">
You can add any wagmi connector as you normally would in wagmi's [`createConfig`](https://wagmi.sh/react/config) function. However, for AppKit to work correctly [WalletConnectConnector](https://wagmi.sh/react/connectors/walletConnect) is required.
Below is a simplified example of how to use [CoinbaseWalletConnector](https://wagmi.sh/react/connectors/coinbaseWallet) together with defaults from `w3mConnectors` helper:
</file>

<file path="web3modal/v2/_partials/customisation/customWagmiWalletsIntro.mdx">
AppKit includes wallets from 3 sources: [WalletGuide](https://walletguide.walletconnect.network/), wagmi connectors and manually defined wallets.
Below are defaults for each source:

1. All WalletConnect explorer wallets that satisfy your options
2. When using `w3mConnectors` helper, modal includes [WalletConnectConnector](https://wagmi.sh/react/connectors/walletConnect) and [InjectedConnector](https://wagmi.sh/react/connectors/injected)
3. No manual wallets are defined by default

Wallets are ordered with following priority: wagmi connectors, manual wallets, explorer wallets.
</file>

<file path="web3modal/v2/_partials/customisation/customWalletImages.mdx">
If your wallet's logo is not supported by AppKit or you want to override default one, you can use `walletImages` option.
</file>

<file path="web3modal/v2/_partials/options/chainImages.mdx">
Array of chain id's and their logo mappings. This will override default logos. You can find detailed chain data at [chainlist.org](https://chainlist.org) Defaults to `undefined`.

```ts
chainImages: {
  1: "/images/ethereum.webp",
  137: "/images/polygon.webp",
};
```
</file>

<file path="web3modal/v2/_partials/options/defaultChain.mdx">
Before the user establishes a connection, the default wagmi chain can be set prompting user to switch in their wallet if they were on a different one. Defaults to `undefined`.

```ts
defaultChain: polygon
```
</file>

<file path="web3modal/v2/_partials/options/enableAccountView.mdx">
Option to enable or disable the modal's account view. The default setting is set to `true`.

```ts
enableAccountView: false
```
</file>

<file path="web3modal/v2/_partials/options/enableNetworkView.mdx">
If more than 1 chain was provided in modal or wagmi configuration, users will be show network selection view before selecting a wallet. This option can enable or disable this behavior. Defaults to `false`.

```ts
enableNetworkView: true
```
</file>

<file path="web3modal/v2/_partials/options/metadata.mdx">
Information about your dapp that will be displayed to users during request approvals within wallets.

```ts
metadata: {
  name: string;
  description: string;
  url: string;
  icons: string[];
};
```
</file>

<file path="web3modal/v2/_partials/options/tokenContracts.mdx">
Allows to override default token(s) address for each chain to show custom balances in account view. Defaults to `undefined`.

```ts
tokenContracts: {
  1: '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
  137: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'
}
```
</file>

<file path="web3modal/v2/_partials/options/tokenImages.mdx">
Array of token symbols and their logo mappings. Defaults to `undefined`.

```ts
tokenImages: {
  ETH: "/images/eth.webp",
  AVAX: "/images/avax.webp",
};
```
</file>

<file path="web3modal/v2/_partials/obtainProjectId.mdx">
Every project using WalletConnect SDKs needs to obtain `projectId` from [cloud.reown.com](https://cloud.reown.com/),
this is absolutely free and only takes a few minutes.
</file>

<file path="web3modal/v2/_partials/themeVariablesTable.mdx">
#### General style variables

<Table
  headers={["Variable", "Description", "Example"]}
  data={[
    {
      variable: { code: "--w3m-font-family" },
      description: "Base font family",
      example: { code: "Roboto, sans-serif" },
    },
    {
      variable: { code: "--w3m-font-feature-settings" },
      description: "Base font features settings",
      example: { code: "tnum" },
    },
    {
      variable: { code: "--w3m-overlay-background-color" },
      description: "Modal overlay background color",
      example: { code: "rgba(0, 0, 0, 0.3)" },
    },
    {
      variable: { code: "--w3m-overlay-backdrop-filter" },
      description: "Modal overlay backdrop filter",
      example: { code: "blur(5px)" },
    },
    {
      variable: { code: "--w3m-z-index" },
      description: "Z-index position",
      example: { code: "10" },
    },
    {
      variable: { code: "--w3m-accent-color" },
      description: "Color used for buttons, icons, labels, etc.",
      example: { code: "#FFFFFF" },
    },
    {
      variable: { code: "--w3m-accent-fill-color" },
      description:
        "Color used for text and icons inside elements with accent color background",
      example: { code: "#000000" },
    },
    {
      variable: { code: "--w3m-background-color" },
      description:
        "Background color to be used instead of default animated gradient",
      example: { code: "#CECECE" },
    },
    {
      variable: { code: "--w3m-background-image-url" },
      description:
        "Background image URL to be used instead of default animated gradient",
      example: { code: "https://..." },
    },
    {
      variable: { code: "--w3m-logo-image-url" },
      description: "Image URL to be used instead of WalletConnect logo",
      example: { code: "https://..." },
    },
    {
      variable: { code: "--w3m-background-border-radius" },
      description: "Border radius applied to the modal background",
      example: { code: "12px" },
    },
    {
      variable: { code: "--w3m-container-border-radius" },
      description: "Border radius applied to main modal content area",
      example: { code: "24px" },
    },
    {
      variable: { code: "--w3m-wallet-icon-border-radius" },
      description: "Border radius applied to wallet icons",
      example: { code: "2em" },
    },
    {
      variable: { code: "--w3m-wallet-icon-large-border-radius" },
      description: "Border radius applied to large wallet icons",
      example: { code: "3em" },
    },
    {
      variable: { code: "--w3m-wallet-icon-small-border-radius " },
      description: "Border radius applied to small wallet icons",
      example: { code: "1em" },
    },
    {
      variable: { code: "--w3m-input-border-radius" },
      description: "Border radius applied to text inputs",
      example: { code: "50%" },
    },
    {
      variable: { code: "--w3m-notification-border-radius" },
      description: "Border radius applied to toast notification",
      example: { code: "2rem" },
    },
    {
      variable: { code: "--w3m-button-border-radius" },
      description:
        "Border radius applied to primary buttons like 'Connect' | 'Account'",
      example: { code: "8px" },
    },
    {
      variable: { code: "--w3m-secondary-button-border-radius" },
      description:
        "Border radius applied to secondary buttons, ones inside modal views",
      example: { code: "8px" },
    },
    {
      variable: { code: "--w3m-icon-button-border-radius" },
      description:
        "Border radius applied to icon only buttons like 'Copy' | 'Disconnect'",
      example: { code: "50%" },
    },
    {
      variable: { code: "--w3m-button-hover-highlight-border-radius" },
      description:
        "Border radius applied to hover highlight on wallet or chain buttons",
      example: { code: "2rem" },
    },
  ]}
/>

#### Text style variables

Granular text style variables for when `--w3m-font-family` is not enough.

<Table
  headers={["Variable", "Description", "Example"]}
  data={[
    {
      variable: { code: "--w3m-text-big-bold-size" },
      description: "Font size of big-bold text variant (modal and page titles)",
      example: { code: "2rem" },
    },
    {
      variable: { code: "--w3m-text-big-bold-weight" },
      description:
        "Font weight of big-bold text variant (modal and page titles)",
      example: { code: "bold" },
    },
    {
      variable: { code: "--w3m-text-big-bold-line-height" },
      description:
        "Line height of big-bold text variant (modal and page titles)",
      example: { code: "14px" },
    },
    {
      variable: { code: "--w3m-text-big-bold-letter-spacing" },
      description:
        "Letter spacing of big-bold text variant (modal and page titles)",
      example: { code: "1px" },
    },
    {
      variable: { code: "--w3m-text-big-bold-text-transform" },
      description:
        "Text transform of big-bold text variant (modal and page titles)",
      example: { code: "uppercase" },
    },
    {
      variable: { code: "--w3m-text-big-bold-font-family" },
      description:
        "Font family of big-bold text variant (modal and page titles)",
      example: { code: "Helvetica, sans-serif" },
    },
    {
      variable: { code: "--w3m-text-medium-regular-size" },
      description:
        "Font size of medium-regular text variant (button and data labels)",
      example: { code: "1rem" },
    },
    {
      variable: { code: "--w3m-text-medium-regular-weight" },
      description:
        "Font weight of medium-regular text variant (button and data labels)",
      example: { code: "normal" },
    },
    {
      variable: { code: "--w3m-text-medium-regular-line-height" },
      description:
        "Line height of medium-regular text variant (button and data labels)",
      example: { code: "14px" },
    },
    {
      variable: { code: "--w3m-text-medium-regular-letter-spacing" },
      description:
        "Letter spacing of medium-regular text variant (button and data labels)",
      example: { code: "1px" },
    },
    {
      variable: { code: "--w3m-text-medium-regular-text-transform" },
      description:
        "Text transform of medium-regular text variant (button and data labels)",
      example: { code: "capitalize" },
    },
    {
      variable: { code: "--w3m-text-medium-regular-font-family" },
      description:
        "Font family of medium-regular text variant (button and data labels)",
      example: { code: "Arial, sans-serif" },
    },
    {
      variable: { code: "--w3m-text-small-regular-size" },
      description:
        "Font size of small-regular text variant (secondary buttons, toast notification and labels)",
      example: { code: "0.75rem" },
    },
    {
      variable: { code: "--w3m-text-small-regular-weight" },
      description:
        "Font weight of small-regular text variant (secondary buttons, toast notification and labels)",
      example: { code: "normal" },
    },
    {
      variable: { code: "--w3m-text-small-regular-line-height" },
      description:
        "Line height of small-regular text variant (secondary buttons, toast notification and labels)",
      example: { code: "14px" },
    },
    {
      variable: { code: "--w3m-text-small-regular-letter-spacing" },
      description:
        "Letter spacing of small-regular text variant (secondary buttons, toast notification and labels)",
      example: { code: "1px" },
    },
    {
      variable: { code: "--w3m-text-small-regular-text-transform" },
      description:
        "Text transform of small-regular text variant (secondary buttons, toast notification and labels)",
      example: { code: "capitalize" },
    },
    {
      variable: { code: "--w3m-text-small-regular-font-family" },
      description:
        "Font family of small-regular text variant (secondary buttons, toast notification and labels)",
      example: { code: "Helvetica, sans-serif" },
    },
    {
      variable: { code: "--w3m-text-small-thin-size" },
      description:
        "Font size of small-thin text variant (input placeholder and help text)",
      example: { code: "0.65rem" },
    },
    {
      variable: { code: "--w3m-text-small-thin-weight" },
      description:
        "Font weight of small-thin text variant (input placeholder and help text)",
      example: { code: "lighter" },
    },
    {
      variable: { code: "--w3m-text-small-thin-line-height" },
      description:
        "Line height of small-thin text variant (input placeholder and help text)",
      example: { code: "0.8rem" },
    },
    {
      variable: { code: "--w3m-text-small-thin-letter-spacing" },
      description:
        "Letter spacing of small-thin text variant (input placeholder and help text)",
      example: { code: "0.01em" },
    },
    {
      variable: { code: "--w3m-text-small-thin-text-transform" },
      description:
        "Text transform of small-thin text variant (input placeholder and help text)",
      example: { code: "none" },
    },
    {
      variable: { code: "--w3m-text-small-thin-font-family" },
      description:
        "Font family of small-thin text variant (input placeholder and help text)",
      example: { code: "Arial, sans-serif" },
    },
    {
      variable: { code: "--w3m-text-xsmall-bold-size" },
      description: "Font size of xsmall-bold text variant (sub-labels)",
      example: { code: "0.5rem" },
    },
    {
      variable: { code: "--w3m-text-xsmall-bold-weight" },
      description: "Font weight of xsmall-bold text variant (sub-labels)",
      example: { code: "bold" },
    },
    {
      variable: { code: "--w3m-text-xsmall-bold-line-height" },
      description: "Line height of xsmall-bold text variant (sub-labels)",
      example: { code: "10px" },
    },
    {
      variable: { code: "--w3m-text-xsmall-bold-letter-spacing" },
      description: "Letter spacing of xsmall-bold text variant (sub-labels)",
      example: { code: "-0.03em" },
    },
    {
      variable: { code: "--w3m-text-xsmall-bold-text-transform" },
      description: "Text transform of xsmall-bold text variant (sub-labels)",
      example: { code: "uppercase" },
    },
    {
      variable: { code: "--w3m-text-xsmall-bold-font-family" },
      description: "Font family of xsmall-bold text variant (sub-labels)",
      example: { code: "Arial, sans-serif" },
    },
    {
      variable: { code: "--w3m-text-xsmall-regular-size" },
      description:
        "Font size of xsmall-regular text variant (wallet and network button labels)",
      example: { code: "0.5rem" },
    },
    {
      variable: { code: "--w3m-text-xsmall-regular-weight" },
      description:
        "Font weight of xsmall-regular text variant (wallet and network button labels)",
      example: { code: "normal" },
    },
    {
      variable: { code: "--w3m-text-xsmall-regular-line-height" },
      description:
        "Line height of xsmall-regular text variant (wallet and network button labels)",
      example: { code: "10px" },
    },
    {
      variable: { code: "--w3m-text-xsmall-regular-letter-spacing" },
      description:
        "Letter spacing of xsmall-regular text variant (wallet and network button labels)",
      example: { code: "0.1em" },
    },
    {
      variable: { code: "--w3m-text-xsmall-regular-text-transform" },
      description:
        "Text transform of xsmall-regular text variant (wallet and network button labels)",
      example: { code: "none" },
    },
    {
      variable: { code: "--w3m-text-xsmall-regular-font-family" },
      description:
        "Font family of xsmall-regular text variant (wallet and network button labels)",
      example: { code: "Helvetica, sans-serif" },
    },
  ]}
/>
</file>

<file path="overview.mdx">
---
title: Overview
---

<Card horizontal>
  <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 sm:gap-8">
    <div className="flex-1">
      WalletConnect Inc. is now known as Reown. See <a href="https://walletconnect.network" className="underline">walletconnect.network</a> for information about the WalletConnect Network.
    </div>
    <div className="w-full sm:w-auto">
      <a href="https://reown.com/blog/walletconnect-is-now-reown" className="w-full sm:w-auto px-3 py-1 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700 whitespace-nowrap inline-block text-center">Learn More</a>
    </div>
  </div>
</Card>

## Reown

Reown is a UX-focused company that provides toolkits – AppKit and WalletKit – for anyone building onchain to leverage and unlock better UX.

Effortlessly integrate Reown's suite of SDKs. 

<CardGroup cols={2}>
  <Card title="AppKit" icon="cubes" href="/appkit/overview">
    AppKit is a comprehensive SDK for creating seamless onchain UX, offering features like login (email & social), 
    gas fee sponsorship, multi-chain support, onramps, swaps, user insights, and access to more than 600 wallets.
  </Card>

  <Card title="WalletKit" icon="wallet" href="/walletkit/overview">
    WalletKit is an open-source SDK for seamless wallet connections across blockchains. 
    It offers one-click authentication, secure transaction signing, phishing protection, 
    and advanced on-chain configurations like batch transactions and paymasters.
  </Card>
</CardGroup>

<Card title="Get Support" icon="discord" href="https://discord.gg/reown">
  Reown offers free unlimited support for builders 24/7. Feel free to read the FAQ or get in touch.
</Card>

## Are you building a Web3 App?

If you're building a Web3 app, you can use Reown AppKit to get started quickly. Using Reown AppKit, you can provide end-to-end wallet connections and interactions for your users.

<CardGroup cols={2}>
  <Card title="Get Started" icon="rocket" href="/appkit/overview">
    Get started with Reown AppKit
  </Card>

  <Card title="Upgrade to Reown" icon="arrow-up" href="/appkit/upgrade/from-w3m-to-reown">
    Upgrade to latest version of Reown AppKit
  </Card>

  <Card title="Features" icon="list-check" href="/appkit/features/">
    Learn about the features Reown has to offer
  </Card>

  <Card title="Try AppKit Demo" icon="flask" href="https://demo.reown.com/?utm_source=navbar&utm_medium=docs&utm_campaign=backlinks">
    Try out the powerful Reown AppKit today
  </Card>

  <Card title="Migrate from Alternatives" icon="arrows-spin" href="/appkit/migration/">
    Migrate from other solutions to Reown AppKit
  </Card>

  <Card title="Github Repositories" icon="github" href="https://github.com/reown-com">
    Browse all of Reown's open-source repositories
  </Card>
</CardGroup>

Navigate to the [AppKit Overview](/appkit/overview) or click the **"AppKit" tab** in the top-left navbar to get started.

## Are you building a Web3 Wallet?

If you're building a Web3 wallet, you can use Reown WalletKit to get started quickly.

<CardGroup cols={2}>
  <Card title="Get Started" icon="rocket" href="/walletkit/overview">
    Get started with Reown WalletKit
  </Card>

  <Card title="Upgrade to Reown" icon="arrow-up" href="/walletkit/upgrade/from-web3wallet-to-reown">
    Upgrade to latest version of Reown WalletKit
  </Card>

  <Card title="Features" icon="list-check" href="/walletkit/features/one-click-auth">
    Learn about the features Reown WalletKit has to offer
  </Card>

  <Card title="Github Repositories" icon="github" href="https://github.com/reown-com">
    Browse all of Reown's open-source repositories
  </Card>
</CardGroup>

Navigate to the [WalletKit Overview](/walletkit/overview) or click the **"WalletKit" tab** in the top-left navbar to get started.

## Guides

Step-by-step guides and ready-to-use code examples designed to help you quickly implement common features and solve specific use cases using the SDK. Perfect for tackling real-world scenarios with ease.

**Click on the "Guides" section in the sidebar to explore more.**

<CardGroup cols={2}>
  <Card title="Build a Telegram Mini App" icon="telegram" href="/appkit/recipes/telegram-mini-app">
    Learn how to create a Telegram Mini App with Reown.
  </Card>

  <Card title="How to Build on EVM" icon="ethereum" href="/appkit/recipes/wagmi-send-transaction">
    Step-by-step guide to building on Ethereum Virtual Machine (EVM).
  </Card>

  <Card title="How to Build on Solana" icon="coins" href="/appkit/recipes/solana-send-transaction">
    Learn how to develop on the Solana blockchain.
  </Card>

  <Card title="How to Build on Bitcoin" icon="bitcoin" href="/appkit/recipes/bitcoin-send-transaction">
    A guide to building on the Bitcoin network.
  </Card>

  <Card title="Travel Rule Compliance using AppKit" icon="scale-balanced" href="/appkit/recipes/travel-rule">
    Learn how to use Reown AppKit to comply with travel rule regulations.
  </Card>

  <Card title="Gas Sponsorship using Reown AppKit" icon="gas-pump" href="/appkit/recipes/sponsoring-first-transaction">
    Learn how to use Reown AppKit to sponsor gas fees for your users.
  </Card>
</CardGroup>


## Join the Reown community

Share your experience, contribute, or ask questions

<CardGroup cols={3}>
  <Card title="X" icon="twitter" href="https://x.com/reowncom">
    Follow Reown on X
  </Card>

  <Card title="Discord" icon="discord" href="https://discord.gg/reown">
    Join Reown's Discord community
  </Card>

  <Card title="GitHub" icon="github" href="https://github.com/reown-com">
    Browse Reown's GitHub repositories
  </Card>

</CardGroup>



## How to contribute
<Info>
  Navigate to the docs repo below and open a Pull Request with the required changes. The Reown team will review it and merge it!
  <Card title="Docs Repo" href="https://github.com/reown-com/reown-docs/" horizontal />
</Info>
</file>

</files>
