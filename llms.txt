This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: *.*, src
- Files matching these patterns are excluded: llms.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  app/
    dashboard/
      layout.tsx
      page.tsx
    layout.tsx
    page.tsx
    providers.tsx
  components/
    dashboard/
      AccountIdentityPanel.tsx
      OwnerPanel.tsx
    modals/
      ApproveModal.tsx
      BaseTxModal.tsx
      QrCodeModal.tsx
      SendModal.tsx
      UnwrapModal.tsx
      WrapModal.tsx
    AccountDisplay.tsx
    ConnectOwnerButton.tsx
    DiscoveryForm.tsx
    WcConnect.tsx
    WcRequestDisplay.tsx
  contexts/
    LensAccountContext.tsx
    WalletConnectProvider.tsx
  hooks/
    useDebounce.ts
  lib/
    constants.ts
    wagmi.ts
  services/
    walletConnectService.ts
  styles/
    globals.css
.dockerignore
.gitignore
.prettierrc
DEVELOPMENT_PLAN.md
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
repomix-output.xml
Spec.functional.md
Spec.technical.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="repomix-output.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
components/
  Head.tsx
  RandomSlogan.tsx
pages/
  _app.tsx
  _document.tsx
  index.tsx
public/
  manifest.json
styles/
  globals.css
  Home.module.css
.eslintrc.json
.gitignore
next-sitemap.config.js
next.config.js
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="pages/_app.tsx">
import '../styles/globals.css'
import type { AppProps } from 'next/app'

function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}

export default MyApp
</file>

<file path="pages/_document.tsx">
import { Html, Head, Main, NextScript } from "next/document";

export default function Document() {
  return (
    <Html lang="en">
      <Head />
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}
</file>

<file path="styles/globals.css">
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
  body {
    color: white;
    background: black;
  }
}
</file>

<file path="styles/Home.module.css">
.container {
  padding: 0;
}

.main {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  padding: 2rem 0;
}

.content {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.logo {
  margin: 0;
  font-size: 6rem;
  letter-spacing: 10px;
}

.slogan {
  margin: 2rem 0 0 0;
  font-size: 1.2rem;
  letter-spacing: 4px;
  color: #666;
  font-weight: 200;
}

.social {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-right: 15px;
  padding-bottom: 1rem;
}
</file>

<file path=".eslintrc.json">
{
  "extends": "next/core-web-vitals"
}
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `pages/index.tsx`. The page auto-updates as you edit the file.

[API routes](https://nextjs.org/docs/api-routes/introduction) can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/hello.ts`.

The `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as [API routes](https://nextjs.org/docs/api-routes/introduction) instead of React pages.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
</file>

<file path="components/Head.tsx">
import Head from "next/head";

const FKNGHead = () => {
  const title = "FKNG.SOCIAL | Making social fkng great again";
  const desc = "Making social fkng great again - A new way to connect in web3";
  const image = "https://fkng.social/fkng.png";
  return (
    <Head>
      <title>{title}</title>
      <link rel="icon" href="/favicon.png" />
      <link rel="manifest" href="/manifest.json" />
      <meta name="description" content={desc} />

      <meta property="og:title" content={title} />
      <meta property="og:description" content={desc} />
      <meta property="og:type" content="website" />
      <meta property="og:url" content="https://fkng.social/" />
      <meta property="og:image" content={image} />
      <meta property="og:image:type" content="image/png" />
      <meta property="og:image:alt" content={desc} />

      <meta name="twitter:site" content="fkng" />
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:title" content={title} />
      <meta name="twitter:description" content={desc} />
      <meta name="twitter:image" content={image} />
      <meta name="twitter:image:alt" content={desc} />
    </Head>
  );
};

export default FKNGHead;
</file>

<file path="public/manifest.json">
{
  "name": "FKNG.SOCIAL",
  "short_name": "FKNG.SOCIAL",
  "start_url": "/",
  "display": "standalone",
  "theme_color": "#fff",
  "background_color": "#fff",
  "icons": [
    {
      "src": "https://fkng.social/favicon.png",
      "sizes": "128x128",
      "type": "image/png"
    }
  ]
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# sitemap
/public/sitemap*.xml
/public/robots.txt

sitemap*.xml
</file>

<file path="next-sitemap.config.js">
/** @type {import('next-sitemap').IConfig} */
const config = {
  siteUrl: "https://fkng.social",
  generateRobotsTxt: true, // (optional)
  changefreq: "monthly",
};

module.exports = config;
</file>

<file path="components/RandomSlogan.tsx">
import { useState, useEffect } from "react";
import styles from "../styles/Home.module.css";

const slogans = [
  "MAKING SOCIAL FKNG GREAT AGAIN",
  "GET REAL. GET FKNG SOCIAL",
  "TOUCH THE FKNG GRASS",
  "NO BOTS. NO SLOP. JUST SOCIAL",
  "THE BEST SOCIAL THERE IS",
  "FKNG TIRED OF FAKE SOCIAL?",
  "SOCIAL MEDIA WORTH GIVING A FK ABOUT",
  "KEEP CALM AND GET FKNG SOCIAL",
  "WHERE REAL PEOPLE GET FKNG REAL",
  "LESS NOISE. MORE FKNG SIGNAL",
  "FKNG AUTHENTIC SINCE DAY ONE",
  "SOCIAL MEDIA DONE FKNG RIGHT",
  "ZERO FKNG ALGORITHMS",
  "YOUR FEED. YOUR FKNG CHOICE",
  "BREAK THE FKNG ALGORITHM",
  "WELCOME TO THE FKNG REVOLUTION",
  "SOCIAL MEDIA THAT HITS DIFFERENT",
  "NO FKNG INFLUENCER BS HERE",
  "BE REAL. DONT FKNG INFLUENCE ME",
  "ZERO FKNG BLUE CHECKMARKS",
  "INFLUENCE THIS 🖕",
  "WHERE NOBODY IS FKNG FAMOUS",
  "NO CLOUT CHASERS. NO FKNG PROBLEM",
  "ZERO SPONSORED FKNG CONTENT",
  "NOT FOR SALE. NOT FKNG EVER",
  "YOUR FEED ISN'T FOR SALE",
  "NO FKNG PRODUCT PLACEMENT",
  "JUST REAL PEOPLE HERE",
  "NO BRANDS. NO SPAM. NO FKNG AROUND",
  "ACTUAL HUMANS BEING FKNG SOCIAL",
  "YOUR ATTENTION ISN'T FOR FKNG SALE",
  "NOT FARMING FOR YOUR FKNG ATTENTION",
  "SCROLL LESS. LIVE FKNG MORE",
  "NO DOPAMINE FARMING HERE",
  "NO FKNG CLICKBAIT ALLOWED",
  "ZERO THIRST TRAPS. ZERO FKNG BAIT",
  "BAIT-FREE ZONE",
  "NO BAITS. NO FKNG TRICKS",
  "NOT FARMING FOR FKNG LIKES",
  "ENGAGEMENT FARMERS CAN FKNG LEAVE",
  "NO FKNG ENGAGEMENT METRICS",
  "REAL TALK. NOT FKNG METRICS",
  "WHERE VIRAL ISN'T A FKNG GOAL",
  "NO FKNG DOPAMINE LOOPS",
  "POST WHATEVER. JUST DON'T BE FKNG FAKE",
  "FREE SPEECH. ZERO FKNG BULLSHIT",
  "ANON AF. REAL AF",
  "PURE CHAOS. ZERO BAIT",
  "REAL TAKES. NO FAKES",
  "PURE CONTENT. ZERO FKNG GAMES",
  "BASED AND FKNG REAL",
  "JUST FKNG POST IT",
  "NO RULES. EXCEPT NO FKNG BAIT",
  "CHRONOLOGICAL FEED. FKNG FINALLY",
  "WE ARE THE FKNG GRASS",
  "WHERE FKNG NORMIES FEAR TO TREAD",
  "ORGANIC REACH IS STILL FKNG REAL",
  "NO FKNG MAIN CHARACTER SYNDROME",
  "PUT A NAIL IN THE ENGAGEMENT COFFIN",
  "FEELS GOOD MAN. FEELS FKNG REAL",
  "NO MORE FKNG COPE",
  "REJECT MODERNITY. EMBRACE FKNG REALITY",
  "TOUCH GRASS ACHIEVEMENT: FKNG UNLOCKED",
  "GG EZ? NAH, JUST BE FKNG REAL",
  "I CAN HAS FKNG AUTHENTICITY?",
  "THIS IS FINE. ACTUALLY FKNG FINE",
  "DOGE IS DEAD. AUTHENTICITY IS FKNG FOREVER",
  "LURK MOAR OR POST REAL",
  "SAGE YOUR FKNG ENGAGEMENT METRICS",
  "TRIPS DECIDE YOUR FKNG REACH",
  "POV: YOU'RE BEING FKNG REAL",
  "NO CAP. JUST FKNG FACTS",
  "RATIO THIS, ENGAGEMENT FARMERS",
  "NOT YOUR PERSONAL FKNG ARMY",
  "COMFY AND FKNG AUTHENTIC",
  "FEELS AUTHENTIC MAN",
  "ZERO FKNG FILTERS FR",
  "NOT YOUR FKNG CONTENT HOUSE",
  "NO FYP",
  "SPEEDRUN TO FKNG REALITY",
  "RAGE QUIT YOUR FKNG ALGORITHM",
  "FINAL BOSS: AUTHENTIC CONTENT",
  "ALL YOUR BASE ARE FKNG REAL",
  "NYAN CAT WOULDN'T FKNG FARM LIKES",
  "PARASOCIAL? PARA-FKNG-NOID",
  "TOUCH GRASS.EXE HAS STARTED",
  "404: FAKE CONTENT NOT FOUND",
  "CHRONOLOGICAL FEED OR GTFO",
  "NORMALIZE BEING FKNG NORMAL",
  "PARASOCIAL RELATIONSHIPS LEFT THE CHAT",
  "PARASOCIAL THIS 🖕",
  "NO RAGE BAIT. NO CRINGE",
  "NOT YOUR FKNG OUTRAGE FARM",
  "CONTROVERSY FARMERS REKT",
  "BLUE CHECK? BLUE FKNG BALLS",
  "YOUR TWEET DECK IS FKNG DEAD",
  "ELON CAN'T BUY FKNG AUTHENTICITY",
  "COMMUNITY NOTES: THIS IS FKNG REAL",
  "NOT YOUR FKNG ECHO CHAMBER",
  "GIGACHAD MOVE: BE FKNG AUTHENTIC",
  "COZY POSTING ONLY FR FR",
  "BLOATMAXXING THE FKNG TRUTH",
  "IT'S GIVING FKNG AUTHENTIC",
  "REAL ONES KNOW FR FR NO CAP",
  "DIDN'T ASK + RATIO + GET REAL",
  "SKILL ISSUE? NAH, AUTHENTICITY ISSUE",
  "NOT THE FKNG ALGORITHM 💀",
  "REAL POSTING (GONE RIGHT)",
  "WHO UP TOUCHING GRASS RN",
  "COMING FKNG SOON™",
  "FKNG IS THE NEW BLACK",
  "NO FKNG FAKE NEWS",
  `NO "CONTENT" HERE. JUST REAL TALK`,
  `CREATORS CAN GO FKNG HOME. THIS IS FOR REAL PEOPLE`,
];

const RandomSlogan = () => {
  const [slogan, setSlogan] = useState(slogans[0]); // Start with a default slogan
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
    setSlogan(slogans[Math.floor(Math.random() * slogans.length)]);
  }, []);

  // During SSR, show the default first slogan
  if (!isClient) {
    return <p className={styles.slogan}>{slogans[0]}</p>;
  }

  return <p className={styles.slogan}>{slogan}</p>;
};

export default RandomSlogan;
</file>

<file path="pages/index.tsx">
import type { NextPage } from "next";
import Image from "next/image";
import styles from "../styles/Home.module.css";
import { FaGithub, FaTwitter } from "react-icons/fa";
import { IoIosMail } from "react-icons/io";
import FKNGHead from "../components/Head";
import RandomSlogan from "../components/RandomSlogan";

const Home: NextPage = () => {
  return (
    <div className={styles.container}>
      <FKNGHead />

      <div className={styles.main}>
        <div className={styles.content}>
          <h1 className={styles.logo}>FKNG.SOCIAL</h1>
          <RandomSlogan />
        </div>
        <div className={styles.social}>
          <a href="mailto:contact@fkng.pro" rel="noreferrer" title="email">
            <IoIosMail size={20} />
          </a>
        </div>
      </div>
    </div>
  );
};

export default Home;
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  poweredByHeader: false,
  reactStrictMode: true,
  output: "export", // Changed from 'standalone' to 'export' for static site generation
  images: {
    unoptimized: true, // Required for static export
  },
};

module.exports = nextConfig;
</file>

<file path="package.json">
{
  "name": "fkng",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build && next-sitemap",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "^14.1.0",
    "next-sitemap": "^4.2.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.0.1"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8.56.0",
    "eslint-config-next": "^14.1.0",
    "typescript": "^5.3.3"
  }
}
</file>

</files>
</file>

<file path="src/components/modals/SendModal.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { isAddress, parseUnits, formatUnits, encodeFunctionData, type Address, type Hash } from "viem";
import { BaseTxModal } from "./BaseTxModal";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, ERC20_ABI } from "@/lib/constants";

interface SendModalProps {
  isOpen: boolean;
  onClose: () => void;
  tokenSymbol: string;
  tokenAddress?: Address; // Undefined for native GHO
  decimals: number;
  balance?: bigint; // Optional: for validation against available balance
}

export function SendModal({ isOpen, onClose, tokenSymbol, tokenAddress, decimals, balance }: SendModalProps) {
  const [recipient, setRecipient] = useState("");
  const [amount, setAmount] = useState("");
  const [inputError, setInputError] = useState<string | null>(null);

  const { lensAccountAddress } = useLensAccount();
  const { address: ownerAddress, chainId } = useAccount();
  const { data: hash, error: writeError, isPending: isWritePending, writeContract, reset } = useWriteContract();

  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
  } = useWaitForTransactionReceipt({
    hash,
    chainId: LENS_CHAIN_ID,
  });

  const isLoading = isWritePending || isConfirming;
  const txError = writeError || receiptError;

  // Reset form when modal opens or closes
  useEffect(() => {
    if (isOpen) {
      setRecipient("");
      setAmount("");
      setInputError(null);
      reset(); // Reset wagmi state
    }
  }, [isOpen, reset]);

  // Validate and prepare transaction
  const handleSend = () => {
    setInputError(null);

    // Basic input validation
    if (!isAddress(recipient)) {
      setInputError("Invalid recipient address");
      return;
    }
    if (!amount || parseFloat(amount) <= 0) {
      setInputError("Invalid amount");
      return;
    }
    if (!lensAccountAddress || !ownerAddress) {
      setInputError("Wallet not connected");
      return;
    }
    if (chainId !== LENS_CHAIN_ID) {
      setInputError(`Please switch to Lens Chain (ID: ${LENS_CHAIN_ID})`);
      return;
    }

    try {
      const amountBigInt = parseUnits(amount, decimals);

      // Optional balance validation
      if (balance !== undefined && amountBigInt > balance) {
        setInputError("Insufficient balance");
        return;
      }

      let targetAddress: Address;
      let txValue: bigint;
      let txData: Hash;

      if (tokenAddress) {
        // ERC20 token transfer
        targetAddress = tokenAddress;
        txValue = 0n;
        txData = encodeFunctionData({
          abi: ERC20_ABI,
          functionName: "transfer",
          args: [recipient as Address, amountBigInt],
        });
      } else {
        // Native GHO transfer
        targetAddress = recipient as Address;
        txValue = amountBigInt;
        txData = "0x";
      }

      console.log("Sending via executeTransaction:", {
        target: targetAddress,
        value: txValue.toString(),
        data: txData,
        type: tokenAddress ? "ERC20" : "Native",
      });

      writeContract({
        address: lensAccountAddress,
        abi: LENS_ACCOUNT_ABI,
        functionName: "executeTransaction",
        args: [targetAddress, txValue, txData],
        account: ownerAddress,
        chainId: LENS_CHAIN_ID,
      });
    } catch (e) {
      console.error("Transaction preparation failed:", e);
      setInputError("Failed to prepare transaction");
    }
  };

  return (
    <BaseTxModal
      isOpen={isOpen}
      onClose={onClose}
      title={`Send ${tokenSymbol}`}
      isLoading={isLoading}
      isSuccess={isConfirmed}
      error={txError}
      txHash={hash}
      disableClose={isLoading} // Prevent closing during transaction
    >
      <div className="space-y-4">
        {/* Recipient Input */}
        <div>
          <label htmlFor="recipient" className="block text-sm font-medium text-gray-700 mb-1">
            Recipient Address
          </label>
          <input
            id="recipient"
            type="text"
            value={recipient}
            onChange={(e) => setRecipient(e.target.value.trim())}
            placeholder="0x..."
            disabled={isLoading}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
          />
        </div>

        {/* Amount Input */}
        <div>
          <label htmlFor="amount" className="block text-sm font-medium text-gray-700 mb-1">
            Amount ({tokenSymbol})
          </label>
          <input
            id="amount"
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            placeholder="0.0"
            min="0"
            step="any"
            disabled={isLoading}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
          />
          {balance !== undefined && (
            <p className="text-xs text-gray-500 mt-1">
              Available: {formatUnits(balance, decimals)} {tokenSymbol}
            </p>
          )}
        </div>

        {/* Error Display */}
        {inputError && <p className="text-sm text-red-600 bg-red-50 p-2 rounded">{inputError}</p>}

        {/* Send Button */}
        <button
          onClick={handleSend}
          disabled={isLoading || isConfirmed || !recipient || !amount}
          className="w-full px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? "Sending..." : isConfirmed ? "Sent!" : `Send ${tokenSymbol}`}
        </button>
      </div>
    </BaseTxModal>
  );
}
</file>

<file path="src/components/ConnectOwnerButton.tsx">
// components/ConnectOwnerButton.tsx
"use client";

import { ConnectKitButton } from "connectkit";

export function ConnectOwnerButton() {
  return (
    <div className="flex justify-center">
      <ConnectKitButton />
    </div>
  );
}
</file>

<file path="src/hooks/useDebounce.ts">
// hooks/useDebounce.ts
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Update debounced value after delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cancel the timeout if value changes (also on delay change or unmount)
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]); // Only re-call effect if value or delay changes

  return debouncedValue;
}
</file>

<file path="src/styles/globals.css">
@import "tailwindcss" source("../**/*.{js,ts,jsx,tsx,mdx}");

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
} */

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path=".dockerignore">
.git
.gitignore
.next
.husky
node_modules
README.md
.env*
npm-debug.log*
pnpm-debug.log*
.DS_Store
.vscode
*.pem
.cursor
tsconfig.tsbuildinfo
llms
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".prettierrc">
{
  "printWidth": 150
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
# Lens Account Web Interface

This project is a web application designed to provide an interface for interacting with a custom EVM Smart Account, specifically the "Lens Account". It allows the account owner to connect their controlling EOA wallet, view basic account information, and interact with external dApps _through_ the Lens Account using WalletConnect v2 via Reown WalletKit.

This is the Minimum Viable Product (MVP) focusing on core functionality as outlined in the project specifications.

## Tech Stack

- **Framework:** Next.js 15+ (App Router)
- **Language:** TypeScript
- **Styling:** Tailwind CSS
- **Package Manager:** pnpm
- **Core Web3 Libraries:**
  - Wagmi
  - Viem
  - ConnectKit
  - @reown/walletkit (for WalletConnect v2 Wallet functionality)
  - @tanstack/react-query (peer dependency for Wagmi)

## Prerequisites

- Node.js (v18.17 or later recommended)
- pnpm

## Getting Started

1.  **Clone the repository (if applicable):**

    ```bash
    git clone <repository-url>
    cd lens-account-interface
    ```

2.  **Install dependencies:**

    ```bash
    pnpm install
    ```

3.  **Set up Environment Variables:**
    Create a `.env.local` file in the root of the project. You **must** obtain a Project ID from [WalletConnect Cloud](https://cloud.walletconnect.com/).

    ```plaintext [.env.local]
    # Get your ID from https://cloud.walletconnect.com/
    NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=YOUR_WALLETCONNECT_PROJECT_ID_HERE
    ```

    Replace `YOUR_WALLETCONNECT_PROJECT_ID_HERE` with your actual Project ID.

4.  **Run the development server:**
    ```bash
    pnpm dev
    ```
    Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Available Scripts

In the project directory, you can run:

- `pnpm dev`: Runs the app in development mode. Open [http://localhost:3000](http://localhost:3000).
- `pnpm build`: Builds the app for production.
- `pnpm start`: Starts the production server.
- `pnpm lint`: Runs ESLint.

## Project Structure

The project uses the Next.js App Router. Key directories will include:

- `app/`: Contains application routes and layouts.
- `components/`: Reusable React components.
- `contexts/`: React Context providers for managing shared state.
- `hooks/`: Custom React Hooks for specific logic.
- `lib/`: Configuration files (Wagmi, constants) and utility functions.
- `services/`: Abstraction layers for external SDKs (e.g., Reown WalletKit).
- `styles/`: Global styles and Tailwind configuration.

_(Refer to the Technical Specification for a more detailed proposed structure)._

## Contributing

_(Placeholder: Add contribution guidelines here when applicable)._

## License

_(Placeholder: Add license information here when applicable)._
</file>

<file path="Spec.functional.md">
# Functional Specification: Lens Account Web Interface - MVP (Iteration 1)

## 1. Introduction

This document outlines the functional requirements for the Minimum Viable Product (MVP) of a web interface designed to interact with a custom EVM Smart Accoun - Lens Account. Users (Owners) will be able to identify their Lens Account, connect their controlling EOA wallet, view a basic balance, and use WalletConnect v2 to interact with external dApps _through_ the Lens Account.

## 2. Target Audience

This specification is intended for developers, QA testers, and product managers involved in building the MVP.

## 3. Key Concepts

- **Lens Account:** The EVM smart contract wallet being managed. It has a single `owner()` address.
- **Owner EOA:** The Externally Owned Account (e.g., MetaMask, hardware wallet address) designated as the `owner()` of the Lens Account. This wallet is used to authorize actions _for_ the Lens Account.
- **Lens Username:** A username potentially linked to a Lens Account address via the `LensGlobalNamespace` contract.
- **WalletConnect (WC):** A protocol allowing wallets (in this case, our interface acting _as_ a wallet for the Lens Account) to connect to dApps.
- **Lens Chain:** The specific blockchain (ID 232) where the Lens Account and related contracts reside.

## 4. Core Scenarios (MVP)

### Scenario 1: Account Discovery and Owner Login

**Goal:** The user identifies their target Lens Account using either a Lens username or the account address and connects their corresponding Owner EOA wallet, ensuring they are on the correct network.

**Steps:**

1.  **Initial View:** The user accesses the web application's main entry page (`/`).
2.  **Input Fields:** The user is presented with two input fields:
    - "Lens Username"
    - "Account Address"
3.  **Username Input (User Action):**
    - The user types a Lens username into the "Lens Username" field.
    - **(App Action):** As the user types (debounced), the application queries the `LensGlobalNamespace` contract on the Lens Chain using the `accountOf(string calldata name)` function.
    - **(Outcome):**
      - If an address is returned, the "Account Address" field is automatically populated with the resolved address.
      - If no address is found (or an error occurs), the "Account Address" field remains empty or clears, and subtle feedback may be shown (e.g., input border color change).
4.  **Address Input (User Action):**
    - The user types or pastes an address into the "Account Address" field.
    - **(App Action):** As the user types/pastes, the application checks until address length & format is correct (0x + 20 chars) and queries the `LensGlobalNamespace` contract on the Lens Chain using the `usernameOf(address user)` function.
    - **(Outcome):**
      - If a username is returned, the "Lens Username" field is populated.
      - If no username is found, the "Lens Username" field remains empty or clears.
5.  **Owner Verification (App Action):**
    - Once a valid address exists in the "Account Address" field, the application queries the Lens Account contract at that address using the `owner()` function.
    - The application stores the returned `owner` address internally as the _expected owner_.
6.  **Wallet Connection (User Action):**
    - A "Connect Wallet" button becomes enabled/visible once an Account Address is determined.
    - The expected owner is also displayed above the Connect Wallet button with some text (something like "To Login - connect with this Owner wallet:" but proper).
    - The user clicks "Connect Wallet".
    - **(App Action):** A standard wallet connection modal (e.g., RainbowKit) appears, prompting the user to choose and connect their Owner EOA wallet.
    - **(App Action):** The application checks if the connected Owner EOA wallet is currently on the **Lens Chain (ID: 232)**.
    - **(Outcome - Chain Mismatch):**
      - If the wallet is on a different chain, the application (via `wagmi`/`RainbowKit`) prompts the user to switch to the Lens Chain.
      - If the Lens Chain is not configured in the user's wallet, the application prompts the user to add it.
      - The connection process pauses until the wallet is successfully connected to the Lens Chain.
    - **(App Action):** Once the Owner EOA is connected and on the Lens Chain, the application compares the connected wallet's address with the _expected owner_ address stored in step 5.b.
    - **(Outcome - Owner Mismatch):**
      - If the addresses do _not_ match, an error message is displayed clearly indicating the mismatch (e.g., "Incorrect owner connected. Please connect with address: `0x...{expectedOwnerAddress}`").
      - The user remains on the login/discovery page and can attempt to connect a different wallet.
    - **(Outcome - Success):**
      - If the addresses _match_ and the wallet is on the Lens Chain, the user is authenticated for this session.
      - The application navigates the user to the main Dashboard page (e.g., `/dashboard`).

### Scenario 2: Viewing Dashboard & Initiating WalletConnect Pairing

**Goal:** The user views basic account information and connects the Lens Account to an external dApp using a WalletConnect URI.

**Preconditions:**

- User has successfully completed Scenario 1.
- Owner EOA wallet is connected and verified.
- User is on the Dashboard page.

**Steps:**

1.  **Dashboard View:** The user sees the Dashboard.
2.  **Account Info Display (App Action):**
    - The Lens Account address is displayed.
    - The WGHO token balance for the Lens Account is fetched and displayed (formatted).
3.  **WalletConnect Input:** The user sees a dedicated section/component for WalletConnect containing:
    - An input field labeled "Paste WalletConnect Code".
    - A "Connect" button next to the input field.
4.  **Obtain WC URI (User Action):** The user navigates to an external dApp (e.g., Aave) and initiates a WalletConnect connection, copying the generated WC v2 URI (e.g., `wc:abc...`).
5.  **Paste & Connect (User Action):**
    - The user pastes the WC URI into the input field in _this_ web app.
    - The user clicks the "Connect" button.
6.  **Pairing & Session (App Action):**
    - The application uses the `@walletconnect/web3wallet` SDK to initiate pairing with the provided URI.
    - The SDK emits a `session_proposal` event.
    - The application automatically approves the session proposal using the Lens Account's address, enforcing Lens Chain (ID: 232) as the only supported chain regardless of dApp's requested chains.
    - The WalletConnect session is established between this interface (acting for the Lens Account) and the external dApp.
    - The input field clears and the WalletConnect section updates to show:
      - A prominent "Connected" status indicator in green
      - Connected dApp information from the session data:
        - dApp name and icon
        - Website URL
        - Connected chain (should always show Lens Chain)
        - Session ID (for debugging purposes)

### Scenario 3: Handling WalletConnect Transaction Requests

**Goal:** The user receives a transaction request from a connected external dApp and authorizes its execution via their Owner EOA.

**Preconditions:**

- User has successfully completed Scenario 1 & 2.
- An active WalletConnect session exists between the Lens Account interface and an external dApp.

**Steps:**

1.  **Request Initiation (External Action):** The user performs an action on the external dApp that requires a transaction (e.g., depositing collateral on Aave).
2.  **Request Reception (App Action):**
    a. The external dApp sends a request (typically `eth_sendTransaction` containing `to`, `value`, `data`) over the established WC session.
    b. The `@walletconnect/web3wallet` SDK listener in the application receives the `session_request` event.
3.  **Request Display:**
    - The application updates its state to indicate a pending request.
    - A dedicated component (`WcRequestDisplay`) appears on the Dashboard, showing:
      - The requesting dApp's name/icon (from session metadata).
      - The transaction details:
        - **Target Address (`to`):** The contract the Lens Account will call.
        - **Value (`value`):** Amount of native currency (GHO) to send (formatted).
        - **Data (`data`):** The raw calldata for the transaction. (MVP: Display raw hex data. Decoding can be added later).
      - A "Send Transaction" button.
      - A "Reject" button (optional for MVP, but good practice).
4.  **User Review & Action:**
    - The user reviews the displayed transaction details.
    - **(Option A - Send):** The user clicks "Send Transaction".
    - **(App Action - Execute):**
      - The application prepares the call to the Lens Account's `executeTransaction(address target, uint256 value, bytes calldata data)` function, using the parameters from the WC request.
      - It triggers the transaction using `wagmi`.
      - The connected **Owner EOA wallet** (MetaMask, etc.) prompts the user to confirm _this_ transaction (the one calling `executeTransaction` on the Lens Account).
      - **(User Action):** The user confirms the transaction in their EOA wallet.
      - The transaction is sent to the Lens Chain network.
      - The application waits for the transaction hash.
      - Upon receiving the hash, the application sends a _success response_ containing the transaction hash back to the external dApp via the WalletConnect session (`web3wallet.respondSessionRequest`).
      - The `WcRequestDisplay` component is hidden or updated.
      - A success indicator (e.g., checkmark, brief message "Transaction Submitted") is displayed on the dashboard.
    - **(Option B - Reject):** The user clicks "Reject" (if implemented).
    - **(App Action - Reject):**
      - The application sends an _error response_ (e.g., user rejection error) back to the external dApp via the WalletConnect session.
      - The `WcRequestDisplay` component is hidden.

### Scenario 4: Handling Errors during WC Request Execution

**Goal:** Inform the user and the external dApp if an error occurs during the authorization or sending of a WC transaction request.

**Steps (Owner Rejection):**

1.  Follow Scenario 3 up to step 4.c.iii (Owner EOA wallet prompt).
2.  **User Action:** User explicitly rejects the transaction in their wallet.
3.  **(App Action):** The `wagmi` transaction hook/promise rejects with a user rejection error.
4.  The application sends an _error response_ (user rejection) back to the external dApp via WalletConnect.
5.  The `WcRequestDisplay` component is hidden.
6.  An error message is displayed on the dashboard (e.g., "Transaction rejected by user").

**Steps (Blockchain Error):**

1.  Follow Scenario 3 up to step 4.c.v (Transaction sent).
2.  **(Blockchain Action):** The transaction execution _fails_ on the Lens Chain (e.g., reverts).
3.  **(App Action):** The `wagmi` transaction hook/promise resolves with a failed status (or requires checking the receipt).
4.  The application sends an _error response_ (generic execution error) back to the external dApp via WalletConnect.
5.  The `WcRequestDisplay` component is hidden.
6.  An error message is displayed on the dashboard (e.g., "Transaction failed on-chain").

## 5. Non-Functional Requirements (MVP)

- **Target Network:** The application MUST operate exclusively on the Lens Chain Mainnet (ID: 232). Network configuration should reflect this.
- **Responsiveness:** The UI should be usable on standard desktop browsers. Mobile responsiveness is secondary for the MVP.
- **Error Handling:** Basic error messages should be displayed for contract call failures, lookup failures, WC connection issues, and incorrect owner connections.
- **Performance:** Interactions (lookups, balance fetches) should feel reasonably responsive. Debouncing should be used for inputs triggering lookups.

## 6. Out of Scope (MVP - Iteration 1)

- Displaying Transaction History or Queue (beyond the currently active WC request).
- Initiating _new_ transactions (e.g., Send ETH/Token) directly from the UI.
- Managing Lens Account settings (Owners, Threshold).
- Detailed decoding of transaction data within the WC request display.
- Address Book functionality.
- NFT display or management.
- Advanced WalletConnect session management (listing active sessions, manual disconnection).
- Gas controls or advanced transaction parameters.
- Support for multiple Lens Account types or versions beyond the specific one targeted.
- Account Manager roles.
- Push notifications or complex real-time updates beyond basic WC request handling.

## 7. Lens Chain Details

- **Chain Type:** ZkSync-based L2, EVM-compatible
- **Network Name:** Lens Chain Mainnet
- **New RPC URL:** https://rpc.lens.xyz
- **Chain ID:** 232
- **Currency Symbol:** GHO
- **Block Explorer URL:** https://explorer.lens.xyz
</file>

<file path="src/components/modals/ApproveModal.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { isAddress, parseUnits, encodeFunctionData, type Address, maxUint256 } from "viem";
import { BaseTxModal } from "./BaseTxModal";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, ERC20_ABI } from "@/lib/constants";

interface ApproveModalProps {
  isOpen: boolean;
  onClose: () => void;
  tokenSymbol: string;
  tokenAddress: Address;
  decimals: number;
}

export function ApproveModal({ isOpen, onClose, tokenSymbol, tokenAddress, decimals }: ApproveModalProps) {
  const [spender, setSpender] = useState("");
  const [amount, setAmount] = useState("");
  const [isInfinite, setIsInfinite] = useState(false);
  const [inputError, setInputError] = useState<string | null>(null);

  const { lensAccountAddress } = useLensAccount();
  const { address: ownerAddress, chainId } = useAccount();
  const { data: hash, error: writeError, isPending: isWritePending, writeContract, reset } = useWriteContract();

  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
  } = useWaitForTransactionReceipt({
    hash,
    chainId: LENS_CHAIN_ID,
  });

  const isLoading = isWritePending || isConfirming;
  const txError = writeError || receiptError;

  // Reset form when modal opens/closes
  useEffect(() => {
    if (isOpen) {
      setSpender("");
      setAmount("");
      setIsInfinite(false);
      setInputError(null);
      reset();
    }
  }, [isOpen, reset]);

  const handleApprove = () => {
    setInputError(null);

    // Input validation
    if (!isAddress(spender)) {
      setInputError("Invalid spender address");
      return;
    }
    if (!isInfinite && (!amount || parseFloat(amount) <= 0)) {
      setInputError("Please enter a valid amount or use infinite approval");
      return;
    }
    if (!lensAccountAddress || !ownerAddress) {
      setInputError("Wallet not connected");
      return;
    }
    if (chainId !== LENS_CHAIN_ID) {
      setInputError(`Please switch to Lens Chain (ID: ${LENS_CHAIN_ID})`);
      return;
    }

    try {
      const amountBigInt = isInfinite ? maxUint256 : parseUnits(amount, decimals);

      const txData = encodeFunctionData({
        abi: ERC20_ABI,
        functionName: "approve",
        args: [spender as Address, amountBigInt],
      });

      console.log("Preparing approval via executeTransaction:", {
        token: tokenAddress,
        spender,
        amount: isInfinite ? "MAX_UINT256" : amount,
        txData,
      });

      writeContract({
        address: lensAccountAddress,
        abi: LENS_ACCOUNT_ABI,
        functionName: "executeTransaction",
        args: [tokenAddress, 0n, txData],
        account: ownerAddress,
        chainId: LENS_CHAIN_ID,
      });
    } catch (e) {
      console.error("Transaction preparation failed:", e);
      setInputError("Failed to prepare transaction");
    }
  };

  return (
    <BaseTxModal
      isOpen={isOpen}
      onClose={onClose}
      title={`Approve ${tokenSymbol} Spending`}
      isLoading={isLoading}
      isSuccess={isConfirmed}
      error={txError}
      txHash={hash}
      disableClose={isLoading}
    >
      <div className="space-y-4">
        {/* Spender Input */}
        <div>
          <label htmlFor="spender" className="block text-sm font-medium text-gray-700 mb-1">
            Spender Address
          </label>
          <input
            id="spender"
            type="text"
            value={spender}
            onChange={(e) => setSpender(e.target.value.trim())}
            placeholder="0x..."
            disabled={isLoading}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
          />
          <p className="mt-1 text-xs text-gray-500">The address that will be allowed to spend your {tokenSymbol}</p>
        </div>

        {/* Amount Input */}
        <div>
          <label htmlFor="amount" className="block text-sm font-medium text-gray-700 mb-1">
            Amount ({tokenSymbol})
          </label>
          <input
            id="amount"
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            placeholder="0.0"
            min="0"
            step="any"
            disabled={isLoading || isInfinite}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
          />

          {/* Infinite Approval Toggle */}
          <div className="mt-2 flex items-center">
            <input
              id="infinite"
              type="checkbox"
              checked={isInfinite}
              onChange={(e) => {
                setIsInfinite(e.target.checked);
                if (e.target.checked) setAmount("");
              }}
              disabled={isLoading}
              className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
            />
            <label htmlFor="infinite" className="ml-2 text-sm text-gray-700">
              Infinite Approval
            </label>
            <span className="ml-1 text-xs text-gray-500">(Maximum possible amount)</span>
          </div>
        </div>

        {/* Warning for Infinite Approval */}
        {isInfinite && (
          <div className="text-sm text-amber-600 bg-amber-50 p-3 rounded-md">
            ⚠️ Infinite approval grants unlimited spending permission to the spender address. Only use this with trusted contracts and platforms.
          </div>
        )}

        {/* Error Display */}
        {inputError && <p className="text-sm text-red-600 bg-red-50 p-2 rounded">{inputError}</p>}

        {/* Approve Button */}
        <button
          onClick={handleApprove}
          disabled={isLoading || isConfirmed || !spender || (!isInfinite && !amount)}
          className="w-full px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? "Approving..." : isConfirmed ? "Approved!" : `Approve ${tokenSymbol}`}
        </button>
      </div>
    </BaseTxModal>
  );
}
</file>

<file path="src/components/modals/BaseTxModal.tsx">
"use client";

import React, { ReactNode, useEffect, useState } from "react";
import { XMarkIcon, ExclamationTriangleIcon, CheckCircleIcon, ArrowPathIcon } from "@heroicons/react/24/solid";
import { type Hash } from "viem";

interface BaseTxModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: ReactNode; // Content specific to the modal type
  isLoading: boolean;
  isSuccess: boolean;
  error: Error | null;
  txHash?: Hash | null; // Optional transaction hash
  disableClose?: boolean; // Optional: prevent closing during transaction
}

export function BaseTxModal({ isOpen, onClose, title, children, isLoading, isSuccess, error, txHash, disableClose = false }: BaseTxModalProps) {
  const [countdown, setCountdown] = useState(5);

  // Auto-close after success
  useEffect(() => {
    if (isSuccess) {
      const timer = setTimeout(() => {
        onClose();
      }, 5000); // 5 seconds
      return () => clearTimeout(timer);
    }
  }, [isSuccess, onClose]);

  // Countdown effect
  useEffect(() => {
    if (isSuccess && countdown > 0) {
      const interval = setInterval(() => {
        setCountdown((prev) => prev - 1);
      }, 1000);
      return () => clearInterval(interval);
    }
  }, [isSuccess, countdown]);

  // Reset countdown when modal opens/closes
  useEffect(() => {
    setCountdown(5);
  }, [isOpen]);

  if (!isOpen) return null;

  const handleClose = () => {
    if (!disableClose && !isLoading) {
      onClose();
    }
  };

  let statusMessage = null;
  if (isLoading) {
    statusMessage = (
      <div className="flex items-center justify-center text-indigo-600 text-sm mt-3 p-2 bg-indigo-50 rounded">
        <ArrowPathIcon className="w-4 h-4 mr-1 animate-spin" />
        Processing transaction... Check your wallet.
      </div>
    );
  } else if (isSuccess) {
    statusMessage = (
      <div className="flex items-center justify-center text-green-600 text-sm mt-3 p-2 bg-green-50 rounded">
        <CheckCircleIcon className="w-4 h-4 mr-1" />
        Transaction successful!
        {txHash && (
          <a
            href={`https://explorer.lens.xyz/tx/${txHash}`}
            target="_blank"
            rel="noopener noreferrer"
            className="ml-1 underline hover:text-green-800"
          >
            View on Explorer
          </a>
        )}
        <span className="ml-2 text-gray-500">(Closing in {countdown}s)</span>
      </div>
    );
  } else if (error) {
    statusMessage = (
      <div className="flex items-center justify-center text-red-600 text-sm mt-3 p-2 bg-red-50 rounded">
        <ExclamationTriangleIcon className="w-4 h-4 mr-1" />
        Error: {error.message?.split("(")?.[0]?.trim() || "Unknown error"} {/* Show concise error with fallback */}
      </div>
    );
  }

  return (
    <div className="fixed inset-0 backdrop-blur-sm bg-black/50 flex items-center justify-center z-50" onClick={handleClose}>
      <div className="bg-white p-6 rounded-lg shadow-xl relative max-w-lg w-full mx-4" onClick={(e) => e.stopPropagation()}>
        <button
          onClick={handleClose}
          disabled={disableClose || isLoading}
          className={`absolute top-3 right-3 ${disableClose || isLoading ? "text-gray-300 cursor-not-allowed" : "text-gray-400 hover:text-gray-600"}`}
          aria-label="Close modal"
        >
          <XMarkIcon className="w-6 h-6" />
        </button>

        <h3 className="text-xl font-semibold mb-4 text-gray-800 pr-8">{title}</h3>

        {/* Modal specific content */}
        <div className="space-y-4">{children}</div>

        {/* Status Message Area */}
        <div className="min-h-[40px] mt-4">{statusMessage}</div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/modals/QrCodeModal.tsx">
"use client";

import React from "react";
import { QRCodeSVG } from "qrcode.react";
import { type Address } from "viem";
import { XMarkIcon } from "@heroicons/react/24/solid";

interface QrCodeModalProps {
  address: Address;
  isOpen: boolean;
  onClose: () => void;
}

export function QrCodeModal({ address, isOpen, onClose }: QrCodeModalProps) {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 backdrop-blur-sm bg-black/50 flex items-center justify-center z-50" onClick={onClose}>
      <div className="bg-white p-6 rounded-lg shadow-xl relative max-w-sm w-full mx-4 text-center" onClick={(e) => e.stopPropagation()}>
        <button onClick={onClose} className="absolute top-3 right-3 text-gray-400 hover:text-gray-600" aria-label="Close modal">
          <XMarkIcon className="w-6 h-6" />
        </button>
        <h3 className="text-xl font-semibold mb-4 text-gray-800 pr-8">Receive Funds</h3>
        <p className="text-sm text-gray-600 mb-4 break-all">Scan this QR code or copy the address below.</p>
        <div className="flex justify-center mb-6">
          <QRCodeSVG value={address} size={250} level="H" includeMargin={true} />
        </div>
        <p className="text-xs font-mono bg-gray-100 p-2 rounded border break-all">{address}</p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/modals/UnwrapModal.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { parseUnits, formatUnits, encodeFunctionData, type Address } from "viem";
import { BaseTxModal } from "./BaseTxModal";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, WGHO_TOKEN_ADDRESS, WGHO_ABI, lensChain } from "@/lib/constants";

interface UnwrapModalProps {
  isOpen: boolean;
  onClose: () => void;
  balance?: bigint; // Optional: WGHO balance for validation
}

export function UnwrapModal({ isOpen, onClose, balance }: UnwrapModalProps) {
  const [amount, setAmount] = useState("");
  const [inputError, setInputError] = useState<string | null>(null);

  const { lensAccountAddress } = useLensAccount();
  const { address: ownerAddress, chainId } = useAccount();
  const { data: hash, error: writeError, isPending: isWritePending, writeContract, reset } = useWriteContract();

  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
  } = useWaitForTransactionReceipt({
    hash,
    chainId: LENS_CHAIN_ID,
  });

  const isLoading = isWritePending || isConfirming;
  const txError = writeError || receiptError;

  // Reset form when modal opens/closes
  useEffect(() => {
    if (isOpen) {
      setAmount("");
      setInputError(null);
      reset();
    }
  }, [isOpen, reset]);

  const handleUnwrap = () => {
    setInputError(null);

    // Input validation
    if (!amount || parseFloat(amount) <= 0) {
      setInputError("Please enter a valid amount");
      return;
    }
    if (!lensAccountAddress || !ownerAddress) {
      setInputError("Wallet not connected");
      return;
    }
    if (chainId !== LENS_CHAIN_ID) {
      setInputError(`Please switch to Lens Chain (ID: ${LENS_CHAIN_ID})`);
      return;
    }

    try {
      const amountBigInt = parseUnits(amount, lensChain.nativeCurrency.decimals);

      // Optional balance validation
      if (balance !== undefined && amountBigInt > balance) {
        setInputError("Insufficient WGHO balance");
        return;
      }

      const txData = encodeFunctionData({
        abi: WGHO_ABI,
        functionName: "withdraw",
        args: [amountBigInt],
      });

      console.log("Preparing unwrap via executeTransaction:", {
        target: WGHO_TOKEN_ADDRESS,
        value: "0",
        amount: amountBigInt.toString(),
        data: txData,
      });

      writeContract({
        address: lensAccountAddress,
        abi: LENS_ACCOUNT_ABI,
        functionName: "executeTransaction",
        args: [WGHO_TOKEN_ADDRESS as Address, 0n, txData],
        account: ownerAddress,
        chainId: LENS_CHAIN_ID,
      });
    } catch (e) {
      console.error("Transaction preparation failed:", e);
      setInputError("Failed to prepare transaction");
    }
  };

  return (
    <BaseTxModal
      isOpen={isOpen}
      onClose={onClose}
      title={`Unwrap WGHO to ${lensChain.nativeCurrency.symbol}`}
      isLoading={isLoading}
      isSuccess={isConfirmed}
      error={txError}
      txHash={hash}
      disableClose={isLoading}
    >
      <div className="space-y-4">
        {/* Amount Input */}
        <div>
          <label htmlFor="amount" className="block text-sm font-medium text-gray-700 mb-1">
            Amount (WGHO)
          </label>
          <input
            id="amount"
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            placeholder="0.0"
            min="0"
            step="any"
            disabled={isLoading}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
          />
          {balance !== undefined && (
            <p className="text-xs text-gray-500 mt-1">Available: {formatUnits(balance, lensChain.nativeCurrency.decimals)} WGHO</p>
          )}
        </div>

        {/* Information Box */}
        <div className="text-sm text-gray-600 bg-gray-50 p-3 rounded-md">
          Unwrapping converts your WGHO (Wrapped {lensChain.nativeCurrency.symbol}) back into native {lensChain.nativeCurrency.symbol}. This is useful
          when you need to use the native token for gas fees or other native transactions.
        </div>

        {/* Error Display */}
        {inputError && <p className="text-sm text-red-600 bg-red-50 p-2 rounded">{inputError}</p>}

        {/* Unwrap Button */}
        <button
          onClick={handleUnwrap}
          disabled={isLoading || isConfirmed || !amount}
          className="w-full px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? "Unwrapping..." : isConfirmed ? "Unwrapped!" : "Unwrap WGHO"}
        </button>
      </div>
    </BaseTxModal>
  );
}
</file>

<file path="src/components/modals/WrapModal.tsx">
"use client";

import React, { useState, useEffect } from "react";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { parseUnits, formatUnits, encodeFunctionData, type Address } from "viem";
import { BaseTxModal } from "./BaseTxModal";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, WGHO_TOKEN_ADDRESS, WGHO_ABI, lensChain } from "@/lib/constants";

interface WrapModalProps {
  isOpen: boolean;
  onClose: () => void;
  balance?: bigint; // Optional: native GHO balance for validation
}

export function WrapModal({ isOpen, onClose, balance }: WrapModalProps) {
  const [amount, setAmount] = useState("");
  const [inputError, setInputError] = useState<string | null>(null);

  const { lensAccountAddress } = useLensAccount();
  const { address: ownerAddress, chainId } = useAccount();
  const { data: hash, error: writeError, isPending: isWritePending, writeContract, reset } = useWriteContract();

  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
  } = useWaitForTransactionReceipt({
    hash,
    chainId: LENS_CHAIN_ID,
  });

  const isLoading = isWritePending || isConfirming;
  const txError = writeError || receiptError;

  // Reset form when modal opens/closes
  useEffect(() => {
    if (isOpen) {
      setAmount("");
      setInputError(null);
      reset();
    }
  }, [isOpen, reset]);

  const handleWrap = () => {
    setInputError(null);

    // Input validation
    if (!amount || parseFloat(amount) <= 0) {
      setInputError("Please enter a valid amount");
      return;
    }
    if (!lensAccountAddress || !ownerAddress) {
      setInputError("Wallet not connected");
      return;
    }
    if (chainId !== LENS_CHAIN_ID) {
      setInputError(`Please switch to Lens Chain (ID: ${LENS_CHAIN_ID})`);
      return;
    }

    try {
      const amountBigInt = parseUnits(amount, lensChain.nativeCurrency.decimals);

      // Optional balance validation
      if (balance !== undefined && amountBigInt > balance) {
        setInputError("Insufficient GHO balance");
        return;
      }

      // WGHO deposit() is called with value, no args needed
      const txData = encodeFunctionData({
        abi: WGHO_ABI,
        functionName: "deposit",
      });

      console.log("Preparing wrap via executeTransaction:", {
        target: WGHO_TOKEN_ADDRESS,
        value: amountBigInt.toString(),
        data: txData,
      });

      writeContract({
        address: lensAccountAddress,
        abi: LENS_ACCOUNT_ABI,
        functionName: "executeTransaction",
        args: [WGHO_TOKEN_ADDRESS as Address, amountBigInt, txData],
        account: ownerAddress,
        chainId: LENS_CHAIN_ID,
      });
    } catch (e) {
      console.error("Transaction preparation failed:", e);
      setInputError("Failed to prepare transaction");
    }
  };

  return (
    <BaseTxModal
      isOpen={isOpen}
      onClose={onClose}
      title={`Wrap ${lensChain.nativeCurrency.symbol} to WGHO`}
      isLoading={isLoading}
      isSuccess={isConfirmed}
      error={txError}
      txHash={hash}
      disableClose={isLoading}
    >
      <div className="space-y-4">
        {/* Amount Input */}
        <div>
          <label htmlFor="amount" className="block text-sm font-medium text-gray-700 mb-1">
            Amount ({lensChain.nativeCurrency.symbol})
          </label>
          <input
            id="amount"
            type="number"
            value={amount}
            onChange={(e) => setAmount(e.target.value)}
            placeholder="0.0"
            min="0"
            step="any"
            disabled={isLoading}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100"
          />
          {balance !== undefined && (
            <p className="text-xs text-gray-500 mt-1">
              Available: {formatUnits(balance, lensChain.nativeCurrency.decimals)} {lensChain.nativeCurrency.symbol}
            </p>
          )}
        </div>

        {/* Information Box */}
        <div className="text-sm text-gray-600 bg-gray-50 p-3 rounded-md">
          Wrapping converts your native {lensChain.nativeCurrency.symbol} into WGHO (Wrapped {lensChain.nativeCurrency.symbol}), an ERC20 token that
          can be used in DeFi applications. You can unwrap back to native {lensChain.nativeCurrency.symbol} at any time.
        </div>

        {/* Error Display */}
        {inputError && <p className="text-sm text-red-600 bg-red-50 p-2 rounded">{inputError}</p>}

        {/* Wrap Button */}
        <button
          onClick={handleWrap}
          disabled={isLoading || isConfirmed || !amount}
          className="w-full px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isLoading ? "Wrapping..." : isConfirmed ? "Wrapped!" : `Wrap ${lensChain.nativeCurrency.symbol}`}
        </button>
      </div>
    </BaseTxModal>
  );
}
</file>

<file path="src/contexts/LensAccountContext.tsx">
// contexts/LensAccountContext.tsx
"use client";

import React, { createContext, useState, useContext, ReactNode } from "react";
import { type Address } from "viem";

interface LensAccountState {
  lensAccountAddress: Address | null;
  ownerAddress: Address | null;
  setVerifiedAccount: (lensAddress: Address, ownerAddress: Address) => void;
  clearAccount: () => void;
}

const LensAccountContext = createContext<LensAccountState | undefined>(undefined);

interface LensAccountProviderProps {
  children: ReactNode;
}

export function LensAccountProvider({ children }: LensAccountProviderProps) {
  const [lensAccountAddress, setLensAccountAddress] = useState<Address | null>(null);
  const [ownerAddress, setOwnerAddress] = useState<Address | null>(null);

  const setVerifiedAccount = (lensAddress: Address, verifiedOwnerAddress: Address) => {
    setLensAccountAddress(lensAddress);
    setOwnerAddress(verifiedOwnerAddress);
    console.log("Context Updated: Lens Account Set ->", lensAddress);
    console.log("Context Updated: Owner Set ->", verifiedOwnerAddress);
  };

  const clearAccount = () => {
    setLensAccountAddress(null);
    setOwnerAddress(null);
    console.log("Context Updated: Account Cleared");
  };

  const value = {
    lensAccountAddress,
    ownerAddress,
    setVerifiedAccount,
    clearAccount,
  };

  return <LensAccountContext.Provider value={value}>{children}</LensAccountContext.Provider>;
}

// Custom hook to use the context
export function useLensAccount() {
  const context = useContext(LensAccountContext);
  if (context === undefined) {
    throw new Error("useLensAccount must be used within a LensAccountProvider");
  }
  return context;
}
</file>

<file path="src/lib/wagmi.ts">
// lib/wagmi.ts
import { http, createConfig } from "wagmi";
import { getDefaultConfig } from "connectkit"; // Correct import
import { lensChain } from "./constants";

const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;

if (!projectId) {
  throw new Error("NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID is not set in .env.local");
}

export const config = createConfig(
  // Use ConnectKit's getDefaultConfig
  getDefaultConfig({
    // Correct function name
    // Required API Keys
    walletConnectProjectId: projectId,

    // Required App Info
    appName: "Lens Account Interface",
    appDescription: "Interact with your Lens Account",
    appUrl: typeof window !== "undefined" ? window.location.origin : "https://example.com",
    appIcon: "/favicon.ico",

    // Chains to support
    chains: [lensChain],

    // Transports (ensure http is configured for your chain)
    transports: {
      [lensChain.id]: http(lensChain.rpcUrls.default.http[0]),
    },

    // ssr: true, // Keep commented unless SSR hydration with cookies is needed
  }),
);

// Optional: Register config for global type inference
// declare module 'wagmi' {
//   interface Register {
//     config: typeof config
//   }
// }
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactStrictMode: false,
};

export default nextConfig;
</file>

<file path="Spec.technical.md">
# Technical Specification: Lens Account Web Interface - MVP (Iteration 1)

**Version:** 1.0
**Date:** 2024-10-27

---

## 1. Introduction

### 1.1. Purpose

This document provides the technical details necessary for the development of the Minimum Viable Product (MVP) of the Lens Account Web Interface. It outlines the technology stack, architecture, key components, APIs, data structures, and implementation details derived from the Functional Specification (`Spec.functional.md`).

### 1.2. Scope

The scope of this MVP is limited to the core scenarios defined in the Functional Specification:

1.  **Account Discovery & Owner Login:** Identifying a Lens Account via username or address, connecting the Owner EOA wallet, and verifying ownership on the Lens Chain.
2.  **Dashboard & WalletConnect Pairing:** Displaying basic Lens Account info (address, balance) and initiating WalletConnect v2 pairings with external dApps.
3.  **WalletConnect Transaction Handling:** Receiving transaction requests from dApps via WalletConnect and facilitating their execution through the Lens Account via the Owner EOA.
4.  **Basic Error Handling:** Managing connection and transaction errors.

Features listed as "Out of Scope" in the Functional Specification are not included in this technical plan.

---

## 2. Technology Stack

- **Framework:** Next.js 15+ (App Router recommended)
- **Language:** TypeScript
- **Core Web3 Libraries:**
  - **Wagmi:** v2.x - For React hooks interacting with Ethereum (account state, contract interaction via Owner EOA, chain state, ENS lookups if adapted).
  - **Viem:** v2.x - Used internally by Wagmi for low-level Ethereum operations (encoding, decoding, RPC calls, utilities). May be used directly for specific utilities if needed.
  - **ConnectKit:** Latest compatible version - For the Owner EOA wallet connection UI and simplifying the `useConnect` flow from Wagmi.
  - **@walletconnect/web3wallet:** Latest v2 compatible version - **Crucially**, this SDK is required for the application to act _as a wallet_ on behalf of the Lens Account when interacting with external dApps via WalletConnect. ConnectKit/Wagmi handle connecting the _Owner EOA_ to _this_ app; `@walletconnect/web3wallet` handles connecting _this_ app (representing the Lens Account) to _other_ dApps.
- **UI/Styling:**
  - **Tailwind CSS:** Recommended for utility-first styling to maintain simplicity and avoid heavy UI library dependencies for the MVP. Basic HTML elements (`input`, `button`, `div`, `p`, etc.) styled with Tailwind will suffice. No complex UI component library is necessary initially.
- **State Management:** React Context API / `useState` / `useReducer` for managing application state (e.g., connected owner, target Lens Account, WC sessions/requests). Avoid Redux/Zustand for MVP complexity unless state becomes unmanageable.
- **Linting/Formatting:** ESLint, Prettier (Standard Next.js setup).

**Note on EthersJS:** While Wagmi v1 used EthersJS, Wagmi v2 (used by ConnectKit) uses **Viem**. EthersJS is **not** expected to be a required dependency for this project based on the chosen stack. We will proceed assuming Viem is the primary low-level library.

---

## 3. Architecture

### 3.1. Overview

The application will be a single-page application (SPA) built with Next.js. The core logic will reside within React components and custom hooks.

- **Client-Side Rendering:** Given the heavy reliance on wallet interactions and real-time state, the application will primarily be client-side rendered. Server components might be used for static layout elements if desired, but core functionality requires client components (`"use client"`).
- **Wallet Connection Management:**
  - **Owner EOA Connection:** Managed by ConnectKit, utilizing Wagmi hooks (`useAccount`, `useConnect`, `useDisconnect`, `useSwitchChain`). State will be accessible via Wagmi's context/hooks.
  - **Lens Account WC Connection (Acting as Wallet):** Managed by a dedicated service/context (`WalletConnectService`) wrapping the `@walletconnect/web3wallet` SDK. This service will handle pairing, session proposals/approvals, request handling, and responses.
- **Contract Interaction:**
  - Reading Lens Account `owner()`: Uses Wagmi's `useReadContract`.
  - Reading `LensGlobalNamespace` (`accountOf`, `usernameOf`): Uses Wagmi's `useReadContract`.
  - Reading WGHO Balance: Uses Wagmi's `useReadContract` (ERC20 `balanceOf`).
  - Executing Lens Account Transactions (via Owner EOA): Uses Wagmi's `useWriteContract` targeting the Lens Account's `executeTransaction`.
- **State Management:** A combination of Wagmi's built-in state, local React component state (`useState`), and potentially 1-2 specific React Contexts (e.g., `WalletConnectContext` for managing WC sessions/requests, `LensAccountContext` for holding the target Lens Account address and owner).

### 3.2. Key Modules/Services

- **Wagmi Config (`lib/wagmi.ts`):** Central configuration for Wagmi/ConnectKit (chains, connectors, transports).
- **WalletConnect Service (`services/walletConnectService.ts`):** Singleton or context-provided class encapsulating `@walletconnect/web3wallet` logic (initialization, pairing, event listeners, session management, request/response handling).
- **Lens Contract Service (`services/lensService.ts`):** Optional utility functions abstracting the direct `useReadContract` calls for Lens Account `owner()`, `LensGlobalNamespace` lookups, and WGHO balance.

---

## 4. Project Structure (App Router Example)

```
src/
├── app/
│   ├── dashboard/             # Dashboard page (requires auth)
│   │   └── page.tsx
│   ├── layout.tsx             # Root layout (WagmiProvider, etc.)
│   └── page.tsx               # Root page (Login/Discovery View)
├── components/
│   ├── layout/                # Header, Footer, etc.
│   ├── ui/                    # Basic UI elements (Button, Input - if abstracting)
│   ├── AccountDisplay.tsx     # Shows Lens Account Address/Balance
│   ├── ConnectOwnerButton.tsx # Uses ConnectKit button/logic
│   ├── DiscoveryForm.tsx      # Username/Address input fields
│   ├── WcConnect.tsx          # WC URI input and connection status
│   └── WcRequestDisplay.tsx   # Displays incoming WC requests
├── contexts/
│   ├── WalletConnectProvider.tsx # Manages WC state/service
│   └── LensAccountProvider.tsx   # Manages target Lens Account state
├── hooks/
│   ├── useLensLookup.ts       # Custom hook for username/address lookups
│   └── useWcRequestHandler.ts # Custom hook for handling WC requests
├── services/
│   ├── walletConnectService.ts # Wrapper around @walletconnect/web3wallet
│   └── lensService.ts          # (Optional) Utilities for Lens contract reads
├── lib/
│   ├── wagmi.ts               # Wagmi/ConnectKit config
│   ├── constants.ts           # Chain info, contract addresses, ABIs
│   └── utils.ts               # Helper functions
├── public/
│   └── ...                    # Static assets
├── styles/
│   └── globals.css            # Tailwind directives
├── .env.local                 # Environment variables (WC Project ID)
├── next.config.mjs
├── package.json
├── tailwind.config.ts
└── tsconfig.json
```

---

## 5. Core Components & Logic Implementation

### 5.1. Scenario 1: Account Discovery and Owner Login (`/app/page.tsx`, `DiscoveryForm.tsx`, `ConnectOwnerButton.tsx`)

- **UI:** `DiscoveryForm.tsx` contains two `<input>` fields styled with Tailwind. `ConnectOwnerButton.tsx` wraps ConnectKit's logic.
- **State:** Local state (`useState`) in `DiscoveryForm.tsx` for input values. A shared state (Context or prop drilling from `page.tsx`) for the determined Lens Account address and expected owner address.
- **Logic (`useLensLookup.ts`, `DiscoveryForm.tsx`):**
  - Use `React.useEffect` with debouncing for input changes.
  - Inside `useEffect`, call `useReadContract` (Wagmi) targeting `LensGlobalNamespace` (`accountOf` or `usernameOf`). **Important:** Need to configure `useReadContract` specifically for Lens Chain (ID 232). Pass the `chainId` parameter.
  - Update the corresponding input field based on lookup results.
  - Once an address is confirmed, call `useReadContract` targeting the Lens Account address for the `owner()` function. Store the result as `expectedOwner`.
  - Display `expectedOwner` near the connect button.
- **Owner Connection (`ConnectOwnerButton.tsx`, `page.tsx`):**
  - Use `ConnectKitButton` component or `useConnect` (Wagmi) + `useAccount` (Wagmi). ConnectKit is simpler.
  - The `wagmi.ts` config must include the Lens Chain definition. ConnectKit/Wagmi will handle prompting the user to add/switch to the Lens Chain.
  - After connection, use `useAccount` hook (Wagmi) to get the `address` and `chainId`.
  - Compare `address` with `expectedOwner`.
  - If match and `chainId === 232`, navigate to `/dashboard` (e.g., using `next/navigation`'s `useRouter`). Store the Lens Account address and Owner EOA address in Context/State for the dashboard.
  - If mismatch, display an error message.

### 5.2. Scenario 2: Viewing Dashboard & Initiating WalletConnect Pairing (`/app/dashboard/page.tsx`, `AccountDisplay.tsx`, `WcConnect.tsx`, `WalletConnectProvider.tsx`, `services/walletConnectService.ts`)

- **UI:** `AccountDisplay.tsx` shows Lens address (from Context/State) and balance. `WcConnect.tsx` shows WC URI input/button initially, then connected dApp info.
- **State:** `WalletConnectContext` manages `Web3Wallet` instance, active sessions, and pairing state.
- **Logic:**
  - Fetch WGHO balance using `useReadContract` (Wagmi) targeting the ERC20 contract with the Lens Account address. Format using Viem's `formatUnits`.
  - In `WalletConnectProvider.tsx` (or on component mount):
    - Initialize `Web3Wallet` from `@walletconnect/web3wallet` using `projectId` from `.env.local`. Store the instance.
    - Set up listeners (`web3wallet.on('session_proposal', ...)` etc.) defined in `walletConnectService.ts`.
  - **Pairing (`WcConnect.tsx`, `walletConnectService.ts`):**
    - On "Connect" button click with URI: Call `web3wallet.core.pairing.pair({ uri })`.
  - **Session Approval (`walletConnectService.ts` listener):**
    - On `session_proposal` event:
      - Construct approved `namespaces` containing **only** the Lens Chain (`eip155:232`) and the Lens Account address (`eip155:232:0x...`). Include standard methods (`eth_sendTransaction`, `personal_sign`, etc.).
      - Call `web3wallet.approveSession({ id: proposal.id, namespaces })`.
      - Store the resulting session details in the `WalletConnectContext`.
      - Update UI state in `WcConnect.tsx` to show connected dApp info.

### 5.3. Scenario 3 & 4: Handling WalletConnect Transaction Requests (`/app/dashboard/page.tsx`, `WcRequestDisplay.tsx`, `useWcRequestHandler.ts`, `services/walletConnectService.ts`)

- **UI:** `WcRequestDisplay.tsx` conditionally renders when a request is pending in `WalletConnectContext`. Displays request details and Approve/Reject buttons.
- **State:** `WalletConnectContext` stores the current pending `session_request` event payload.
- **Logic:**
  - **Request Listener (`walletConnectService.ts`):**
    - On `session_request` event: Store the event payload (`topic`, `params`, `id`) in `WalletConnectContext` state.
  - **Transaction Execution (`WcRequestDisplay.tsx`, `useWcRequestHandler.ts`):**
    - On "Send Transaction" click:
      - Retrieve request details (`to`, `value`, `data`) from the context state.
      - Use Viem's `encodeFunctionData` to prepare the calldata for the Lens Account's `executeTransaction(address target, uint256 value, bytes calldata data)` function.
      - Call the `writeContract` mutation function returned by `useWriteContract` (Wagmi), providing:
        - `address`: The Lens Account address (from Context/State).
        - `abi`: The Lens Account ABI (including `executeTransaction`).
        - `functionName`: `'executeTransaction'`.
        - `args`: `[to, value, data]`.
        - `account`: The connected Owner EOA address (from `useAccount`).
        - `chainId`: Must be Lens Chain ID (232).
      - Handle `useWriteContract`'s `isPending`, `isSuccess`, `error` states.
      - If `isPending`, show loading state.
      - If `error`, call `web3wallet.respondSessionRequest` with an appropriate error payload (e.g., `{ code: 5000, message: 'User Rejected' }` or a generic error). Display error in UI. Clear the pending request state.
      - If `isSuccess` (meaning the _Owner EOA_ transaction was submitted), wait for the transaction receipt using `useWaitForTransactionReceipt` (Wagmi).
        - If the receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`. Display success in UI. Clear the pending request state.
        - If the receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a generic execution error payload. Display error in UI. Clear the pending request state.
    - On "Reject" button click:
      - Call `web3wallet.respondSessionRequest` with a user rejection error payload.
      - Clear the pending request state.

---

## 6. State Management

- **Wagmi:** Manages Owner EOA connection state (address, chainId, connector, connection status) and provides TanStack Query caching for reads.
- **LensAccountContext:** Stores the identified Lens Account address and the verified Owner EOA address upon successful login.
- **WalletConnectContext:** Stores the `@walletconnect/web3wallet` instance, active WC sessions (list/map), current pending WC request payload, and connection/pairing status flags.
- **Local Component State:** Used for form inputs, UI loading/error states within specific components.

---

## 7. Styling

- Utilize **Tailwind CSS** for styling all components.
- Keep styling minimal and functional for the MVP.
- Ensure basic layout structure (header, main content area).

---

## 8. Error Handling

- Implement `try...catch` blocks around critical operations (WC pairing, session approval, request responses).
- Utilize the `error` states returned by Wagmi hooks (`useReadContract`, `useWriteContract`, `useWaitForTransactionReceipt`).
- Display user-friendly error messages for common issues (network mismatch, incorrect owner, transaction rejection, WC errors, contract reverts). Log detailed errors to the console for debugging.
- Specifically handle WalletConnect SDK errors during pairing and session proposals.

---

## 9. Constants & Configuration

- **`lib/constants.ts`:**
  - `LENS_CHAIN_ID = 232`
  - `LENS_CHAIN_RPC_URL = 'https://rpc.lens.xyz'`
  - `LENS_CHAIN_EXPLORER_URL = 'https://explorer.lens.xyz'`
  - `LENS_CHAIN_CURRENCY = { name: 'GHO', symbol: 'GHO', decimals: 18 }`
  - `LENS_GLOBAL_NAMESPACE_ADDRESS = '0x1aA55B9042f08f45825dC4b651B64c9F98Af4615'`
  - `WGHO_TOKEN_ADDRESS = '0x6bDc36E20D267Ff0dd6097799f82e78907105e2F'` (Actual Address Needed)
  - `LENS_ACCOUNT_ABI = [...]` (Include `owner()`, `executeTransaction()`)
  - `LENS_GLOBAL_NAMESPACE_ABI = [...]` (Include `accountOf(string)`, `usernameOf(address)`)
  - `ERC20_ABI = [...]` (Include `balanceOf(address)`)
- **`lib/wagmi.ts`:**
  - Define the `lensChain` object using Viem's `defineChain`.
  - Configure `createConfig` (Wagmi) with `chains: [lensChain]`, necessary connectors (e.g., `injected`, `walletConnect`), and transports.
- **`.env.local`:**
  - `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=<Your_WC_Project_ID>` (Obtain from [cloud.walletconnect.com](https://cloud.walletconnect.com/))

---

## 10. Deployment

- Standard Next.js deployment process (e.g., Vercel, Netlify).
- Ensure environment variables (like `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`) are configured in the deployment environment.

---

## 11. Future Considerations (Post-MVP)

- Support for multiple Lens Account types/versions.
- Transaction history display.
- Direct sending of GHO/WGHO from the UI.
- More detailed transaction decoding for WC requests.
- Advanced error handling and user feedback.
- Mobile responsiveness improvements.
- Session management UI (disconnecting specific WC sessions).
- Support for additional WC methods (e.g., `personal_sign`).
- Potential integration of Safe SDKs if the Lens Account implements Safe compatibility layers.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/dashboard/layout.tsx">
// src/app/dashboard/layout.tsx
"use client"; // Context providers require client components

import { WalletConnectProvider } from "@/contexts/WalletConnectProvider";
// No need to import useLensAccount here if it's not used directly in this layout

// This layout wraps the content of `/dashboard/page.tsx` and any other
// potential pages under the /dashboard route (e.g., /dashboard/settings).

// Add the default export
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  // We assume LensAccountProvider is already wrapping the RootLayout
  // in src/app/layout.tsx via src/app/providers.tsx.
  // Therefore, we only need to add the WalletConnectProvider here.
  return <WalletConnectProvider>{children}</WalletConnectProvider>;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import "@/styles/globals.css";
import { Geist, Geist_Mono } from "next/font/google";
import { Providers } from "./providers"; // Import the Providers component

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Lens Account Interface", // Updated title
  description: "Manage your Lens Account", // Updated description
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // If using SSR hydration, you would get initialState here from headers/cookies
  // const initialState = cookieToInitialState(...) etc.

  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} min-h-screen`}>
        {/* Wrap children with Providers */}
        <Providers /*initialState={initialState}*/>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/components/dashboard/AccountIdentityPanel.tsx">
"use client";

import { type Address } from "viem";
import { DocumentDuplicateIcon, QrCodeIcon, CheckIcon } from "@heroicons/react/24/outline";
import { ArrowTopRightOnSquareIcon } from "@heroicons/react/24/solid";
import { useState } from "react";
import { QrCodeModal } from "@/components/modals/QrCodeModal";

interface AccountIdentityPanelProps {
  username: string | null;
  address: Address;
}

export function AccountIdentityPanel({ username, address }: AccountIdentityPanelProps) {
  const [copied, setCopied] = useState(false);
  const [isQrModalOpen, setIsQrModalOpen] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(address);
      setCopied(true);
      console.log("Address copied to clipboard:", address);
      // Reset icon after a short delay
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy address: ", err);
      alert("Failed to copy address."); // Simple error feedback
    }
  };

  const handleShowQr = () => {
    setIsQrModalOpen(true);
    console.log("Showing QR code modal for:", address);
  };

  const handleCloseQr = () => {
    setIsQrModalOpen(false);
  };

  const handleOpenExplorer = () => {
    window.open(`https://explorer.lens.xyz/address/${address}`, "_blank");
  };

  return (
    <div>
      {username && (
        <h2 className="text-2xl font-bold text-gray-800 mb-2">
          Welcome, <span className="text-indigo-600">{username}</span>!
        </h2>
      )}
      <p className="text-sm text-gray-500 mb-3">Managing Lens Account:</p>
      <div className="flex items-center space-x-4 bg-gray-50 p-3 rounded-md border border-gray-200">
        <p className="text-lg md:text-xl font-mono text-gray-700 break-all flex-1">{address}</p>
        <button
          onClick={handleOpenExplorer}
          title="View on Explorer"
          className="p-2 text-gray-500 hover:text-indigo-600 hover:bg-gray-200 rounded-md transition-colors duration-150"
        >
          <ArrowTopRightOnSquareIcon className="w-5 h-5" />
        </button>
        <button
          onClick={handleCopy}
          title={copied ? "Copied!" : "Copy Address"}
          className={`p-2 rounded-md transition-colors duration-150 ${
            copied ? "text-green-600 bg-green-100" : "text-gray-500 hover:text-indigo-600 hover:bg-gray-200"
          }`}
        >
          {copied ? <CheckIcon className="w-5 h-5" /> : <DocumentDuplicateIcon className="w-5 h-5" />}
        </button>
        <button
          onClick={handleShowQr}
          title="Show QR Code"
          className="p-2 text-gray-500 hover:text-indigo-600 hover:bg-gray-200 rounded-md transition-colors duration-150"
        >
          <QrCodeIcon className="w-5 h-5" />
        </button>
      </div>

      {/* Render the QR modal */}
      <QrCodeModal address={address} isOpen={isQrModalOpen} onClose={handleCloseQr} />
    </div>
  );
}
</file>

<file path="src/components/WcRequestDisplay.tsx">
// src/components/WcRequestDisplay.tsx
"use client";

import React, { useState, useEffect, useCallback, useRef } from "react";
import { useWalletConnect } from "@/contexts/WalletConnectProvider";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { formatUnits, type Hash } from "viem";
import { getSdkError } from "@walletconnect/utils";
import { formatJsonRpcError, formatJsonRpcResult, JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, lensChain } from "@/lib/constants";

// Basic Fallback Icon Component
const FallbackIcon = ({ size = 30 }: { size?: number }) => (
  <div
    style={{ width: `${size}px`, height: `${size}px` }}
    className="rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs"
  >
    ?
  </div>
);

export function WcRequestDisplay() {
  const { pendingRequest, respondRequest, error: wcError, isLoading: isWcLoading } = useWalletConnect();
  const { lensAccountAddress } = useLensAccount();
  const { address: ownerAddress, chainId: ownerChainId } = useAccount();

  // State related to the write *initiation*
  const { data: hash, error: writeError, isPending: isWritePending, writeContractAsync, reset: resetWriteContract } = useWriteContract();
  // State related to the *confirmation* of the hash from write initiation
  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
    data: receipt,
  } = useWaitForTransactionReceipt({ hash, chainId: LENS_CHAIN_ID });

  const [localError, setLocalError] = useState<string | null>(null);
  const [localLoadingMessage, setLocalLoadingMessage] = useState<string | null>(null);
  // Store the ID of the request currently being actively processed
  const processingRequestId = useRef<number | null>(null);
  // Store the hash associated with the *currently processed* request ID
  const processingRequestHash = useRef<Hash | null>(null);

  // --- Log Component Render ---
  console.log(
    `%cWcRequestDisplay Render: pendingReqId=${pendingRequest?.id ?? "null"}, currentProcessingId=${processingRequestId.current}, currentProcessingHash=${processingRequestHash.current ?? "null"}, hookHash=${hash ?? "null"}, isWritePending=${isWritePending}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, writeError=${!!writeError}, receiptError=${!!receiptError}`,
    "color: magenta",
  );
  // --------------------------

  // --- Effect to Reset State When a NEW Request Arrives ---
  useEffect(() => {
    const incomingRequestId = pendingRequest?.id ?? null;
    const currentProcessing = processingRequestId.current;

    console.log(
      `%cWcRequestDisplay ResetEffect: Running. Incoming ID: ${incomingRequestId}, Current Processing ID: ${currentProcessing}`,
      "color: teal",
    );

    if (incomingRequestId !== null) {
      if (currentProcessing !== incomingRequestId) {
        console.log(`%cWcRequestDisplay ResetEffect: New request ${incomingRequestId} detected. Resetting state.`, "color: teal");
        resetWriteContract();
        setLocalError(null);
        setLocalLoadingMessage(null);
        processingRequestId.current = incomingRequestId;
        processingRequestHash.current = null; // Reset hash ref
      } else {
        console.log(
          `%cWcRequestDisplay ResetEffect: Incoming ID ${incomingRequestId} matches current Processing ID. No reset needed.`,
          "color: teal",
        );
      }
    } else {
      if (currentProcessing !== null) {
        console.log(`%cWcRequestDisplay ResetEffect: No pending request. Resetting state.`, "color: teal");
        resetWriteContract();
        setLocalError(null);
        setLocalLoadingMessage(null);
        processingRequestId.current = null;
        processingRequestHash.current = null; // Reset hash ref
      } else {
        console.log(`%cWcRequestDisplay ResetEffect: No pending request and nothing processing. No reset needed.`, "color: teal");
      }
    }
  }, [pendingRequest, resetWriteContract]); // Now depends on pendingRequest object itself

  // --- Effect to track the hash associated with the current request ---
  useEffect(() => {
    if (hash && processingRequestId.current && !processingRequestHash.current) {
      console.log(`%cWcRequestDisplay HashTrackEffect: Associating hash ${hash} with request ID ${processingRequestId.current}`, "color: purple");
      processingRequestHash.current = hash; // Store the hash for the request we are processing
    }
  }, [hash, processingRequestId]); // Run when hash changes and we have a processing ID

  // --- Centralized Respond Function ---
  const handleRespond = useCallback(
    (response: JsonRpcResponse) => {
      const currentId = processingRequestId.current;
      if (currentId !== null && currentId === response.id) {
        console.log(`%cWcRequestDisplay handleRespond: Responding for request ID: ${response.id}`, "color: darkmagenta", response);
        respondRequest(response);
        // Reset processing state *after* responding
        processingRequestId.current = null;
        processingRequestHash.current = null; // Reset hash ref
        setLocalLoadingMessage(null);
        resetWriteContract(); // Try resetting here too
      } else {
        console.warn(
          `%cWcRequestDisplay handleRespond: Ignoring response attempt for stale/mismatched request ID: ${response.id} (Current Processing: ${currentId})`,
          "color: orange",
        );
      }
    },
    [respondRequest, resetWriteContract],
  ); // Add resetWriteContract

  // --- Effect to Handle Transaction Submission Result ---
  useEffect(() => {
    const currentProcessingId = processingRequestId.current;
    const currentReqHash = processingRequestHash.current; // Use the hash we stored for this request

    console.log(
      `%cWcRequestDisplay ReceiptEffect: Running. CurrentProcessingId=${currentProcessingId}, CurrentReqHash=${currentReqHash ?? "null"}, HookHash=${hash ?? "null"}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, receiptError=${!!receiptError}`,
      "color: #2ECC71",
    );

    // Guards:
    // 1. Must be processing a request.
    // 2. Must have a specific hash associated with *this* request attempt.
    // 3. The confirmation process must be finished (or errored).
    // 4. The hook's current hash must match the hash associated with our request.
    if (!currentProcessingId || !currentReqHash || isConfirming || hash !== currentReqHash) {
      console.log(
        `%cWcRequestDisplay ReceiptEffect: Bailing out (ProcessingID: ${currentProcessingId}, CurrentReqHash: ${currentReqHash}, HookHash: ${hash}, Confirming: ${isConfirming})`,
        "color: gray",
      );
      return;
    }

    // Now check receipt and errors, ensuring they match the currentReqHash
    if (receipt && receipt.transactionHash === currentReqHash) {
      console.log(`%cWcRequestDisplay ReceiptEffect: Receipt received for current hash ${currentReqHash}`, "color: #2ECC71");
      setLocalLoadingMessage(null);
      if (receipt.status === "success") {
        console.log(
          `%cWcRequestDisplay ReceiptEffect: Transaction successful, calling handleRespond for ID ${currentProcessingId}`,
          "color: #2ECC71",
        );
        handleRespond(formatJsonRpcResult(currentProcessingId, receipt.transactionHash));
      } else {
        console.error(
          `%cWcRequestDisplay ReceiptEffect: Transaction reverted, calling handleRespond for ID ${currentProcessingId}`,
          "color: red",
          receipt,
        );
        setLocalError("Transaction reverted on chain.");
        handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction reverted" }));
      }
    } else if (receiptError) {
      console.error(
        `%cWcRequestDisplay ReceiptEffect: Transaction Receipt Error for hash ${currentReqHash}, calling handleRespond for ID ${currentProcessingId}`,
        "color: red",
        receiptError,
      );
      setLocalError(`Transaction failed: ${receiptError.message}`);
      handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction Failed on chain" }));
    } else if (isConfirmed && !receipt) {
      console.warn(
        `%cWcRequestDisplay ReceiptEffect: isConfirmed is true but receipt is still null/undefined for hash ${currentReqHash}. Waiting.`,
        "color: orange",
      );
    } else {
      console.log(`%cWcRequestDisplay ReceiptEffect: No definitive action taken for hash ${currentReqHash}`, "color: gray");
    }
  }, [isConfirming, isConfirmed, receiptError, receipt, hash, handleRespond]); // Keep dependencies

  // --- Effect to Handle Direct Write Errors ---
  useEffect(() => {
    const currentProcessingId = processingRequestId.current;
    console.log(`%cWcRequestDisplay WriteErrorEffect: Running. writeError=${!!writeError}, currentProcessingId=${currentProcessingId}`, "color: red");
    if (writeError && currentProcessingId) {
      console.error("WcRequestDisplay WriteErrorEffect: Write Contract Error detected:", writeError);
      setLocalError(`Transaction rejected or failed to send: ${writeError.message}`);
      handleRespond(formatJsonRpcError(currentProcessingId, getSdkError("USER_REJECTED")));
    }
  }, [writeError, handleRespond]);

  const handleApprove = async () => {
    if (!pendingRequest) return setLocalError("No request to approve.");
    if (!lensAccountAddress) return setLocalError("Lens Account address missing.");
    if (!ownerAddress) return setLocalError("Owner wallet not connected.");
    if (!writeContractAsync) return setLocalError("Transaction function not ready.");
    if (ownerChainId !== LENS_CHAIN_ID) return setLocalError("Owner wallet not on Lens Chain.");

    // Reset local state AND ensure we reset wagmi state *before* initiating write
    console.log(`%cWcRequestDisplay handleApprove: Resetting state before write for request ID: ${pendingRequest.id}`, "color: blueviolet");
    resetWriteContract(); // Reset here as well
    processingRequestId.current = pendingRequest.id; // Mark immediately
    processingRequestHash.current = null; // Clear previous hash
    setLocalError(null);
    setLocalLoadingMessage("Please confirm in your wallet...");

    const { method, params } = pendingRequest.params.request;
    if (method !== "eth_sendTransaction") {
      const errorMsg = `Unsupported method: ${method}`;
      setLocalError(errorMsg);
      handleRespond(formatJsonRpcError(pendingRequest.id, { code: 4200, message: "Method not supported" }));
      return;
    }

    const tx = params[0] as { to?: `0x${string}`; value?: string; data?: `0x${string}` };
    const targetAddress = tx.to;
    const value = tx.value ? BigInt(tx.value) : 0n;
    const data = tx.data || "0x";

    if (!targetAddress) {
      const errorMsg = "Transaction 'to' address is missing.";
      setLocalError(errorMsg);
      handleRespond(formatJsonRpcError(pendingRequest.id, { code: -32602, message: "Invalid parameters: missing 'to' address" }));
      return;
    }

    try {
      console.log("%cWcRequestDisplay handleApprove: Calling writeContractAsync...", "color: blueviolet");
      // Call async, the hash state update will trigger the HashTrackEffect
      await writeContractAsync({
        address: lensAccountAddress,
        abi: LENS_ACCOUNT_ABI,
        functionName: "executeTransaction",
        args: [targetAddress, value, data],
        account: ownerAddress,
        chainId: LENS_CHAIN_ID,
      });
      console.log("%cWcRequestDisplay handleApprove: writeContractAsync call submitted.", "color: blueviolet");
    } catch (error) {
      console.error("WcRequestDisplay handleApprove: Error calling writeContractAsync:", error);
      if (!writeError && processingRequestId.current) {
        // Check current ID before responding
        const errorMsg = `Failed to initiate transaction: ${(error as Error).message}`;
        setLocalError(errorMsg);
        handleRespond(formatJsonRpcError(processingRequestId.current, getSdkError("USER_REJECTED")));
      }
    }
  };

  const handleReject = () => {
    if (!pendingRequest) return;
    processingRequestId.current = pendingRequest.id; // Mark which request we are rejecting
    setLocalError(null);
    setLocalLoadingMessage(null);
    console.log("WcRequestDisplay handleReject: Rejecting request:", pendingRequest.id);
    handleRespond(formatJsonRpcError(pendingRequest.id, getSdkError("USER_REJECTED")));
  };

  // --- Render Logic ---
  if (!pendingRequest) {
    return (
      <div className="p-4 border rounded-md bg-gray-50">
        <p className="text-gray-600 text-center italic">No pending WalletConnect requests.</p>
      </div>
    );
  }

  // Extract request details safely
  const { request, chainId } = pendingRequest.params;
  const txDetails = request.params?.[0] as { to?: string; value?: string; data?: string } | undefined;
  const dAppName = pendingRequest.verifyContext?.verified.origin || "Unknown dApp";
  const dAppUrl = pendingRequest.verifyContext?.verified.origin;
  const formattedValue = txDetails?.value
    ? `${formatUnits(BigInt(txDetails.value), lensChain.nativeCurrency.decimals)} ${lensChain.nativeCurrency.symbol}`
    : `0 ${lensChain.nativeCurrency.symbol}`;
  const isLoading = isWritePending || isConfirming || isWcLoading;

  return (
    <div className="p-4 border-2 border-blue-300 rounded-md bg-blue-50 shadow-md space-y-4">
      <h3 className="text-md font-semibold text-blue-800">WalletConnect Request</h3>
      <div className="flex items-center space-x-3 mb-3 pb-3 border-b border-blue-200">
        <FallbackIcon size={30} />
        <div>
          <p className="text-sm font-medium text-gray-800">{dAppName}</p>
          {dAppUrl && <p className="text-xs text-gray-500">{dAppUrl}</p>}
        </div>
      </div>

      <div className="space-y-2 text-sm">
        <p>
          <strong className="text-gray-600">Method:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{request.method}</span>
        </p>
        <p>
          <strong className="text-gray-600">Chain:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{chainId}</span>
        </p>
        <p>
          <strong className="text-gray-600">Target (to):</strong> <span className="font-mono text-xs break-all">{txDetails?.to ?? "N/A"}</span>
        </p>
        <p>
          <strong className="text-gray-600">Value:</strong> <span className="font-mono">{formattedValue}</span>
        </p>
        <div>
          <strong className="text-gray-600">Data:</strong>
          <textarea
            readOnly
            value={txDetails?.data ?? "0x"}
            className="mt-1 w-full h-20 p-1 border border-gray-300 rounded text-xs font-mono bg-gray-50"
          />
        </div>
      </div>

      {/* Status Display */}
      {localLoadingMessage && <p className="text-sm text-center text-indigo-600 animate-pulse">{localLoadingMessage}</p>}
      {localError && <p className="text-sm text-center text-red-600">{localError}</p>}
      {wcError && !localError && <p className="text-sm text-center text-red-600">WC Error: {wcError}</p>}

      {/* Action Buttons */}
      <div className="flex space-x-3 pt-2">
        <button
          onClick={handleApprove}
          disabled={isLoading}
          className="flex-1 px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
        >
          {isWritePending ? "Check Wallet..." : isConfirming ? "Confirming..." : "Approve & Send"}
        </button>
        <button
          onClick={handleReject}
          disabled={isLoading}
          className="flex-1 px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-md shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
        >
          Reject
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/app/providers.tsx">
// src/app/providers.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import { ConnectKitProvider } from "connectkit";
import { config } from "@/lib/wagmi";
import React, { useState } from "react";
import { LensAccountProvider } from "@/contexts/LensAccountContext";

type Props = {
  children: React.ReactNode;
};

export function Providers({ children }: Props) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <ConnectKitProvider>
          {/* Wrap with LensAccountProvider */}
          <LensAccountProvider>
            {/* Wrap with WalletConnectProvider */}
            {children}
          </LensAccountProvider>
        </ConnectKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
</file>

<file path="src/components/dashboard/OwnerPanel.tsx">
"use client";

import { type Address, isAddress } from "viem";
import { useState } from "react";
import { ExclamationTriangleIcon, CheckCircleIcon, ArrowPathIcon, ArrowTopRightOnSquareIcon } from "@heroicons/react/24/solid";
import { DocumentDuplicateIcon, CheckIcon } from "@heroicons/react/24/outline";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID } from "@/lib/constants";

interface OwnerPanelProps {
  ownerAddress: Address;
}

export function OwnerPanel({ ownerAddress }: OwnerPanelProps) {
  const [isChangingOwner, setIsChangingOwner] = useState(false);
  const [newOwner, setNewOwner] = useState("");
  const [inputError, setInputError] = useState<string | null>(null);
  const [copied, setCopied] = useState(false);

  // Wagmi hooks
  const { address: connectedOwnerAddress, chainId } = useAccount();
  const { lensAccountAddress } = useLensAccount();
  const { data: hash, error: writeError, isPending: isWritePending, writeContract, reset } = useWriteContract();
  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
  } = useWaitForTransactionReceipt({
    hash,
    chainId: LENS_CHAIN_ID,
  });

  const isLoading = isWritePending || isConfirming;
  const txError = writeError || receiptError;

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(ownerAddress);
      setCopied(true);
      console.log("Address copied to clipboard:", ownerAddress);
      // Reset icon after a short delay
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy address:", err);
      alert("Failed to copy address."); // Simple error feedback
    }
  };

  const handleOpenExplorer = () => {
    window.open(`https://explorer.lens.xyz/address/${ownerAddress}`, "_blank");
  };

  const handleToggleChangeOwner = () => {
    setIsChangingOwner(!isChangingOwner);
    setNewOwner("");
    setInputError(null);
    reset(); // Reset wagmi state on toggle
  };

  const handleNewOwnerChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value.trim();
    setNewOwner(value);
    if (value && !isAddress(value)) {
      setInputError("Invalid address format");
    } else {
      setInputError(null);
    }
  };

  const handleConfirmChangeOwner = () => {
    if (!isAddress(newOwner) || !lensAccountAddress || !connectedOwnerAddress) {
      setInputError("A valid new owner address is required and wallet must be connected.");
      return;
    }
    if (newOwner.toLowerCase() === ownerAddress.toLowerCase()) {
      setInputError("New owner cannot be the same as the current owner.");
      return;
    }
    // Ensure the connected wallet IS the current owner
    if (connectedOwnerAddress.toLowerCase() !== ownerAddress.toLowerCase()) {
      setInputError("Only the current owner can initiate this transfer.");
      return;
    }
    // Ensure connected to the correct chain
    if (chainId !== LENS_CHAIN_ID) {
      setInputError(`Please switch your wallet to Lens Chain (ID: ${LENS_CHAIN_ID}) to proceed.`);
      return;
    }

    console.log(`Initiating ownership transfer to ${newOwner} for account ${lensAccountAddress}`);
    writeContract({
      address: lensAccountAddress,
      abi: LENS_ACCOUNT_ABI,
      functionName: "transferOwnership",
      args: [newOwner as Address],
      account: connectedOwnerAddress,
      chainId: LENS_CHAIN_ID,
    });
  };

  // Display Success/Error messages after transaction attempt
  let statusMessage = null;
  if (isLoading) {
    statusMessage = (
      <div className="flex items-center text-indigo-600 text-sm mt-2">
        <ArrowPathIcon className="w-4 h-4 mr-1 animate-spin" />
        {isWritePending ? "Waiting for confirmation..." : "Processing transaction..."}
      </div>
    );
  } else if (isConfirmed) {
    statusMessage = (
      <div className="flex items-center text-green-600 text-sm mt-2">
        <CheckCircleIcon className="w-4 h-4 mr-1" />
        Ownership transferred successfully! Please login with the new owner account.
      </div>
    );
  } else if (txError) {
    statusMessage = (
      <div className="flex items-center text-red-600 text-sm mt-2">
        <ExclamationTriangleIcon className="w-4 h-4 mr-1" />
        Error: {txError.message.split(":")[0]} {/* Show concise error */}
      </div>
    );
  }

  return (
    <div>
      <h2 className="text-xl font-semibold mb-4 text-gray-700">Account Owner</h2>
      <div className="flex items-center bg-gray-50 p-3 rounded-md border border-gray-200 mb-4">
        <p className="text-sm font-mono text-gray-700 break-all flex-1">{ownerAddress}</p>
        <button
          onClick={handleOpenExplorer}
          title="View on Explorer"
          className="p-2 text-gray-500 hover:text-indigo-600 hover:bg-gray-200 rounded-md transition-colors duration-150"
        >
          <ArrowTopRightOnSquareIcon className="w-5 h-5" />
        </button>
        <button
          onClick={handleCopy}
          title={copied ? "Copied!" : "Copy Address"}
          className={`p-2 rounded-md transition-colors duration-150 ${
            copied ? "text-green-600 bg-green-100" : "text-gray-500 hover:text-indigo-600 hover:bg-gray-200"
          }`}
        >
          {copied ? <CheckIcon className="w-5 h-5" /> : <DocumentDuplicateIcon className="w-5 h-5" />}
        </button>
      </div>

      {!isChangingOwner && (
        <button onClick={handleToggleChangeOwner} className="text-sm text-indigo-600 hover:text-indigo-800 hover:underline">
          Change Owner
        </button>
      )}

      {isChangingOwner && (
        <div className="mt-4 p-4 border border-red-200 rounded-md bg-red-50 space-y-4">
          <div className="flex items-center text-red-700">
            <ExclamationTriangleIcon className="w-6 h-6 mr-2" />
            <p className="text-sm font-semibold">Danger Zone: Transfer Ownership</p>
          </div>
          <p className="text-xs text-red-600">
            Warning: Transferring ownership is irreversible. Ensure the new address is correct and accessible. You will lose control of this Lens
            Account if you proceed.
          </p>
          <div>
            <label htmlFor="new-owner" className="block text-sm font-medium text-gray-700 mb-1">
              New Owner Address
            </label>
            <input
              id="new-owner"
              name="new-owner"
              type="text"
              value={newOwner}
              onChange={handleNewOwnerChange}
              placeholder="0x..."
              className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-1 sm:text-sm ${
                inputError ? "border-red-500 ring-red-500" : "border-gray-300 focus:ring-red-500 focus:border-red-500"
              }`}
            />
            {inputError && <p className="mt-1 text-xs text-red-600">{inputError}</p>}
          </div>
          <div className="flex space-x-3">
            <button
              onClick={handleConfirmChangeOwner}
              disabled={!isAddress(newOwner) || newOwner.toLowerCase() === ownerAddress.toLowerCase() || isLoading || isConfirmed}
              className="flex-1 px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isLoading ? "Processing..." : isConfirmed ? "Transferred" : "Confirm Change Owner"}
            </button>
            <button
              onClick={handleToggleChangeOwner}
              disabled={isLoading}
              className="flex-1 px-4 py-2 bg-gray-200 text-gray-700 text-sm font-medium rounded-md shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 disabled:opacity-50"
            >
              Cancel
            </button>
          </div>
          {/* Display status message */}
          <div className="min-h-[20px]">{statusMessage}</div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/WcConnect.tsx">
// src/components/WcConnect.tsx
"use client";

import React, { useState, useEffect } from "react";
import { useWalletConnect } from "@/contexts/WalletConnectProvider"; // Ensure correct path
import Image from "next/image";

// Default/Fallback Icon
const FallbackIcon = () => <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs">?</div>;

// Helper function to resolve icon URL
const resolveIconUrl = (iconPath: string | null | undefined, baseUrl: string | null | undefined): string | undefined => {
  if (!iconPath) return undefined;

  try {
    // Handle absolute URLs
    if (iconPath.startsWith("http://") || iconPath.startsWith("https://")) {
      return iconPath;
    }
    // Handle root-relative paths if base URL exists
    if (iconPath.startsWith("/") && baseUrl) {
      const origin = new URL(baseUrl).origin;
      return `${origin}${iconPath}`;
    }
    console.warn("Invalid icon URL format:", iconPath);
    return undefined;
  } catch (e) {
    console.warn("Error resolving icon URL:", e);
    return undefined;
  }
};

// Icon component with error handling
const DAppIcon = ({ iconUrl, name, size = 40 }: { iconUrl?: string; name: string; size?: number }) => {
  const [hasError, setHasError] = useState(false);

  if (!iconUrl || hasError) return <FallbackIcon />;

  return (
    <Image
      src={iconUrl}
      alt={`${name} icon`}
      width={size}
      height={size}
      className="rounded-full"
      unoptimized
      onError={() => {
        console.warn("Failed to load icon:", iconUrl);
        setHasError(true);
      }}
    />
  );
};

export function WcConnect() {
  // Destructure states from the refactored provider, including isInitializing
  const {
    activeSessions,
    pair,
    disconnect,
    isLoading, // Use the combined loading state
    isPairing,
    error,
    isInitialized, // Use the service readiness flag
    pendingProposal, // Get the pending proposal
    approveSession, // Get approve action
    rejectSession, // Get reject action
    isInitializing, // <<<--- ADDED isInitializing HERE ---<<<
  } = useWalletConnect();
  const [uri, setUri] = useState("");

  const activeSessionTopic = Object.keys(activeSessions)[0]; // Assuming only one session for MVP
  const connectedSession = activeSessionTopic ? activeSessions[activeSessionTopic] : null;

  // --- Add this useEffect ---
  useEffect(() => {
    // If there's no connected session (either initially or after disconnect),
    // clear the URI input field.
    if (!connectedSession) {
      setUri("");
    }
  }, [connectedSession]); // Run this effect when connectedSession changes
  // -------------------------

  const handleConnect = () => {
    if (!uri || !isInitialized || isLoading) return; // Check initialization and combined loading state
    pair(uri);
  };

  const handleDisconnect = () => {
    if (connectedSession && isInitialized && !isLoading) {
      // Check initialization and combined loading state
      disconnect(connectedSession.topic);
    }
  };

  const handleApprove = () => {
    if (pendingProposal && !isLoading) {
      approveSession();
    }
  };

  const handleReject = () => {
    if (pendingProposal && !isLoading) {
      rejectSession();
    }
  };

  // Display loading states more granularly if needed, otherwise use `isLoading`
  const connectButtonText = isPairing ? "Pairing..." : isLoading ? "Working..." : "Connect";
  const disconnectButtonText = isLoading ? "Working..." : "Disconnect";
  const approveButtonText = isLoading ? "Working..." : "Approve Session";
  const rejectButtonText = isLoading ? "Working..." : "Reject Session";

  // Resolve icon URLs
  const connectedDAppIconUrl = connectedSession
    ? resolveIconUrl(connectedSession.peer.metadata.icons?.[0] ?? undefined, connectedSession.peer.metadata.url ?? undefined)
    : undefined;

  const proposalIconUrl = pendingProposal
    ? resolveIconUrl(pendingProposal.params.proposer.metadata.icons?.[0] ?? undefined, pendingProposal.params.proposer.metadata.url ?? undefined)
    : undefined;

  return (
    <div className="p-4 border rounded-md bg-gray-50 space-y-4">
      <h3 className="text-md font-semibold text-gray-700">Connect to dApp (via Lens Account)</h3>

      {/* --- Session Proposal Modal (Simplified Inline) --- */}
      {pendingProposal && (
        <div className="p-3 border border-yellow-300 bg-yellow-50 rounded-md space-y-2">
          <p className="text-sm font-medium text-yellow-800">Connection Request from:</p>
          <div className="flex items-center space-x-2">
            <DAppIcon iconUrl={proposalIconUrl} name={pendingProposal.params.proposer.metadata.name} size={30} />
            <span className="text-sm text-gray-700">{pendingProposal.params.proposer.metadata.name}</span>
          </div>
          {/* TODO: Display requested permissions details if needed */}
          <div className="flex space-x-2 pt-2">
            <button
              onClick={handleApprove}
              disabled={isLoading || !isInitialized}
              className="flex-1 px-3 py-1 bg-green-500 text-white text-xs font-medium rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {approveButtonText}
            </button>
            <button
              onClick={handleReject}
              disabled={isLoading || !isInitialized}
              className="flex-1 px-3 py-1 bg-red-500 text-white text-xs font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {rejectButtonText}
            </button>
          </div>
        </div>
      )}

      {/* --- Connected Session Display --- */}
      {connectedSession && !pendingProposal && (
        <div className="space-y-3 p-3 bg-green-50 border border-green-200 rounded-md">
          {/* Display connected dApp info */}
          <p className="text-green-800 font-medium">Connected to:</p>
          <div className="flex items-center space-x-3">
            <DAppIcon iconUrl={connectedDAppIconUrl} name={connectedSession.peer.metadata.name} size={40} />
            <div>
              <p className="text-sm font-semibold text-gray-900">{connectedSession.peer.metadata.name}</p>
              <p className="text-xs text-gray-600 break-all">{connectedSession.peer.metadata.url}</p>
            </div>
          </div>
          <p className="text-xs text-gray-500">
            Topic: <span className="font-mono break-all">{connectedSession.topic}</span>
          </p>
          <button
            onClick={handleDisconnect}
            disabled={isLoading || !isInitialized} // Use combined loading state
            className="w-full px-4 py-2 mt-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
          >
            {disconnectButtonText}
          </button>
        </div>
      )}

      {/* --- Pairing/Connection Form --- */}
      {!connectedSession && !pendingProposal && (
        <div className="space-y-2">
          <label htmlFor="wc-uri" className="block text-sm font-medium text-gray-700">
            Paste WalletConnect URI
          </label>
          <div className="flex space-x-2">
            <input
              id="wc-uri"
              name="wc-uri"
              type="text"
              value={uri}
              onChange={(e) => setUri(e.target.value)}
              placeholder="wc:..."
              className="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm disabled:bg-gray-100"
              disabled={isLoading || !isInitialized} // Use combined loading state
            />
            <button
              onClick={handleConnect}
              disabled={!uri || isLoading || !isInitialized} // Use combined loading state
              className="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {connectButtonText}
            </button>
          </div>
        </div>
      )}

      {/* --- Status/Error Messages --- */}
      {error && !isLoading && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
      {isPairing && <p className="text-indigo-600 text-sm mt-2">Pairing initiated, check dApp/wallet if needed...</p>}
      {/* Check both flags here now */}
      {!isInitialized && !isInitializing && !error && <p className="text-orange-600 text-sm mt-2">WalletConnect service not ready.</p>}
      {/* And display initializing message correctly */}
      {isInitializing && <p className="text-gray-500 text-sm mt-2">Initializing WalletConnect...</p>}
    </div>
  );
}
</file>

<file path="src/components/AccountDisplay.tsx">
// components/AccountDisplay.tsx
"use client";

import React, { useState } from "react";
import { useReadContract, useBalance } from "wagmi";
import { formatUnits, type Address } from "viem";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { ERC20_ABI, WGHO_TOKEN_ADDRESS, BONSAI_TOKEN_ADDRESS, LENS_CHAIN_ID, lensChain } from "@/lib/constants";
import { SendModal } from "@/components/modals/SendModal";
import { ApproveModal } from "@/components/modals/ApproveModal";
import { WrapModal } from "@/components/modals/WrapModal";
import { UnwrapModal } from "@/components/modals/UnwrapModal";

interface ActionButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
}

function ActionButton({ label, onClick, disabled = false }: ActionButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className="ml-2 px-2 py-1 text-xs bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200 transition-colors disabled:opacity-50"
    >
      {label}
    </button>
  );
}

// Define Modal State Type
type ModalType = "send" | "approve" | "wrap" | "unwrap";
interface ModalState {
  type: ModalType | null;
  tokenSymbol: string;
  tokenAddress?: Address;
  decimals: number;
  balance?: bigint;
}

export function AccountDisplay() {
  const { lensAccountAddress } = useLensAccount();
  const [modalState, setModalState] = useState<ModalState>({
    type: null,
    tokenSymbol: "",
    decimals: 18,
  });

  // Native GHO Balance
  const { data: nativeBalanceData, isLoading: isLoadingNative } = useBalance({
    address: lensAccountAddress as Address | undefined,
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: !!lensAccountAddress,
      refetchInterval: 5000,
      refetchOnWindowFocus: true,
    },
  });

  // WGHO Balance
  const { data: wghoBalanceData, isLoading: isLoadingWgho } = useReadContract({
    address: WGHO_TOKEN_ADDRESS,
    abi: ERC20_ABI,
    functionName: "balanceOf",
    args: lensAccountAddress ? [lensAccountAddress] : undefined,
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: !!lensAccountAddress,
      refetchInterval: 5000,
      refetchOnWindowFocus: true,
    },
  });

  // BONSAI Balance
  const { data: bonsaiBalanceData, isLoading: isLoadingBonsai } = useReadContract({
    address: BONSAI_TOKEN_ADDRESS,
    abi: ERC20_ABI,
    functionName: "balanceOf",
    args: lensAccountAddress ? [lensAccountAddress] : undefined,
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: !!lensAccountAddress,
      refetchInterval: 5000,
      refetchOnWindowFocus: true,
    },
  });

  const isLoadingBalances = isLoadingNative || isLoadingWgho || isLoadingBonsai;

  // Format balances for display
  const formattedNativeBalance = nativeBalanceData ? formatUnits(nativeBalanceData.value, nativeBalanceData.decimals) : "0";
  const formattedWghoBalance = wghoBalanceData ? formatUnits(wghoBalanceData, 18) : "0";
  const formattedBonsaiBalance = bonsaiBalanceData ? formatUnits(bonsaiBalanceData, 18) : "0";

  const handleActionClick = (actionType: ModalType, symbol: string, address?: Address, decimals = 18, balance?: bigint) => {
    console.log(`Opening ${actionType} modal for ${symbol}`, { address, decimals, balance });
    setModalState({ type: actionType, tokenSymbol: symbol, tokenAddress: address, decimals, balance });
  };

  const closeModal = () => {
    setModalState({ type: null, tokenSymbol: "", decimals: 18 });
  };

  if (!lensAccountAddress) {
    return <p className="text-gray-500">Connect your wallet to view account balances.</p>;
  }

  return (
    <div className="space-y-4">
      {isLoadingBalances && <p className="text-gray-500 text-sm">Loading balances...</p>}

      {/* Native GHO Row */}
      <div className="flex items-center justify-between border-b pb-2">
        <div>
          <h3 className="text-lg font-medium text-gray-900">{lensChain.nativeCurrency.symbol}</h3>
          <p className="text-gray-500">{formattedNativeBalance}</p>
        </div>
        <div className="flex gap-2">
          <ActionButton
            label="Wrap"
            onClick={() =>
              handleActionClick("wrap", lensChain.nativeCurrency.symbol, undefined, lensChain.nativeCurrency.decimals, nativeBalanceData?.value)
            }
          />
          <ActionButton
            label="Send"
            onClick={() =>
              handleActionClick("send", lensChain.nativeCurrency.symbol, undefined, lensChain.nativeCurrency.decimals, nativeBalanceData?.value)
            }
          />
        </div>
      </div>

      {/* WGHO Row */}
      <div className="flex items-center justify-between border-b pb-2">
        <div>
          <h3 className="text-lg font-medium text-gray-900">WGHO</h3>
          <p className="text-gray-500">{formattedWghoBalance}</p>
        </div>
        <div className="flex gap-2">
          <ActionButton label="Unwrap" onClick={() => handleActionClick("unwrap", "WGHO", WGHO_TOKEN_ADDRESS as Address, 18, wghoBalanceData)} />
          <ActionButton label="Approve" onClick={() => handleActionClick("approve", "WGHO", WGHO_TOKEN_ADDRESS as Address, 18, wghoBalanceData)} />
          <ActionButton label="Send" onClick={() => handleActionClick("send", "WGHO", WGHO_TOKEN_ADDRESS as Address, 18, wghoBalanceData)} />
        </div>
      </div>

      {/* BONSAI Row */}
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-medium text-gray-900">BONSAI</h3>
          <p className="text-gray-500">{formattedBonsaiBalance}</p>
        </div>
        <div className="flex gap-2">
          <ActionButton
            label="Approve"
            onClick={() => handleActionClick("approve", "BONSAI", BONSAI_TOKEN_ADDRESS as Address, 18, bonsaiBalanceData)}
          />
          <ActionButton label="Send" onClick={() => handleActionClick("send", "BONSAI", BONSAI_TOKEN_ADDRESS as Address, 18, bonsaiBalanceData)} />
        </div>
      </div>

      {/* Render Modals */}
      {modalState.type === "send" && (
        <SendModal
          isOpen={true}
          onClose={closeModal}
          tokenSymbol={modalState.tokenSymbol}
          tokenAddress={modalState.tokenAddress}
          decimals={modalState.decimals}
          balance={modalState.balance}
        />
      )}
      {modalState.type === "approve" && modalState.tokenAddress && (
        <ApproveModal
          isOpen={true}
          onClose={closeModal}
          tokenSymbol={modalState.tokenSymbol}
          tokenAddress={modalState.tokenAddress}
          decimals={modalState.decimals}
        />
      )}
      {modalState.type === "wrap" && <WrapModal isOpen={true} onClose={closeModal} balance={modalState.balance} />}
      {modalState.type === "unwrap" && <UnwrapModal isOpen={true} onClose={closeModal} balance={modalState.balance} />}
    </div>
  );
}
</file>

<file path="src/components/DiscoveryForm.tsx">
// components/DiscoveryForm.tsx
"use client";

import React, { useState, useEffect } from "react";
import { useReadContract } from "wagmi";
import { isAddress, type Address } from "viem";
import { useDebounce } from "@/hooks/useDebounce";
import { LENS_CHAIN_ID, LENS_GLOBAL_NAMESPACE_ADDRESS, LENS_GLOBAL_NAMESPACE_ABI } from "@/lib/constants";

// Import icons from Heroicons
import { CheckCircleIcon, ExclamationTriangleIcon, ArrowPathIcon } from "@heroicons/react/24/solid";

interface DiscoveryFormProps {
  // Update the callback prop definition
  onAccountDetailsFound: (details: { address: Address | ""; username: string }) => void;
  initialUsername?: string;
  initialAddress?: string;
}

// Add a StatusMessage component for consistent styling
function StatusMessage({ type, message }: { type: "loading" | "error" | "success"; message: string }) {
  return (
    <div
      className={`flex items-center justify-center gap-2 text-sm font-medium ${
        type === "loading" ? "text-indigo-600" : type === "error" ? "text-red-600" : "text-green-600"
      }`}
    >
      {type === "loading" && <ArrowPathIcon className="w-4 h-4 animate-spin" />}
      {type === "error" && <ExclamationTriangleIcon className="w-4 h-4" />}
      {type === "success" && <CheckCircleIcon className="w-4 h-4" />}
      <span>{message}</span>
    </div>
  );
}

export function DiscoveryForm({ onAccountDetailsFound, initialUsername = "", initialAddress = "" }: DiscoveryFormProps) {
  const [username, setUsername] = useState(initialUsername);
  const [address, setAddress] = useState(initialAddress);
  const [lookupError, setLookupError] = useState<string | null>(null);
  const [lastEdited, setLastEdited] = useState<"username" | "address" | null>(initialUsername ? "username" : initialAddress ? "address" : null);

  const debouncedUsername = useDebounce(username, 500);
  const debouncedAddress = useDebounce(address, 500);

  const {
    data: addressFromUsername,
    isLoading: isLoadingAddress,
    error: addressError,
    refetch: refetchAddress,
  } = useReadContract({
    address: LENS_GLOBAL_NAMESPACE_ADDRESS,
    abi: LENS_GLOBAL_NAMESPACE_ABI,
    functionName: "accountOf",
    args: [debouncedUsername || ""],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: false,
    },
  });

  const {
    data: usernameFromAddress,
    isLoading: isLoadingUsername,
    error: usernameError,
    refetch: refetchUsername,
  } = useReadContract({
    address: LENS_GLOBAL_NAMESPACE_ADDRESS,
    abi: LENS_GLOBAL_NAMESPACE_ABI,
    functionName: "usernameOf",
    args: [debouncedAddress as `0x${string}`],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: false,
    },
  });

  useEffect(() => {
    if (debouncedUsername && lastEdited === "username") {
      setLookupError(null);
      console.log(`Looking up address for username: ${debouncedUsername}`);
      refetchAddress();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedUsername, lastEdited]);

  useEffect(() => {
    if (debouncedAddress && isAddress(debouncedAddress) && lastEdited === "address") {
      setLookupError(null);
      console.log(`Looking up username for address: ${debouncedAddress}`);
      refetchUsername();
    } else if (debouncedAddress && !isAddress(debouncedAddress) && lastEdited === "address") {
      setLookupError("Invalid address format");
      onAccountDetailsFound({ address: "", username: "" });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedAddress, lastEdited]);

  useEffect(() => {
    if (addressFromUsername && isAddress(addressFromUsername) && lastEdited === "username") {
      if (addressFromUsername === "0x0000000000000000000000000000000000000000") {
        setLookupError(`No account found for username "${debouncedUsername}"`);
        setAddress("");
        onAccountDetailsFound({ address: "", username: debouncedUsername || "" });
      } else {
        console.log(`Found address: ${addressFromUsername}`);
        setAddress(addressFromUsername);
        onAccountDetailsFound({ address: addressFromUsername, username: debouncedUsername || "" });
        setLookupError(null);
      }
    } else if (addressError && lastEdited === "username") {
      console.error("Error fetching address:", addressError);
      if (addressError.message.includes("0xb0ce7591") || addressError.message.includes("DoesNotExist")) {
        setLookupError(`Username "${debouncedUsername}" does not exist`);
      } else {
        setLookupError("Error fetching address. Please try again.");
      }
      onAccountDetailsFound({ address: "", username: debouncedUsername || "" });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [addressFromUsername, addressError, lastEdited, debouncedUsername]);

  useEffect(() => {
    if (usernameFromAddress && lastEdited === "address") {
      console.log(`Found username: ${usernameFromAddress}`);
      setUsername(usernameFromAddress);
      if (isAddress(debouncedAddress)) {
        onAccountDetailsFound({ address: debouncedAddress as Address, username: usernameFromAddress });
      }
      setLookupError(null);
    } else if (usernameError && lastEdited === "address") {
      console.log("No primary username found for address or error:", usernameError.message);
      setUsername("");
      if (isAddress(debouncedAddress)) {
        onAccountDetailsFound({ address: debouncedAddress as Address, username: "" });
      }
      setLookupError(null);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [usernameFromAddress, usernameError, lastEdited, debouncedAddress]);

  const handleUsernameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const cleanValue = e.target.value.replace(/\s+/g, "");
    setUsername(cleanValue);
    setLastEdited("username");
    if (lastEdited !== "address") setAddress("");
    onAccountDetailsFound({ address: "", username: cleanValue });
    setLookupError(null);
  };

  const handleAddressChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const cleanValue = e.target.value.replace(/\s+/g, "");
    setAddress(cleanValue);
    setLastEdited("address");
    if (lastEdited !== "username") setUsername("");
    if (!isAddress(cleanValue) && cleanValue !== "") {
      setLookupError("Invalid address format");
      onAccountDetailsFound({ address: "", username: "" });
    } else {
      setLookupError(null);
      if (isAddress(cleanValue)) {
        onAccountDetailsFound({ address: cleanValue as Address, username: "" });
      } else {
        onAccountDetailsFound({ address: "", username: "" });
      }
    }
  };

  const isLoading = isLoadingAddress || isLoadingUsername;

  return (
    <div className="w-full max-w-md mx-auto space-y-8">
      <div className="text-center space-y-2">
        <p className="text-lg text-gray-600 font-light">To login, please enter your</p>
      </div>

      <div className="space-y-6">
        <div>
          <label htmlFor="username" className="block text-lg font-medium text-gray-700 mb-2">
            Lens Username
          </label>
          <input
            id="username"
            name="username"
            type="text"
            value={username}
            onChange={handleUsernameChange}
            placeholder="e.g. stani"
            className="w-full px-4 py-3 border border-gray-200 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition duration-200"
            aria-describedby="username-status"
            disabled={isLoading && lastEdited === "address"}
          />
        </div>

        <div className="flex items-center justify-center space-x-4">
          <div className="h-px bg-gray-200 w-20"></div>
          <span className="text-xl font-semibold text-gray-400">OR</span>
          <div className="h-px bg-gray-200 w-20"></div>
        </div>

        <div>
          <label htmlFor="address" className="block text-lg font-medium text-gray-700 mb-2">
            Lens Account Address
          </label>
          <input
            id="address"
            name="address"
            type="text"
            value={address}
            onChange={handleAddressChange}
            placeholder="0x..."
            className={`w-full px-4 py-3 border rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition duration-200 ${
              !lookupError && isAddress(address) ? "border-green-500" : address && !isAddress(address) ? "border-red-500" : "border-gray-200"
            }`}
            aria-describedby="address-status"
            disabled={isLoading && lastEdited === "username"}
          />
        </div>
      </div>

      {/* Status messages with improved styling */}
      <div className="min-h-[28px] flex justify-center">
        {isLoading && lastEdited === "username" && <StatusMessage type="loading" message="Checking username..." />}
        {isLoading && lastEdited === "address" && <StatusMessage type="loading" message="Checking address..." />}
        {lookupError && <StatusMessage type="error" message={lookupError} />}
        {!lookupError && isAddress(address) && lastEdited !== "username" && <StatusMessage type="success" message="Valid Address" />}
      </div>
    </div>
  );
}
</file>

<file path="src/services/walletConnectService.ts">
// src/services/walletConnectService.ts
import { WalletKit, IWalletKit, WalletKitTypes } from "@reown/walletkit";
import { Core } from "@walletconnect/core";
import { ICore, SessionTypes, SignClientTypes } from "@walletconnect/types";
import { ErrorResponse, JsonRpcResponse } from "@walletconnect/jsonrpc-utils"; // Import JsonRpcResponse
import EventEmitter from "events";

// --- Export Enums and Interfaces ---
export enum ServiceEvents {
  Initialized = "initialized",
  PairStatus = "pair_status",
  SessionProposal = "session_proposal",
  SessionConnect = "session_connect",
  SessionDelete = "session_delete",
  SessionRequest = "session_request", // <<<--- ADDED
  Error = "error",
  SessionsUpdated = "sessions_updated",
  IS_LOADING = "is_loading",
  IS_PAIRING = "is_pairing",
}

export interface WalletConnectServiceEvents {
  [ServiceEvents.Initialized]: (payload: { success: boolean; instance: IWalletKit | null }) => void;
  [ServiceEvents.PairStatus]: (payload: { status: "pairing" | "paired" | "error"; message?: string }) => void;
  [ServiceEvents.SessionProposal]: (payload: { proposal: WalletKitTypes.SessionProposal }) => void;
  [ServiceEvents.SessionConnect]: (payload: { session: SessionTypes.Struct }) => void;
  [ServiceEvents.SessionDelete]: (payload: { topic: string }) => void;
  [ServiceEvents.SessionRequest]: (payload: { request: WalletKitTypes.SessionRequest }) => void; // <<<--- ADDED
  [ServiceEvents.Error]: (payload: { message: string }) => void;
  [ServiceEvents.SessionsUpdated]: (payload: { sessions: Record<string, SessionTypes.Struct> }) => void;
  [ServiceEvents.IS_LOADING]: (payload: { isLoading: boolean }) => void;
  [ServiceEvents.IS_PAIRING]: (payload: { isPairing: boolean }) => void;
}
// ------------------------------------

// --- Export the Class Definition ---
export class WalletConnectService extends EventEmitter {
  private core: ICore | undefined;
  private walletKit: IWalletKit | undefined;
  private projectId: string;
  private metadata: WalletKitTypes.Metadata;
  private _isInitialized = false;
  private _isInitializing = false;
  private initPromise: Promise<IWalletKit> | null = null;

  constructor(projectId: string, metadata: WalletKitTypes.Metadata) {
    super();
    if (!projectId) {
      throw new Error("WalletConnectService: Project ID is required.");
    }
    this.projectId = projectId;
    this.metadata = JSON.parse(JSON.stringify(metadata));
    console.log("WalletConnectService: NEW Instance created (by Provider).");
  }

  // --- Getters (keep as before) ---
  public isInitialized(): boolean {
    return this._isInitialized;
  }
  public isInitializing(): boolean {
    return this._isInitializing;
  }
  public getWalletKitInstance(): IWalletKit | undefined {
    return this.walletKit;
  }
  public getActiveSessions(): Record<string, SessionTypes.Struct> {
    return this.walletKit?.getActiveSessions() || {};
  }

  // --- Core Initialization (Idempotent) ---
  async init(): Promise<IWalletKit> {
    if (this._isInitialized && this.walletKit) {
      console.log("WalletConnectService Instance: Init called but already initialized.");
      this.emit(ServiceEvents.Initialized, { success: true, instance: this.walletKit });
      return this.walletKit;
    }
    if (this._isInitializing && this.initPromise) {
      console.log("WalletConnectService Instance: Init called while already initializing. Returning existing promise.");
      return this.initPromise;
    }
    console.log("WalletConnectService Instance: Starting initialization (init)...");
    this._isInitializing = true;
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    this.initPromise = (async () => {
      try {
        console.log("WalletConnectService Instance: Initializing WalletConnect Core...");
        process.env.DISABLE_GLOBAL_CORE = "true";
        this.core = new Core({ projectId: this.projectId });
        process.env.DISABLE_GLOBAL_CORE = "false";
        console.log("WalletConnectService Instance: Initializing WalletKit...");
        this.walletKit = await WalletKit.init({ core: this.core, metadata: this.metadata });
        this.setupInternalListeners();
        this._isInitialized = true;
        console.log("WalletConnectService Instance: Initialization successful.");
        this.emit(ServiceEvents.Initialized, { success: true, instance: this.walletKit });
        this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
        return this.walletKit;
      } catch (error: unknown) {
        console.error("WalletConnectService Instance: Initialization failed:", error);
        this._isInitialized = false;
        this.emit(ServiceEvents.Initialized, { success: false, instance: null });
        this.emit(ServiceEvents.Error, { message: `Initialization failed: ${(error as Error).message}` });
        throw error;
      } finally {
        this._isInitializing = false;
        this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
        this.initPromise = null;
      }
    })();
    return this.initPromise;
  }

  private setupInternalListeners() {
    if (!this.walletKit) {
      console.error("WalletConnectService: Cannot setup listeners, WalletKit not ready.");
      return;
    }
    console.log("WalletConnectService: Setting up internal event listeners...");

    this.walletKit.off("session_proposal", this.handleSessionProposal);
    this.walletKit.on("session_proposal", this.handleSessionProposal);

    if (this.walletKit.engine?.signClient?.events) {
      this.walletKit.engine.signClient.events.off("session_connect", this.handleSessionConnect);
      this.walletKit.engine.signClient.events.on("session_connect", this.handleSessionConnect);
    } else {
      console.warn("WalletConnectService: SignClient events not available for session_connect listener.");
    }

    this.walletKit.off("session_delete", this.handleSessionDelete);
    this.walletKit.on("session_delete", this.handleSessionDelete);

    // --- Add session_request Listener ---
    this.walletKit.off("session_request", this.handleSessionRequest); // <<<--- ADDED
    this.walletKit.on("session_request", this.handleSessionRequest); // <<<--- ADDED
    // ------------------------------------

    console.log("WalletConnectService: Internal listeners attached.");
  }

  // --- Event Handlers (bound methods) ---
  private handleSessionProposal = (proposal: WalletKitTypes.SessionProposal) => {
    console.log("Service Handler: session_proposal", proposal.id);
    this.emit(ServiceEvents.SessionProposal, { proposal });
    this.emit(ServiceEvents.IS_PAIRING, { isPairing: false });
  };

  private handleSessionConnect = (sessionArgs: SignClientTypes.EventArguments["session_connect"]) => {
    console.log("Service Handler: session_connect", sessionArgs.session.topic);
    this.emit(ServiceEvents.SessionConnect, { session: sessionArgs.session });
    this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
  };

  private handleSessionDelete = (event: { id: number; topic: string }) => {
    console.log("Service Handler: session_delete", event.topic);
    this.emit(ServiceEvents.SessionDelete, { topic: event.topic });
    this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
  };

  // --- Handler for Session Request ---
  private handleSessionRequest = (request: WalletKitTypes.SessionRequest) => {
    // <<<--- ADDED
    console.log("Service Handler: session_request", request.id, request.params.request.method);
    this.emit(ServiceEvents.SessionRequest, { request });
  };
  // -----------------------------------

  // --- Public Methods ---
  async pair(uri: string): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot pair.");
    console.log("Service: Attempting to pair with URI:", uri);
    this.emit(ServiceEvents.IS_PAIRING, { isPairing: true });
    this.emit(ServiceEvents.PairStatus, { status: "pairing" });
    try {
      await this.walletKit.pair({ uri });
      console.log("Service: Pairing initiated for URI:", uri);
    } catch (error: unknown) {
      console.error("Service: Pairing failed:", error);
      const message = (error as Error).message || "Pairing failed";
      this.emit(ServiceEvents.PairStatus, { status: "error", message });
      this.emit(ServiceEvents.IS_PAIRING, { isPairing: false });
      this.emit(ServiceEvents.Error, { message });
      throw error;
    }
  }

  async approveSession(proposal: WalletKitTypes.SessionProposal, approvedNamespaces: SessionTypes.Namespaces): Promise<SessionTypes.Struct> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot approve session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Approving session:", proposal.id);
      const session = await this.walletKit.approveSession({ id: proposal.id, namespaces: approvedNamespaces });
      console.log("Service: Session approved via approveSession:", session.topic);
      return session;
    } catch (error: unknown) {
      console.error("Service: Failed to approve session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to approve session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  async rejectSession(proposal: WalletKitTypes.SessionProposal, reason: ErrorResponse): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot reject session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Rejecting session:", proposal.id);
      await this.walletKit.rejectSession({ id: proposal.id, reason: reason });
      console.log("Service: Session rejected:", proposal.id);
    } catch (error: unknown) {
      console.error("Service: Failed to reject session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to reject session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  async disconnectSession(topic: string, reason: ErrorResponse): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot disconnect session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Disconnecting session:", topic);
      await this.walletKit.disconnectSession({ topic: topic, reason: reason });
      console.log("Service: Disconnect call successful for topic:", topic);
    } catch (error: unknown) {
      console.error("Service: Failed to disconnect session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to disconnect session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  // --- Method to Respond to Session Requests ---
  async respondSessionRequest(topic: string, response: JsonRpcResponse): Promise<void> {
    // <<<--- ADDED
    if (!this._isInitialized || !this.walletKit) {
      throw new Error("WalletConnectService: Not initialized. Cannot respond to request.");
    }
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Responding to session request:", response.id, "on topic:", topic);
      await this.walletKit.respondSessionRequest({ topic, response });
      console.log("Service: Response sent for request:", response.id);
    } catch (error: unknown) {
      console.error("Service: Failed to respond to session request:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to respond to request" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }
  // -------------------------------------------

  // Typed EventEmitter methods (Apply this pattern to on, once, off, removeListener)
  on<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.on(event, listener as (...args: any[]) => void);
  }

  once<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.once(event, listener as (...args: any[]) => void);
  }

  off<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.off(event, listener as (...args: any[]) => void);
  }

  removeListener<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.removeListener(event, listener as (...args: any[]) => void);
  }

  emit<E extends keyof WalletConnectServiceEvents>(event: E, ...args: Parameters<WalletConnectServiceEvents[E]>): boolean {
    return super.emit(event, ...args);
  }
}
</file>

<file path="src/app/page.tsx">
// src/app/page.tsx
"use client";

import { DiscoveryForm } from "@/components/DiscoveryForm";
import { ConnectOwnerButton } from "@/components/ConnectOwnerButton";
import { useState, useEffect } from "react";
import { useAccount, useReadContract } from "wagmi";
import { useRouter } from "next/navigation";
import { type Address, isAddress } from "viem";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, LOCAL_STORAGE_KEYS } from "@/lib/constants";

export default function Home() {
  // Initialize state from localStorage
  const [lensAccountAddress, setLensAccountAddress] = useState<Address | "">(() => {
    if (typeof window !== "undefined") {
      try {
        const storedAddress = localStorage.getItem(LOCAL_STORAGE_KEYS.LENS_ACCOUNT_ADDRESS);
        return storedAddress && isAddress(storedAddress) ? storedAddress : "";
      } catch (error) {
        console.error("Failed to read lensAccountAddress from localStorage:", error);
      }
    }
    return "";
  });

  const [lensUsername, setLensUsername] = useState<string>(() => {
    if (typeof window !== "undefined") {
      try {
        return localStorage.getItem(LOCAL_STORAGE_KEYS.LENS_USERNAME) || "";
      } catch (error) {
        console.error("Failed to read lensUsername from localStorage:", error);
      }
    }
    return "";
  });

  const [expectedOwner, setExpectedOwner] = useState<Address | null>(null);
  const [ownerFetchError, setOwnerFetchError] = useState<string | null>(null);
  const [verificationError, setVerificationError] = useState<string | null>(null);

  const { address: connectedAddress, chainId: connectedChainId, isConnected, isConnecting, isReconnecting, status } = useAccount();
  const router = useRouter();
  const { setVerifiedAccount, clearAccount: clearContext } = useLensAccount();

  // Updated handler for DiscoveryForm callback
  const handleAccountDetailsFound = (details: { address: Address | ""; username: string }) => {
    console.log("Account Details Updated in Parent:", details);
    setLensAccountAddress(details.address);
    setLensUsername(details.username);
    setExpectedOwner(null);
    setOwnerFetchError(null);
    setVerificationError(null);
    clearContext();
  };

  const {
    data: ownerData,
    error: ownerError,
    isLoading: isLoadingOwner,
  } = useReadContract({
    address: lensAccountAddress || undefined,
    abi: LENS_ACCOUNT_ABI,
    functionName: "owner",
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: isAddress(lensAccountAddress),
    },
  });

  // Effect to update expectedOwner state
  useEffect(() => {
    if (ownerData) {
      setExpectedOwner(ownerData);
      setOwnerFetchError(null);
      console.log("Fetched Expected Owner:", ownerData);
    }
  }, [ownerData]);

  // Effect to handle owner fetch errors
  useEffect(() => {
    if (ownerError) {
      console.error("Error fetching owner:", ownerError);
      setOwnerFetchError("Could not fetch account owner. Ensure the address is correct and on Lens Chain.");
      setExpectedOwner(null);
    } else if (isAddress(lensAccountAddress)) {
      setOwnerFetchError(null);
    }
  }, [ownerError, lensAccountAddress]);

  // Session Restore Effect
  useEffect(() => {
    console.log("Session Restore Check Effect: Running...");
    // Prevent restore logic while connection is initializing/reconnecting
    if (isConnecting || isReconnecting || status !== "connected") {
      console.log("Session Restore Check Effect: Waiting for connection to settle...");
      return;
    }

    // Only attempt restore if the wallet is definitively connected
    if (!connectedAddress) {
      console.log("Session Restore Check Effect: Wallet not connected, skipping restore.");
      // Ensure local storage is cleared if wallet is disconnected but data exists
      try {
        if (localStorage.getItem(LOCAL_STORAGE_KEYS.LENS_ACCOUNT_ADDRESS)) {
          console.log("Session Restore Check Effect: Clearing stale localStorage data as wallet is disconnected.");
          localStorage.removeItem(LOCAL_STORAGE_KEYS.LENS_ACCOUNT_ADDRESS);
          localStorage.removeItem(LOCAL_STORAGE_KEYS.EXPECTED_OWNER_ADDRESS);
          localStorage.removeItem(LOCAL_STORAGE_KEYS.LENS_USERNAME);
        }
      } catch (error) {
        console.error("Failed to clear stale session from localStorage:", error);
      }
      return;
    }

    let storedLensAddress: Address | null = null;
    let storedOwner: Address | null = null;
    let storedUsername: string | null = null;

    try {
      storedLensAddress = localStorage.getItem(LOCAL_STORAGE_KEYS.LENS_ACCOUNT_ADDRESS) as Address | null;
      storedOwner = localStorage.getItem(LOCAL_STORAGE_KEYS.EXPECTED_OWNER_ADDRESS) as Address | null;
      storedUsername = localStorage.getItem(LOCAL_STORAGE_KEYS.LENS_USERNAME);
      console.log("Session Restore Check Effect: Found stored data:", { storedLensAddress, storedOwner, storedUsername });
    } catch (error) {
      console.error("Session Restore Check Effect: Failed to read session from localStorage:", error);
      return;
    }

    // Check if essential data exists and is valid, and matches the connected wallet
    if (
      storedLensAddress &&
      isAddress(storedLensAddress) &&
      storedOwner &&
      isAddress(storedOwner) &&
      connectedAddress.toLowerCase() === storedOwner.toLowerCase()
    ) {
      // Check chain ID
      if (connectedChainId !== LENS_CHAIN_ID) {
        console.log("Session Restore Check Effect: Wallet connected but on wrong chain. Waiting for switch.");
        setVerificationError("Previous session found. Please switch to the Lens Chain.");
        setLensAccountAddress(storedLensAddress);
        setLensUsername(storedUsername || "");
        setExpectedOwner(storedOwner);
        return;
      }

      console.log("Session Restore Check Effect: Valid session found, wallet connected correctly. Restoring session and redirecting...");
      setVerifiedAccount(storedLensAddress, connectedAddress);
      setLensAccountAddress(storedLensAddress);
      setLensUsername(storedUsername || "");
      setExpectedOwner(storedOwner);
      setVerificationError(null);

      router.replace("/dashboard");
    } else {
      console.log("Session Restore Check Effect: No valid stored session found or owner mismatch.");
      try {
        localStorage.removeItem(LOCAL_STORAGE_KEYS.LENS_ACCOUNT_ADDRESS);
        localStorage.removeItem(LOCAL_STORAGE_KEYS.EXPECTED_OWNER_ADDRESS);
        localStorage.removeItem(LOCAL_STORAGE_KEYS.LENS_USERNAME);
      } catch (error) {
        console.error("Failed to clear invalid session data from localStorage:", error);
      }
    }
  }, [status, connectedAddress, connectedChainId, isConnecting, isReconnecting, router, setVerifiedAccount, clearContext]);

  // Effect for Owner Verification and Navigation
  useEffect(() => {
    if (!isConnected || !connectedAddress || !expectedOwner || !isAddress(lensAccountAddress)) {
      return;
    }

    if (connectedChainId !== LENS_CHAIN_ID) {
      setVerificationError("Please switch to the Lens Chain in your wallet.");
      clearContext();
      return;
    }

    if (connectedAddress.toLowerCase() === expectedOwner.toLowerCase()) {
      console.log("Owner verified! Storing session and navigating...");
      setVerificationError(null);

      try {
        localStorage.setItem(LOCAL_STORAGE_KEYS.LENS_ACCOUNT_ADDRESS, lensAccountAddress);
        localStorage.setItem(LOCAL_STORAGE_KEYS.EXPECTED_OWNER_ADDRESS, expectedOwner);
        localStorage.setItem(LOCAL_STORAGE_KEYS.LENS_USERNAME, lensUsername || "");
        console.log("Session data stored in localStorage");
      } catch (error) {
        console.error("Failed to write session to localStorage:", error);
      }

      setVerifiedAccount(lensAccountAddress, connectedAddress);
      router.push("/dashboard");
    } else {
      console.log("Owner mismatch:", { connected: connectedAddress, expected: expectedOwner });
      setVerificationError(`Incorrect owner connected. Please connect with wallet: ${expectedOwner}`);
      try {
        localStorage.removeItem(LOCAL_STORAGE_KEYS.LENS_ACCOUNT_ADDRESS);
        localStorage.removeItem(LOCAL_STORAGE_KEYS.EXPECTED_OWNER_ADDRESS);
        localStorage.removeItem(LOCAL_STORAGE_KEYS.LENS_USERNAME);
      } catch (error) {
        console.error("Failed to clear session from localStorage during mismatch:", error);
      }
      clearContext();
    }
  }, [connectedAddress, connectedChainId, expectedOwner, lensAccountAddress, lensUsername, isConnected, router, setVerifiedAccount, clearContext]);

  const showConnectButton = expectedOwner && !isLoadingOwner && !ownerFetchError;

  return (
    <main className="relative flex min-h-screen flex-col items-center justify-center p-6 md:p-24 bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50">
      <h1 className="text-4xl font-bold text-gray-800 mb-12">Lens Account Dashboard</h1>
      <div className="w-full max-w-lg p-8 space-y-8 bg-white rounded-xl shadow-lg">
        <DiscoveryForm
          onAccountDetailsFound={handleAccountDetailsFound}
          initialAddress={lensAccountAddress || ""}
          initialUsername={lensUsername || ""}
        />

        <div className="space-y-4">
          {isAddress(lensAccountAddress) && isLoadingOwner && <p className="text-center text-indigo-600">Fetching owner...</p>}

          {ownerFetchError && !isLoadingOwner && <p className="text-center text-red-600">{ownerFetchError}</p>}

          {expectedOwner && !isLoadingOwner && !ownerFetchError && (
            <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
              <p className="text-sm font-medium text-blue-800 mb-1">Identified Account Owner:</p>
              <p className="text-xs text-blue-700 break-words font-mono">{expectedOwner}</p>
              {!isConnected && <p className="text-xs text-blue-600 mt-2">Connect this wallet to proceed.</p>}
            </div>
          )}

          {verificationError && <p className="text-sm text-center text-red-600">{verificationError}</p>}

          {showConnectButton && (
            <div className="flex flex-col items-center gap-2">
              <ConnectOwnerButton />
              {isConnected && connectedChainId !== LENS_CHAIN_ID && <p className="text-xs text-orange-600">Waiting for network switch...</p>}
            </div>
          )}
        </div>
      </div>

      <div className="absolute bottom-8 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2">
        <a href="https://fkng.social" target="_blank" rel="noopener noreferrer" className="block text-gray-400 hover:text-gray-500 transition-colors">
          <img src="/FKNG.SOCIAL.svg" alt="FKNG.SOCIAL" className="h-4 w-auto" />
        </a>
        <p className="font-sans text-[10px] font-extralight text-gray-400">JOIN THE FKNG REVOLUTION</p>
      </div>
    </main>
  );
}
</file>

<file path="src/lib/constants.ts">
// lib/constants.ts
import { defineChain, parseAbi } from "viem";

export const LENS_CHAIN_ID = 232;

export const lensChain = defineChain({
  id: LENS_CHAIN_ID,
  name: "Lens Chain",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"],
    },
  },
  blockExplorers: {
    default: { name: "Lens Explorer", url: "https://explorer.lens.xyz" },
  },
  testnet: false,
});

// --- Contract Addresses ---
export const LENS_GLOBAL_NAMESPACE_ADDRESS = "0x1aA55B9042f08f45825dC4b651B64c9F98Af4615";
export const WGHO_TOKEN_ADDRESS = "0x6bDc36E20D267Ff0dd6097799f82e78907105e2F";
export const BONSAI_TOKEN_ADDRESS = "0xB0588f9A9cADe7CD5f194a5fe77AcD6A58250f82";

// --- ABIs ---
export const LENS_GLOBAL_NAMESPACE_ABI = parseAbi([
  "function accountOf(string calldata name) view returns (address)",
  "function usernameOf(address user) view returns (string)",
  "error DoesNotExist()",
]);

export const LENS_ACCOUNT_ABI = parseAbi([
  "function owner() view returns (address)",
  "function executeTransaction(address target, uint256 value, bytes calldata data)",
  "function transferOwnership(address newOwner)",
]);

// Standard ERC20 ABI including transfer and approve
export const ERC20_ABI = parseAbi([
  "function balanceOf(address owner) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)", // Needed for Send
  "function approve(address spender, uint256 amount) returns (bool)", // Needed for Approve
  "function allowance(address owner, address spender) view returns (uint256)", // Optional: useful for display
  "function decimals() view returns (uint8)", // Optional: useful for parsing amounts
  "event Transfer(address indexed from, address indexed to, uint256 value)",
  "event Approval(address indexed owner, address indexed spender, uint256 value)",
]);

// Specific ABI for WGHO Wrap/Unwrap
export const WGHO_ABI = parseAbi([
  "function deposit() payable", // payable is key
  "function withdraw(uint256 amount)",
  "event Deposit(address indexed dst, uint256 wad)",
  "event Withdrawal(address indexed src, uint256 wad)",
]);

// --- Local Storage Keys ---
export const LOCAL_STORAGE_KEYS = {
  LENS_ACCOUNT_ADDRESS: "lensSession:lensAccountAddress",
  EXPECTED_OWNER_ADDRESS: "lensSession:expectedOwner",
  LENS_USERNAME: "lensSession:username",
};
</file>

<file path="DEVELOPMENT_PLAN.md">
**Version:** 1.0
**Date:** 2025-04-19

## 1. Introduction

This document outlines the phased development plan for building the Minimum Viable Product (MVP) of the Lens Account Web Interface. It breaks down the work into manageable stages, aligning with the Functional Specification (`Spec.functional.md`) and Technical Specification (`TECHNICAL_SPEC.md`).

## 2. Methodology

We will follow an incremental development approach, building and verifying core features stage by stage. Each stage should result in a testable piece of functionality.

## 3. Development Stages

### Stage 0: Project Setup & Base Configuration (Completed via Setup)

- [x] Initialize Next.js 15+ project with TypeScript, Tailwind CSS, App Router.
- [x] Install pnpm as the package manager.
- [x] Install core dependencies: `wagmi`, `viem`, `@tanstack/react-query`, `connectkit`, `@reown/walletkit`, `@walletconnect/core`, `@walletconnect/utils`.
- [x] Set up basic ESLint and Prettier configuration.
- [x] Create `.env.local` with `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID` placeholder.
- [x] Configure `WagmiProvider` and `QueryClientProvider` in the root layout (`app/layout.tsx`).
  - **Check:** Development server runs (`pnpm dev`) without errors. Base Next.js page loads.

### Stage 1: Account Discovery & Chain Read Interaction

**Goal:** Implement the username/address input fields and the logic to look up corresponding data from the `LensGlobalNamespace` contract on the Lens Chain. Verify basic read operations work.

- **Tasks:**
  - [x] **Create Constants:** Define Lens Chain details (ID 232, RPC URL, etc.), `LensGlobalNamespace` address, and its partial ABI (`accountOf(string)`, `usernameOf(address)`) in `lib/constants.ts`.
  - [x] **Update Wagmi Config:** Ensure the `lensChain` object is defined using `defineChain` and included in the `createConfig` call in `lib/wagmi.ts`.
  - [x] **Create DiscoveryForm Component:** Build `components/DiscoveryForm.tsx` with two controlled input fields (Username, Account Address) styled with Tailwind.
  - [x] **Implement Lookup Logic:**
    - [x] Inside `DiscoveryForm.tsx` or a custom hook (`hooks/useLensLookup.ts`), use `useState` for input values.
    - [x] Use `useEffect` with a debounce utility (e.g., from `lodash.debounce` or simple `setTimeout`) to trigger lookups on input change.
    - [x] Call `useReadContract` (Wagmi) within the debounced effect:
      - Target `LensGlobalNamespace` address.
      - Use the appropriate function (`accountOf` or `usernameOf`) based on which input changed.
      - **Crucially:** Pass `chainId: LENS_CHAIN_ID` to ensure the call targets the correct network.
      - Handle loading and error states from `useReadContract`.
    - [x] Update the _other_ input field's state based on the successful result from `useReadContract`.
  - [x] **Integrate Form:** Place `DiscoveryForm.tsx` onto the root page (`app/page.tsx`).
- **Verification:**
  - [x] Typing a known Lens username (e.g., `stani`) correctly populates the Account Address field.
  - [x] Typing/pasting a known Lens Account address correctly populates the Lens Username field (if one exists).
  - [x] Invalid inputs show no result or subtle error indication.
  - [x] Check browser developer console for any Wagmi/Viem errors related to contract reads. Network tab should show RPC calls to the Lens Chain RPC URL.

### Stage 2: Owner EOA Connection & Verification

**Goal:** Integrate the "Connect Wallet" functionality, fetch the Lens Account owner, verify it against the connected EOA, handle chain switching, and navigate to the dashboard.

- **Tasks:**
  - [x] **Add Owner ABI:** Include the `owner()` function signature in the `LENS_ACCOUNT_ABI` within `lib/constants.ts`.
  - [x] **Create Connect Button:** Build `components/ConnectOwnerButton.tsx`. Use ConnectKit's `<ConnectKitButton />` or its underlying hooks (`useModal`, etc.) for the UI.
  - [x] **Fetch Expected Owner:**
    - In `app/page.tsx`, once a valid Lens Account address is determined (from Stage 1 state), use `useReadContract` to call `owner()` on the Lens Account address.
    - Pass `chainId: LENS_CHAIN_ID`.
    - Store the result in state (`expectedOwner`).
  - [x] **Display Expected Owner:** Show the `expectedOwner` address clearly near the `ConnectOwnerButton`.
  - [x] **Integrate Connect Button:** Add `ConnectOwnerButton` to `app/page.tsx`, potentially disabling it until `expectedOwner` is fetched.
  - [x] **Implement Verification Logic:**
    - In `app/page.tsx`, use `useAccount` (Wagmi) to get the connected EOA's `address` and `chainId`.
    - Use `useEffect` to monitor changes in the connected `address`, `chainId`, and the `expectedOwner`.
    - Inside the effect:
      - If `address` and `expectedOwner` exist:
        - If `chainId !== LENS_CHAIN_ID`, do nothing (ConnectKit/Wagmi handle switch prompt).
        - If `address.toLowerCase() === expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, proceed to navigation.
        - If `address.toLowerCase() !== expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, set an error state ("Incorrect owner connected...").
      - If `address` is disconnected, clear any error state.
  - [x] **Implement Navigation:**
    - Use `useRouter` from `next/navigation`.
    - When verification passes (addresses match, correct chain), call `router.push('/dashboard')`.
  - [x] **Create Context (Optional but Recommended):** Create `contexts/LensAccountProvider.tsx` to store the verified `lensAccountAddress` and `ownerAddress` so the dashboard can access them. Wrap the root layout or dashboard layout with this provider. Update `app/page.tsx` to set context values upon successful verification before navigating.
- **Verification:**
  - [x] "Connect Wallet" button appears/enables only when a Lens Account address is set and `owner()` has been potentially fetched. Expected owner address is displayed.
  - [x] Clicking "Connect Wallet" opens the ConnectKit modal.
  - [x] Connecting the _correct_ Owner EOA wallet on the wrong network prompts a "Switch Network" request to Lens Chain.
  - [x] Connecting the _correct_ Owner EOA wallet on the Lens Chain navigates the user to `/dashboard`.
  - [x] Connecting an _incorrect_ EOA wallet (not the owner) on the Lens Chain displays a clear error message and _does not_ navigate.
  - [x] Disconnecting the wallet returns the user to the login/discovery state or clears the owner state.

### Stage 3: Basic Dashboard Display

**Goal:** Create the dashboard page and display the Lens Account address and its WGHO balance.

- **Tasks:**
  - [x] **Create Dashboard Page:** Create `app/dashboard/page.tsx`. Ensure it's protected or redirects if owner/lens account state (from Context) is missing.
  - [x] **Add WGHO Constants:** Define `WGHO_TOKEN_ADDRESS` and `ERC20_ABI` (with `balanceOf(address)`) in `lib/constants.ts`.
  - [x] **Create AccountDisplay Component:** Build `components/AccountDisplay.tsx`.
  - [x] **Fetch/Display Data:**
    - In `AccountDisplay.tsx`, retrieve the `lensAccountAddress` from context (e.g., `useContext(LensAccountContext)`).
    - Use `useReadContract` (Wagmi) to call `balanceOf(lensAccountAddress)` on the `WGHO_TOKEN_ADDRESS`.
    - Pass `chainId: LENS_CHAIN_ID`.
    - Use Viem's `formatUnits` to format the returned balance (assuming WGHO has 18 decimals).
    - Display the `lensAccountAddress` and the formatted WGHO balance. Handle loading/error states for the balance fetch.
  - [x] **Integrate Component:** Add `AccountDisplay` to the dashboard page.
  - [x] Do the same for native GHO
- **Verification:**
  - [x] Navigating to `/dashboard` after successful login shows the correct Lens Account address.
  - [x] The GHO/WGHO balance for the Lens Account is fetched and displayed correctly (or shows loading/error state).

### Stage 4: WalletConnect v2 Pairing (Act as Wallet)

**Goal:** Implement the WalletConnect URI input and pairing logic, allowing the web app (representing the Lens Account) to connect to external dApps.

- **Tasks:**
  - [x] **Create WC Service:** Set up `services/walletConnectService.ts`. Include an `init` method that creates a `Web3Wallet` instance from `@reown/walletkit` using the `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`. Store the instance.
  - [x] **Create WC Context:** Set up `contexts/WalletConnectProvider.tsx`. Initialize the `walletConnectService` on mount. Provide the `web3wallet` instance, active sessions state (`useState`), pairing state (`useState`), and pending request state (`useState`) via context.
  - [x] **Wrap Layout:** Wrap the relevant part of the application (e.g., dashboard layout or root layout) with `WalletConnectProvider`.
  - [x] **Create WcConnect Component:** Build `components/WcConnect.tsx`.
    - Include an `<input>` for the WC URI and a `<button>` ("Connect").
    - Add state for the input value.
    - On button click, call a `pair` function provided by the `WalletConnectContext`.
  - [x] **Implement Pairing Logic:**
    - In `WalletConnectProvider` (or the service), define the `pair(uri)` function. Call `web3wallet.core.pairing.pair({ uri })`. Handle potential errors.
    - Set up the `session_proposal` listener (`web3wallet.on('session_proposal', handleSessionProposal)`).
  - [x] **Implement Session Approval:**
    - Define `handleSessionProposal(proposal)` in the service/provider.
    - Retrieve the `lensAccountAddress` and `LENS_CHAIN_ID` from state/constants.
    - Construct the `approvedNamespaces` object containing only the `eip155` namespace, with the `LENS_CHAIN_ID`, the Lens Account address (formatted as `eip155:232:0x...`), required methods (`eth_sendTransaction`, `personal_sign`, etc.), and events (`chainChanged`, `accountsChanged`).
    - Call `web3wallet.approveSession({ id: proposal.id, namespaces: approvedNamespaces })`.
    - On success, update the `activeSessions` state in the context.
    - Handle potential errors during approval.
  - [x] **Update UI:** Modify `WcConnect.tsx` to:
    - Conditionally render the input/button form OR the connected dApp info based on `activeSessions` state from context.
    - Display dApp metadata (name, icon, url) from the active session.
- **Verification:**
  - [x] Open the dashboard page. The WC input form is visible.
  - [x] Go to a test dApp (e.g., Reown's React Dapp Example) and generate a WC v2 URI.
  - [x] Paste the URI into the input field in _this_ app and click "Connect".
  - [x] The connection should establish successfully (no prompt needed in the Owner EOA wallet for pairing/session _approval_ in this flow).
  - [x] The `WcConnect.tsx` component should update to show the connected dApp's information. Check the dApp, it should also show a successful connection to the _Lens Account address_.

### Stage 5: WalletConnect v2 Transaction Request Handling

**Goal:** Handle incoming `eth_sendTransaction` requests from the connected dApp, prompt the Owner EOA for approval via the Lens Account's `executeTransaction`, and relay the result.

- **Tasks:**
  - [ ] **Create WcRequestDisplay Component:** Build `components/WcRequestDisplay.tsx`. It should conditionally render based on the `pendingRequest` state from `WalletConnectContext`. Display request details (`to`, `value`, `data` hex string) and "Send Transaction" / "Reject" buttons.
  - [ ] **Implement Request Listener:**
    - In `WalletConnectProvider` (or service), set up the `session_request` listener (`web3wallet.on('session_request', handleSessionRequest)`).
    - Define `handleSessionRequest(event)`: Store the `event.topic`, `event.id`, and `event.params.request` (`{ method, params }`) in the `pendingRequest` state of the context. Only handle `eth_sendTransaction` for MVP.
  - [ ] **Implement Transaction Execution Logic:**
    - Create `hooks/useWcRequestHandler.ts` or add logic to `WcRequestDisplay.tsx`.
    - On "Send Transaction" click:
      - Get `lensAccountAddress`, `ownerAddress` from relevant contexts.
      - Get `topic`, `id`, `request` (`method`, `params`) from `WalletConnectContext.pendingRequest`.
      - Extract `to`, `value`, `data` from `request.params[0]`.
      - Call `useWriteContract` (Wagmi) hook configured for the `executeTransaction` function on the `LENS_ACCOUNT_ABI` and `lensAccountAddress`.
      - The `args` for `executeTransaction` will be `[to, value || 0n, data || '0x']`.
      - Pass `account: ownerAddress` and `chainId: LENS_CHAIN_ID` to `useWriteContract`'s mutation function.
      - Use `useWaitForTransactionReceipt` to wait for the transaction hash returned by `writeContract`.
  - [ ] **Implement Response Logic:**
    - Modify the "Send Transaction" click handler:
      - On `writeContract` success: Wait for the receipt. If receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`.
      - If receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a JSON-RPC error payload (e.g., `{ id, jsonrpc: '2.0', error: { code: -32000, message: 'Transaction reverted' } }`).
      - On `writeContract` error (e.g., user rejection in EOA wallet): Call `web3wallet.respondSessionRequest` with a user rejection error payload (`{ id, jsonrpc: '2.0', error: { code: 5000, message: 'User Rejected' } }`).
    - On "Reject" click: Call `web3wallet.respondSessionRequest` with a user rejection error payload.
    - After responding (success or error), clear the `pendingRequest` state in the context.
  - [ ] **Integrate Component:** Add `WcRequestDisplay` to the dashboard page.
- **Verification:**
  - [ ] Connect to a test dApp (e.g., Aave testnet interface pointed to Lens Chain RPC, or a simple custom test page).
  - [ ] Initiate a transaction on the test dApp (e.g., a simple contract call or ETH transfer _if possible via the dApp_).
  - [ ] The `WcRequestDisplay` component should appear in _this_ app showing the request details.
  - [ ] Clicking "Reject" should send an error to the dApp and hide the request display.
  - [ ] Clicking "Send Transaction" should:
    - Prompt the _Owner EOA wallet_ (MetaMask, etc.) to confirm the `executeTransaction` call on the Lens Account.
    - Rejecting in the Owner EOA wallet sends an error to the dApp.
    - Confirming in the Owner EOA wallet sends the transaction.
    - Upon successful mining, the transaction hash is sent back to the dApp, and the request display hides. Success feedback is shown.
    - If the on-chain execution reverts, an error is sent back to the dApp, and the request display hides. Error feedback is shown.

## 4. Post-MVP Considerations

- Implement handling for other WalletConnect methods (`personal_sign`, etc.).
- Add UI for managing active WalletConnect sessions (viewing, disconnecting).
- Improve transaction data decoding in the request display.
- Enhance error messages and user feedback.
- Refine UI/UX, add loading states more granularly.
- Mobile responsiveness.
</file>

<file path="src/app/dashboard/page.tsx">
// src/app/dashboard/page.tsx
"use client";

import { useLensAccount } from "@/contexts/LensAccountContext";
import { useAccount, useDisconnect } from "wagmi";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { AccountDisplay } from "@/components/AccountDisplay";
import { WcConnect } from "@/components/WcConnect";
import { WcRequestDisplay } from "@/components/WcRequestDisplay";
import { LOCAL_STORAGE_KEYS } from "@/lib/constants";
import { AccountIdentityPanel } from "@/components/dashboard/AccountIdentityPanel";
import { OwnerPanel } from "@/components/dashboard/OwnerPanel";

export default function Dashboard() {
  const { lensAccountAddress, ownerAddress, clearAccount } = useLensAccount();
  const { isConnected } = useAccount();
  const { disconnect: disconnectOwnerWallet } = useDisconnect();
  const router = useRouter();
  const [lensUsername, setLensUsername] = useState<string | null>(null);

  useEffect(() => {
    try {
      const storedUsername = localStorage.getItem(LOCAL_STORAGE_KEYS.LENS_USERNAME);
      setLensUsername(storedUsername);
    } catch (error) {
      console.error("Failed to read username from localStorage:", error);
    }
  }, []);

  useEffect(() => {
    if (!isConnected || !lensAccountAddress || !ownerAddress) {
      clearAccount();
      router.push("/");
    }
  }, [isConnected, lensAccountAddress, ownerAddress, router, clearAccount]);

  const handleLogout = () => {
    disconnectOwnerWallet();
    clearAccount();
    router.push("/");
  };

  if (!isConnected || !lensAccountAddress || !ownerAddress) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-500">Loading or redirecting...</p>
      </div>
    );
  }

  return (
    <main className="min-h-screen bg-gray-100 p-4 md:p-8">
      {/* Header Area */}
      <div className="max-w-7xl mx-auto mb-6 flex justify-between items-center">
        <h1 className="text-3xl font-bold text-gray-800">Lens Account Dashboard</h1>
        <button
          onClick={handleLogout}
          className="px-4 py-2 bg-red-600 text-white text-sm font-medium rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 shadow-sm"
        >
          Logout
        </button>
      </div>

      {/* Main Grid for Panels */}
      <div className="max-w-7xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Panel 1: Account Identity */}
        <div className="col-span-1 md:col-span-2 bg-white p-6 rounded-lg shadow">
          <AccountIdentityPanel username={lensUsername} address={lensAccountAddress} />
        </div>

        {/* Panel 2: Owner Info */}
        <div className="col-span-1 bg-white p-6 rounded-lg shadow">
          <OwnerPanel ownerAddress={ownerAddress} />
        </div>

        {/* Panel 3: Balances */}
        <div className="col-span-1 bg-white p-6 rounded-lg shadow">
          <h2 className="text-xl font-semibold mb-4 text-gray-700">Account Balances</h2>
          <AccountDisplay />
        </div>

        {/* Panel 4: WalletConnect Connect */}
        <div className="col-span-1 md:col-span-2 bg-white p-6 rounded-lg shadow">
          <WcConnect />
        </div>

        {/* Panel 5: WalletConnect Requests */}
        <div className="col-span-1 md:col-span-2 bg-white p-6 rounded-lg shadow">
          <WcRequestDisplay />
        </div>
      </div>
    </main>
  );
}
</file>

<file path="package.json">
{
  "name": "lens-account-interface4",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prepare": "husky",
    "generate-llms": "repomix --include \"*.*,src\" --ignore \"llms.txt\" -o llms.txt",
    "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,css,md,json}\"",
    "format:check": "prettier --check \"src/**/*.{js,jsx,ts,tsx,css,md,json}\""
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@reown/walletkit": "^1.2.3",
    "@tanstack/react-query": "^5.74.4",
    "@walletconnect/core": "^2.20.0",
    "@walletconnect/jsonrpc-utils": "^1.0.8",
    "@walletconnect/utils": "^2.20.0",
    "connectkit": "^1.9.0",
    "next": "15.3.1",
    "qrcode.react": "^4.2.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "viem": "^2.27.2",
    "wagmi": "^2.14.16"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/webpack": "^5.28.5",
    "@walletconnect/types": "^2.20.0",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "husky": "^9.1.7",
    "pino-pretty": "^13.0.0",
    "prettier": "^3.5.3",
    "repomix": "^0.3.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="src/contexts/WalletConnectProvider.tsx">
// src/contexts/WalletConnectProvider.tsx
"use client";

import React, { createContext, useState, useContext, ReactNode, useEffect, useCallback, useMemo, useRef } from "react";
// Import the CLASS and types
import { WalletConnectService, ServiceEvents, type WalletConnectServiceEvents } from "@/services/walletConnectService";
import { SessionTypes } from "@walletconnect/types";
import { IWalletKit, WalletKitTypes } from "@reown/walletkit";
import { buildApprovedNamespaces, getSdkError } from "@walletconnect/utils";
import { useLensAccount } from "./LensAccountContext";
import { LENS_CHAIN_ID } from "@/lib/constants";
import { JsonRpcResponse } from "@walletconnect/jsonrpc-utils";

// Keep the context state definition
interface WalletConnectContextState {
  walletKitInstance: IWalletKit | null;
  activeSessions: Record<string, SessionTypes.Struct>;
  pendingProposal: WalletKitTypes.SessionProposal | null;
  pendingRequest: WalletKitTypes.SessionRequest | null;
  pair: (uri: string) => Promise<void>;
  disconnect: (topic: string) => Promise<void>;
  approveSession: () => Promise<void>;
  rejectSession: () => Promise<void>;
  respondRequest: (response: JsonRpcResponse) => Promise<void>;
  isLoading: boolean;
  isInitializing: boolean;
  isPairing: boolean;
  isProcessingAction: boolean;
  error: string | null;
  isInitialized: boolean;
}

const WalletConnectContext = createContext<WalletConnectContextState | undefined>(undefined);

interface WalletConnectProviderProps {
  children: ReactNode;
}

const DAPP_METADATA: WalletKitTypes.Metadata = {
  name: "Lens Account Interface",
  description: "Interface for managing Lens Account via WalletConnect",
  url: typeof window !== "undefined" ? window.location.origin : "http://localhost:3000",
  icons: ["/favicon.ico"],
};

// --- WalletConnectProvider Component ---
export function WalletConnectProvider({ children }: WalletConnectProviderProps) {
  const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;

  // --- State Management ---
  const serviceRef = useRef<WalletConnectService | null>(null);
  const [walletKitInstance, setWalletKitInstance] = useState<IWalletKit | null>(null);
  const [activeSessions, setActiveSessions] = useState<Record<string, SessionTypes.Struct>>({});
  const [pendingProposal, setPendingProposal] = useState<WalletKitTypes.SessionProposal | null>(null);
  const [pendingRequest, setPendingRequest] = useState<WalletKitTypes.SessionRequest | null>(null);
  const [isInitializing, setIsInitializing] = useState(true);
  const [isPairing, setIsPairing] = useState(false);
  const [isProcessingAction, setIsProcessingAction] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  const { lensAccountAddress } = useLensAccount();

  console.log(
    `%cWalletConnectProvider Render: isInitialized=${isInitialized}, isInitializing=${isInitializing}, isPairing=${isPairing}, isProcessing=${isProcessingAction}, serviceExists=${!!serviceRef.current}, pendingProposal=${!!pendingProposal}, pendingRequest=${!!pendingRequest}`,
    "color: blue",
  );

  // --- Effect to Create Instance, Initialize ONCE ---
  useEffect(() => {
    if (!projectId) {
      console.error("WalletConnectProvider: Project ID missing. Cannot initialize service.");
      setError("WalletConnect Project ID is missing.");
      setIsInitializing(false);
      setIsInitialized(false);
      return;
    }
    // Prevent re-initialization if instance already exists in ref
    if (serviceRef.current) {
      console.log(
        `%cWalletConnectProvider Mount Effect: Service instance already exists in ref. Skipping creation/init. isInitialized=${serviceRef.current.isInitialized()}`,
        "color: yellow",
      );
      // Sync state if needed (e.g. HMR occurred after init finished)
      if (serviceRef.current.isInitialized() && !isInitialized) {
        setIsInitialized(true);
        setIsInitializing(false);
        setWalletKitInstance(serviceRef.current.getWalletKitInstance() ?? null);
        setActiveSessions(serviceRef.current.getActiveSessions());
      } else if (serviceRef.current.isInitializing() && !isInitializing) {
        setIsInitializing(true);
      }
    } else {
      console.log(`%cWalletConnectProvider Mount Effect: Creating NEW service instance and initializing...`, "color: orange");
      setIsInitializing(true);
      setError(null);
      const service = new WalletConnectService(projectId, DAPP_METADATA);
      serviceRef.current = service; // Store the instance in the ref

      service.init().catch((initError: Error | unknown) => {
        console.error("WalletConnectProvider Mount Effect: service.init() rejected.", initError);
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [projectId]); // Add projectId dependency

  // --- Effect to Attach/Detach Event Listeners ---
  useEffect(() => {
    const currentService = serviceRef.current; // Capture ref value for effect closure
    if (!currentService) {
      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
      return;
    }

    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");

    // Define handlers
    const handleInitialized: WalletConnectServiceEvents[ServiceEvents.Initialized] = ({ success, instance }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
      setIsInitialized(success);
      setWalletKitInstance(success ? instance : null);
      if (currentService) setActiveSessions(currentService.getActiveSessions());
      setIsInitializing(false);
      if (!success && !error) setError("Initialization failed via event");
    };
    const handlePairStatus: WalletConnectServiceEvents[ServiceEvents.PairStatus] = ({ status, message }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
      setIsPairing(status === "pairing");
      if (status === "error") {
        setError(message || "Pairing failed");
        setIsPairing(false);
      } else if (status !== "pairing") {
        setError(null);
      }
    };
    const handleSessionProposal: WalletConnectServiceEvents[ServiceEvents.SessionProposal] = ({ proposal }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
      setPendingProposal(proposal);
      setIsPairing(false);
      setError(null);
    };
    const handleSessionConnect: WalletConnectServiceEvents[ServiceEvents.SessionConnect] = ({ session }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
      setIsPairing(false);
      setError(null);
      setPendingProposal(null);
    };
    // This now handles PEER disconnects or SDK internal cleanup events
    const handleSessionDelete: WalletConnectServiceEvents[ServiceEvents.SessionDelete] = ({ topic }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
      setActiveSessions((prev) => {
        if (!prev[topic]) return prev;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { [topic]: _removed, ...rest } = prev;
        console.log(`%cProvider State: Removing session ${topic} based on SDK/PEER event.`, "color: brown");
        return rest;
      });
      setIsPairing(false);
      if (pendingProposal && pendingProposal.params.pairingTopic === topic) {
        console.log("%cProvider: Clearing pending proposal due to SDK/peer session delete event.", "color: brown");
        setPendingProposal(null);
      }
    };
    const handleSessionsUpdated: WalletConnectServiceEvents[ServiceEvents.SessionsUpdated] = ({ sessions }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
      setActiveSessions(sessions);
    };
    const handleSessionRequest: WalletConnectServiceEvents[ServiceEvents.SessionRequest] = ({ request }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
      if (request.params.request.method === "eth_sendTransaction") {
        setPendingRequest(request);
        setError(null);
      } else {
        console.warn(`%cProvider Listener: Received unhandled request method: ${request.params.request.method}`, "color: orange");
      }
    };
    const handleError: WalletConnectServiceEvents[ServiceEvents.Error] = ({ message }) => {
      console.error(`%cProvider Listener: ${ServiceEvents.Error} received:`, "color: red", message);
      setError(message);
      setIsPairing(false);
      setIsProcessingAction(false);
    };
    const handleIsLoading: WalletConnectServiceEvents[ServiceEvents.IS_LOADING] = ({ isLoading }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
      setIsProcessingAction(isLoading);
    };
    const handleIsPairing: WalletConnectServiceEvents[ServiceEvents.IS_PAIRING] = ({ isPairing }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
      setIsPairing(isPairing);
    };

    // Attach listeners
    currentService.on(ServiceEvents.Initialized, handleInitialized);
    currentService.on(ServiceEvents.PairStatus, handlePairStatus);
    currentService.on(ServiceEvents.SessionProposal, handleSessionProposal);
    currentService.on(ServiceEvents.SessionConnect, handleSessionConnect);
    currentService.on(ServiceEvents.SessionDelete, handleSessionDelete);
    currentService.on(ServiceEvents.SessionsUpdated, handleSessionsUpdated);
    currentService.on(ServiceEvents.Error, handleError);
    currentService.on(ServiceEvents.IS_LOADING, handleIsLoading);
    currentService.on(ServiceEvents.IS_PAIRING, handleIsPairing);
    currentService.on(ServiceEvents.SessionRequest, handleSessionRequest);

    // Cleanup function
    return () => {
      console.log("%cWalletConnectProvider Mount Effect: Cleaning up listeners.", "color: orange");
      if (currentService) {
        // Use the captured variable
        console.log("%cDetaching listeners from service instance in ref.", "color: orange");
        currentService.off(ServiceEvents.Initialized, handleInitialized);
        currentService.off(ServiceEvents.PairStatus, handlePairStatus);
        currentService.off(ServiceEvents.SessionProposal, handleSessionProposal);
        currentService.off(ServiceEvents.SessionConnect, handleSessionConnect);
        currentService.off(ServiceEvents.SessionDelete, handleSessionDelete);
        currentService.off(ServiceEvents.SessionsUpdated, handleSessionsUpdated);
        currentService.off(ServiceEvents.Error, handleError);
        currentService.off(ServiceEvents.IS_LOADING, handleIsLoading);
        currentService.off(ServiceEvents.IS_PAIRING, handleIsPairing);
        currentService.off(ServiceEvents.SessionRequest, handleSessionRequest);
      }
    };
  }, [error, pendingProposal]);

  // --- Context Methods ---
  const pair = useCallback(async (uri: string) => {
    if (!serviceRef.current?.isInitialized()) return setError("Service not initialized");
    console.log(`%cWalletConnectProvider: pair called`, "color: cyan");
    setError(null);
    await serviceRef.current.pair(uri);
  }, []);

  const approveSession = useCallback(async () => {
    if (!serviceRef.current?.isInitialized() || !pendingProposal || !lensAccountAddress) {
      const reason = !isInitialized ? "Service not ready." : !pendingProposal ? "No proposal." : "No Lens address.";
      setError(`Cannot approve: ${reason}`);
      return;
    }
    console.log(`%cWalletConnectProvider: approveSession called for proposal ${pendingProposal.id}`, "color: cyan");
    setError(null);

    try {
      const requiredNamespaces = pendingProposal.params.requiredNamespaces || {};
      const optionalNamespaces = pendingProposal.params.optionalNamespaces || {};
      const requestedMethods = [...(requiredNamespaces.eip155?.methods || []), ...(optionalNamespaces.eip155?.methods || [])];
      const requestedEvents = [...(requiredNamespaces.eip155?.events || []), ...(optionalNamespaces.eip155?.events || [])];
      const methods = requestedMethods.length > 0 ? requestedMethods : ["eth_sendTransaction", "personal_sign", "eth_signTypedData_v4"];
      const events = requestedEvents.length > 0 ? requestedEvents : ["chainChanged", "accountsChanged"];
      const approvedNamespaces = buildApprovedNamespaces({
        proposal: pendingProposal.params,
        supportedNamespaces: {
          eip155: {
            chains: [`eip155:${LENS_CHAIN_ID}`],
            methods: methods,
            events: events,
            accounts: [`eip155:${LENS_CHAIN_ID}:${lensAccountAddress}`],
          },
        },
      });

      const session = await serviceRef.current.approveSession(pendingProposal, approvedNamespaces);
      console.log(`%cWalletConnectProvider: approveSession successful, received session:`, "color: green", session);
      // Manually update state since event might not fire from SDK
      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
      setPendingProposal(null);
      setIsPairing(false);
      setError(null);
    } catch (e) {
      console.error(`%cWalletConnectProvider: approveSession failed:`, "color: red", e);
    }
  }, [isInitialized, pendingProposal, lensAccountAddress]);

  const rejectSession = useCallback(async () => {
    if (!serviceRef.current?.isInitialized() || !pendingProposal) {
      const reason = !isInitialized ? "Service not ready." : "No proposal.";
      setError(`Cannot reject: ${reason}`);
      return;
    }
    console.log(`%cWalletConnectProvider: rejectSession called for proposal ${pendingProposal.id}`, "color: cyan");
    setError(null);
    try {
      await serviceRef.current.rejectSession(pendingProposal, getSdkError("USER_REJECTED"));
      setPendingProposal(null); // Clear proposal state immediately
    } catch (e) {
      console.error(`%cWalletConnectProvider: rejectSession failed:`, "color: red", e);
    }
  }, [isInitialized, pendingProposal]);

  // >>>>>>>> REVERTED disconnect callback <<<<<<<<
  const disconnect = useCallback(
    async (topic: string) => {
      if (!serviceRef.current?.isInitialized()) {
        setError("Service not initialized");
        console.error("WalletConnectProvider: disconnect called before service initialized.");
        return;
      }
      console.log(`%cWalletConnectProvider: disconnect called for topic ${topic}`, "color: cyan");
      setError(null);

      try {
        await serviceRef.current.disconnectSession(topic, getSdkError("USER_DISCONNECTED"));
        console.log(`%cWalletConnectProvider: disconnect service call succeeded for topic ${topic}`, "color: green");

        // Manually update the Provider's state AFTER successful call
        setActiveSessions((prev) => {
          if (!prev[topic]) {
            console.warn(`%cWalletConnectProvider: Tried to remove non-existent session ${topic} from state.`, "color: orange");
            return prev;
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const { [topic]: _removed, ...rest } = prev;
          console.log(`%cWalletConnectProvider: Manually removing session ${topic} from state.`, "color: brown");
          return rest;
        });
        // Ensure other related states are cleared
        setIsPairing(false);
        if (pendingProposal?.params?.pairingTopic === topic) {
          console.log(`%cWalletConnectProvider: Clearing pending proposal during manual disconnect cleanup for topic ${topic}.`, "color: brown");
          setPendingProposal(null);
        }
      } catch (e) {
        console.error(`%cWalletConnectProvider: disconnect failed for topic ${topic}:`, "color: red", e);
        setError((e as Error)?.message || "Disconnect failed");
      }
    },
    [pendingProposal], // isInitialized was correctly removed previously
  );
  // >>>>>>>> ----------------------------- <<<<<<<<

  const respondRequest = useCallback(
    async (response: JsonRpcResponse) => {
      if (!serviceRef.current?.isInitialized() || !pendingRequest) {
        setError("Service not initialized or no pending request.");
        console.error("WalletConnectProvider: respondRequest called incorrectly.");
        return;
      }
      console.log(`%cWalletConnectProvider: respondRequest called for ID ${response.id}`, "color: cyan", response);
      setError(null);

      try {
        await serviceRef.current.respondSessionRequest(pendingRequest.topic, response);
        console.log(`%cWalletConnectProvider: response sent successfully for request ${response.id}`, "color: green");
      } catch (e) {
        console.error(`%cWalletConnectProvider: respondRequest failed for ID ${response.id}:`, "color: red", e);
        setError((e as Error)?.message || "Failed to send response");
      } finally {
        setPendingRequest(null);
      }
    },
    [pendingRequest], // Remove isInitialized
  );

  // --- Context Value Memoization ---
  const contextValue = useMemo(
    () => ({
      walletKitInstance,
      activeSessions,
      pendingProposal,
      pendingRequest,
      pair,
      disconnect, // Pass the reverted disconnect function
      approveSession,
      rejectSession,
      respondRequest,
      isLoading: isInitializing || isPairing || isProcessingAction,
      isInitializing,
      isPairing,
      isProcessingAction,
      error,
      isInitialized,
    }),
    [
      walletKitInstance,
      activeSessions,
      pendingProposal,
      pendingRequest,
      pair,
      disconnect, // Include reverted disconnect
      approveSession,
      rejectSession,
      respondRequest,
      isInitializing,
      isPairing,
      isProcessingAction,
      error,
      isInitialized,
    ],
  );

  if (!projectId) {
    throw new Error("WalletConnect projectId is required. Please set NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID in your environment variables.");
  }

  return projectId ? (
    <WalletConnectContext.Provider value={contextValue}>{children}</WalletConnectContext.Provider>
  ) : (
    <div>Error: WalletConnect Project ID is missing. Cannot initialize WalletConnect.</div>
  );
}

// Keep hook
export function useWalletConnect() {
  const context = useContext(WalletConnectContext);
  if (context === undefined) {
    throw new Error("useWalletConnect must be used within a WalletConnectProvider");
  }
  return context;
}

// Export the context for direct usage if needed
export { WalletConnectContext };
</file>

</files>
