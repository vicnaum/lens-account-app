This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: *.*, src
- Files matching these patterns are excluded: llms.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  app/
    dashboard/
      layout.tsx
      page.tsx
    layout.tsx
    page.tsx
    providers.tsx
  components/
    AccountDisplay.tsx
    ConnectOwnerButton.tsx
    DiscoveryForm.tsx
    WcConnect.tsx
    WcRequestDisplay.tsx
  contexts/
    LensAccountContext.tsx
    WalletConnectProvider.tsx
  hooks/
    useDebounce.ts
  lib/
    constants.ts
    wagmi.ts
  services/
    walletConnectService.ts
  styles/
    globals.css
.gitignore
.prettierrc
DEVELOPMENT_PLAN.md
diff.txt
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
Spec.functional.md
Spec.technical.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="diff.txt">
diff --git a/llms.txt b/llms.txt
index b9e1e50..ff0162b 100644
--- a/llms.txt
+++ b/llms.txt
@@ -1,4 +1,4 @@
-This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
+This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
 
 <file_summary>
 This section contains a summary of this file.
@@ -32,6 +32,7 @@ The content is organized as follows:
 - Some files may have been excluded based on .gitignore rules and Repomix's configuration
 - Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
 - Only files matching these patterns are included: *.*, src
+- Files matching these patterns are excluded: llms.txt
 - Files matching patterns in .gitignore are excluded
 - Files matching default ignore patterns are excluded
 - Files are sorted by Git change count (files with more changes are at the bottom)
@@ -712,433 +713,95 @@ export function DiscoveryForm({ onAccountAddressFound, initialUsername = "", ini
 }
 </file>
 
-<file path="src/components/WcRequestDisplay.tsx">
-// src/components/WcRequestDisplay.tsx
+<file path="src/contexts/LensAccountContext.tsx">
+// contexts/LensAccountContext.tsx
 "use client";
 
-import React, { useState, useEffect, useCallback, useRef } from "react";
-import { useWalletConnect } from "@/contexts/WalletConnectProvider";
-import { useLensAccount } from "@/contexts/LensAccountContext";
-import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
-import { formatUnits, type Hash } from "viem";
-import { getSdkError } from "@walletconnect/utils";
-import { formatJsonRpcError, formatJsonRpcResult, JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
-import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, lensChain } from "@/lib/constants";
+import React, { createContext, useState, useContext, ReactNode } from "react";
+import { type Address } from "viem";
 
-// Basic Fallback Icon Component
-const FallbackIcon = ({ size = 30 }: { size?: number }) => (
-  <div
-    style={{ width: `${size}px`, height: `${size}px` }}
-    className="rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs"
-  >
-    ?
-  </div>
-);
+interface LensAccountState {
+  lensAccountAddress: Address | null;
+  ownerAddress: Address | null;
+  setVerifiedAccount: (lensAddress: Address, ownerAddress: Address) => void;
+  clearAccount: () => void;
+}
 
-export function WcRequestDisplay() {
-  const { pendingRequest, respondRequest, error: wcError, isLoading: isWcLoading } = useWalletConnect();
-  const { lensAccountAddress } = useLensAccount();
-  const { address: ownerAddress, chainId: ownerChainId } = useAccount();
+const LensAccountContext = createContext<LensAccountState | undefined>(undefined);
 
-  // State related to the write *initiation*
-  const { data: hash, error: writeError, isPending: isWritePending, writeContractAsync, reset: resetWriteContract } = useWriteContract();
-  // State related to the *confirmation* of the hash from write initiation
-  const {
-    isLoading: isConfirming,
-    isSuccess: isConfirmed,
-    error: receiptError,
-    data: receipt,
-  } = useWaitForTransactionReceipt({ hash, chainId: LENS_CHAIN_ID });
+interface LensAccountProviderProps {
+  children: ReactNode;
+}
 
-  const [localError, setLocalError] = useState<string | null>(null);
-  const [localLoadingMessage, setLocalLoadingMessage] = useState<string | null>(null);
-  // Store the ID of the request currently being actively processed
-  const processingRequestId = useRef<number | null>(null);
-  // Store the hash associated with the *currently processed* request ID
-  const processingRequestHash = useRef<Hash | null>(null);
+export function LensAccountProvider({ children }: LensAccountProviderProps) {
+  const [lensAccountAddress, setLensAccountAddress] = useState<Address | null>(null);
+  const [ownerAddress, setOwnerAddress] = useState<Address | null>(null);
 
-  // --- Log Component Render ---
-  console.log(
-    `%cWcRequestDisplay Render: pendingReqId=${pendingRequest?.id ?? "null"}, currentProcessingId=${processingRequestId.current}, currentProcessingHash=${processingRequestHash.current ?? "null"}, hookHash=${hash ?? "null"}, isWritePending=${isWritePending}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, writeError=${!!writeError}, receiptError=${!!receiptError}`,
-    "color: magenta",
-  );
-  // --------------------------
+  const setVerifiedAccount = (lensAddress: Address, verifiedOwnerAddress: Address) => {
+    setLensAccountAddress(lensAddress);
+    setOwnerAddress(verifiedOwnerAddress);
+    console.log("Context Updated: Lens Account Set ->", lensAddress);
+    console.log("Context Updated: Owner Set ->", verifiedOwnerAddress);
+  };
 
-  // --- Effect to Reset State When a NEW Request Arrives ---
-  useEffect(() => {
-    const incomingRequestId = pendingRequest?.id ?? null;
-    const currentProcessing = processingRequestId.current;
+  const clearAccount = () => {
+    setLensAccountAddress(null);
+    setOwnerAddress(null);
+    console.log("Context Updated: Account Cleared");
+  };
 
-    console.log(
-      `%cWcRequestDisplay ResetEffect: Running. Incoming ID: ${incomingRequestId}, Current Processing ID: ${currentProcessing}`,
-      "color: teal",
-    );
+  const value = {
+    lensAccountAddress,
+    ownerAddress,
+    setVerifiedAccount,
+    clearAccount,
+  };
 
-    if (incomingRequestId !== null) {
-      if (currentProcessing !== incomingRequestId) {
-        console.log(`%cWcRequestDisplay ResetEffect: New request ${incomingRequestId} detected. Resetting state.`, "color: teal");
-        resetWriteContract();
-        setLocalError(null);
-        setLocalLoadingMessage(null);
-        processingRequestId.current = incomingRequestId;
-        processingRequestHash.current = null; // Reset hash ref
-      } else {
-        console.log(
-          `%cWcRequestDisplay ResetEffect: Incoming ID ${incomingRequestId} matches current Processing ID. No reset needed.`,
-          "color: teal",
-        );
-      }
-    } else {
-      if (currentProcessing !== null) {
-        console.log(`%cWcRequestDisplay ResetEffect: No pending request. Resetting state.`, "color: teal");
-        resetWriteContract();
-        setLocalError(null);
-        setLocalLoadingMessage(null);
-        processingRequestId.current = null;
-        processingRequestHash.current = null; // Reset hash ref
-      } else {
-        console.log(`%cWcRequestDisplay ResetEffect: No pending request and nothing processing. No reset needed.`, "color: teal");
-      }
-    }
-  }, [pendingRequest, resetWriteContract]); // Now depends on pendingRequest object itself
+  return <LensAccountContext.Provider value={value}>{children}</LensAccountContext.Provider>;
+}
 
-  // --- Effect to track the hash associated with the current request ---
-  useEffect(() => {
-    if (hash && processingRequestId.current && !processingRequestHash.current) {
-      console.log(`%cWcRequestDisplay HashTrackEffect: Associating hash ${hash} with request ID ${processingRequestId.current}`, "color: purple");
-      processingRequestHash.current = hash; // Store the hash for the request we are processing
-    }
-  }, [hash, processingRequestId]); // Run when hash changes and we have a processing ID
+// Custom hook to use the context
+export function useLensAccount() {
+  const context = useContext(LensAccountContext);
+  if (context === undefined) {
+    throw new Error("useLensAccount must be used within a LensAccountProvider");
+  }
+  return context;
+}
+</file>
 
-  // --- Centralized Respond Function ---
-  const handleRespond = useCallback(
-    (response: JsonRpcResponse) => {
-      const currentId = processingRequestId.current;
-      if (currentId !== null && currentId === response.id) {
-        console.log(`%cWcRequestDisplay handleRespond: Responding for request ID: ${response.id}`, "color: darkmagenta", response);
-        respondRequest(response);
-        // Reset processing state *after* responding
-        processingRequestId.current = null;
-        processingRequestHash.current = null; // Reset hash ref
-        setLocalLoadingMessage(null);
-        resetWriteContract(); // Try resetting here too
-      } else {
-        console.warn(
-          `%cWcRequestDisplay handleRespond: Ignoring response attempt for stale/mismatched request ID: ${response.id} (Current Processing: ${currentId})`,
-          "color: orange",
-        );
-      }
-    },
-    [respondRequest, resetWriteContract],
-  ); // Add resetWriteContract
+<file path="src/lib/wagmi.ts">
+// lib/wagmi.ts
+import { http, createConfig } from "wagmi";
+import { getDefaultConfig } from "connectkit"; // Correct import
+import { lensChain } from "./constants";
 
-  // --- Effect to Handle Transaction Submission Result ---
-  useEffect(() => {
-    const currentProcessingId = processingRequestId.current;
-    const currentReqHash = processingRequestHash.current; // Use the hash we stored for this request
+const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;
 
-    console.log(
-      `%cWcRequestDisplay ReceiptEffect: Running. CurrentProcessingId=${currentProcessingId}, CurrentReqHash=${currentReqHash ?? "null"}, HookHash=${hash ?? "null"}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, receiptError=${!!receiptError}`,
-      "color: #2ECC71",
-    );
+if (!projectId) {
+  throw new Error("NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID is not set in .env.local");
+}
 
-    // Guards:
-    // 1. Must be processing a request.
-    // 2. Must have a specific hash associated with *this* request attempt.
-    // 3. The confirmation process must be finished (or errored).
-    // 4. The hook's current hash must match the hash associated with our request.
-    if (!currentProcessingId || !currentReqHash || isConfirming || hash !== currentReqHash) {
-      console.log(
-        `%cWcRequestDisplay ReceiptEffect: Bailing out (ProcessingID: ${currentProcessingId}, CurrentReqHash: ${currentReqHash}, HookHash: ${hash}, Confirming: ${isConfirming})`,
-        "color: gray",
-      );
-      return;
-    }
+export const config = createConfig(
+  // Use ConnectKit's getDefaultConfig
+  getDefaultConfig({
+    // Correct function name
+    // Required API Keys
+    walletConnectProjectId: projectId,
 
-    // Now check receipt and errors, ensuring they match the currentReqHash
-    if (receipt && receipt.transactionHash === currentReqHash) {
-      console.log(`%cWcRequestDisplay ReceiptEffect: Receipt received for current hash ${currentReqHash}`, "color: #2ECC71");
-      setLocalLoadingMessage(null);
-      if (receipt.status === "success") {
-        console.log(
-          `%cWcRequestDisplay ReceiptEffect: Transaction successful, calling handleRespond for ID ${currentProcessingId}`,
-          "color: #2ECC71",
-        );
-        handleRespond(formatJsonRpcResult(currentProcessingId, receipt.transactionHash));
-      } else {
-        console.error(
-          `%cWcRequestDisplay ReceiptEffect: Transaction reverted, calling handleRespond for ID ${currentProcessingId}`,
-          "color: red",
-          receipt,
-        );
-        setLocalError("Transaction reverted on chain.");
-        handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction reverted" }));
-      }
-    } else if (receiptError) {
-      console.error(
-        `%cWcRequestDisplay ReceiptEffect: Transaction Receipt Error for hash ${currentReqHash}, calling handleRespond for ID ${currentProcessingId}`,
-        "color: red",
-        receiptError,
-      );
-      setLocalError(`Transaction failed: ${receiptError.message}`);
-      handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction Failed on chain" }));
-    } else if (isConfirmed && !receipt) {
-      console.warn(
-        `%cWcRequestDisplay ReceiptEffect: isConfirmed is true but receipt is still null/undefined for hash ${currentReqHash}. Waiting.`,
-        "color: orange",
-      );
-    } else {
-      console.log(`%cWcRequestDisplay ReceiptEffect: No definitive action taken for hash ${currentReqHash}`, "color: gray");
-    }
-  }, [isConfirming, isConfirmed, receiptError, receipt, hash, handleRespond]); // Keep dependencies
+    // Required App Info
+    appName: "Lens Account Interface",
+    appDescription: "Interact with your Lens Account",
+    appUrl: typeof window !== "undefined" ? window.location.origin : "https://example.com",
+    appIcon: "/favicon.ico",
 
-  // --- Effect to Handle Direct Write Errors ---
-  useEffect(() => {
-    const currentProcessingId = processingRequestId.current;
-    console.log(`%cWcRequestDisplay WriteErrorEffect: Running. writeError=${!!writeError}, currentProcessingId=${currentProcessingId}`, "color: red");
-    if (writeError && currentProcessingId) {
-      console.error("WcRequestDisplay WriteErrorEffect: Write Contract Error detected:", writeError);
-      setLocalError(`Transaction rejected or failed to send: ${writeError.message}`);
-      handleRespond(formatJsonRpcError(currentProcessingId, getSdkError("USER_REJECTED")));
-    }
-  }, [writeError, handleRespond]);
+    // Chains to support
+    chains: [lensChain],
 
-  const handleApprove = async () => {
-    if (!pendingRequest) return setLocalError("No request to approve.");
-    if (!lensAccountAddress) return setLocalError("Lens Account address missing.");
-    if (!ownerAddress) return setLocalError("Owner wallet not connected.");
-    if (!writeContractAsync) return setLocalError("Transaction function not ready.");
-    if (ownerChainId !== LENS_CHAIN_ID) return setLocalError("Owner wallet not on Lens Chain.");
-
-    // Reset local state AND ensure we reset wagmi state *before* initiating write
-    console.log(`%cWcRequestDisplay handleApprove: Resetting state before write for request ID: ${pendingRequest.id}`, "color: blueviolet");
-    resetWriteContract(); // Reset here as well
-    processingRequestId.current = pendingRequest.id; // Mark immediately
-    processingRequestHash.current = null; // Clear previous hash
-    setLocalError(null);
-    setLocalLoadingMessage("Please confirm in your wallet...");
-
-    const { method, params } = pendingRequest.params.request;
-    if (method !== "eth_sendTransaction") {
-      const errorMsg = `Unsupported method: ${method}`;
-      setLocalError(errorMsg);
-      handleRespond(formatJsonRpcError(pendingRequest.id, { code: 4200, message: "Method not supported" }));
-      return;
-    }
-
-    const tx = params[0] as { to?: `0x${string}`; value?: string; data?: `0x${string}` };
-    const targetAddress = tx.to;
-    const value = tx.value ? BigInt(tx.value) : 0n;
-    const data = tx.data || "0x";
-
-    if (!targetAddress) {
-      const errorMsg = "Transaction 'to' address is missing.";
-      setLocalError(errorMsg);
-      handleRespond(formatJsonRpcError(pendingRequest.id, { code: -32602, message: "Invalid parameters: missing 'to' address" }));
-      return;
-    }
-
-    try {
-      console.log("%cWcRequestDisplay handleApprove: Calling writeContractAsync...", "color: blueviolet");
-      // Call async, the hash state update will trigger the HashTrackEffect
-      await writeContractAsync({
-        address: lensAccountAddress,
-        abi: LENS_ACCOUNT_ABI,
-        functionName: "executeTransaction",
-        args: [targetAddress, value, data],
-        account: ownerAddress,
-        chainId: LENS_CHAIN_ID,
-      });
-      console.log("%cWcRequestDisplay handleApprove: writeContractAsync call submitted.", "color: blueviolet");
-    } catch (error) {
-      console.error("WcRequestDisplay handleApprove: Error calling writeContractAsync:", error);
-      if (!writeError && processingRequestId.current) {
-        // Check current ID before responding
-        const errorMsg = `Failed to initiate transaction: ${(error as Error).message}`;
-        setLocalError(errorMsg);
-        handleRespond(formatJsonRpcError(processingRequestId.current, getSdkError("USER_REJECTED")));
-      }
-    }
-  };
-
-  const handleReject = () => {
-    if (!pendingRequest) return;
-    processingRequestId.current = pendingRequest.id; // Mark which request we are rejecting
-    setLocalError(null);
-    setLocalLoadingMessage(null);
-    console.log("WcRequestDisplay handleReject: Rejecting request:", pendingRequest.id);
-    handleRespond(formatJsonRpcError(pendingRequest.id, getSdkError("USER_REJECTED")));
-  };
-
-  // --- Render Logic ---
-  if (!pendingRequest) {
-    return (
-      <div className="p-4 border rounded-md bg-gray-50">
-        <p className="text-gray-600 text-center italic">No pending WalletConnect requests.</p>
-      </div>
-    );
-  }
-
-  // Extract request details safely
-  const { request, chainId } = pendingRequest.params;
-  const txDetails = request.params?.[0] as { to?: string; value?: string; data?: string } | undefined;
-  const dAppName = pendingRequest.verifyContext?.verified.origin || "Unknown dApp";
-  const dAppUrl = pendingRequest.verifyContext?.verified.origin;
-  const formattedValue = txDetails?.value
-    ? `${formatUnits(BigInt(txDetails.value), lensChain.nativeCurrency.decimals)} ${lensChain.nativeCurrency.symbol}`
-    : `0 ${lensChain.nativeCurrency.symbol}`;
-  const isLoading = isWritePending || isConfirming || isWcLoading;
-
-  return (
-    <div className="p-4 border-2 border-blue-300 rounded-md bg-blue-50 shadow-md space-y-4">
-      <h3 className="text-md font-semibold text-blue-800">WalletConnect Request</h3>
-      <div className="flex items-center space-x-3 mb-3 pb-3 border-b border-blue-200">
-        <FallbackIcon size={30} />
-        <div>
-          <p className="text-sm font-medium text-gray-800">{dAppName}</p>
-          {dAppUrl && <p className="text-xs text-gray-500">{dAppUrl}</p>}
-        </div>
-      </div>
-
-      <div className="space-y-2 text-sm">
-        <p>
-          <strong className="text-gray-600">Method:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{request.method}</span>
-        </p>
-        <p>
-          <strong className="text-gray-600">Chain:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{chainId}</span>
-        </p>
-        <p>
-          <strong className="text-gray-600">Target (to):</strong> <span className="font-mono text-xs break-all">{txDetails?.to ?? "N/A"}</span>
-        </p>
-        <p>
-          <strong className="text-gray-600">Value:</strong> <span className="font-mono">{formattedValue}</span>
-        </p>
-        <div>
-          <strong className="text-gray-600">Data:</strong>
-          <textarea
-            readOnly
-            value={txDetails?.data ?? "0x"}
-            className="mt-1 w-full h-20 p-1 border border-gray-300 rounded text-xs font-mono bg-gray-50"
-          />
-        </div>
-      </div>
-
-      {/* Status Display */}
-      {localLoadingMessage && <p className="text-sm text-center text-indigo-600 animate-pulse">{localLoadingMessage}</p>}
-      {localError && <p className="text-sm text-center text-red-600">{localError}</p>}
-      {wcError && !localError && <p className="text-sm text-center text-red-600">WC Error: {wcError}</p>}
-
-      {/* Action Buttons */}
-      <div className="flex space-x-3 pt-2">
-        <button
-          onClick={handleApprove}
-          disabled={isLoading}
-          className="flex-1 px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
-        >
-          {isWritePending ? "Check Wallet..." : isConfirming ? "Confirming..." : "Approve & Send"}
-        </button>
-        <button
-          onClick={handleReject}
-          disabled={isLoading}
-          className="flex-1 px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-md shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
-        >
-          Reject
-        </button>
-      </div>
-    </div>
-  );
-}
-</file>
-
-<file path="src/contexts/LensAccountContext.tsx">
-// contexts/LensAccountContext.tsx
-"use client";
-
-import React, { createContext, useState, useContext, ReactNode } from "react";
-import { type Address } from "viem";
-
-interface LensAccountState {
-  lensAccountAddress: Address | null;
-  ownerAddress: Address | null;
-  setVerifiedAccount: (lensAddress: Address, ownerAddress: Address) => void;
-  clearAccount: () => void;
-}
-
-const LensAccountContext = createContext<LensAccountState | undefined>(undefined);
-
-interface LensAccountProviderProps {
-  children: ReactNode;
-}
-
-export function LensAccountProvider({ children }: LensAccountProviderProps) {
-  const [lensAccountAddress, setLensAccountAddress] = useState<Address | null>(null);
-  const [ownerAddress, setOwnerAddress] = useState<Address | null>(null);
-
-  const setVerifiedAccount = (lensAddress: Address, verifiedOwnerAddress: Address) => {
-    setLensAccountAddress(lensAddress);
-    setOwnerAddress(verifiedOwnerAddress);
-    console.log("Context Updated: Lens Account Set ->", lensAddress);
-    console.log("Context Updated: Owner Set ->", verifiedOwnerAddress);
-  };
-
-  const clearAccount = () => {
-    setLensAccountAddress(null);
-    setOwnerAddress(null);
-    console.log("Context Updated: Account Cleared");
-  };
-
-  const value = {
-    lensAccountAddress,
-    ownerAddress,
-    setVerifiedAccount,
-    clearAccount,
-  };
-
-  return <LensAccountContext.Provider value={value}>{children}</LensAccountContext.Provider>;
-}
-
-// Custom hook to use the context
-export function useLensAccount() {
-  const context = useContext(LensAccountContext);
-  if (context === undefined) {
-    throw new Error("useLensAccount must be used within a LensAccountProvider");
-  }
-  return context;
-}
-</file>
-
-<file path="src/lib/wagmi.ts">
-// lib/wagmi.ts
-import { http, createConfig } from "wagmi";
-import { getDefaultConfig } from "connectkit"; // Correct import
-import { lensChain } from "./constants";
-
-const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;
-
-if (!projectId) {
-  throw new Error("NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID is not set in .env.local");
-}
-
-export const config = createConfig(
-  // Use ConnectKit's getDefaultConfig
-  getDefaultConfig({
-    // Correct function name
-    // Required API Keys
-    walletConnectProjectId: projectId,
-
-    // Required App Info
-    appName: "Lens Account Interface",
-    appDescription: "Interact with your Lens Account",
-    appUrl: typeof window !== "undefined" ? window.location.origin : "https://example.com",
-    appIcon: "/favicon.ico",
-
-    // Chains to support
-    chains: [lensChain],
-
-    // Transports (ensure http is configured for your chain)
-    transports: {
-      [lensChain.id]: http(lensChain.rpcUrls.default.http[0]),
-    },
+    // Transports (ensure http is configured for your chain)
+    transports: {
+      [lensChain.id]: http(lensChain.rpcUrls.default.http[0]),
+    },
 
     // ssr: true, // Keep commented unless SSR hydration with cookies is needed
   }),
@@ -1584,21 +1247,359 @@ export function AccountDisplay() {
         )}
       </div>
 
-      {/* WGHO Balance */}
-      <div>
-        {wghoBalanceError && !isLoadingWghoBalance && (
-          <p className="text-red-600 text-sm">
-            Error loading WGHO balance: {(wghoBalanceError as BaseError).shortMessage || wghoBalanceError.message}
-          </p>
-        )}
-        {!wghoBalanceError && !isLoadingWghoBalance && lensAccountAddress && (
-          <p className="text-gray-800">
-            <span className="font-medium">WGHO Token:</span> <span className="font-mono text-lg">{formattedWghoBalance}</span> GHO
-          </p>
-        )}
+      {/* WGHO Balance */}
+      <div>
+        {wghoBalanceError && !isLoadingWghoBalance && (
+          <p className="text-red-600 text-sm">
+            Error loading WGHO balance: {(wghoBalanceError as BaseError).shortMessage || wghoBalanceError.message}
+          </p>
+        )}
+        {!wghoBalanceError && !isLoadingWghoBalance && lensAccountAddress && (
+          <p className="text-gray-800">
+            <span className="font-medium">WGHO Token:</span> <span className="font-mono text-lg">{formattedWghoBalance}</span> GHO
+          </p>
+        )}
+      </div>
+
+      {!lensAccountAddress && !isLoading && <p className="text-gray-500 text-sm mt-2">Cannot fetch balances without Lens Account address.</p>}
+    </div>
+  );
+}
+</file>
+
+<file path="src/components/WcRequestDisplay.tsx">
+// src/components/WcRequestDisplay.tsx
+"use client";
+
+import React, { useState, useEffect, useCallback, useRef } from "react";
+import { useWalletConnect } from "@/contexts/WalletConnectProvider";
+import { useLensAccount } from "@/contexts/LensAccountContext";
+import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
+import { formatUnits, type Hash } from "viem";
+import { getSdkError } from "@walletconnect/utils";
+import { formatJsonRpcError, formatJsonRpcResult, JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
+import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, lensChain } from "@/lib/constants";
+
+// Basic Fallback Icon Component
+const FallbackIcon = ({ size = 30 }: { size?: number }) => (
+  <div
+    style={{ width: `${size}px`, height: `${size}px` }}
+    className="rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs"
+  >
+    ?
+  </div>
+);
+
+export function WcRequestDisplay() {
+  const { pendingRequest, respondRequest, error: wcError, isLoading: isWcLoading } = useWalletConnect();
+  const { lensAccountAddress } = useLensAccount();
+  const { address: ownerAddress, chainId: ownerChainId } = useAccount();
+
+  // State related to the write *initiation*
+  const { data: hash, error: writeError, isPending: isWritePending, writeContractAsync, reset: resetWriteContract } = useWriteContract();
+  // State related to the *confirmation* of the hash from write initiation
+  const {
+    isLoading: isConfirming,
+    isSuccess: isConfirmed,
+    error: receiptError,
+    data: receipt,
+  } = useWaitForTransactionReceipt({ hash, chainId: LENS_CHAIN_ID });
+
+  const [localError, setLocalError] = useState<string | null>(null);
+  const [localLoadingMessage, setLocalLoadingMessage] = useState<string | null>(null);
+  // Store the ID of the request currently being actively processed
+  const processingRequestId = useRef<number | null>(null);
+  // Store the hash associated with the *currently processed* request ID
+  const processingRequestHash = useRef<Hash | null>(null);
+
+  // --- Log Component Render ---
+  console.log(
+    `%cWcRequestDisplay Render: pendingReqId=${pendingRequest?.id ?? "null"}, currentProcessingId=${processingRequestId.current}, currentProcessingHash=${processingRequestHash.current ?? "null"}, hookHash=${hash ?? "null"}, isWritePending=${isWritePending}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, writeError=${!!writeError}, receiptError=${!!receiptError}`,
+    "color: magenta",
+  );
+  // --------------------------
+
+  // --- Effect to Reset State When a NEW Request Arrives ---
+  useEffect(() => {
+    const incomingRequestId = pendingRequest?.id ?? null;
+    const currentProcessing = processingRequestId.current;
+
+    console.log(
+      `%cWcRequestDisplay ResetEffect: Running. Incoming ID: ${incomingRequestId}, Current Processing ID: ${currentProcessing}`,
+      "color: teal",
+    );
+
+    if (incomingRequestId !== null) {
+      if (currentProcessing !== incomingRequestId) {
+        console.log(`%cWcRequestDisplay ResetEffect: New request ${incomingRequestId} detected. Resetting state.`, "color: teal");
+        resetWriteContract();
+        setLocalError(null);
+        setLocalLoadingMessage(null);
+        processingRequestId.current = incomingRequestId;
+        processingRequestHash.current = null; // Reset hash ref
+      } else {
+        console.log(
+          `%cWcRequestDisplay ResetEffect: Incoming ID ${incomingRequestId} matches current Processing ID. No reset needed.`,
+          "color: teal",
+        );
+      }
+    } else {
+      if (currentProcessing !== null) {
+        console.log(`%cWcRequestDisplay ResetEffect: No pending request. Resetting state.`, "color: teal");
+        resetWriteContract();
+        setLocalError(null);
+        setLocalLoadingMessage(null);
+        processingRequestId.current = null;
+        processingRequestHash.current = null; // Reset hash ref
+      } else {
+        console.log(`%cWcRequestDisplay ResetEffect: No pending request and nothing processing. No reset needed.`, "color: teal");
+      }
+    }
+  }, [pendingRequest, resetWriteContract]); // Now depends on pendingRequest object itself
+
+  // --- Effect to track the hash associated with the current request ---
+  useEffect(() => {
+    if (hash && processingRequestId.current && !processingRequestHash.current) {
+      console.log(`%cWcRequestDisplay HashTrackEffect: Associating hash ${hash} with request ID ${processingRequestId.current}`, "color: purple");
+      processingRequestHash.current = hash; // Store the hash for the request we are processing
+    }
+  }, [hash, processingRequestId]); // Run when hash changes and we have a processing ID
+
+  // --- Centralized Respond Function ---
+  const handleRespond = useCallback(
+    (response: JsonRpcResponse) => {
+      const currentId = processingRequestId.current;
+      if (currentId !== null && currentId === response.id) {
+        console.log(`%cWcRequestDisplay handleRespond: Responding for request ID: ${response.id}`, "color: darkmagenta", response);
+        respondRequest(response);
+        // Reset processing state *after* responding
+        processingRequestId.current = null;
+        processingRequestHash.current = null; // Reset hash ref
+        setLocalLoadingMessage(null);
+        resetWriteContract(); // Try resetting here too
+      } else {
+        console.warn(
+          `%cWcRequestDisplay handleRespond: Ignoring response attempt for stale/mismatched request ID: ${response.id} (Current Processing: ${currentId})`,
+          "color: orange",
+        );
+      }
+    },
+    [respondRequest, resetWriteContract],
+  ); // Add resetWriteContract
+
+  // --- Effect to Handle Transaction Submission Result ---
+  useEffect(() => {
+    const currentProcessingId = processingRequestId.current;
+    const currentReqHash = processingRequestHash.current; // Use the hash we stored for this request
+
+    console.log(
+      `%cWcRequestDisplay ReceiptEffect: Running. CurrentProcessingId=${currentProcessingId}, CurrentReqHash=${currentReqHash ?? "null"}, HookHash=${hash ?? "null"}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, receiptError=${!!receiptError}`,
+      "color: #2ECC71",
+    );
+
+    // Guards:
+    // 1. Must be processing a request.
+    // 2. Must have a specific hash associated with *this* request attempt.
+    // 3. The confirmation process must be finished (or errored).
+    // 4. The hook's current hash must match the hash associated with our request.
+    if (!currentProcessingId || !currentReqHash || isConfirming || hash !== currentReqHash) {
+      console.log(
+        `%cWcRequestDisplay ReceiptEffect: Bailing out (ProcessingID: ${currentProcessingId}, CurrentReqHash: ${currentReqHash}, HookHash: ${hash}, Confirming: ${isConfirming})`,
+        "color: gray",
+      );
+      return;
+    }
+
+    // Now check receipt and errors, ensuring they match the currentReqHash
+    if (receipt && receipt.transactionHash === currentReqHash) {
+      console.log(`%cWcRequestDisplay ReceiptEffect: Receipt received for current hash ${currentReqHash}`, "color: #2ECC71");
+      setLocalLoadingMessage(null);
+      if (receipt.status === "success") {
+        console.log(
+          `%cWcRequestDisplay ReceiptEffect: Transaction successful, calling handleRespond for ID ${currentProcessingId}`,
+          "color: #2ECC71",
+        );
+        handleRespond(formatJsonRpcResult(currentProcessingId, receipt.transactionHash));
+      } else {
+        console.error(
+          `%cWcRequestDisplay ReceiptEffect: Transaction reverted, calling handleRespond for ID ${currentProcessingId}`,
+          "color: red",
+          receipt,
+        );
+        setLocalError("Transaction reverted on chain.");
+        handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction reverted" }));
+      }
+    } else if (receiptError) {
+      console.error(
+        `%cWcRequestDisplay ReceiptEffect: Transaction Receipt Error for hash ${currentReqHash}, calling handleRespond for ID ${currentProcessingId}`,
+        "color: red",
+        receiptError,
+      );
+      setLocalError(`Transaction failed: ${receiptError.message}`);
+      handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction Failed on chain" }));
+    } else if (isConfirmed && !receipt) {
+      console.warn(
+        `%cWcRequestDisplay ReceiptEffect: isConfirmed is true but receipt is still null/undefined for hash ${currentReqHash}. Waiting.`,
+        "color: orange",
+      );
+    } else {
+      console.log(`%cWcRequestDisplay ReceiptEffect: No definitive action taken for hash ${currentReqHash}`, "color: gray");
+    }
+  }, [isConfirming, isConfirmed, receiptError, receipt, hash, handleRespond]); // Keep dependencies
+
+  // --- Effect to Handle Direct Write Errors ---
+  useEffect(() => {
+    const currentProcessingId = processingRequestId.current;
+    console.log(`%cWcRequestDisplay WriteErrorEffect: Running. writeError=${!!writeError}, currentProcessingId=${currentProcessingId}`, "color: red");
+    if (writeError && currentProcessingId) {
+      console.error("WcRequestDisplay WriteErrorEffect: Write Contract Error detected:", writeError);
+      setLocalError(`Transaction rejected or failed to send: ${writeError.message}`);
+      handleRespond(formatJsonRpcError(currentProcessingId, getSdkError("USER_REJECTED")));
+    }
+  }, [writeError, handleRespond]);
+
+  const handleApprove = async () => {
+    if (!pendingRequest) return setLocalError("No request to approve.");
+    if (!lensAccountAddress) return setLocalError("Lens Account address missing.");
+    if (!ownerAddress) return setLocalError("Owner wallet not connected.");
+    if (!writeContractAsync) return setLocalError("Transaction function not ready.");
+    if (ownerChainId !== LENS_CHAIN_ID) return setLocalError("Owner wallet not on Lens Chain.");
+
+    // Reset local state AND ensure we reset wagmi state *before* initiating write
+    console.log(`%cWcRequestDisplay handleApprove: Resetting state before write for request ID: ${pendingRequest.id}`, "color: blueviolet");
+    resetWriteContract(); // Reset here as well
+    processingRequestId.current = pendingRequest.id; // Mark immediately
+    processingRequestHash.current = null; // Clear previous hash
+    setLocalError(null);
+    setLocalLoadingMessage("Please confirm in your wallet...");
+
+    const { method, params } = pendingRequest.params.request;
+    if (method !== "eth_sendTransaction") {
+      const errorMsg = `Unsupported method: ${method}`;
+      setLocalError(errorMsg);
+      handleRespond(formatJsonRpcError(pendingRequest.id, { code: 4200, message: "Method not supported" }));
+      return;
+    }
+
+    const tx = params[0] as { to?: `0x${string}`; value?: string; data?: `0x${string}` };
+    const targetAddress = tx.to;
+    const value = tx.value ? BigInt(tx.value) : 0n;
+    const data = tx.data || "0x";
+
+    if (!targetAddress) {
+      const errorMsg = "Transaction 'to' address is missing.";
+      setLocalError(errorMsg);
+      handleRespond(formatJsonRpcError(pendingRequest.id, { code: -32602, message: "Invalid parameters: missing 'to' address" }));
+      return;
+    }
+
+    try {
+      console.log("%cWcRequestDisplay handleApprove: Calling writeContractAsync...", "color: blueviolet");
+      // Call async, the hash state update will trigger the HashTrackEffect
+      await writeContractAsync({
+        address: lensAccountAddress,
+        abi: LENS_ACCOUNT_ABI,
+        functionName: "executeTransaction",
+        args: [targetAddress, value, data],
+        account: ownerAddress,
+        chainId: LENS_CHAIN_ID,
+      });
+      console.log("%cWcRequestDisplay handleApprove: writeContractAsync call submitted.", "color: blueviolet");
+    } catch (error) {
+      console.error("WcRequestDisplay handleApprove: Error calling writeContractAsync:", error);
+      if (!writeError && processingRequestId.current) {
+        // Check current ID before responding
+        const errorMsg = `Failed to initiate transaction: ${(error as Error).message}`;
+        setLocalError(errorMsg);
+        handleRespond(formatJsonRpcError(processingRequestId.current, getSdkError("USER_REJECTED")));
+      }
+    }
+  };
+
+  const handleReject = () => {
+    if (!pendingRequest) return;
+    processingRequestId.current = pendingRequest.id; // Mark which request we are rejecting
+    setLocalError(null);
+    setLocalLoadingMessage(null);
+    console.log("WcRequestDisplay handleReject: Rejecting request:", pendingRequest.id);
+    handleRespond(formatJsonRpcError(pendingRequest.id, getSdkError("USER_REJECTED")));
+  };
+
+  // --- Render Logic ---
+  if (!pendingRequest) {
+    return (
+      <div className="p-4 border rounded-md bg-gray-50">
+        <p className="text-gray-600 text-center italic">No pending WalletConnect requests.</p>
+      </div>
+    );
+  }
+
+  // Extract request details safely
+  const { request, chainId } = pendingRequest.params;
+  const txDetails = request.params?.[0] as { to?: string; value?: string; data?: string } | undefined;
+  const dAppName = pendingRequest.verifyContext?.verified.origin || "Unknown dApp";
+  const dAppUrl = pendingRequest.verifyContext?.verified.origin;
+  const formattedValue = txDetails?.value
+    ? `${formatUnits(BigInt(txDetails.value), lensChain.nativeCurrency.decimals)} ${lensChain.nativeCurrency.symbol}`
+    : `0 ${lensChain.nativeCurrency.symbol}`;
+  const isLoading = isWritePending || isConfirming || isWcLoading;
+
+  return (
+    <div className="p-4 border-2 border-blue-300 rounded-md bg-blue-50 shadow-md space-y-4">
+      <h3 className="text-md font-semibold text-blue-800">WalletConnect Request</h3>
+      <div className="flex items-center space-x-3 mb-3 pb-3 border-b border-blue-200">
+        <FallbackIcon size={30} />
+        <div>
+          <p className="text-sm font-medium text-gray-800">{dAppName}</p>
+          {dAppUrl && <p className="text-xs text-gray-500">{dAppUrl}</p>}
+        </div>
+      </div>
+
+      <div className="space-y-2 text-sm">
+        <p>
+          <strong className="text-gray-600">Method:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{request.method}</span>
+        </p>
+        <p>
+          <strong className="text-gray-600">Chain:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{chainId}</span>
+        </p>
+        <p>
+          <strong className="text-gray-600">Target (to):</strong> <span className="font-mono text-xs break-all">{txDetails?.to ?? "N/A"}</span>
+        </p>
+        <p>
+          <strong className="text-gray-600">Value:</strong> <span className="font-mono">{formattedValue}</span>
+        </p>
+        <div>
+          <strong className="text-gray-600">Data:</strong>
+          <textarea
+            readOnly
+            value={txDetails?.data ?? "0x"}
+            className="mt-1 w-full h-20 p-1 border border-gray-300 rounded text-xs font-mono bg-gray-50"
+          />
+        </div>
       </div>
 
-      {!lensAccountAddress && !isLoading && <p className="text-gray-500 text-sm mt-2">Cannot fetch balances without Lens Account address.</p>}
+      {/* Status Display */}
+      {localLoadingMessage && <p className="text-sm text-center text-indigo-600 animate-pulse">{localLoadingMessage}</p>}
+      {localError && <p className="text-sm text-center text-red-600">{localError}</p>}
+      {wcError && !localError && <p className="text-sm text-center text-red-600">WC Error: {wcError}</p>}
+
+      {/* Action Buttons */}
+      <div className="flex space-x-3 pt-2">
+        <button
+          onClick={handleApprove}
+          disabled={isLoading}
+          className="flex-1 px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
+        >
+          {isWritePending ? "Check Wallet..." : isConfirming ? "Confirming..." : "Approve & Send"}
+        </button>
+        <button
+          onClick={handleReject}
+          disabled={isLoading}
+          className="flex-1 px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-md shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
+        >
+          Reject
+        </button>
+      </div>
     </div>
   );
 }
@@ -1837,9 +1838,10 @@ export default function Home() {
 // src/components/WcConnect.tsx
 "use client";
 
-import React, { useState, useEffect } from "react";
+import React, { useState, useEffect, useCallback, useMemo } from "react";
 import { useWalletConnect } from "@/contexts/WalletConnectProvider"; // Ensure correct path
 import Image from "next/image";
+import { isExpired } from "@walletconnect/utils"; // <-- Import isExpired utility
 
 // Default/Fallback Icon
 const FallbackIcon = () => <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs">?</div>;
@@ -1901,52 +1903,75 @@ export function WcConnect() {
     pendingProposal, // Get the pending proposal
     approveSession, // Get approve action
     rejectSession, // Get reject action
-    isInitializing, // <<<--- ADDED isInitializing HERE ---<<<
+    isInitializing,
   } = useWalletConnect();
   const [uri, setUri] = useState("");
+  const [isSubmitting, setIsSubmitting] = useState(false);
 
   const activeSessionTopic = Object.keys(activeSessions)[0]; // Assuming only one session for MVP
   const connectedSession = activeSessionTopic ? activeSessions[activeSessionTopic] : null;
 
-  // --- Add this useEffect ---
+  // ---> Check if proposal is expired for UI state <--- //
+  const isProposalExpired = useMemo(() => {
+    if (!pendingProposal?.params?.expiryTimestamp) return false; // No timestamp means can't determine expiry this way
+    return isExpired(pendingProposal.params.expiryTimestamp);
+  }, [pendingProposal]); // Re-calculate only when proposal changes
+  // ---> End Expiry Check <--- //
+
   useEffect(() => {
-    // If there's no connected session (either initially or after disconnect),
-    // clear the URI input field.
     if (!connectedSession) {
       setUri("");
     }
-  }, [connectedSession]); // Run this effect when connectedSession changes
-  // -------------------------
-
-  const handleConnect = () => {
-    if (!uri || !isInitialized || isLoading) return; // Check initialization and combined loading state
-    pair(uri);
-  };
-
-  const handleDisconnect = () => {
-    if (connectedSession && isInitialized && !isLoading) {
-      // Check initialization and combined loading state
-      disconnect(connectedSession.topic);
+  }, [connectedSession]);
+
+  const handleConnect = useCallback(() => {
+    if (!uri || !isInitialized || isLoading || isSubmitting) return;
+    setIsSubmitting(true);
+    pair(uri).finally(() => setIsSubmitting(false));
+  }, [uri, isInitialized, isLoading, isSubmitting, pair]);
+
+  const handleDisconnect = useCallback(() => {
+    if (connectedSession && isInitialized && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      disconnect(connectedSession.topic).finally(() => setIsSubmitting(false));
     }
-  };
+  }, [connectedSession, isInitialized, isLoading, isSubmitting, disconnect]);
 
-  const handleApprove = () => {
-    if (pendingProposal && !isLoading) {
-      approveSession();
+  const handleApprove = useCallback(async () => {
+    if (pendingProposal && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      try {
+        await approveSession();
+      } catch (err) {
+        console.error("Approval failed:", err);
+      } finally {
+        setIsSubmitting(false);
+      }
     }
-  };
+  }, [pendingProposal, isLoading, isSubmitting, approveSession]);
 
-  const handleReject = () => {
-    if (pendingProposal && !isLoading) {
-      rejectSession();
+  const handleReject = useCallback(async () => {
+    if (pendingProposal && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      try {
+        await rejectSession();
+      } catch (err) {
+        console.error("Rejection failed:", err);
+      } finally {
+        setIsSubmitting(false);
+      }
     }
-  };
+  }, [pendingProposal, isLoading, isSubmitting, rejectSession]);
+
+  // Combined loading state (context is loading OR local component is submitting)
+  const isDisabled = isLoading || isSubmitting || !isInitialized;
+  const approveDisabled = isDisabled || isProposalExpired; // <-- Disable approve if expired
 
   // Display loading states more granularly if needed, otherwise use `isLoading`
-  const connectButtonText = isPairing ? "Pairing..." : isLoading ? "Working..." : "Connect";
-  const disconnectButtonText = isLoading ? "Working..." : "Disconnect";
-  const approveButtonText = isLoading ? "Working..." : "Approve Session";
-  const rejectButtonText = isLoading ? "Working..." : "Reject Session";
+  const connectButtonText = isPairing ? "Pairing..." : isSubmitting ? "Connecting..." : isLoading ? "Working..." : "Connect";
+  const disconnectButtonText = isSubmitting ? "Working..." : isLoading ? "Working..." : "Disconnect";
+  const approveButtonText = isSubmitting ? "Approving..." : isLoading ? "Working..." : "Approve Session";
+  const rejectButtonText = isSubmitting ? "Rejecting..." : isLoading ? "Working..." : "Reject Session";
 
   // Resolve icon URLs
   const connectedDAppIconUrl = connectedSession
@@ -1970,17 +1995,24 @@ export function WcConnect() {
             <span className="text-sm text-gray-700">{pendingProposal.params.proposer.metadata.name}</span>
           </div>
           {/* TODO: Display requested permissions details if needed */}
+          {/* ---> Add Expiry Message <--- */}
+          {isProposalExpired && (
+            <p className="text-sm font-medium text-red-600 text-center">
+              This connection proposal has expired. Please generate a new one from the dApp.
+            </p>
+          )}
+          {/* ---> End Expiry Message <--- */}
           <div className="flex space-x-2 pt-2">
             <button
               onClick={handleApprove}
-              disabled={isLoading || !isInitialized}
+              disabled={approveDisabled} // <--- Use specific disabled state
               className="flex-1 px-3 py-1 bg-green-500 text-white text-xs font-medium rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {approveButtonText}
             </button>
             <button
               onClick={handleReject}
-              disabled={isLoading || !isInitialized}
+              disabled={isDisabled} // Reject might still be possible even if expired, or disable too: `disabled={isDisabled || isProposalExpired}`
               className="flex-1 px-3 py-1 bg-red-500 text-white text-xs font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {rejectButtonText}
@@ -2006,7 +2038,7 @@ export function WcConnect() {
           </p>
           <button
             onClick={handleDisconnect}
-            disabled={isLoading || !isInitialized} // Use combined loading state
+            disabled={isDisabled}
             className="w-full px-4 py-2 mt-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
           >
             {disconnectButtonText}
@@ -2029,11 +2061,11 @@ export function WcConnect() {
               onChange={(e) => setUri(e.target.value)}
               placeholder="wc:..."
               className="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm disabled:bg-gray-100"
-              disabled={isLoading || !isInitialized} // Use combined loading state
+              disabled={isDisabled}
             />
             <button
               onClick={handleConnect}
-              disabled={!uri || isLoading || !isInitialized} // Use combined loading state
+              disabled={!uri || isDisabled}
               className="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {connectButtonText}
@@ -2043,11 +2075,9 @@ export function WcConnect() {
       )}
 
       {/* --- Status/Error Messages --- */}
-      {error && !isLoading && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
+      {error && !isLoading && !isSubmitting && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
       {isPairing && <p className="text-indigo-600 text-sm mt-2">Pairing initiated, check dApp/wallet if needed...</p>}
-      {/* Check both flags here now */}
       {!isInitialized && !isInitializing && !error && <p className="text-orange-600 text-sm mt-2">WalletConnect service not ready.</p>}
-      {/* And display initializing message correctly */}
       {isInitializing && <p className="text-gray-500 text-sm mt-2">Initializing WalletConnect...</p>}
     </div>
   );
@@ -2311,19 +2341,27 @@ export class WalletConnectService extends EventEmitter {
   }
   // -------------------------------------------
 
-  // Typed EventEmitter methods (keep as before)
+  // Typed EventEmitter methods (Apply this pattern to on, once, off, removeListener)
   on<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.on(event, listener as (...args: any[]) => void);
   }
+
   once<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.once(event, listener as (...args: any[]) => void);
   }
+
   off<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.off(event, listener as (...args: any[]) => void);
   }
+
   removeListener<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.removeListener(event, listener as (...args: any[]) => void);
   }
+
   emit<E extends keyof WalletConnectServiceEvents>(event: E, ...args: Parameters<WalletConnectServiceEvents[E]>): boolean {
     return super.emit(event, ...args);
   }
@@ -2341,7 +2379,7 @@ export class WalletConnectService extends EventEmitter {
     "start": "next start",
     "lint": "next lint",
     "prepare": "husky",
-    "generate-llms": "repomix --include \"*.*,src\" -o llms.txt",
+    "generate-llms": "repomix --include \"*.*,src\" --ignore \"llms.txt\" -o llms.txt",
     "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,css,md,json}\"",
     "format:check": "prettier --check \"src/**/*.{js,jsx,ts,tsx,css,md,json}\""
   },
@@ -2452,6 +2490,189 @@ export default function Dashboard() {
 }
 </file>
 
+<file path="DEVELOPMENT_PLAN.md">
+**Version:** 1.0
+**Date:** 2025-04-19
+
+## 1. Introduction
+
+This document outlines the phased development plan for building the Minimum Viable Product (MVP) of the Lens Account Web Interface. It breaks down the work into manageable stages, aligning with the Functional Specification (`Spec.functional.md`) and Technical Specification (`TECHNICAL_SPEC.md`).
+
+## 2. Methodology
+
+We will follow an incremental development approach, building and verifying core features stage by stage. Each stage should result in a testable piece of functionality.
+
+## 3. Development Stages
+
+### Stage 0: Project Setup & Base Configuration (Completed via Setup)
+
+- [x] Initialize Next.js 15+ project with TypeScript, Tailwind CSS, App Router.
+- [x] Install pnpm as the package manager.
+- [x] Install core dependencies: `wagmi`, `viem`, `@tanstack/react-query`, `connectkit`, `@reown/walletkit`, `@walletconnect/core`, `@walletconnect/utils`.
+- [x] Set up basic ESLint and Prettier configuration.
+- [x] Create `.env.local` with `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID` placeholder.
+- [x] Configure `WagmiProvider` and `QueryClientProvider` in the root layout (`app/layout.tsx`).
+  - **Check:** Development server runs (`pnpm dev`) without errors. Base Next.js page loads.
+
+### Stage 1: Account Discovery & Chain Read Interaction
+
+**Goal:** Implement the username/address input fields and the logic to look up corresponding data from the `LensGlobalNamespace` contract on the Lens Chain. Verify basic read operations work.
+
+- **Tasks:**
+  - [x] **Create Constants:** Define Lens Chain details (ID 232, RPC URL, etc.), `LensGlobalNamespace` address, and its partial ABI (`accountOf(string)`, `usernameOf(address)`) in `lib/constants.ts`.
+  - [x] **Update Wagmi Config:** Ensure the `lensChain` object is defined using `defineChain` and included in the `createConfig` call in `lib/wagmi.ts`.
+  - [x] **Create DiscoveryForm Component:** Build `components/DiscoveryForm.tsx` with two controlled input fields (Username, Account Address) styled with Tailwind.
+  - [x] **Implement Lookup Logic:**
+    - [x] Inside `DiscoveryForm.tsx` or a custom hook (`hooks/useLensLookup.ts`), use `useState` for input values.
+    - [x] Use `useEffect` with a debounce utility (e.g., from `lodash.debounce` or simple `setTimeout`) to trigger lookups on input change.
+    - [x] Call `useReadContract` (Wagmi) within the debounced effect:
+      - Target `LensGlobalNamespace` address.
+      - Use the appropriate function (`accountOf` or `usernameOf`) based on which input changed.
+      - **Crucially:** Pass `chainId: LENS_CHAIN_ID` to ensure the call targets the correct network.
+      - Handle loading and error states from `useReadContract`.
+    - [x] Update the _other_ input field's state based on the successful result from `useReadContract`.
+  - [x] **Integrate Form:** Place `DiscoveryForm.tsx` onto the root page (`app/page.tsx`).
+- **Verification:**
+  - [x] Typing a known Lens username (e.g., `stani`) correctly populates the Account Address field.
+  - [x] Typing/pasting a known Lens Account address correctly populates the Lens Username field (if one exists).
+  - [x] Invalid inputs show no result or subtle error indication.
+  - [x] Check browser developer console for any Wagmi/Viem errors related to contract reads. Network tab should show RPC calls to the Lens Chain RPC URL.
+
+### Stage 2: Owner EOA Connection & Verification
+
+**Goal:** Integrate the "Connect Wallet" functionality, fetch the Lens Account owner, verify it against the connected EOA, handle chain switching, and navigate to the dashboard.
+
+- **Tasks:**
+  - [x] **Add Owner ABI:** Include the `owner()` function signature in the `LENS_ACCOUNT_ABI` within `lib/constants.ts`.
+  - [x] **Create Connect Button:** Build `components/ConnectOwnerButton.tsx`. Use ConnectKit's `<ConnectKitButton />` or its underlying hooks (`useModal`, etc.) for the UI.
+  - [x] **Fetch Expected Owner:**
+    - In `app/page.tsx`, once a valid Lens Account address is determined (from Stage 1 state), use `useReadContract` to call `owner()` on the Lens Account address.
+    - Pass `chainId: LENS_CHAIN_ID`.
+    - Store the result in state (`expectedOwner`).
+  - [x] **Display Expected Owner:** Show the `expectedOwner` address clearly near the `ConnectOwnerButton`.
+  - [x] **Integrate Connect Button:** Add `ConnectOwnerButton` to `app/page.tsx`, potentially disabling it until `expectedOwner` is fetched.
+  - [x] **Implement Verification Logic:**
+    - In `app/page.tsx`, use `useAccount` (Wagmi) to get the connected EOA's `address` and `chainId`.
+    - Use `useEffect` to monitor changes in the connected `address`, `chainId`, and the `expectedOwner`.
+    - Inside the effect:
+      - If `address` and `expectedOwner` exist:
+        - If `chainId !== LENS_CHAIN_ID`, do nothing (ConnectKit/Wagmi handle switch prompt).
+        - If `address.toLowerCase() === expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, proceed to navigation.
+        - If `address.toLowerCase() !== expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, set an error state ("Incorrect owner connected...").
+      - If `address` is disconnected, clear any error state.
+  - [x] **Implement Navigation:**
+    - Use `useRouter` from `next/navigation`.
+    - When verification passes (addresses match, correct chain), call `router.push('/dashboard')`.
+  - [x] **Create Context (Optional but Recommended):** Create `contexts/LensAccountProvider.tsx` to store the verified `lensAccountAddress` and `ownerAddress` so the dashboard can access them. Wrap the root layout or dashboard layout with this provider. Update `app/page.tsx` to set context values upon successful verification before navigating.
+- **Verification:**
+  - [x] "Connect Wallet" button appears/enables only when a Lens Account address is set and `owner()` has been potentially fetched. Expected owner address is displayed.
+  - [x] Clicking "Connect Wallet" opens the ConnectKit modal.
+  - [x] Connecting the _correct_ Owner EOA wallet on the wrong network prompts a "Switch Network" request to Lens Chain.
+  - [x] Connecting the _correct_ Owner EOA wallet on the Lens Chain navigates the user to `/dashboard`.
+  - [x] Connecting an _incorrect_ EOA wallet (not the owner) on the Lens Chain displays a clear error message and _does not_ navigate.
+  - [x] Disconnecting the wallet returns the user to the login/discovery state or clears the owner state.
+
+### Stage 3: Basic Dashboard Display
+
+**Goal:** Create the dashboard page and display the Lens Account address and its WGHO balance.
+
+- **Tasks:**
+  - [x] **Create Dashboard Page:** Create `app/dashboard/page.tsx`. Ensure it's protected or redirects if owner/lens account state (from Context) is missing.
+  - [x] **Add WGHO Constants:** Define `WGHO_TOKEN_ADDRESS` and `ERC20_ABI` (with `balanceOf(address)`) in `lib/constants.ts`.
+  - [x] **Create AccountDisplay Component:** Build `components/AccountDisplay.tsx`.
+  - [x] **Fetch/Display Data:**
+    - In `AccountDisplay.tsx`, retrieve the `lensAccountAddress` from context (e.g., `useContext(LensAccountContext)`).
+    - Use `useReadContract` (Wagmi) to call `balanceOf(lensAccountAddress)` on the `WGHO_TOKEN_ADDRESS`.
+    - Pass `chainId: LENS_CHAIN_ID`.
+    - Use Viem's `formatUnits` to format the returned balance (assuming WGHO has 18 decimals).
+    - Display the `lensAccountAddress` and the formatted WGHO balance. Handle loading/error states for the balance fetch.
+  - [x] **Integrate Component:** Add `AccountDisplay` to the dashboard page.
+  - [x] Do the same for native GHO
+- **Verification:**
+  - [x] Navigating to `/dashboard` after successful login shows the correct Lens Account address.
+  - [x] The GHO/WGHO balance for the Lens Account is fetched and displayed correctly (or shows loading/error state).
+
+### Stage 4: WalletConnect v2 Pairing (Act as Wallet)
+
+**Goal:** Implement the WalletConnect URI input and pairing logic, allowing the web app (representing the Lens Account) to connect to external dApps.
+
+- **Tasks:**
+  - [x] **Create WC Service:** Set up `services/walletConnectService.ts`. Include an `init` method that creates a `Web3Wallet` instance from `@reown/walletkit` using the `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`. Store the instance.
+  - [x] **Create WC Context:** Set up `contexts/WalletConnectProvider.tsx`. Initialize the `walletConnectService` on mount. Provide the `web3wallet` instance, active sessions state (`useState`), pairing state (`useState`), and pending request state (`useState`) via context.
+  - [x] **Wrap Layout:** Wrap the relevant part of the application (e.g., dashboard layout or root layout) with `WalletConnectProvider`.
+  - [x] **Create WcConnect Component:** Build `components/WcConnect.tsx`.
+    - Include an `<input>` for the WC URI and a `<button>` ("Connect").
+    - Add state for the input value.
+    - On button click, call a `pair` function provided by the `WalletConnectContext`.
+  - [x] **Implement Pairing Logic:**
+    - In `WalletConnectProvider` (or the service), define the `pair(uri)` function. Call `web3wallet.core.pairing.pair({ uri })`. Handle potential errors.
+    - Set up the `session_proposal` listener (`web3wallet.on('session_proposal', handleSessionProposal)`).
+  - [x] **Implement Session Approval:**
+    - Define `handleSessionProposal(proposal)` in the service/provider.
+    - Retrieve the `lensAccountAddress` and `LENS_CHAIN_ID` from state/constants.
+    - Construct the `approvedNamespaces` object containing only the `eip155` namespace, with the `LENS_CHAIN_ID`, the Lens Account address (formatted as `eip155:232:0x...`), required methods (`eth_sendTransaction`, `personal_sign`, etc.), and events (`chainChanged`, `accountsChanged`).
+    - Call `web3wallet.approveSession({ id: proposal.id, namespaces: approvedNamespaces })`.
+    - On success, update the `activeSessions` state in the context.
+    - Handle potential errors during approval.
+  - [x] **Update UI:** Modify `WcConnect.tsx` to:
+    - Conditionally render the input/button form OR the connected dApp info based on `activeSessions` state from context.
+    - Display dApp metadata (name, icon, url) from the active session.
+- **Verification:**
+  - [x] Open the dashboard page. The WC input form is visible.
+  - [x] Go to a test dApp (e.g., Reown's React Dapp Example) and generate a WC v2 URI.
+  - [x] Paste the URI into the input field in _this_ app and click "Connect".
+  - [x] The connection should establish successfully (no prompt needed in the Owner EOA wallet for pairing/session _approval_ in this flow).
+  - [x] The `WcConnect.tsx` component should update to show the connected dApp's information. Check the dApp, it should also show a successful connection to the _Lens Account address_.
+
+### Stage 5: WalletConnect v2 Transaction Request Handling
+
+**Goal:** Handle incoming `eth_sendTransaction` requests from the connected dApp, prompt the Owner EOA for approval via the Lens Account's `executeTransaction`, and relay the result.
+
+- **Tasks:**
+  - [ ] **Create WcRequestDisplay Component:** Build `components/WcRequestDisplay.tsx`. It should conditionally render based on the `pendingRequest` state from `WalletConnectContext`. Display request details (`to`, `value`, `data` hex string) and "Send Transaction" / "Reject" buttons.
+  - [ ] **Implement Request Listener:**
+    - In `WalletConnectProvider` (or service), set up the `session_request` listener (`web3wallet.on('session_request', handleSessionRequest)`).
+    - Define `handleSessionRequest(event)`: Store the `event.topic`, `event.id`, and `event.params.request` (`{ method, params }`) in the `pendingRequest` state of the context. Only handle `eth_sendTransaction` for MVP.
+  - [ ] **Implement Transaction Execution Logic:**
+    - Create `hooks/useWcRequestHandler.ts` or add logic to `WcRequestDisplay.tsx`.
+    - On "Send Transaction" click:
+      - Get `lensAccountAddress`, `ownerAddress` from relevant contexts.
+      - Get `topic`, `id`, `request` (`method`, `params`) from `WalletConnectContext.pendingRequest`.
+      - Extract `to`, `value`, `data` from `request.params[0]`.
+      - Call `useWriteContract` (Wagmi) hook configured for the `executeTransaction` function on the `LENS_ACCOUNT_ABI` and `lensAccountAddress`.
+      - The `args` for `executeTransaction` will be `[to, value || 0n, data || '0x']`.
+      - Pass `account: ownerAddress` and `chainId: LENS_CHAIN_ID` to `useWriteContract`'s mutation function.
+      - Use `useWaitForTransactionReceipt` to wait for the transaction hash returned by `writeContract`.
+  - [ ] **Implement Response Logic:**
+    - Modify the "Send Transaction" click handler:
+      - On `writeContract` success: Wait for the receipt. If receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`.
+      - If receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a JSON-RPC error payload (e.g., `{ id, jsonrpc: '2.0', error: { code: -32000, message: 'Transaction reverted' } }`).
+      - On `writeContract` error (e.g., user rejection in EOA wallet): Call `web3wallet.respondSessionRequest` with a user rejection error payload (`{ id, jsonrpc: '2.0', error: { code: 5000, message: 'User Rejected' } }`).
+    - On "Reject" click: Call `web3wallet.respondSessionRequest` with a user rejection error payload.
+    - After responding (success or error), clear the `pendingRequest` state in the context.
+  - [ ] **Integrate Component:** Add `WcRequestDisplay` to the dashboard page.
+- **Verification:**
+  - [ ] Connect to a test dApp (e.g., Aave testnet interface pointed to Lens Chain RPC, or a simple custom test page).
+  - [ ] Initiate a transaction on the test dApp (e.g., a simple contract call or ETH transfer _if possible via the dApp_).
+  - [ ] The `WcRequestDisplay` component should appear in _this_ app showing the request details.
+  - [ ] Clicking "Reject" should send an error to the dApp and hide the request display.
+  - [ ] Clicking "Send Transaction" should:
+    - Prompt the _Owner EOA wallet_ (MetaMask, etc.) to confirm the `executeTransaction` call on the Lens Account.
+    - Rejecting in the Owner EOA wallet sends an error to the dApp.
+    - Confirming in the Owner EOA wallet sends the transaction.
+    - Upon successful mining, the transaction hash is sent back to the dApp, and the request display hides. Success feedback is shown.
+    - If the on-chain execution reverts, an error is sent back to the dApp, and the request display hides. Error feedback is shown.
+
+## 4. Post-MVP Considerations
+
+- Implement handling for other WalletConnect methods (`personal_sign`, etc.).
+- Add UI for managing active WalletConnect sessions (viewing, disconnecting).
+- Improve transaction data decoding in the request display.
+- Enhance error messages and user feedback.
+- Refine UI/UX, add loading states more granularly.
+- Mobile responsiveness.
+</file>
+
 <file path="src/contexts/WalletConnectProvider.tsx">
 // src/contexts/WalletConnectProvider.tsx
 "use client";
@@ -2461,7 +2682,7 @@ import React, { createContext, useState, useContext, ReactNode, useEffect, useCa
 import { WalletConnectService, ServiceEvents, type WalletConnectServiceEvents } from "@/services/walletConnectService";
 import { SessionTypes } from "@walletconnect/types";
 import { IWalletKit, WalletKitTypes } from "@reown/walletkit";
-import { buildApprovedNamespaces, getSdkError } from "@walletconnect/utils";
+import { buildApprovedNamespaces, getSdkError, isExpired } from "@walletconnect/utils";
 import { useLensAccount } from "./LensAccountContext";
 import { LENS_CHAIN_ID } from "@/lib/constants";
 import { JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
@@ -2556,94 +2777,114 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
         console.error("WalletConnectProvider Mount Effect: service.init() rejected.", initError);
       });
     }
-  }, [projectId]); // Add projectId dependency
-
-  // --- Effect to Attach/Detach Event Listeners ---
-  useEffect(() => {
-    const currentService = serviceRef.current; // Capture ref value for effect closure
-    if (!currentService) {
-      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
-      return;
-    }
-
-    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [projectId]); // Keep only projectId as it's needed for creation
 
-    // Define handlers
-    const handleInitialized: WalletConnectServiceEvents[ServiceEvents.Initialized] = ({ success, instance }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
+  // --- Event Handlers (wrapped in useCallback) ---
+  const handleInitialized = useCallback<WalletConnectServiceEvents[ServiceEvents.Initialized]>(
+    ({ success, instance }) => {
+      console.log(`%cProvider Handler: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
       setIsInitialized(success);
       setWalletKitInstance(success ? instance : null);
-      if (currentService) setActiveSessions(currentService.getActiveSessions());
+      // Check serviceRef directly instead of captured value, as it might change over time if remount occurs
+      if (serviceRef.current) setActiveSessions(serviceRef.current.getActiveSessions());
       setIsInitializing(false);
       if (!success && !error) setError("Initialization failed via event");
-    };
-    const handlePairStatus: WalletConnectServiceEvents[ServiceEvents.PairStatus] = ({ status, message }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
-      setIsPairing(status === "pairing");
-      if (status === "error") {
-        setError(message || "Pairing failed");
-        setIsPairing(false);
-      } else if (status !== "pairing") {
-        setError(null);
-      }
-    };
-    const handleSessionProposal: WalletConnectServiceEvents[ServiceEvents.SessionProposal] = ({ proposal }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
-      setPendingProposal(proposal);
-      setIsPairing(false);
-      setError(null);
-    };
-    const handleSessionConnect: WalletConnectServiceEvents[ServiceEvents.SessionConnect] = ({ session }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
-      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
+    },
+    [error],
+  ); // Dependency: error (to avoid setting error if one already exists)
+
+  const handlePairStatus = useCallback<WalletConnectServiceEvents[ServiceEvents.PairStatus]>(({ status, message }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
+    setIsPairing(status === "pairing");
+    if (status === "error") {
+      setError(message || "Pairing failed");
       setIsPairing(false);
+    } else if (status !== "pairing") {
       setError(null);
-      setPendingProposal(null);
-    };
-    // This now handles PEER disconnects or SDK internal cleanup events
-    const handleSessionDelete: WalletConnectServiceEvents[ServiceEvents.SessionDelete] = ({ topic }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
+    }
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionProposal = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionProposal]>(({ proposal }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
+    setPendingProposal(proposal);
+    setIsPairing(false);
+    setError(null);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionConnect = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionConnect]>(({ session }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
+    setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
+    setIsPairing(false);
+    setError(null);
+    setPendingProposal(null);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionDelete = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionDelete]>(
+    ({ topic }) => {
+      console.log(`%cProvider Handler: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
       setActiveSessions((prev) => {
         if (!prev[topic]) return prev;
+        // eslint-disable-next-line @typescript-eslint/no-unused-vars
         const { [topic]: _removed, ...rest } = prev;
         console.log(`%cProvider State: Removing session ${topic} based on SDK/PEER event.`, "color: brown");
         return rest;
       });
       setIsPairing(false);
+      // Need pendingProposal to check pairingTopic
       if (pendingProposal && pendingProposal.params.pairingTopic === topic) {
         console.log("%cProvider: Clearing pending proposal due to SDK/peer session delete event.", "color: brown");
         setPendingProposal(null);
       }
-    };
-    const handleSessionsUpdated: WalletConnectServiceEvents[ServiceEvents.SessionsUpdated] = ({ sessions }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
-      setActiveSessions(sessions);
-    };
-    const handleSessionRequest: WalletConnectServiceEvents[ServiceEvents.SessionRequest] = ({ request }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
-      if (request.params.request.method === "eth_sendTransaction") {
-        setPendingRequest(request);
-        setError(null);
-      } else {
-        console.warn(`%cProvider Listener: Received unhandled request method: ${request.params.request.method}`, "color: orange");
-      }
-    };
-    const handleError: WalletConnectServiceEvents[ServiceEvents.Error] = ({ message }) => {
-      console.error(`%cProvider Listener: ${ServiceEvents.Error} received:`, "color: red", message);
-      setError(message);
-      setIsPairing(false);
-      setIsProcessingAction(false);
-    };
-    const handleIsLoading: WalletConnectServiceEvents[ServiceEvents.IS_LOADING] = ({ isLoading }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
-      setIsProcessingAction(isLoading);
-    };
-    const handleIsPairing: WalletConnectServiceEvents[ServiceEvents.IS_PAIRING] = ({ isPairing }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
-      setIsPairing(isPairing);
-    };
+    },
+    [pendingProposal],
+  ); // Dependency: pendingProposal
+
+  const handleSessionsUpdated = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionsUpdated]>(({ sessions }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
+    setActiveSessions(sessions);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionRequest = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionRequest]>(({ request }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
+    if (request.params.request.method === "eth_sendTransaction") {
+      setPendingRequest(request);
+      setError(null);
+    } else {
+      console.warn(`%cProvider Handler: Received unhandled request method: ${request.params.request.method}`, "color: orange");
+      // Maybe respond with an error here automatically?
+      // respondRequest({ id: request.id, jsonrpc: '2.0', error: { code: -32601, message: 'Method not supported' } });
+    }
+  }, []); // Dependency: respondRequest (if adding automatic error response)
+
+  const handleError = useCallback<WalletConnectServiceEvents[ServiceEvents.Error]>(({ message }) => {
+    console.error(`%cProvider Handler: ${ServiceEvents.Error} received:`, "color: red", message);
+    setError(message);
+    setIsPairing(false);
+    setIsProcessingAction(false);
+  }, []); // No dependencies needed here as it only calls setters
 
-    // Attach listeners
+  const handleIsLoading = useCallback<WalletConnectServiceEvents[ServiceEvents.IS_LOADING]>(({ isLoading }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
+    setIsProcessingAction(isLoading);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleIsPairing = useCallback<WalletConnectServiceEvents[ServiceEvents.IS_PAIRING]>(({ isPairing }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
+    setIsPairing(isPairing);
+  }, []); // No dependencies needed here as it only calls setters
+
+  // --- Effect to Attach/Detach Event Listeners ---
+  useEffect(() => {
+    const currentService = serviceRef.current; // Capture ref value
+    if (!currentService) {
+      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
+      return;
+    }
+
+    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");
+
+    // Attach the useCallback handlers
     currentService.on(ServiceEvents.Initialized, handleInitialized);
     currentService.on(ServiceEvents.PairStatus, handlePairStatus);
     currentService.on(ServiceEvents.SessionProposal, handleSessionProposal);
@@ -2655,11 +2896,10 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
     currentService.on(ServiceEvents.IS_PAIRING, handleIsPairing);
     currentService.on(ServiceEvents.SessionRequest, handleSessionRequest);
 
-    // Cleanup function
+    // Cleanup function using the same stable handlers
     return () => {
-      console.log("%cWalletConnectProvider Mount Effect: Cleaning up listeners.", "color: orange");
+      console.log("%cWalletConnectProvider Listener Effect: Cleaning up listeners.", "color: orange");
       if (currentService) {
-        // Use the captured variable
         console.log("%cDetaching listeners from service instance in ref.", "color: orange");
         currentService.off(ServiceEvents.Initialized, handleInitialized);
         currentService.off(ServiceEvents.PairStatus, handlePairStatus);
@@ -2673,7 +2913,21 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
         currentService.off(ServiceEvents.SessionRequest, handleSessionRequest);
       }
     };
-  }, []);
+  }, [
+    // Dependencies are the stable handler functions themselves
+    handleInitialized,
+    handlePairStatus,
+    handleSessionProposal,
+    handleSessionConnect,
+    handleSessionDelete,
+    handleSessionsUpdated,
+    handleError,
+    handleIsLoading,
+    handleIsPairing,
+    handleSessionRequest,
+    // Also include isInitialized or serviceRef.current? Let's try without first.
+    // If listeners aren't attached correctly after init, add isInitialized.
+  ]);
 
   // --- Context Methods ---
   const pair = useCallback(
@@ -2683,15 +2937,29 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
       setError(null);
       await serviceRef.current.pair(uri);
     },
-    [isInitialized],
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+    [isInitialized], // Keep isInitialized here
   );
 
   const approveSession = useCallback(async () => {
-    if (!serviceRef.current?.isInitialized() || !pendingProposal || !lensAccountAddress) {
-      const reason = !isInitialized ? "Service not ready." : !pendingProposal ? "No proposal." : "No Lens address.";
+    if (!serviceRef.current?.isInitialized() || !pendingProposal) {
+      const reason = !isInitialized ? "Service not ready." : "No proposal.";
       setError(`Cannot approve: ${reason}`);
       return;
     }
+
+    if (pendingProposal.params.expiryTimestamp && isExpired(pendingProposal.params.expiryTimestamp)) {
+      console.warn(`Attempted to approve expired proposal ${pendingProposal.id}.`);
+      setError("Connection proposal expired. Please try again.");
+      setPendingProposal(null);
+      return;
+    }
+
+    if (!lensAccountAddress) {
+      setError("Cannot approve: Lens Account address is missing.");
+      return;
+    }
+
     console.log(`%cWalletConnectProvider: approveSession called for proposal ${pendingProposal.id}`, "color: cyan");
     setError(null);
 
@@ -2716,8 +2984,6 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
 
       const session = await serviceRef.current.approveSession(pendingProposal, approvedNamespaces);
       console.log(`%cWalletConnectProvider: approveSession successful, received session:`, "color: green", session);
-      // Manually update state since event might not fire from SDK
-      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
       setPendingProposal(null);
       setIsPairing(false);
       setError(null);
@@ -2742,7 +3008,6 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
     }
   }, [isInitialized, pendingProposal]);
 
-  // >>>>>>>> REVERTED disconnect callback <<<<<<<<
   const disconnect = useCallback(
     async (topic: string) => {
       if (!serviceRef.current?.isInitialized()) {
@@ -2763,24 +3028,27 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
             console.warn(`%cWalletConnectProvider: Tried to remove non-existent session ${topic} from state.`, "color: orange");
             return prev;
           }
+          // eslint-disable-next-line @typescript-eslint/no-unused-vars
           const { [topic]: _removed, ...rest } = prev;
           console.log(`%cWalletConnectProvider: Manually removing session ${topic} from state.`, "color: brown");
           return rest;
         });
-        // Ensure other related states are cleared
+
+        // ---> KEEP This State Clearing Logic <---
+        setPendingProposal(null);
+        setPendingRequest(null); // Clear pending requests too
         setIsPairing(false);
-        if (pendingProposal?.params?.pairingTopic === topic) {
-          console.log(`%cWalletConnectProvider: Clearing pending proposal during manual disconnect cleanup for topic ${topic}.`, "color: brown");
-          setPendingProposal(null);
-        }
+        setError(null);
+        // ---> End State Clearing Logic <---
       } catch (e) {
         console.error(`%cWalletConnectProvider: disconnect failed for topic ${topic}:`, "color: red", e);
         setError((e as Error)?.message || "Disconnect failed");
       }
     },
-    [pendingProposal], // isInitialized was correctly removed previously
+    // Add dependencies if they are used *inside* the logic before the service call,
+    // but since it primarily relies on the `topic` argument, `[]` is okay here.
+    [],
   );
-  // >>>>>>>> ----------------------------- <<<<<<<<
 
   const respondRequest = useCallback(
     async (response: JsonRpcResponse) => {
@@ -2866,187 +3134,4 @@ export function useWalletConnect() {
 export { WalletConnectContext };
 </file>
 
-<file path="DEVELOPMENT_PLAN.md">
-**Version:** 1.0
-**Date:** 2025-04-19
-
-## 1. Introduction
-
-This document outlines the phased development plan for building the Minimum Viable Product (MVP) of the Lens Account Web Interface. It breaks down the work into manageable stages, aligning with the Functional Specification (`Spec.functional.md`) and Technical Specification (`TECHNICAL_SPEC.md`).
-
-## 2. Methodology
-
-We will follow an incremental development approach, building and verifying core features stage by stage. Each stage should result in a testable piece of functionality.
-
-## 3. Development Stages
-
-### Stage 0: Project Setup & Base Configuration (Completed via Setup)
-
-- [x] Initialize Next.js 15+ project with TypeScript, Tailwind CSS, App Router.
-- [x] Install pnpm as the package manager.
-- [x] Install core dependencies: `wagmi`, `viem`, `@tanstack/react-query`, `connectkit`, `@reown/walletkit`, `@walletconnect/core`, `@walletconnect/utils`.
-- [x] Set up basic ESLint and Prettier configuration.
-- [x] Create `.env.local` with `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID` placeholder.
-- [x] Configure `WagmiProvider` and `QueryClientProvider` in the root layout (`app/layout.tsx`).
-  - **Check:** Development server runs (`pnpm dev`) without errors. Base Next.js page loads.
-
-### Stage 1: Account Discovery & Chain Read Interaction
-
-**Goal:** Implement the username/address input fields and the logic to look up corresponding data from the `LensGlobalNamespace` contract on the Lens Chain. Verify basic read operations work.
-
-- **Tasks:**
-  - [x] **Create Constants:** Define Lens Chain details (ID 232, RPC URL, etc.), `LensGlobalNamespace` address, and its partial ABI (`accountOf(string)`, `usernameOf(address)`) in `lib/constants.ts`.
-  - [x] **Update Wagmi Config:** Ensure the `lensChain` object is defined using `defineChain` and included in the `createConfig` call in `lib/wagmi.ts`.
-  - [x] **Create DiscoveryForm Component:** Build `components/DiscoveryForm.tsx` with two controlled input fields (Username, Account Address) styled with Tailwind.
-  - [x] **Implement Lookup Logic:**
-    - [x] Inside `DiscoveryForm.tsx` or a custom hook (`hooks/useLensLookup.ts`), use `useState` for input values.
-    - [x] Use `useEffect` with a debounce utility (e.g., from `lodash.debounce` or simple `setTimeout`) to trigger lookups on input change.
-    - [x] Call `useReadContract` (Wagmi) within the debounced effect:
-      - Target `LensGlobalNamespace` address.
-      - Use the appropriate function (`accountOf` or `usernameOf`) based on which input changed.
-      - **Crucially:** Pass `chainId: LENS_CHAIN_ID` to ensure the call targets the correct network.
-      - Handle loading and error states from `useReadContract`.
-    - [x] Update the _other_ input field's state based on the successful result from `useReadContract`.
-  - [x] **Integrate Form:** Place `DiscoveryForm.tsx` onto the root page (`app/page.tsx`).
-- **Verification:**
-  - [x] Typing a known Lens username (e.g., `stani`) correctly populates the Account Address field.
-  - [x] Typing/pasting a known Lens Account address correctly populates the Lens Username field (if one exists).
-  - [x] Invalid inputs show no result or subtle error indication.
-  - [x] Check browser developer console for any Wagmi/Viem errors related to contract reads. Network tab should show RPC calls to the Lens Chain RPC URL.
-
-### Stage 2: Owner EOA Connection & Verification
-
-**Goal:** Integrate the "Connect Wallet" functionality, fetch the Lens Account owner, verify it against the connected EOA, handle chain switching, and navigate to the dashboard.
-
-- **Tasks:**
-  - [x] **Add Owner ABI:** Include the `owner()` function signature in the `LENS_ACCOUNT_ABI` within `lib/constants.ts`.
-  - [x] **Create Connect Button:** Build `components/ConnectOwnerButton.tsx`. Use ConnectKit's `<ConnectKitButton />` or its underlying hooks (`useModal`, etc.) for the UI.
-  - [x] **Fetch Expected Owner:**
-    - In `app/page.tsx`, once a valid Lens Account address is determined (from Stage 1 state), use `useReadContract` to call `owner()` on the Lens Account address.
-    - Pass `chainId: LENS_CHAIN_ID`.
-    - Store the result in state (`expectedOwner`).
-  - [x] **Display Expected Owner:** Show the `expectedOwner` address clearly near the `ConnectOwnerButton`.
-  - [x] **Integrate Connect Button:** Add `ConnectOwnerButton` to `app/page.tsx`, potentially disabling it until `expectedOwner` is fetched.
-  - [x] **Implement Verification Logic:**
-    - In `app/page.tsx`, use `useAccount` (Wagmi) to get the connected EOA's `address` and `chainId`.
-    - Use `useEffect` to monitor changes in the connected `address`, `chainId`, and the `expectedOwner`.
-    - Inside the effect:
-      - If `address` and `expectedOwner` exist:
-        - If `chainId !== LENS_CHAIN_ID`, do nothing (ConnectKit/Wagmi handle switch prompt).
-        - If `address.toLowerCase() === expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, proceed to navigation.
-        - If `address.toLowerCase() !== expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, set an error state ("Incorrect owner connected...").
-      - If `address` is disconnected, clear any error state.
-  - [x] **Implement Navigation:**
-    - Use `useRouter` from `next/navigation`.
-    - When verification passes (addresses match, correct chain), call `router.push('/dashboard')`.
-  - [x] **Create Context (Optional but Recommended):** Create `contexts/LensAccountProvider.tsx` to store the verified `lensAccountAddress` and `ownerAddress` so the dashboard can access them. Wrap the root layout or dashboard layout with this provider. Update `app/page.tsx` to set context values upon successful verification before navigating.
-- **Verification:**
-  - [x] "Connect Wallet" button appears/enables only when a Lens Account address is set and `owner()` has been potentially fetched. Expected owner address is displayed.
-  - [x] Clicking "Connect Wallet" opens the ConnectKit modal.
-  - [x] Connecting the _correct_ Owner EOA wallet on the wrong network prompts a "Switch Network" request to Lens Chain.
-  - [x] Connecting the _correct_ Owner EOA wallet on the Lens Chain navigates the user to `/dashboard`.
-  - [x] Connecting an _incorrect_ EOA wallet (not the owner) on the Lens Chain displays a clear error message and _does not_ navigate.
-  - [x] Disconnecting the wallet returns the user to the login/discovery state or clears the owner state.
-
-### Stage 3: Basic Dashboard Display
-
-**Goal:** Create the dashboard page and display the Lens Account address and its WGHO balance.
-
-- **Tasks:**
-  - [x] **Create Dashboard Page:** Create `app/dashboard/page.tsx`. Ensure it's protected or redirects if owner/lens account state (from Context) is missing.
-  - [x] **Add WGHO Constants:** Define `WGHO_TOKEN_ADDRESS` and `ERC20_ABI` (with `balanceOf(address)`) in `lib/constants.ts`.
-  - [x] **Create AccountDisplay Component:** Build `components/AccountDisplay.tsx`.
-  - [x] **Fetch/Display Data:**
-    - In `AccountDisplay.tsx`, retrieve the `lensAccountAddress` from context (e.g., `useContext(LensAccountContext)`).
-    - Use `useReadContract` (Wagmi) to call `balanceOf(lensAccountAddress)` on the `WGHO_TOKEN_ADDRESS`.
-    - Pass `chainId: LENS_CHAIN_ID`.
-    - Use Viem's `formatUnits` to format the returned balance (assuming WGHO has 18 decimals).
-    - Display the `lensAccountAddress` and the formatted WGHO balance. Handle loading/error states for the balance fetch.
-  - [x] **Integrate Component:** Add `AccountDisplay` to the dashboard page.
-  - [x] Do the same for native GHO
-- **Verification:**
-  - [x] Navigating to `/dashboard` after successful login shows the correct Lens Account address.
-  - [x] The GHO/WGHO balance for the Lens Account is fetched and displayed correctly (or shows loading/error state).
-
-### Stage 4: WalletConnect v2 Pairing (Act as Wallet)
-
-**Goal:** Implement the WalletConnect URI input and pairing logic, allowing the web app (representing the Lens Account) to connect to external dApps.
-
-- **Tasks:**
-  - [x] **Create WC Service:** Set up `services/walletConnectService.ts`. Include an `init` method that creates a `Web3Wallet` instance from `@reown/walletkit` using the `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`. Store the instance.
-  - [x] **Create WC Context:** Set up `contexts/WalletConnectProvider.tsx`. Initialize the `walletConnectService` on mount. Provide the `web3wallet` instance, active sessions state (`useState`), pairing state (`useState`), and pending request state (`useState`) via context.
-  - [x] **Wrap Layout:** Wrap the relevant part of the application (e.g., dashboard layout or root layout) with `WalletConnectProvider`.
-  - [x] **Create WcConnect Component:** Build `components/WcConnect.tsx`.
-    - Include an `<input>` for the WC URI and a `<button>` ("Connect").
-    - Add state for the input value.
-    - On button click, call a `pair` function provided by the `WalletConnectContext`.
-  - [x] **Implement Pairing Logic:**
-    - In `WalletConnectProvider` (or the service), define the `pair(uri)` function. Call `web3wallet.core.pairing.pair({ uri })`. Handle potential errors.
-    - Set up the `session_proposal` listener (`web3wallet.on('session_proposal', handleSessionProposal)`).
-  - [x] **Implement Session Approval:**
-    - Define `handleSessionProposal(proposal)` in the service/provider.
-    - Retrieve the `lensAccountAddress` and `LENS_CHAIN_ID` from state/constants.
-    - Construct the `approvedNamespaces` object containing only the `eip155` namespace, with the `LENS_CHAIN_ID`, the Lens Account address (formatted as `eip155:232:0x...`), required methods (`eth_sendTransaction`, `personal_sign`, etc.), and events (`chainChanged`, `accountsChanged`).
-    - Call `web3wallet.approveSession({ id: proposal.id, namespaces: approvedNamespaces })`.
-    - On success, update the `activeSessions` state in the context.
-    - Handle potential errors during approval.
-  - [x] **Update UI:** Modify `WcConnect.tsx` to:
-    - Conditionally render the input/button form OR the connected dApp info based on `activeSessions` state from context.
-    - Display dApp metadata (name, icon, url) from the active session.
-- **Verification:**
-  - [x] Open the dashboard page. The WC input form is visible.
-  - [x] Go to a test dApp (e.g., Reown's React Dapp Example) and generate a WC v2 URI.
-  - [x] Paste the URI into the input field in _this_ app and click "Connect".
-  - [x] The connection should establish successfully (no prompt needed in the Owner EOA wallet for pairing/session _approval_ in this flow).
-  - [x] The `WcConnect.tsx` component should update to show the connected dApp's information. Check the dApp, it should also show a successful connection to the _Lens Account address_.
-
-### Stage 5: WalletConnect v2 Transaction Request Handling
-
-**Goal:** Handle incoming `eth_sendTransaction` requests from the connected dApp, prompt the Owner EOA for approval via the Lens Account's `executeTransaction`, and relay the result.
-
-- **Tasks:**
-  - [ ] **Create WcRequestDisplay Component:** Build `components/WcRequestDisplay.tsx`. It should conditionally render based on the `pendingRequest` state from `WalletConnectContext`. Display request details (`to`, `value`, `data` hex string) and "Send Transaction" / "Reject" buttons.
-  - [ ] **Implement Request Listener:**
-    - In `WalletConnectProvider` (or service), set up the `session_request` listener (`web3wallet.on('session_request', handleSessionRequest)`).
-    - Define `handleSessionRequest(event)`: Store the `event.topic`, `event.id`, and `event.params.request` (`{ method, params }`) in the `pendingRequest` state of the context. Only handle `eth_sendTransaction` for MVP.
-  - [ ] **Implement Transaction Execution Logic:**
-    - Create `hooks/useWcRequestHandler.ts` or add logic to `WcRequestDisplay.tsx`.
-    - On "Send Transaction" click:
-      - Get `lensAccountAddress`, `ownerAddress` from relevant contexts.
-      - Get `topic`, `id`, `request` (`method`, `params`) from `WalletConnectContext.pendingRequest`.
-      - Extract `to`, `value`, `data` from `request.params[0]`.
-      - Call `useWriteContract` (Wagmi) hook configured for the `executeTransaction` function on the `LENS_ACCOUNT_ABI` and `lensAccountAddress`.
-      - The `args` for `executeTransaction` will be `[to, value || 0n, data || '0x']`.
-      - Pass `account: ownerAddress` and `chainId: LENS_CHAIN_ID` to `useWriteContract`'s mutation function.
-      - Use `useWaitForTransactionReceipt` to wait for the transaction hash returned by `writeContract`.
-  - [ ] **Implement Response Logic:**
-    - Modify the "Send Transaction" click handler:
-      - On `writeContract` success: Wait for the receipt. If receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`.
-      - If receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a JSON-RPC error payload (e.g., `{ id, jsonrpc: '2.0', error: { code: -32000, message: 'Transaction reverted' } }`).
-      - On `writeContract` error (e.g., user rejection in EOA wallet): Call `web3wallet.respondSessionRequest` with a user rejection error payload (`{ id, jsonrpc: '2.0', error: { code: 5000, message: 'User Rejected' } }`).
-    - On "Reject" click: Call `web3wallet.respondSessionRequest` with a user rejection error payload.
-    - After responding (success or error), clear the `pendingRequest` state in the context.
-  - [ ] **Integrate Component:** Add `WcRequestDisplay` to the dashboard page.
-- **Verification:**
-  - [ ] Connect to a test dApp (e.g., Aave testnet interface pointed to Lens Chain RPC, or a simple custom test page).
-  - [ ] Initiate a transaction on the test dApp (e.g., a simple contract call or ETH transfer _if possible via the dApp_).
-  - [ ] The `WcRequestDisplay` component should appear in _this_ app showing the request details.
-  - [ ] Clicking "Reject" should send an error to the dApp and hide the request display.
-  - [ ] Clicking "Send Transaction" should:
-    - Prompt the _Owner EOA wallet_ (MetaMask, etc.) to confirm the `executeTransaction` call on the Lens Account.
-    - Rejecting in the Owner EOA wallet sends an error to the dApp.
-    - Confirming in the Owner EOA wallet sends the transaction.
-    - Upon successful mining, the transaction hash is sent back to the dApp, and the request display hides. Success feedback is shown.
-    - If the on-chain execution reverts, an error is sent back to the dApp, and the request display hides. Error feedback is shown.
-
-## 4. Post-MVP Considerations
-
-- Implement handling for other WalletConnect methods (`personal_sign`, etc.).
-- Add UI for managing active WalletConnect sessions (viewing, disconnecting).
-- Improve transaction data decoding in the request display.
-- Enhance error messages and user feedback.
-- Refine UI/UX, add loading states more granularly.
-- Mobile responsiveness.
-</file>
-
 </files>
diff --git a/llms/Src.WalletConnect.xml b/llms/Src.WalletConnect.xml
deleted file mode 100644
index 98e5bb1..0000000
--- a/llms/Src.WalletConnect.xml
+++ /dev/null
@@ -1,10028 +0,0 @@
-This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
-The content has been processed where security check has been disabled.
-
-<file_summary>
-This section contains a summary of this file.
-
-<purpose>
-This file contains a packed representation of the entire repository's contents.
-It is designed to be easily consumable by AI systems for analysis, code review,
-or other automated processes.
-</purpose>
-
-<file_format>
-The content is organized as follows:
-1. This summary section
-2. Repository information
-3. Directory structure
-4. Repository files, each consisting of:
-  - File path as an attribute
-  - Full contents of the file
-</file_format>
-
-<usage_guidelines>
-- This file should be treated as read-only. Any changes should be made to the
-  original repository files, not this packed version.
-- When processing this file, use the file path to distinguish
-  between different files in the repository.
-- Be aware that this file may contain sensitive information. Handle it with
-  the same level of security as you would the original repository.
-</usage_guidelines>
-
-<notes>
-- Some files may have been excluded based on .gitignore rules and Repomix's configuration
-- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
-- Only files matching these patterns are included: packages/types, packages/core
-- Files matching patterns in .gitignore are excluded
-- Files matching default ignore patterns are excluded
-- Security check has been disabled - content may contain sensitive information
-- Files are sorted by Git change count (files with more changes are at the bottom)
-</notes>
-
-<additional_info>
-
-</additional_info>
-
-</file_summary>
-
-<directory_structure>
-packages/
-  core/
-    src/
-      constants/
-        core.ts
-        crypto.ts
-        echo.ts
-        events.ts
-        expirer.ts
-        history.ts
-        index.ts
-        keychain.ts
-        messages.ts
-        pairing.ts
-        publisher.ts
-        relayer.ts
-        store.ts
-        subscriber.ts
-        verify.ts
-      controllers/
-        crypto.ts
-        echo.ts
-        events.ts
-        expirer.ts
-        history.ts
-        index.ts
-        keychain.ts
-        messages.ts
-        pairing.ts
-        publisher.ts
-        relayer.ts
-        store.ts
-        subscriber.ts
-        topicmap.ts
-        verify.ts
-      core.ts
-      index.ts
-    test/
-      shared/
-        helpers.ts
-        index.ts
-        values.ts
-        ws.ts
-      core.spec.ts
-      crypto.spec.ts
-      events.spec.ts
-      expirer.spec.ts
-      history.spec.ts
-      keychain.spec.ts
-      messages.spec.ts
-      pairing.spec.ts
-      persistence.spec.ts
-      publisher.spec.ts
-      relayer.spec.ts
-      store.spec.ts
-      subscriber.spec.ts
-      verify.spec.ts
-    .npmignore
-    CHANGELOG.md
-    LICENSE
-    package.json
-    README.md
-    rollup.config.js
-    tsconfig.json
-  types/
-    src/
-      core/
-        core.ts
-        crypto.ts
-        echo.ts
-        events.ts
-        expirer.ts
-        history.ts
-        index.ts
-        keychain.ts
-        messages.ts
-        pairing.ts
-        publisher.ts
-        relayer.ts
-        store.ts
-        subscriber.ts
-        verify.ts
-      sign-client/
-        auth.ts
-        client.ts
-        engine.ts
-        index.ts
-        jsonrpc.ts
-        pendingRequest.ts
-        proposal.ts
-        session.ts
-      index.ts
-    .npmignore
-    CHANGELOG.md
-    LICENSE
-    package.json
-    README.md
-    rollup.config.js
-    tsconfig.json
-</directory_structure>
-
-<files>
-This section contains the contents of the repository's files.
-
-<file path="packages/core/src/constants/core.ts">
-export const CORE_PROTOCOL = "wc";
-export const CORE_VERSION = 2;
-export const CORE_CONTEXT = "core";
-
-export const CORE_STORAGE_PREFIX = `${CORE_PROTOCOL}@${CORE_VERSION}:${CORE_CONTEXT}:`;
-
-export const CORE_DEFAULT = {
-  name: CORE_CONTEXT,
-  logger: "error",
-};
-
-export const CORE_STORAGE_OPTIONS = {
-  database: ":memory:",
-};
-</file>
-
-<file path="packages/core/src/constants/crypto.ts">
-import { ONE_DAY } from "@walletconnect/time";
-
-export const CRYPTO_CONTEXT = "crypto";
-
-export const CRYPTO_CLIENT_SEED = "client_ed25519_seed";
-
-export const CRYPTO_JWT_TTL = ONE_DAY;
-</file>
-
-<file path="packages/core/src/constants/echo.ts">
-export const ECHO_CONTEXT = "echo";
-
-export const ECHO_URL = "https://echo.walletconnect.com";
-</file>
-
-<file path="packages/core/src/constants/events.ts">
-export const EVENT_CLIENT_CONTEXT = "event-client";
-
-export const EVENT_CLIENT_PAIRING_TRACES = {
-  pairing_started: "pairing_started",
-  pairing_uri_validation_success: "pairing_uri_validation_success",
-  pairing_uri_not_expired: "pairing_uri_not_expired",
-  store_new_pairing: "store_new_pairing",
-  subscribing_pairing_topic: "subscribing_pairing_topic",
-  subscribe_pairing_topic_success: "subscribe_pairing_topic_success",
-  existing_pairing: "existing_pairing",
-  pairing_not_expired: "pairing_not_expired",
-  emit_inactive_pairing: "emit_inactive_pairing",
-  emit_session_proposal: "emit_session_proposal",
-  subscribing_to_pairing_topic: "subscribing_to_pairing_topic",
-};
-
-export const EVENT_CLIENT_PAIRING_ERRORS = {
-  no_wss_connection: "no_wss_connection",
-  no_internet_connection: "no_internet_connection",
-  malformed_pairing_uri: "malformed_pairing_uri",
-  active_pairing_already_exists: "active_pairing_already_exists",
-  subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure",
-  pairing_expired: "pairing_expired",
-  proposal_expired: "proposal_expired",
-  proposal_listener_not_found: "proposal_listener_not_found",
-};
-
-export const EVENT_CLIENT_SESSION_TRACES = {
-  session_approve_started: "session_approve_started",
-  proposal_not_expired: "proposal_not_expired",
-  session_namespaces_validation_success: "session_namespaces_validation_success",
-  create_session_topic: "create_session_topic",
-  subscribing_session_topic: "subscribing_session_topic",
-  subscribe_session_topic_success: "subscribe_session_topic_success",
-  publishing_session_approve: "publishing_session_approve",
-  session_approve_publish_success: "session_approve_publish_success",
-  store_session: "store_session",
-  publishing_session_settle: "publishing_session_settle",
-  session_settle_publish_success: "session_settle_publish_success",
-};
-
-export const EVENT_CLIENT_SESSION_ERRORS = {
-  no_internet_connection: "no_internet_connection",
-  no_wss_connection: "no_wss_connection",
-  proposal_expired: "proposal_expired",
-  subscribe_session_topic_failure: "subscribe_session_topic_failure",
-  session_approve_publish_failure: "session_approve_publish_failure",
-  session_settle_publish_failure: "session_settle_publish_failure",
-  session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure",
-  proposal_not_found: "proposal_not_found",
-};
-
-export const EVENT_CLIENT_AUTHENTICATE_TRACES = {
-  authenticated_session_approve_started: "authenticated_session_approve_started",
-  authenticated_session_not_expired: "authenticated_session_not_expired",
-  chains_caip2_compliant: "chains_caip2_compliant",
-  chains_evm_compliant: "chains_evm_compliant",
-  create_authenticated_session_topic: "create_authenticated_session_topic",
-  cacaos_verified: "cacaos_verified",
-  store_authenticated_session: "store_authenticated_session",
-  subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic",
-  subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success",
-  publishing_authenticated_session_approve: "publishing_authenticated_session_approve",
-  authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success",
-};
-
-export const EVENT_CLIENT_AUTHENTICATE_ERRORS = {
-  no_internet_connection: "no_internet_connection",
-  no_wss_connection: "no_wss_connection",
-  missing_session_authenticate_request: "missing_session_authenticate_request",
-  session_authenticate_request_expired: "session_authenticate_request_expired",
-  chains_caip2_compliant_failure: "chains_caip2_compliant_failure",
-  chains_evm_compliant_failure: "chains_evm_compliant_failure",
-  invalid_cacao: "invalid_cacao",
-  subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure",
-  authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure",
-  authenticated_session_pending_request_not_found:
-    "authenticated_session_pending_request_not_found",
-};
-
-export const EVENTS_STORAGE_VERSION = 0.1;
-
-export const EVENTS_STORAGE_CONTEXT = "event-client";
-
-export const EVENTS_STORAGE_CLEANUP_INTERVAL = 86400;
-
-export const EVENTS_CLIENT_API_URL = "https://pulse.walletconnect.org/batch";
-</file>
-
-<file path="packages/core/src/constants/expirer.ts">
-import { ONE_DAY } from "@walletconnect/time";
-
-export const EXPIRER_CONTEXT = "expirer";
-
-export const EXPIRER_EVENTS = {
-  created: "expirer_created",
-  deleted: "expirer_deleted",
-  expired: "expirer_expired",
-  sync: "expirer_sync",
-};
-
-export const EXPIRER_STORAGE_VERSION = "0.3";
-
-export const EXPIRER_DEFAULT_TTL = ONE_DAY;
-</file>
-
-<file path="packages/core/src/constants/history.ts">
-export const HISTORY_EVENTS = {
-  created: "history_created",
-  updated: "history_updated",
-  deleted: "history_deleted",
-  sync: "history_sync",
-};
-
-export const HISTORY_CONTEXT = "history";
-
-export const HISTORY_STORAGE_VERSION = "0.3";
-</file>
-
-<file path="packages/core/src/constants/index.ts">
-export * from "./core";
-export * from "./crypto";
-export * from "./keychain";
-export * from "./messages";
-export * from "./publisher";
-export * from "./relayer";
-export * from "./store";
-export * from "./subscriber";
-export * from "./pairing";
-export * from "./history";
-export * from "./expirer";
-export * from "./verify";
-export * from "./echo";
-export * from "./events";
-</file>
-
-<file path="packages/core/src/constants/keychain.ts">
-export const KEYCHAIN_CONTEXT = "keychain";
-
-export const KEYCHAIN_STORAGE_VERSION = "0.3";
-</file>
-
-<file path="packages/core/src/constants/messages.ts">
-export const MESSAGES_CONTEXT = "messages";
-
-export const MESSAGES_STORAGE_VERSION = "0.3";
-</file>
-
-<file path="packages/core/src/constants/pairing.ts">
-import { THIRTY_DAYS, ONE_DAY, THIRTY_SECONDS } from "@walletconnect/time";
-import { RelayerTypes, PairingJsonRpcTypes } from "@walletconnect/types";
-
-export const PAIRING_CONTEXT = "pairing";
-
-export const PAIRING_STORAGE_VERSION = "0.3";
-
-export const PAIRING_DEFAULT_TTL = THIRTY_DAYS;
-
-export const PAIRING_RPC_OPTS: Record<
-  PairingJsonRpcTypes.WcMethod | "unregistered_method",
-  {
-    req: RelayerTypes.PublishOptions;
-    res: RelayerTypes.PublishOptions;
-  }
-> = {
-  wc_pairingDelete: {
-    req: {
-      ttl: ONE_DAY,
-      prompt: false,
-      tag: 1000,
-    },
-    res: {
-      ttl: ONE_DAY,
-      prompt: false,
-      tag: 1001,
-    },
-  },
-  wc_pairingPing: {
-    req: {
-      ttl: THIRTY_SECONDS,
-      prompt: false,
-      tag: 1002,
-    },
-    res: {
-      ttl: THIRTY_SECONDS,
-      prompt: false,
-      tag: 1003,
-    },
-  },
-  unregistered_method: {
-    req: {
-      ttl: ONE_DAY,
-      prompt: false,
-      tag: 0,
-    },
-    res: {
-      ttl: ONE_DAY,
-      prompt: false,
-      tag: 0,
-    },
-  },
-};
-
-export const PAIRING_EVENTS = {
-  create: "pairing_create",
-  expire: "pairing_expire",
-  delete: "pairing_delete",
-  ping: "pairing_ping",
-};
-</file>
-
-<file path="packages/core/src/constants/publisher.ts">
-import { SIX_HOURS } from "@walletconnect/time";
-
-export const PUBLISHER_DEFAULT_TTL = SIX_HOURS;
-
-export const PUBLISHER_CONTEXT = "publisher";
-</file>
-
-<file path="packages/core/src/constants/relayer.ts">
-export const RELAYER_DEFAULT_PROTOCOL = "irn";
-
-export const RELAYER_DEFAULT_LOGGER = "error";
-
-export const RELAYER_DEFAULT_RELAY_URL = "wss://relay.walletconnect.org";
-
-export const RELAYER_CONTEXT = "relayer";
-
-export const RELAYER_EVENTS = {
-  message: "relayer_message",
-  message_ack: "relayer_message_ack",
-  connect: "relayer_connect",
-  disconnect: "relayer_disconnect",
-  error: "relayer_error",
-  connection_stalled: "relayer_connection_stalled",
-  transport_closed: "relayer_transport_closed",
-  publish: "relayer_publish",
-};
-
-export const RELAYER_SUBSCRIBER_SUFFIX = "_subscription";
-
-export const RELAYER_PROVIDER_EVENTS = {
-  payload: "payload",
-  connect: "connect",
-  disconnect: "disconnect",
-  error: "error",
-};
-
-export const RELAYER_RECONNECT_TIMEOUT = 0.1;
-
-export const RELAYER_STORAGE_OPTIONS = {
-  database: ":memory:",
-};
-
-// Updated automatically via `new-version` npm script.
-
-export const RELAYER_SDK_VERSION = "2.19.2";
-
-// delay to wait before closing the transport connection after init if not active
-export const RELAYER_TRANSPORT_CUTOFF = 10_000;
-
-export const TRANSPORT_TYPES = {
-  link_mode: "link_mode",
-  relay: "relay",
-} as const;
-
-export const MESSAGE_DIRECTION = {
-  inbound: "inbound",
-  outbound: "outbound",
-} as const;
-</file>
-
-<file path="packages/core/src/constants/store.ts">
-export const STORE_STORAGE_VERSION = "0.3";
-
-export const WALLETCONNECT_CLIENT_ID = "WALLETCONNECT_CLIENT_ID";
-export const WALLETCONNECT_LINK_MODE_APPS = "WALLETCONNECT_LINK_MODE_APPS";
-</file>
-
-<file path="packages/core/src/constants/subscriber.ts">
-import { THIRTY_DAYS, FIVE_SECONDS } from "@walletconnect/time";
-
-export const SUBSCRIBER_EVENTS = {
-  created: "subscription_created",
-  deleted: "subscription_deleted",
-  expired: "subscription_expired",
-  disabled: "subscription_disabled",
-  sync: "subscription_sync",
-  resubscribed: "subscription_resubscribed",
-};
-
-export const SUBSCRIBER_DEFAULT_TTL = THIRTY_DAYS;
-
-export const SUBSCRIBER_CONTEXT = "subscription";
-
-export const SUBSCRIBER_STORAGE_VERSION = "0.3";
-
-export const PENDING_SUB_RESOLUTION_TIMEOUT = FIVE_SECONDS * 1000;
-</file>
-
-<file path="packages/core/src/constants/verify.ts">
-export const VERIFY_CONTEXT = "verify-api";
-
-const VERIFY_SERVER_COM = "https://verify.walletconnect.com";
-const VERIFY_SERVER_ORG = "https://verify.walletconnect.org";
-export const VERIFY_SERVER = VERIFY_SERVER_ORG;
-export const VERIFY_SERVER_V3 = `${VERIFY_SERVER}/v3`;
-
-export const TRUSTED_VERIFY_URLS = [VERIFY_SERVER_COM, VERIFY_SERVER_ORG];
-</file>
-
-<file path="packages/core/src/controllers/crypto.ts">
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { safeJsonParse, safeJsonStringify } from "@walletconnect/safe-json";
-import { ICore, ICrypto, IKeyChain } from "@walletconnect/types";
-import * as relayAuth from "@walletconnect/relay-auth";
-import { fromString } from "uint8arrays/from-string";
-import {
-  decrypt,
-  deriveSymKey,
-  encrypt,
-  generateKeyPair as generateKeyPairUtil,
-  hashKey,
-  getInternalError,
-  generateRandomBytes32,
-  validateEncoding,
-  validateDecoding,
-  isTypeOneEnvelope,
-  isTypeTwoEnvelope,
-  encodeTypeTwoEnvelope,
-  decodeTypeTwoEnvelope,
-  deserialize,
-  decodeTypeByte,
-  BASE16,
-  BASE64,
-} from "@walletconnect/utils";
-import { toString } from "uint8arrays";
-
-import { CRYPTO_CONTEXT, CRYPTO_CLIENT_SEED, CRYPTO_JWT_TTL } from "../constants";
-import { KeyChain } from "./keychain";
-
-export class Crypto implements ICrypto {
-  public name = CRYPTO_CONTEXT;
-  public keychain: ICrypto["keychain"];
-  public readonly randomSessionIdentifier = generateRandomBytes32();
-
-  private initialized = false;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    keychain?: IKeyChain,
-  ) {
-    this.core = core;
-    this.logger = generateChildLogger(logger, this.name);
-    this.keychain = keychain || new KeyChain(this.core, this.logger);
-  }
-
-  public init: ICrypto["init"] = async () => {
-    if (!this.initialized) {
-      await this.keychain.init();
-      this.initialized = true;
-    }
-  };
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  public hasKeys: ICrypto["hasKeys"] = (tag) => {
-    this.isInitialized();
-    return this.keychain.has(tag);
-  };
-
-  public getClientId: ICrypto["getClientId"] = async () => {
-    this.isInitialized();
-    const seed = await this.getClientSeed();
-    const keyPair = relayAuth.generateKeyPair(seed);
-    const clientId = relayAuth.encodeIss(keyPair.publicKey);
-    return clientId;
-  };
-
-  public generateKeyPair: ICrypto["generateKeyPair"] = () => {
-    this.isInitialized();
-    const keyPair = generateKeyPairUtil();
-    return this.setPrivateKey(keyPair.publicKey, keyPair.privateKey);
-  };
-
-  public signJWT: ICrypto["signJWT"] = async (aud) => {
-    this.isInitialized();
-    const seed = await this.getClientSeed();
-    const keyPair = relayAuth.generateKeyPair(seed);
-    const sub = this.randomSessionIdentifier;
-    const ttl = CRYPTO_JWT_TTL;
-    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);
-    return jwt;
-  };
-
-  public generateSharedKey: ICrypto["generateSharedKey"] = (
-    selfPublicKey,
-    peerPublicKey,
-    overrideTopic,
-  ) => {
-    this.isInitialized();
-    const selfPrivateKey = this.getPrivateKey(selfPublicKey);
-    const symKey = deriveSymKey(selfPrivateKey, peerPublicKey);
-    return this.setSymKey(symKey, overrideTopic);
-  };
-
-  public setSymKey: ICrypto["setSymKey"] = async (symKey, overrideTopic) => {
-    this.isInitialized();
-    const topic = overrideTopic || hashKey(symKey);
-    await this.keychain.set(topic, symKey);
-    return topic;
-  };
-
-  public deleteKeyPair: ICrypto["deleteKeyPair"] = async (publicKey: string) => {
-    this.isInitialized();
-    await this.keychain.del(publicKey);
-  };
-
-  public deleteSymKey: ICrypto["deleteSymKey"] = async (topic: string) => {
-    this.isInitialized();
-    await this.keychain.del(topic);
-  };
-
-  public encode: ICrypto["encode"] = async (topic, payload, opts) => {
-    this.isInitialized();
-    const params = validateEncoding(opts);
-    const message = safeJsonStringify(payload);
-
-    if (isTypeTwoEnvelope(params)) {
-      return encodeTypeTwoEnvelope(message, opts?.encoding);
-    }
-
-    if (isTypeOneEnvelope(params)) {
-      const selfPublicKey = params.senderPublicKey;
-      const peerPublicKey = params.receiverPublicKey;
-      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);
-    }
-    const symKey = this.getSymKey(topic);
-    const { type, senderPublicKey } = params;
-    const result = encrypt({ type, symKey, message, senderPublicKey, encoding: opts?.encoding });
-    return result;
-  };
-
-  public decode: ICrypto["decode"] = async (topic, encoded, opts) => {
-    this.isInitialized();
-    const params = validateDecoding(encoded, opts);
-    if (isTypeTwoEnvelope(params)) {
-      const message = decodeTypeTwoEnvelope(encoded, opts?.encoding);
-      return safeJsonParse(message);
-    }
-    if (isTypeOneEnvelope(params)) {
-      const selfPublicKey = params.receiverPublicKey;
-      const peerPublicKey = params.senderPublicKey;
-      topic = await this.generateSharedKey(selfPublicKey, peerPublicKey);
-    }
-    try {
-      const symKey = this.getSymKey(topic);
-      const message = decrypt({ symKey, encoded, encoding: opts?.encoding });
-      const payload = safeJsonParse(message);
-      return payload;
-    } catch (error) {
-      this.logger.error(
-        `Failed to decode message from topic: '${topic}', clientId: '${await this.getClientId()}'`,
-      );
-      this.logger.error(error);
-    }
-  };
-
-  public getPayloadType: ICrypto["getPayloadType"] = (encoded, encoding = BASE64) => {
-    const deserialized = deserialize({ encoded, encoding });
-    return decodeTypeByte(deserialized.type);
-  };
-
-  public getPayloadSenderPublicKey: ICrypto["getPayloadSenderPublicKey"] = (
-    encoded,
-    encoding = BASE64,
-  ) => {
-    const deserialized = deserialize({ encoded, encoding });
-    return deserialized.senderPublicKey
-      ? toString(deserialized.senderPublicKey, BASE16)
-      : undefined;
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private async setPrivateKey(publicKey: string, privateKey: string): Promise<string> {
-    await this.keychain.set(publicKey, privateKey);
-    return publicKey;
-  }
-
-  private getPrivateKey(publicKey: string) {
-    const privateKey = this.keychain.get(publicKey);
-    return privateKey;
-  }
-
-  private async getClientSeed(): Promise<Uint8Array> {
-    let seed = "";
-    try {
-      seed = this.keychain.get(CRYPTO_CLIENT_SEED);
-    } catch {
-      seed = generateRandomBytes32();
-      await this.keychain.set(CRYPTO_CLIENT_SEED, seed);
-    }
-    return fromString(seed, "base16");
-  }
-
-  private getSymKey(topic: string) {
-    const symKey = this.keychain.get(topic);
-    return symKey;
-  }
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/echo.ts">
-import { generateChildLogger, Logger } from "@walletconnect/logger";
-import { IEchoClient } from "@walletconnect/types";
-import { ECHO_CONTEXT, ECHO_URL } from "../constants";
-
-export class EchoClient extends IEchoClient {
-  public readonly context = ECHO_CONTEXT;
-  constructor(
-    public projectId: string,
-    public logger: Logger,
-  ) {
-    super(projectId, logger);
-    this.logger = generateChildLogger(logger, this.context);
-  }
-
-  public registerDeviceToken: IEchoClient["registerDeviceToken"] = async (params) => {
-    const { clientId, token, notificationType, enableEncrypted = false } = params;
-
-    const echoUrl = `${ECHO_URL}/${this.projectId}/clients`;
-
-    await fetch(echoUrl, {
-      method: "POST",
-      headers: {
-        "Content-Type": "application/json",
-      },
-      body: JSON.stringify({
-        client_id: clientId,
-        type: notificationType,
-        token,
-        always_raw: enableEncrypted,
-      }),
-    });
-  };
-}
-</file>
-
-<file path="packages/core/src/controllers/events.ts">
-import { generateChildLogger, Logger } from "@walletconnect/logger";
-import { ICore, IEventClient, EventClientTypes } from "@walletconnect/types";
-import { formatUA, isTestRun, uuidv4, getAppMetadata } from "@walletconnect/utils";
-import {
-  CORE_STORAGE_PREFIX,
-  EVENTS_CLIENT_API_URL,
-  EVENTS_STORAGE_CLEANUP_INTERVAL,
-  EVENTS_STORAGE_CONTEXT,
-  EVENTS_STORAGE_VERSION,
-  RELAYER_SDK_VERSION,
-} from "../constants";
-import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
-import { fromMiliseconds } from "@walletconnect/time";
-
-export class EventClient extends IEventClient {
-  public readonly context = EVENTS_STORAGE_CONTEXT;
-  private readonly storagePrefix = CORE_STORAGE_PREFIX;
-  private readonly storageVersion = EVENTS_STORAGE_VERSION;
-  private events = new Map<string, EventClientTypes.Event>();
-  private shouldPersist = false;
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    telemetryEnabled = true,
-  ) {
-    super(core, logger, telemetryEnabled);
-    this.logger = generateChildLogger(logger, this.context);
-    this.telemetryEnabled = telemetryEnabled;
-    if (telemetryEnabled) {
-      this.restore().then(async () => {
-        await this.submit();
-        this.setEventListeners();
-      });
-    } else {
-      // overwrite any persisted events with an empty array
-      this.persist();
-    }
-  }
-
-  get storageKey() {
-    return (
-      this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context
-    );
-  }
-
-  public init: IEventClient["init"] = async () => {
-    if (isTestRun()) return;
-    try {
-      const initEvent = {
-        eventId: uuidv4(),
-        timestamp: Date.now(),
-        domain: this.getAppDomain(),
-        props: {
-          event: "INIT",
-          type: "",
-          properties: {
-            client_id: await this.core.crypto.getClientId(),
-            user_agent: formatUA(
-              this.core.relayer.protocol,
-              this.core.relayer.version,
-              RELAYER_SDK_VERSION,
-            ),
-          },
-        },
-      };
-      await this.sendEvent([initEvent] as unknown as EventClientTypes.Event[]);
-    } catch (error) {
-      this.logger.warn(error);
-    }
-  };
-
-  public createEvent: IEventClient["createEvent"] = (params) => {
-    const {
-      event = "ERROR",
-      type = "",
-      properties: { topic, trace },
-    } = params;
-    const eventId = uuidv4();
-    const bundleId = this.core.projectId || "";
-    const timestamp = Date.now();
-    const props = {
-      event,
-      type,
-      properties: {
-        topic,
-        trace,
-      },
-    };
-    const eventObj = {
-      eventId,
-      timestamp,
-      props,
-      bundleId,
-      domain: this.getAppDomain(),
-      ...this.setMethods(eventId),
-    };
-    if (this.telemetryEnabled) {
-      this.events.set(eventId, eventObj);
-      this.shouldPersist = true;
-    }
-
-    return eventObj;
-  };
-
-  public getEvent: IEventClient["getEvent"] = (params) => {
-    const { eventId, topic } = params;
-    if (eventId) {
-      return this.events.get(eventId);
-    }
-    const event = Array.from(this.events.values()).find(
-      (event) => event.props.properties.topic === topic,
-    );
-
-    if (!event) return;
-
-    return {
-      ...event,
-      ...this.setMethods(event.eventId),
-    };
-  };
-
-  public deleteEvent: IEventClient["deleteEvent"] = (params) => {
-    const { eventId } = params;
-    this.events.delete(eventId);
-    this.shouldPersist = true;
-  };
-
-  private setEventListeners = () => {
-    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {
-      if (this.shouldPersist) await this.persist();
-      // cleanup events older than EVENTS_STORAGE_CLEANUP_INTERVAL
-      this.events.forEach((event) => {
-        if (
-          fromMiliseconds(Date.now()) - fromMiliseconds(event.timestamp) >
-          EVENTS_STORAGE_CLEANUP_INTERVAL
-        ) {
-          this.events.delete(event.eventId);
-          this.shouldPersist = true;
-        }
-      });
-    });
-  };
-
-  private setMethods = (eventId: string) => {
-    return {
-      addTrace: (trace: string) => this.addTrace(eventId, trace),
-      setError: (errorType: string) => this.setError(eventId, errorType),
-    };
-  };
-
-  private addTrace = (eventId: string, trace: string) => {
-    const event = this.events.get(eventId);
-    if (!event) return;
-    event.props.properties.trace.push(trace);
-    this.events.set(eventId, event);
-    this.shouldPersist = true;
-  };
-
-  private setError = (eventId: string, errorType: string) => {
-    const event = this.events.get(eventId);
-    if (!event) return;
-    event.props.type = errorType;
-    event.timestamp = Date.now();
-    this.events.set(eventId, event);
-    this.shouldPersist = true;
-  };
-
-  private persist = async () => {
-    await this.core.storage.setItem(this.storageKey, Array.from(this.events.values()));
-    this.shouldPersist = false;
-  };
-
-  private restore = async () => {
-    try {
-      const events =
-        (await this.core.storage.getItem<EventClientTypes.Event[]>(this.storageKey)) || [];
-      if (!events.length) return;
-      events.forEach((event) => {
-        this.events.set(event.eventId, {
-          ...event,
-          ...this.setMethods(event.eventId),
-        });
-      });
-    } catch (error) {
-      this.logger.warn(error);
-    }
-  };
-
-  private submit = async () => {
-    if (!this.telemetryEnabled) return;
-
-    if (this.events.size === 0) return;
-
-    const eventsToSend: EventClientTypes.Event[] = [];
-    // exclude events without type as they can be considered `in progress`
-    for (const [_, event] of this.events) {
-      if (event.props.type) {
-        eventsToSend.push(event);
-      }
-    }
-
-    if (eventsToSend.length === 0) return;
-
-    try {
-      const response = await this.sendEvent(eventsToSend);
-      if (response.ok) {
-        for (const event of eventsToSend) {
-          this.events.delete(event.eventId);
-          this.shouldPersist = true;
-        }
-      }
-    } catch (error) {
-      this.logger.warn(error);
-    }
-  };
-
-  private sendEvent = async (events: EventClientTypes.Event[]) => {
-    // if domain isn't available, set `sp` as `desktop` so data would be extracted on api side
-    const platform = this.getAppDomain() ? "" : "&sp=desktop";
-    const response = await fetch(
-      `${EVENTS_CLIENT_API_URL}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${RELAYER_SDK_VERSION}${platform}`,
-      {
-        method: "POST",
-        body: JSON.stringify(events),
-      },
-    );
-    return response;
-  };
-
-  private getAppDomain = () => {
-    return getAppMetadata().url;
-  };
-}
-</file>
-
-<file path="packages/core/src/controllers/expirer.ts">
-import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { toMiliseconds } from "@walletconnect/time";
-import { ExpirerTypes, ICore, IExpirer } from "@walletconnect/types";
-import { getInternalError, formatIdTarget, formatTopicTarget } from "@walletconnect/utils";
-import { EventEmitter } from "events";
-import {
-  CORE_STORAGE_PREFIX,
-  EXPIRER_CONTEXT,
-  EXPIRER_EVENTS,
-  EXPIRER_STORAGE_VERSION,
-} from "../constants";
-
-export class Expirer extends IExpirer {
-  public expirations = new Map<string, ExpirerTypes.Expiration>();
-  public events = new EventEmitter();
-  public name = EXPIRER_CONTEXT;
-  public version = EXPIRER_STORAGE_VERSION;
-
-  private cached: ExpirerTypes.Expiration[] = [];
-  private initialized = false;
-
-  private storagePrefix = CORE_STORAGE_PREFIX;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-  ) {
-    super(core, logger);
-    this.logger = generateChildLogger(logger, this.name);
-  }
-
-  public init: IExpirer["init"] = async () => {
-    if (!this.initialized) {
-      this.logger.trace(`Initialized`);
-      await this.restore();
-      this.cached.forEach((expiration) => this.expirations.set(expiration.target, expiration));
-      this.cached = [];
-      this.registerEventListeners();
-      this.initialized = true;
-    }
-  };
-
-  get context(): string {
-    return getLoggerContext(this.logger);
-  }
-
-  get storageKey() {
-    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
-  }
-
-  get length(): number {
-    return this.expirations.size;
-  }
-
-  get keys(): string[] {
-    return Array.from(this.expirations.keys());
-  }
-
-  get values(): ExpirerTypes.Expiration[] {
-    return Array.from(this.expirations.values());
-  }
-
-  public has: IExpirer["has"] = (key) => {
-    try {
-      const target = this.formatTarget(key);
-      const expiration = this.getExpiration(target);
-      return typeof expiration !== "undefined";
-    } catch (e) {
-      // ignore
-      return false;
-    }
-  };
-
-  public set: IExpirer["set"] = (key, expiry) => {
-    this.isInitialized();
-    const target = this.formatTarget(key);
-    const expiration = { target, expiry };
-    this.expirations.set(target, expiration);
-    this.checkExpiry(target, expiration);
-    this.events.emit(EXPIRER_EVENTS.created, {
-      target,
-      expiration,
-    } as ExpirerTypes.Created);
-  };
-
-  public get: IExpirer["get"] = (key) => {
-    this.isInitialized();
-    const target = this.formatTarget(key);
-    return this.getExpiration(target);
-  };
-
-  public del: IExpirer["del"] = (key) => {
-    this.isInitialized();
-    const exists = this.has(key);
-    if (exists) {
-      const target = this.formatTarget(key);
-      const expiration = this.getExpiration(target);
-      this.expirations.delete(target);
-      this.events.emit(EXPIRER_EVENTS.deleted, {
-        target,
-        expiration,
-      } as ExpirerTypes.Deleted);
-    }
-  };
-
-  public on: IExpirer["on"] = (event, listener) => {
-    this.events.on(event, listener);
-  };
-
-  public once: IExpirer["once"] = (event, listener) => {
-    this.events.once(event, listener);
-  };
-
-  public off: IExpirer["off"] = (event, listener) => {
-    this.events.off(event, listener);
-  };
-
-  public removeListener: IExpirer["removeListener"] = (event, listener) => {
-    this.events.removeListener(event, listener);
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private formatTarget(key: string | number) {
-    if (typeof key === "string") {
-      return formatTopicTarget(key);
-    } else if (typeof key === "number") {
-      return formatIdTarget(key);
-    }
-    const { message } = getInternalError("UNKNOWN_TYPE", `Target type: ${typeof key}`);
-    throw new Error(message);
-  }
-
-  private async setExpirations(expirations: ExpirerTypes.Expiration[]): Promise<void> {
-    await this.core.storage.setItem<ExpirerTypes.Expiration[]>(this.storageKey, expirations);
-  }
-
-  private async getExpirations(): Promise<ExpirerTypes.Expiration[] | undefined> {
-    const expirations = await this.core.storage.getItem<ExpirerTypes.Expiration[]>(this.storageKey);
-    return expirations;
-  }
-
-  private async persist() {
-    await this.setExpirations(this.values);
-    this.events.emit(EXPIRER_EVENTS.sync);
-  }
-
-  private async restore() {
-    try {
-      const persisted = await this.getExpirations();
-      if (typeof persisted === "undefined") return;
-      if (!persisted.length) return;
-      if (this.expirations.size) {
-        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
-        this.logger.error(message);
-        throw new Error(message);
-      }
-      this.cached = persisted;
-      this.logger.debug(`Successfully Restored expirations for ${this.name}`);
-      this.logger.trace({ type: "method", method: "restore", expirations: this.values });
-    } catch (e) {
-      this.logger.debug(`Failed to Restore expirations for ${this.name}`);
-      this.logger.error(e as any);
-    }
-  }
-
-  private getExpiration(target: string): ExpirerTypes.Expiration {
-    const expiration = this.expirations.get(target);
-    if (!expiration) {
-      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${target}`);
-      this.logger.warn(message);
-      throw new Error(message);
-    }
-    return expiration;
-  }
-
-  private checkExpiry(target: string, expiration: ExpirerTypes.Expiration): void {
-    const { expiry } = expiration;
-    const msToTimeout = toMiliseconds(expiry) - Date.now();
-    if (msToTimeout <= 0) this.expire(target, expiration);
-  }
-
-  private expire(target: string, expiration: ExpirerTypes.Expiration): void {
-    this.expirations.delete(target);
-    this.events.emit(EXPIRER_EVENTS.expired, {
-      target,
-      expiration,
-    } as ExpirerTypes.Expired);
-  }
-
-  private checkExpirations(): void {
-    // avoid auto expiring if the relayer is not connected
-    if (!this.core.relayer.connected) return;
-    this.expirations.forEach((expiration, target) => this.checkExpiry(target, expiration));
-  }
-
-  private registerEventListeners(): void {
-    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => this.checkExpirations());
-    this.events.on(EXPIRER_EVENTS.created, (createdEvent: ExpirerTypes.Created) => {
-      const eventName = EXPIRER_EVENTS.created;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, data: createdEvent });
-      this.persist();
-    });
-    this.events.on(EXPIRER_EVENTS.expired, (expiredEvent: ExpirerTypes.Expired) => {
-      const eventName = EXPIRER_EVENTS.expired;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, data: expiredEvent });
-      this.persist();
-    });
-    this.events.on(EXPIRER_EVENTS.deleted, (deletedEvent: ExpirerTypes.Deleted) => {
-      const eventName = EXPIRER_EVENTS.deleted;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
-      this.persist();
-    });
-  }
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/history.ts">
-import { formatJsonRpcRequest, isJsonRpcError } from "@walletconnect/jsonrpc-utils";
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { IJsonRpcHistory, JsonRpcRecord, RequestEvent, ICore } from "@walletconnect/types";
-import { calcExpiry, getInternalError } from "@walletconnect/utils";
-import { EventEmitter } from "events";
-import { THIRTY_DAYS, toMiliseconds } from "@walletconnect/time";
-import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
-import {
-  CORE_STORAGE_PREFIX,
-  HISTORY_CONTEXT,
-  HISTORY_EVENTS,
-  HISTORY_STORAGE_VERSION,
-} from "../constants";
-
-export class JsonRpcHistory extends IJsonRpcHistory {
-  public records = new Map<number, JsonRpcRecord>();
-  public events = new EventEmitter();
-  public name = HISTORY_CONTEXT;
-  public version = HISTORY_STORAGE_VERSION;
-
-  private cached: JsonRpcRecord[] = [];
-  private initialized = false;
-  private storagePrefix = CORE_STORAGE_PREFIX;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-  ) {
-    super(core, logger);
-    this.logger = generateChildLogger(logger, this.name);
-  }
-
-  public init: IJsonRpcHistory["init"] = async () => {
-    if (!this.initialized) {
-      this.logger.trace(`Initialized`);
-      await this.restore();
-      this.cached.forEach((record) => this.records.set(record.id, record));
-      this.cached = [];
-      this.registerEventListeners();
-      this.initialized = true;
-    }
-  };
-
-  get context(): string {
-    return getLoggerContext(this.logger);
-  }
-
-  get storageKey() {
-    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
-  }
-
-  get size(): number {
-    return this.records.size;
-  }
-
-  get keys(): number[] {
-    return Array.from(this.records.keys());
-  }
-
-  get values() {
-    return Array.from(this.records.values());
-  }
-
-  get pending(): RequestEvent[] {
-    const requests: RequestEvent[] = [];
-    this.values.forEach((record) => {
-      if (typeof record.response !== "undefined") return;
-      const requestEvent: RequestEvent = {
-        topic: record.topic,
-        request: formatJsonRpcRequest(record.request.method, record.request.params, record.id),
-        chainId: record.chainId,
-      };
-      return requests.push(requestEvent);
-    });
-    return requests;
-  }
-
-  public set: IJsonRpcHistory["set"] = (topic, request, chainId) => {
-    this.isInitialized();
-    this.logger.debug(`Setting JSON-RPC request history record`);
-    this.logger.trace({ type: "method", method: "set", topic, request, chainId });
-    if (this.records.has(request.id)) return;
-    const record: JsonRpcRecord = {
-      id: request.id,
-      topic,
-      request: { method: request.method, params: request.params || null },
-      chainId,
-      expiry: calcExpiry(THIRTY_DAYS),
-    };
-    this.records.set(record.id, record);
-    this.persist();
-    this.events.emit(HISTORY_EVENTS.created, record);
-  };
-
-  public resolve: IJsonRpcHistory["resolve"] = async (response) => {
-    this.isInitialized();
-    this.logger.debug(`Updating JSON-RPC response history record`);
-    this.logger.trace({ type: "method", method: "update", response });
-    if (!this.records.has(response.id)) return;
-    const record = await this.getRecord(response.id);
-    if (typeof record.response !== "undefined") return;
-    record.response = isJsonRpcError(response)
-      ? { error: response.error }
-      : { result: response.result };
-    this.records.set(record.id, record);
-    this.persist();
-    this.events.emit(HISTORY_EVENTS.updated, record);
-  };
-
-  public get: IJsonRpcHistory["get"] = async (topic, id) => {
-    this.isInitialized();
-    this.logger.debug(`Getting record`);
-    this.logger.trace({ type: "method", method: "get", topic, id });
-    const record = await this.getRecord(id);
-    return record;
-  };
-
-  public delete: IJsonRpcHistory["delete"] = (topic, id) => {
-    this.isInitialized();
-    this.logger.debug(`Deleting record`);
-    this.logger.trace({ type: "method", method: "delete", id });
-    this.values.forEach((record: JsonRpcRecord) => {
-      if (record.topic === topic) {
-        if (typeof id !== "undefined" && record.id !== id) return;
-        this.records.delete(record.id);
-        this.events.emit(HISTORY_EVENTS.deleted, record);
-      }
-    });
-    this.persist();
-  };
-
-  public exists: IJsonRpcHistory["exists"] = async (topic, id) => {
-    this.isInitialized();
-    if (!this.records.has(id)) return false;
-    const record = await this.getRecord(id);
-    return record.topic === topic;
-  };
-
-  public on: IJsonRpcHistory["on"] = (event, listener) => {
-    this.events.on(event, listener);
-  };
-
-  public once: IJsonRpcHistory["once"] = (event, listener) => {
-    this.events.once(event, listener);
-  };
-
-  public off: IJsonRpcHistory["off"] = (event, listener) => {
-    this.events.off(event, listener);
-  };
-
-  public removeListener: IJsonRpcHistory["removeListener"] = (event, listener) => {
-    this.events.removeListener(event, listener);
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private async setJsonRpcRecords(records: JsonRpcRecord[]): Promise<void> {
-    await this.core.storage.setItem<JsonRpcRecord[]>(this.storageKey, records);
-  }
-
-  private async getJsonRpcRecords(): Promise<JsonRpcRecord[] | undefined> {
-    const records = await this.core.storage.getItem<JsonRpcRecord[]>(this.storageKey);
-    return records;
-  }
-
-  private getRecord(id: number) {
-    this.isInitialized();
-    const record = this.records.get(id);
-    if (!record) {
-      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${id}`);
-      throw new Error(message);
-    }
-    return record;
-  }
-
-  private async persist() {
-    await this.setJsonRpcRecords(this.values);
-    this.events.emit(HISTORY_EVENTS.sync);
-  }
-
-  private async restore() {
-    try {
-      const persisted = await this.getJsonRpcRecords();
-      if (typeof persisted === "undefined") return;
-      if (!persisted.length) return;
-      if (this.records.size) {
-        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
-        this.logger.error(message);
-        throw new Error(message);
-      }
-      this.cached = persisted;
-      this.logger.debug(`Successfully Restored records for ${this.name}`);
-      this.logger.trace({ type: "method", method: "restore", records: this.values });
-    } catch (e) {
-      this.logger.debug(`Failed to Restore records for ${this.name}`);
-      this.logger.error(e as any);
-    }
-  }
-
-  private registerEventListeners(): void {
-    this.events.on(HISTORY_EVENTS.created, (record: JsonRpcRecord) => {
-      const eventName = HISTORY_EVENTS.created;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, record });
-    });
-    this.events.on(HISTORY_EVENTS.updated, (record: JsonRpcRecord) => {
-      const eventName = HISTORY_EVENTS.updated;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, record });
-    });
-
-    this.events.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {
-      const eventName = HISTORY_EVENTS.deleted;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, record });
-    });
-
-    this.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {
-      this.cleanup();
-    });
-  }
-
-  private cleanup() {
-    try {
-      this.isInitialized();
-      let deleted = false;
-      this.records.forEach((record: JsonRpcRecord) => {
-        const msToExpiry = toMiliseconds(record.expiry || 0) - Date.now();
-        if (msToExpiry <= 0) {
-          this.logger.info(`Deleting expired history log: ${record.id}`);
-          this.records.delete(record.id);
-          this.events.emit(HISTORY_EVENTS.deleted, record, false);
-          deleted = true;
-        }
-      });
-      if (deleted) {
-        this.persist();
-      }
-    } catch (e) {
-      this.logger.warn(e);
-    }
-  }
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/index.ts">
-export * from "./crypto";
-export * from "./messages";
-export * from "./relayer";
-export * from "./store";
-export * from "./subscriber";
-export * from "./keychain";
-export * from "./pairing";
-export * from "./history";
-export * from "./expirer";
-export * from "./verify";
-export * from "./echo";
-export * from "./events";
-</file>
-
-<file path="packages/core/src/controllers/keychain.ts">
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { ICore, IKeyChain } from "@walletconnect/types";
-import { getInternalError, mapToObj, objToMap } from "@walletconnect/utils";
-
-import { CORE_STORAGE_PREFIX, KEYCHAIN_CONTEXT, KEYCHAIN_STORAGE_VERSION } from "../constants";
-
-export class KeyChain implements IKeyChain {
-  public keychain = new Map<string, string>();
-  public name = KEYCHAIN_CONTEXT;
-  public version = KEYCHAIN_STORAGE_VERSION;
-
-  private initialized = false;
-  private storagePrefix = CORE_STORAGE_PREFIX;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-  ) {
-    this.core = core;
-    this.logger = generateChildLogger(logger, this.name);
-  }
-
-  public init: IKeyChain["init"] = async () => {
-    if (!this.initialized) {
-      const keychain = await this.getKeyChain();
-      if (typeof keychain !== "undefined") {
-        this.keychain = keychain;
-      }
-      this.initialized = true;
-    }
-  };
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  get storageKey() {
-    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
-  }
-
-  public has: IKeyChain["has"] = (tag) => {
-    this.isInitialized();
-    return this.keychain.has(tag);
-  };
-
-  public set: IKeyChain["set"] = async (tag, key) => {
-    this.isInitialized();
-    this.keychain.set(tag, key);
-    await this.persist();
-  };
-
-  public get: IKeyChain["get"] = (tag) => {
-    this.isInitialized();
-    const key = this.keychain.get(tag);
-    if (typeof key === "undefined") {
-      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${tag}`);
-      throw new Error(message);
-    }
-    return key;
-  };
-
-  public del: IKeyChain["del"] = async (tag) => {
-    this.isInitialized();
-    this.keychain.delete(tag);
-    await this.persist();
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private async setKeyChain(keychain: Map<string, string>) {
-    await this.core.storage.setItem<Record<string, string>>(this.storageKey, mapToObj(keychain));
-  }
-
-  private async getKeyChain() {
-    const keychain = await this.core.storage.getItem<Record<string, string>>(this.storageKey);
-    return typeof keychain !== "undefined" ? objToMap(keychain) : undefined;
-  }
-
-  private async persist() {
-    await this.setKeyChain(this.keychain);
-  }
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/messages.ts">
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { ICore, IMessageTracker, MessageRecord } from "@walletconnect/types";
-import { hashMessage, mapToObj, objToMap, getInternalError } from "@walletconnect/utils";
-import {
-  CORE_STORAGE_PREFIX,
-  MESSAGE_DIRECTION,
-  MESSAGES_CONTEXT,
-  MESSAGES_STORAGE_VERSION,
-} from "../constants";
-
-export class MessageTracker extends IMessageTracker {
-  public messages = new Map<string, MessageRecord>();
-  /**
-   * stores messages that have not been acknowledged by the implementing client
-   * this is used to prevent losing messages in race conditions such as
-   * when a message is received by the relayer before the implementing client is ready to receive it
-   */
-  public messagesWithoutClientAck = new Map<string, MessageRecord>();
-  public name = MESSAGES_CONTEXT;
-  public version = MESSAGES_STORAGE_VERSION;
-
-  private initialized = false;
-  private storagePrefix = CORE_STORAGE_PREFIX;
-
-  constructor(
-    public logger: Logger,
-    public core: ICore,
-  ) {
-    super(logger, core);
-    this.logger = generateChildLogger(logger, this.name);
-    this.core = core;
-  }
-
-  public init: IMessageTracker["init"] = async () => {
-    if (!this.initialized) {
-      this.logger.trace(`Initialized`);
-      try {
-        const messages = await this.getRelayerMessages();
-        if (typeof messages !== "undefined") {
-          this.messages = messages;
-        }
-        const messagesWithoutClientAck = await this.getRelayerMessagesWithoutClientAck();
-        if (typeof messagesWithoutClientAck !== "undefined") {
-          this.messagesWithoutClientAck = messagesWithoutClientAck;
-        }
-        this.logger.debug(`Successfully Restored records for ${this.name}`);
-        this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
-      } catch (e) {
-        this.logger.debug(`Failed to Restore records for ${this.name}`);
-        this.logger.error(e as any);
-      } finally {
-        this.initialized = true;
-      }
-    }
-  };
-
-  get context(): string {
-    return getLoggerContext(this.logger);
-  }
-
-  get storageKey() {
-    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
-  }
-
-  get storageKeyWithoutClientAck() {
-    return (
-      this.storagePrefix +
-      this.version +
-      this.core.customStoragePrefix +
-      "//" +
-      this.name +
-      "_withoutClientAck"
-    );
-  }
-
-  public set: IMessageTracker["set"] = async (topic, message, direction) => {
-    this.isInitialized();
-    const hash = hashMessage(message);
-    let messages = this.messages.get(topic);
-    if (typeof messages === "undefined") {
-      messages = {};
-    }
-    if (typeof messages[hash] !== "undefined") {
-      return hash;
-    }
-    messages[hash] = message;
-    this.messages.set(topic, messages);
-    // Only store messages without client ack for inbound messages
-    if (direction === MESSAGE_DIRECTION.inbound) {
-      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};
-      this.messagesWithoutClientAck.set(topic, {
-        ...messagesWithoutClientAck,
-        [hash]: message,
-      });
-    }
-
-    await this.persist();
-    return hash;
-  };
-
-  public get: IMessageTracker["get"] = (topic) => {
-    this.isInitialized();
-    let messages = this.messages.get(topic);
-    if (typeof messages === "undefined") {
-      messages = {};
-    }
-    return messages;
-  };
-
-  public getWithoutAck: IMessageTracker["getWithoutAck"] = (topics) => {
-    this.isInitialized();
-    const messages: Record<string, string[]> = {};
-    for (const topic of topics) {
-      const messagesWithoutClientAck = this.messagesWithoutClientAck.get(topic) || {};
-      messages[topic] = Object.values(messagesWithoutClientAck);
-    }
-    return messages;
-  };
-
-  public has: IMessageTracker["has"] = (topic, message) => {
-    this.isInitialized();
-    const messages = this.get(topic);
-    const hash = hashMessage(message);
-    return typeof messages[hash] !== "undefined";
-  };
-
-  public ack: IMessageTracker["ack"] = async (topic, message) => {
-    this.isInitialized();
-    const messages = this.messagesWithoutClientAck.get(topic);
-    if (typeof messages === "undefined") {
-      return;
-    }
-
-    const hash = hashMessage(message);
-
-    delete messages[hash];
-    if (Object.keys(messages).length === 0) {
-      this.messagesWithoutClientAck.delete(topic);
-    } else {
-      this.messagesWithoutClientAck.set(topic, messages);
-    }
-    await this.persist();
-  };
-
-  public del: IMessageTracker["del"] = async (topic) => {
-    this.isInitialized();
-    this.messages.delete(topic);
-    this.messagesWithoutClientAck.delete(topic);
-    await this.persist();
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private async setRelayerMessages(messages: Map<string, MessageRecord>): Promise<void> {
-    await this.core.storage.setItem<Record<string, MessageRecord>>(
-      this.storageKey,
-      mapToObj(messages),
-    );
-  }
-
-  private async setRelayerMessagesWithoutClientAck(
-    messages: Map<string, MessageRecord>,
-  ): Promise<void> {
-    await this.core.storage.setItem<Record<string, MessageRecord>>(
-      this.storageKeyWithoutClientAck,
-      mapToObj(messages),
-    );
-  }
-
-  private async getRelayerMessages(): Promise<Map<string, MessageRecord> | undefined> {
-    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(
-      this.storageKey,
-    );
-    return typeof messages !== "undefined" ? objToMap(messages) : undefined;
-  }
-
-  private async getRelayerMessagesWithoutClientAck(): Promise<
-    Map<string, MessageRecord> | undefined
-  > {
-    const messages = await this.core.storage.getItem<Record<string, MessageRecord>>(
-      this.storageKeyWithoutClientAck,
-    );
-    return typeof messages !== "undefined" ? objToMap(messages) : undefined;
-  }
-
-  private async persist() {
-    await this.setRelayerMessages(this.messages);
-    await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
-  }
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/pairing.ts">
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import {
-  ICore,
-  PairingTypes,
-  IPairing,
-  IPairingPrivate,
-  IStore,
-  RelayerTypes,
-  PairingJsonRpcTypes,
-  ExpirerTypes,
-  EventClientTypes,
-} from "@walletconnect/types";
-import {
-  getInternalError,
-  parseUri,
-  calcExpiry,
-  generateRandomBytes32,
-  formatUri,
-  getSdkError,
-  engineEvent,
-  createDelayedPromise,
-  isValidParams,
-  isValidUrl,
-  isValidString,
-  isExpired,
-  parseExpirerTarget,
-  TYPE_1,
-} from "@walletconnect/utils";
-import {
-  formatJsonRpcRequest,
-  formatJsonRpcResult,
-  formatJsonRpcError,
-  isJsonRpcRequest,
-  isJsonRpcResponse,
-  isJsonRpcResult,
-  isJsonRpcError,
-} from "@walletconnect/jsonrpc-utils";
-import { FIVE_MINUTES, toMiliseconds } from "@walletconnect/time";
-import EventEmitter from "events";
-import {
-  PAIRING_CONTEXT,
-  PAIRING_STORAGE_VERSION,
-  CORE_STORAGE_PREFIX,
-  RELAYER_DEFAULT_PROTOCOL,
-  PAIRING_RPC_OPTS,
-  RELAYER_EVENTS,
-  EXPIRER_EVENTS,
-  PAIRING_EVENTS,
-  EVENT_CLIENT_PAIRING_TRACES,
-  EVENT_CLIENT_PAIRING_ERRORS,
-  TRANSPORT_TYPES,
-} from "../constants";
-import { Store } from "../controllers/store";
-
-export class Pairing implements IPairing {
-  public name = PAIRING_CONTEXT;
-  public version = PAIRING_STORAGE_VERSION;
-
-  public events = new EventEmitter();
-  public pairings: IStore<string, PairingTypes.Struct>;
-
-  private initialized = false;
-  private storagePrefix = CORE_STORAGE_PREFIX;
-  private ignoredPayloadTypes = [TYPE_1];
-  private registeredMethods: string[] = [];
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-  ) {
-    this.core = core;
-    this.logger = generateChildLogger(logger, this.name);
-    this.pairings = new Store(this.core, this.logger, this.name, this.storagePrefix);
-  }
-
-  public init: IPairing["init"] = async () => {
-    if (!this.initialized) {
-      await this.pairings.init();
-      await this.cleanup();
-      this.registerRelayerEvents();
-      this.registerExpirerEvents();
-      this.initialized = true;
-      this.logger.trace(`Initialized`);
-    }
-  };
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  public register: IPairing["register"] = ({ methods }) => {
-    this.isInitialized();
-    this.registeredMethods = [...new Set([...this.registeredMethods, ...methods])];
-  };
-
-  public create: IPairing["create"] = async (params) => {
-    this.isInitialized();
-    const symKey = generateRandomBytes32();
-    const topic = await this.core.crypto.setSymKey(symKey);
-    const expiry = calcExpiry(FIVE_MINUTES);
-    const relay = { protocol: RELAYER_DEFAULT_PROTOCOL };
-    const pairing = { topic, expiry, relay, active: false, methods: params?.methods };
-    const uri = formatUri({
-      protocol: this.core.protocol,
-      version: this.core.version,
-      topic,
-      symKey,
-      relay,
-      expiryTimestamp: expiry,
-      methods: params?.methods,
-    });
-    this.events.emit(PAIRING_EVENTS.create, pairing);
-    this.core.expirer.set(topic, expiry);
-    await this.pairings.set(topic, pairing);
-    await this.core.relayer.subscribe(topic, { transportType: params?.transportType });
-
-    return { topic, uri };
-  };
-
-  public pair: IPairing["pair"] = async (params) => {
-    this.isInitialized();
-
-    const event = this.core.eventClient.createEvent({
-      properties: {
-        topic: params?.uri,
-        trace: [EVENT_CLIENT_PAIRING_TRACES.pairing_started],
-      },
-    });
-
-    this.isValidPair(params, event);
-
-    const { topic, symKey, relay, expiryTimestamp, methods } = parseUri(params.uri);
-
-    event.props.properties.topic = topic;
-    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_validation_success);
-    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_uri_not_expired);
-
-    let existingPairing;
-    if (this.pairings.keys.includes(topic)) {
-      existingPairing = this.pairings.get(topic);
-      event.addTrace(EVENT_CLIENT_PAIRING_TRACES.existing_pairing);
-      if (existingPairing.active) {
-        event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);
-        throw new Error(
-          `Pairing already exists: ${topic}. Please try again with a new connection URI.`,
-        );
-      } else {
-        event.addTrace(EVENT_CLIENT_PAIRING_TRACES.pairing_not_expired);
-      }
-    }
-
-    const expiry = expiryTimestamp || calcExpiry(FIVE_MINUTES);
-    const pairing = { topic, relay, expiry, active: false, methods };
-    this.core.expirer.set(topic, expiry);
-    await this.pairings.set(topic, pairing);
-
-    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.store_new_pairing);
-
-    if (params.activatePairing) {
-      await this.activate({ topic });
-    }
-
-    this.events.emit(PAIRING_EVENTS.create, pairing);
-
-    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.emit_inactive_pairing);
-
-    // avoid overwriting keychain pairing already exists
-    if (!this.core.crypto.keychain.has(topic)) {
-      await this.core.crypto.setSymKey(symKey, topic);
-    }
-    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribing_pairing_topic);
-
-    try {
-      await this.core.relayer.confirmOnlineStateOrThrow();
-    } catch (error) {
-      event.setError(EVENT_CLIENT_PAIRING_ERRORS.no_internet_connection);
-    }
-
-    try {
-      await this.core.relayer.subscribe(topic, { relay });
-    } catch (error) {
-      event.setError(EVENT_CLIENT_PAIRING_ERRORS.subscribe_pairing_topic_failure);
-      throw error;
-    }
-
-    event.addTrace(EVENT_CLIENT_PAIRING_TRACES.subscribe_pairing_topic_success);
-
-    return pairing;
-  };
-
-  public activate: IPairing["activate"] = async ({ topic }) => {
-    this.isInitialized();
-    const expiry = calcExpiry(FIVE_MINUTES);
-    this.core.expirer.set(topic, expiry);
-    await this.pairings.update(topic, { active: true, expiry });
-  };
-
-  /**
-   * @deprecated Ping will be removed in the next major release.
-   */
-  public ping: IPairing["ping"] = async (params) => {
-    this.isInitialized();
-    await this.isValidPing(params);
-    this.logger.warn("ping() is deprecated and will be removed in the next major release.");
-    const { topic } = params;
-    if (this.pairings.keys.includes(topic)) {
-      const id = await this.sendRequest(topic, "wc_pairingPing", {});
-      const { done, resolve, reject } = createDelayedPromise<void>();
-      this.events.once(engineEvent("pairing_ping", id), ({ error }) => {
-        if (error) reject(error);
-        else resolve();
-      });
-      await done();
-    }
-  };
-
-  public updateExpiry: IPairing["updateExpiry"] = async ({ topic, expiry }) => {
-    this.isInitialized();
-    await this.pairings.update(topic, { expiry });
-  };
-
-  public updateMetadata: IPairing["updateMetadata"] = async ({ topic, metadata }) => {
-    this.isInitialized();
-    await this.pairings.update(topic, { peerMetadata: metadata });
-  };
-
-  public getPairings: IPairing["getPairings"] = () => {
-    this.isInitialized();
-    return this.pairings.values;
-  };
-
-  public disconnect: IPairing["disconnect"] = async (params) => {
-    this.isInitialized();
-    await this.isValidDisconnect(params);
-    const { topic } = params;
-    if (this.pairings.keys.includes(topic)) {
-      await this.sendRequest(topic, "wc_pairingDelete", getSdkError("USER_DISCONNECTED"));
-      await this.deletePairing(topic);
-    }
-  };
-
-  public formatUriFromPairing: IPairing["formatUriFromPairing"] = (pairing) => {
-    this.isInitialized();
-    const { topic, relay, expiry, methods } = pairing;
-    const symKey = this.core.crypto.keychain.get(topic);
-    return formatUri({
-      protocol: this.core.protocol,
-      version: this.core.version,
-      topic,
-      symKey,
-      relay,
-      expiryTimestamp: expiry,
-      methods,
-    });
-  };
-
-  // ---------- Private Helpers ----------------------------------------------- //
-
-  private sendRequest: IPairingPrivate["sendRequest"] = async (topic, method, params) => {
-    const payload = formatJsonRpcRequest(method, params);
-    const message = await this.core.crypto.encode(topic, payload);
-    const opts = PAIRING_RPC_OPTS[method].req;
-    this.core.history.set(topic, payload);
-    this.core.relayer.publish(topic, message, opts);
-    return payload.id;
-  };
-
-  private sendResult: IPairingPrivate["sendResult"] = async (id, topic, result) => {
-    const payload = formatJsonRpcResult(id, result);
-    const message = await this.core.crypto.encode(topic, payload);
-    const record = await this.core.history.get(topic, id);
-    const method = record.request.method as PairingJsonRpcTypes.WcMethod;
-    const opts = PAIRING_RPC_OPTS[method].res;
-    await this.core.relayer.publish(topic, message, opts);
-    await this.core.history.resolve(payload);
-  };
-
-  private sendError: IPairingPrivate["sendError"] = async (id, topic, error) => {
-    const payload = formatJsonRpcError(id, error);
-    const message = await this.core.crypto.encode(topic, payload);
-    const record = await this.core.history.get(topic, id);
-    const method = record.request.method as PairingJsonRpcTypes.WcMethod;
-
-    const opts = PAIRING_RPC_OPTS[method]
-      ? PAIRING_RPC_OPTS[method].res
-      : PAIRING_RPC_OPTS.unregistered_method.res;
-
-    await this.core.relayer.publish(topic, message, opts);
-    await this.core.history.resolve(payload);
-  };
-
-  private deletePairing: IPairingPrivate["deletePairing"] = async (topic, expirerHasDeleted) => {
-    // Await the unsubscribe first to avoid deleting the symKey too early below.
-    await this.core.relayer.unsubscribe(topic);
-    await Promise.all([
-      this.pairings.delete(topic, getSdkError("USER_DISCONNECTED")),
-      this.core.crypto.deleteSymKey(topic),
-      expirerHasDeleted ? Promise.resolve() : this.core.expirer.del(topic),
-    ]);
-  };
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-
-  private cleanup = async () => {
-    const expiredPairings = this.pairings.getAll().filter((pairing) => isExpired(pairing.expiry));
-    await Promise.all(expiredPairings.map((pairing) => this.deletePairing(pairing.topic)));
-  };
-
-  // ---------- Relay Events Router ----------------------------------- //
-
-  private registerRelayerEvents() {
-    this.core.relayer.on(RELAYER_EVENTS.message, async (event: RelayerTypes.MessageEvent) => {
-      const { topic, message, transportType } = event;
-
-      // Do not handle if the topic is not related to known pairing topics.
-      if (!this.pairings.keys.includes(topic)) return;
-
-      // Do not handle link-mode messages
-      if (transportType === TRANSPORT_TYPES.link_mode) return;
-
-      // messages of certain types should be ignored as they are handled by their respective SDKs
-      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(message))) return;
-
-      try {
-        const payload = await this.core.crypto.decode(topic, message);
-
-        if (isJsonRpcRequest(payload)) {
-          this.core.history.set(topic, payload);
-          await this.onRelayEventRequest({ topic, payload });
-        } else if (isJsonRpcResponse(payload)) {
-          await this.core.history.resolve(payload);
-          await this.onRelayEventResponse({ topic, payload });
-          this.core.history.delete(topic, payload.id);
-        }
-        await this.core.relayer.messages.ack(topic, message);
-      } catch (error) {
-        this.logger.error(error);
-      }
-    });
-  }
-
-  private onRelayEventRequest: IPairingPrivate["onRelayEventRequest"] = async (event) => {
-    const { topic, payload } = event;
-    const reqMethod = payload.method as PairingJsonRpcTypes.WcMethod;
-
-    switch (reqMethod) {
-      case "wc_pairingPing":
-        return await this.onPairingPingRequest(topic, payload);
-      case "wc_pairingDelete":
-        return await this.onPairingDeleteRequest(topic, payload);
-      default:
-        return await this.onUnknownRpcMethodRequest(topic, payload);
-    }
-  };
-
-  private onRelayEventResponse: IPairingPrivate["onRelayEventResponse"] = async (event) => {
-    const { topic, payload } = event;
-    const record = await this.core.history.get(topic, payload.id);
-    const resMethod = record.request.method as PairingJsonRpcTypes.WcMethod;
-
-    switch (resMethod) {
-      case "wc_pairingPing":
-        return this.onPairingPingResponse(topic, payload);
-      default:
-        return this.onUnknownRpcMethodResponse(resMethod);
-    }
-  };
-
-  private onPairingPingRequest: IPairingPrivate["onPairingPingRequest"] = async (
-    topic,
-    payload,
-  ) => {
-    const { id } = payload;
-    try {
-      this.isValidPing({ topic });
-      await this.sendResult<"wc_pairingPing">(id, topic, true);
-      this.events.emit(PAIRING_EVENTS.ping, { id, topic });
-    } catch (err: any) {
-      await this.sendError(id, topic, err);
-      this.logger.error(err);
-    }
-  };
-
-  private onPairingPingResponse: IPairingPrivate["onPairingPingResponse"] = (_topic, payload) => {
-    const { id } = payload;
-    // put at the end of the stack to avoid a race condition
-    // where pairing_ping listener is not yet initialized
-    setTimeout(() => {
-      if (isJsonRpcResult(payload)) {
-        this.events.emit(engineEvent("pairing_ping", id), {});
-      } else if (isJsonRpcError(payload)) {
-        this.events.emit(engineEvent("pairing_ping", id), { error: payload.error });
-      }
-    }, 500);
-  };
-
-  private onPairingDeleteRequest: IPairingPrivate["onPairingDeleteRequest"] = async (
-    topic,
-    payload,
-  ) => {
-    const { id } = payload;
-    try {
-      this.isValidDisconnect({ topic });
-      await this.deletePairing(topic);
-      this.events.emit(PAIRING_EVENTS.delete, { id, topic });
-    } catch (err: any) {
-      await this.sendError(id, topic, err);
-      this.logger.error(err);
-    }
-  };
-
-  private onUnknownRpcMethodRequest: IPairingPrivate["onUnknownRpcMethodRequest"] = async (
-    topic,
-    payload,
-  ) => {
-    const { id, method } = payload;
-
-    try {
-      // Ignore if the implementing client has registered this method as known.
-      if (this.registeredMethods.includes(method)) return;
-      const error = getSdkError("WC_METHOD_UNSUPPORTED", method);
-      await this.sendError(id, topic, error);
-      this.logger.error(error);
-    } catch (err: any) {
-      await this.sendError(id, topic, err);
-      this.logger.error(err);
-    }
-  };
-
-  private onUnknownRpcMethodResponse: IPairingPrivate["onUnknownRpcMethodResponse"] = (method) => {
-    // Ignore if the implementing client has registered this method as known.
-    if (this.registeredMethods.includes(method)) return;
-    this.logger.error(getSdkError("WC_METHOD_UNSUPPORTED", method));
-  };
-
-  // ---------- Expirer Events ---------------------------------------- //
-
-  private registerExpirerEvents() {
-    this.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {
-      const { topic } = parseExpirerTarget(event.target);
-      if (!topic) return;
-      if (!this.pairings.keys.includes(topic)) return;
-      await this.deletePairing(topic, true);
-      this.events.emit(PAIRING_EVENTS.expire, { topic });
-    });
-  }
-
-  // ---------- Validation Helpers ----------------------------------- //
-
-  private isValidPair = (params: { uri: string }, event: EventClientTypes.Event) => {
-    if (!isValidParams(params)) {
-      const { message } = getInternalError("MISSING_OR_INVALID", `pair() params: ${params}`);
-      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
-      throw new Error(message);
-    }
-    if (!isValidUrl(params.uri)) {
-      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri: ${params.uri}`);
-      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
-      throw new Error(message);
-    }
-    const uri = parseUri(params?.uri);
-    if (!uri?.relay?.protocol) {
-      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri#relay-protocol`);
-      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
-      throw new Error(message);
-    }
-    if (!uri?.symKey) {
-      const { message } = getInternalError("MISSING_OR_INVALID", `pair() uri#symKey`);
-      event.setError(EVENT_CLIENT_PAIRING_ERRORS.malformed_pairing_uri);
-      throw new Error(message);
-    }
-    if (uri?.expiryTimestamp) {
-      const expiration = toMiliseconds(uri?.expiryTimestamp);
-      if (expiration < Date.now()) {
-        event.setError(EVENT_CLIENT_PAIRING_ERRORS.pairing_expired);
-        const { message } = getInternalError(
-          "EXPIRED",
-          `pair() URI has expired. Please try again with a new connection URI.`,
-        );
-        throw new Error(message);
-      }
-    }
-  };
-
-  private isValidPing = async (params: { topic: string }) => {
-    if (!isValidParams(params)) {
-      const { message } = getInternalError("MISSING_OR_INVALID", `ping() params: ${params}`);
-      throw new Error(message);
-    }
-    const { topic } = params;
-    await this.isValidPairingTopic(topic);
-  };
-
-  private isValidDisconnect = async (params: { topic: string }) => {
-    if (!isValidParams(params)) {
-      const { message } = getInternalError("MISSING_OR_INVALID", `disconnect() params: ${params}`);
-      throw new Error(message);
-    }
-    const { topic } = params;
-    await this.isValidPairingTopic(topic);
-  };
-
-  private isValidPairingTopic = async (topic: any) => {
-    if (!isValidString(topic, false)) {
-      const { message } = getInternalError(
-        "MISSING_OR_INVALID",
-        `pairing topic should be a string: ${topic}`,
-      );
-      throw new Error(message);
-    }
-    if (!this.pairings.keys.includes(topic)) {
-      const { message } = getInternalError(
-        "NO_MATCHING_KEY",
-        `pairing topic doesn't exist: ${topic}`,
-      );
-      throw new Error(message);
-    }
-    if (isExpired(this.pairings.get(topic).expiry)) {
-      await this.deletePairing(topic);
-      const { message } = getInternalError("EXPIRED", `pairing topic: ${topic}`);
-      throw new Error(message);
-    }
-  };
-}
-</file>
-
-<file path="packages/core/src/controllers/publisher.ts">
-import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
-import { JsonRpcPayload, RequestArguments } from "@walletconnect/jsonrpc-types";
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { RelayJsonRpc } from "@walletconnect/relay-api";
-import { IPublisher, IRelayer, PublisherTypes, RelayerTypes } from "@walletconnect/types";
-import {
-  getRelayProtocolApi,
-  getRelayProtocolName,
-  isUndefined,
-  createExpiringPromise,
-} from "@walletconnect/utils";
-import { EventEmitter } from "events";
-
-import { PUBLISHER_CONTEXT, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from "../constants";
-import { getBigIntRpcId } from "@walletconnect/jsonrpc-utils";
-import { ONE_MINUTE, ONE_SECOND, toMiliseconds } from "@walletconnect/time";
-
-type IPublishType = PublisherTypes.Params & {
-  attestation?: string;
-  attempt: number;
-};
-export class Publisher extends IPublisher {
-  public events = new EventEmitter();
-  public name = PUBLISHER_CONTEXT;
-  public queue = new Map<string, IPublishType>();
-
-  private publishTimeout = toMiliseconds(ONE_MINUTE);
-  private initialPublishTimeout = toMiliseconds(ONE_SECOND * 15);
-  private needsTransportRestart = false;
-
-  constructor(
-    public relayer: IRelayer,
-    public logger: Logger,
-  ) {
-    super(relayer, logger);
-    this.relayer = relayer;
-    this.logger = generateChildLogger(logger, this.name);
-    this.registerEventListeners();
-  }
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  public publish: IPublisher["publish"] = async (topic, message, opts) => {
-    this.logger.debug(`Publishing Payload`);
-    this.logger.trace({ type: "method", method: "publish", params: { topic, message, opts } });
-
-    const ttl = opts?.ttl || PUBLISHER_DEFAULT_TTL;
-    const relay = getRelayProtocolName(opts);
-    const prompt = opts?.prompt || false;
-    const tag = opts?.tag || 0;
-    const id = opts?.id || (getBigIntRpcId().toString() as any);
-    const params = {
-      topic,
-      message,
-      opts: {
-        ttl,
-        relay,
-        prompt,
-        tag,
-        id,
-        attestation: opts?.attestation,
-        tvf: opts?.tvf,
-      },
-    };
-    const failedPublishMessage = `Failed to publish payload, please try again. id:${id} tag:${tag}`;
-
-    try {
-      /**
-       * attempt to publish the payload for <initialPublishTimeout> seconds,
-       * if the publish fails, add the payload to the queue and it will be retried on every pulse
-       * until it is successfully published or <publishTimeout> seconds have passed
-       */
-      const publishPromise = new Promise(async (resolve) => {
-        const onPublish = ({ id }: { id: string }) => {
-          if (params.opts.id === id) {
-            this.removeRequestFromQueue(id);
-            this.relayer.events.removeListener(RELAYER_EVENTS.publish, onPublish);
-            resolve(params);
-          }
-        };
-        this.relayer.events.on(RELAYER_EVENTS.publish, onPublish);
-        const initialPublish = createExpiringPromise(
-          new Promise((resolve, reject) => {
-            this.rpcPublish({
-              topic,
-              message,
-              ttl,
-              prompt,
-              tag,
-              id,
-              attestation: opts?.attestation,
-              tvf: opts?.tvf,
-            })
-              .then(resolve)
-              .catch((e) => {
-                this.logger.warn(e, e?.message);
-                reject(e);
-              });
-          }),
-          this.initialPublishTimeout,
-          `Failed initial publish, retrying.... id:${id} tag:${tag}`,
-        );
-        try {
-          await initialPublish;
-          this.events.removeListener(RELAYER_EVENTS.publish, onPublish);
-        } catch (e) {
-          this.queue.set(id, { ...params, attempt: 1 });
-          this.logger.warn(e, (e as Error)?.message);
-        }
-      });
-      this.logger.trace({
-        type: "method",
-        method: "publish",
-        params: { id, topic, message, opts },
-      });
-
-      await createExpiringPromise(publishPromise, this.publishTimeout, failedPublishMessage);
-    } catch (e) {
-      this.logger.debug(`Failed to Publish Payload`);
-      this.logger.error(e as any);
-      if (opts?.internal?.throwOnFailedPublish) {
-        throw e;
-      }
-    } finally {
-      this.queue.delete(id);
-    }
-  };
-
-  public on: IPublisher["on"] = (event, listener) => {
-    this.events.on(event, listener);
-  };
-
-  public once: IPublisher["once"] = (event, listener) => {
-    this.events.once(event, listener);
-  };
-
-  public off: IPublisher["off"] = (event, listener) => {
-    this.events.off(event, listener);
-  };
-
-  public removeListener: IPublisher["removeListener"] = (event, listener) => {
-    this.events.removeListener(event, listener);
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private async rpcPublish(params: {
-    topic: string;
-    message: string;
-    ttl?: number;
-    prompt?: boolean;
-    tag?: number;
-    id?: number;
-    attestation?: string;
-    tvf?: RelayerTypes.ITVF;
-  }) {
-    const {
-      topic,
-      message,
-      ttl = PUBLISHER_DEFAULT_TTL,
-      prompt,
-      tag,
-      id,
-      attestation,
-      tvf,
-    } = params;
-    const api = getRelayProtocolApi(getRelayProtocolName().protocol);
-    const request: RequestArguments<RelayJsonRpc.PublishParams> = {
-      method: api.publish,
-      params: {
-        topic,
-        message,
-        ttl,
-        prompt,
-        tag,
-        attestation,
-        ...tvf,
-      },
-      id,
-    };
-    if (isUndefined(request.params?.prompt)) delete request.params?.prompt;
-    if (isUndefined(request.params?.tag)) delete request.params?.tag;
-    this.logger.debug(`Outgoing Relay Payload`);
-    this.logger.trace({ type: "message", direction: "outgoing", request });
-    const result = await this.relayer.request(request);
-    this.relayer.events.emit(RELAYER_EVENTS.publish, params);
-    this.logger.debug(`Successfully Published Payload`);
-    return result;
-  }
-
-  private removeRequestFromQueue(id: string) {
-    this.queue.delete(id);
-  }
-
-  private checkQueue() {
-    this.queue.forEach(async (params, id) => {
-      const attempt = params.attempt + 1;
-      this.queue.set(id, { ...params, attempt });
-      const { topic, message, opts, attestation } = params;
-      this.logger.warn(
-        {},
-        `Publisher: queue->publishing: ${params.opts.id}, tag: ${params.opts.tag}, attempt: ${attempt}`,
-      );
-      await this.rpcPublish({
-        ...params,
-        topic,
-        message,
-        ttl: opts.ttl,
-        prompt: opts.prompt,
-        tag: opts.tag,
-        id: opts.id,
-        attestation,
-        tvf: opts.tvf,
-      });
-      this.logger.warn({}, `Publisher: queue->published: ${params.opts.id}`);
-    });
-  }
-
-  private registerEventListeners() {
-    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, () => {
-      // restart the transport if needed
-      // queue will be processed on the next pulse
-      if (this.needsTransportRestart) {
-        this.needsTransportRestart = false;
-        this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
-        return;
-      }
-      this.checkQueue();
-    });
-    this.relayer.on(RELAYER_EVENTS.message_ack, (event: JsonRpcPayload) => {
-      this.removeRequestFromQueue(event.id.toString());
-    });
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/relayer.ts">
-import { EventEmitter } from "events";
-import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";
-import {
-  formatJsonRpcResult,
-  getBigIntRpcId,
-  IJsonRpcProvider,
-  isJsonRpcRequest,
-  isJsonRpcResponse,
-  JsonRpcPayload,
-  JsonRpcRequest,
-  RequestArguments,
-} from "@walletconnect/jsonrpc-utils";
-import WsConnection from "@walletconnect/jsonrpc-ws-connection";
-import {
-  generateChildLogger,
-  getDefaultLoggerOptions,
-  getLoggerContext,
-  pino,
-  Logger,
-} from "@walletconnect/logger";
-import { RelayJsonRpc } from "@walletconnect/relay-api";
-import {
-  FIVE_MINUTES,
-  ONE_SECOND,
-  FIVE_SECONDS,
-  THIRTY_SECONDS,
-  toMiliseconds,
-} from "@walletconnect/time";
-import {
-  ICore,
-  IMessageTracker,
-  IPublisher,
-  IRelayer,
-  ISubscriber,
-  RelayerOptions,
-  RelayerTypes,
-  SubscriberTypes,
-} from "@walletconnect/types";
-import {
-  createExpiringPromise,
-  formatRelayRpcUrl,
-  isOnline,
-  subscribeToNetworkChange,
-  getAppId,
-  isAndroid,
-  isIos,
-  getInternalError,
-  isNode,
-  calcExpiry,
-} from "@walletconnect/utils";
-
-import {
-  RELAYER_SDK_VERSION,
-  RELAYER_CONTEXT,
-  RELAYER_DEFAULT_LOGGER,
-  RELAYER_EVENTS,
-  RELAYER_PROVIDER_EVENTS,
-  RELAYER_SUBSCRIBER_SUFFIX,
-  RELAYER_DEFAULT_RELAY_URL,
-  SUBSCRIBER_EVENTS,
-  RELAYER_RECONNECT_TIMEOUT,
-  TRANSPORT_TYPES,
-  MESSAGE_DIRECTION,
-} from "../constants";
-import { MessageTracker } from "./messages";
-import { Publisher } from "./publisher";
-import { Subscriber } from "./subscriber";
-
-export class Relayer extends IRelayer {
-  public protocol = "wc";
-  public version = 2;
-
-  public core: ICore;
-  public logger: Logger;
-  public events = new EventEmitter();
-  public provider: IJsonRpcProvider;
-  public messages: IMessageTracker;
-  public subscriber: ISubscriber;
-  public publisher: IPublisher;
-  public name = RELAYER_CONTEXT;
-  public transportExplicitlyClosed = false;
-
-  private initialized = false;
-  private connectionAttemptInProgress = false;
-
-  private relayUrl: string;
-  private projectId: string | undefined;
-  private packageName: string | undefined;
-  private bundleId: string | undefined;
-  private hasExperiencedNetworkDisruption = false;
-  private pingTimeout: NodeJS.Timeout | undefined;
-  /**
-   * the relay pings the client 30 seconds after the last message was received
-   * meaning if we don't receive a message in 30 seconds, the connection can be considered dead
-   */
-  private heartBeatTimeout = toMiliseconds(THIRTY_SECONDS + FIVE_SECONDS);
-  private reconnectTimeout: NodeJS.Timeout | undefined;
-  private connectPromise: Promise<void> | undefined;
-  private reconnectInProgress = false;
-  private requestsInFlight: string[] = [];
-  private connectTimeout = toMiliseconds(ONE_SECOND * 15);
-  constructor(opts: RelayerOptions) {
-    super(opts);
-    this.core = opts.core;
-    this.logger =
-      typeof opts.logger !== "undefined" && typeof opts.logger !== "string"
-        ? generateChildLogger(opts.logger, this.name)
-        : pino(getDefaultLoggerOptions({ level: opts.logger || RELAYER_DEFAULT_LOGGER }));
-    this.messages = new MessageTracker(this.logger, opts.core);
-    this.subscriber = new Subscriber(this, this.logger);
-    this.publisher = new Publisher(this, this.logger);
-
-    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;
-    this.projectId = opts.projectId;
-
-    if (isAndroid()) {
-      this.packageName = getAppId();
-    } else if (isIos()) {
-      this.bundleId = getAppId();
-    }
-
-    // re-assigned during init()
-    this.provider = {} as IJsonRpcProvider;
-  }
-
-  public async init() {
-    this.logger.trace(`Initialized`);
-    this.registerEventListeners();
-    await Promise.all([this.messages.init(), this.subscriber.init()]);
-    this.initialized = true;
-    if (this.subscriber.hasAnyTopics) {
-      try {
-        await this.transportOpen();
-      } catch (e) {
-        this.logger.warn(e, (e as Error)?.message);
-      }
-    }
-  }
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  get connected() {
-    // @ts-expect-error
-    return this.provider?.connection?.socket?.readyState === 1 || false;
-  }
-
-  get connecting() {
-    return (
-      // @ts-expect-error
-      this.provider?.connection?.socket?.readyState === 0 ||
-      this.connectPromise !== undefined ||
-      false
-    );
-  }
-
-  public async publish(topic: string, message: string, opts?: RelayerTypes.PublishOptions) {
-    this.isInitialized();
-    await this.publisher.publish(topic, message, opts);
-    await this.recordMessageEvent(
-      {
-        topic,
-        message,
-        // We don't have `publishedAt` from the relay server on outgoing, so use current time to satisfy type.
-        publishedAt: Date.now(),
-        transportType: TRANSPORT_TYPES.relay,
-      },
-      MESSAGE_DIRECTION.outbound,
-    );
-  }
-
-  public async subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions) {
-    this.isInitialized();
-    if (!opts?.transportType || opts?.transportType === "relay") {
-      await this.toEstablishConnection();
-    }
-    // throw unless explicitly set to false
-    const shouldThrowOnFailure =
-      typeof opts?.internal?.throwOnFailedPublish === "undefined"
-        ? true
-        : opts?.internal?.throwOnFailedPublish;
-
-    let id = this.subscriber.topicMap.get(topic)?.[0] || "";
-    let resolvePromise: () => void;
-    const onSubCreated = (subscription: SubscriberTypes.Active) => {
-      if (subscription.topic === topic) {
-        this.subscriber.off(SUBSCRIBER_EVENTS.created, onSubCreated);
-        resolvePromise();
-      }
-    };
-
-    await Promise.all([
-      new Promise<void>((resolve) => {
-        resolvePromise = resolve;
-        this.subscriber.on(SUBSCRIBER_EVENTS.created, onSubCreated);
-      }),
-      new Promise<void>(async (resolve, reject) => {
-        const result = await this.subscriber
-          .subscribe(topic, {
-            internal: {
-              throwOnFailedPublish: shouldThrowOnFailure,
-            },
-            ...opts,
-          })
-          .catch((error) => {
-            if (shouldThrowOnFailure) {
-              reject(error);
-            }
-          });
-        id = result || id;
-        resolve();
-      }),
-    ]);
-    return id;
-  }
-
-  public request = async (request: RequestArguments<RelayJsonRpc.SubscribeParams>) => {
-    this.logger.debug(`Publishing Request Payload`);
-    const id = request.id || (getBigIntRpcId().toString() as any);
-    await this.toEstablishConnection();
-    try {
-      this.logger.trace(
-        {
-          id,
-          method: request.method,
-          topic: request.params?.topic,
-        },
-        "relayer.request - publishing...",
-      );
-      const tag = `${id}:${(request.params as any)?.tag || ""}`;
-      this.requestsInFlight.push(tag);
-      const result = await this.provider.request(request);
-      this.requestsInFlight = this.requestsInFlight.filter((i) => i !== tag);
-      return result;
-    } catch (e) {
-      this.logger.debug(`Failed to Publish Request: ${id}`);
-      throw e;
-    }
-  };
-
-  public async unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {
-    this.isInitialized();
-    await this.subscriber.unsubscribe(topic, opts);
-  }
-
-  public on(event: string, listener: any) {
-    this.events.on(event, listener);
-  }
-
-  public once(event: string, listener: any) {
-    this.events.once(event, listener);
-  }
-
-  public off(event: string, listener: any) {
-    this.events.off(event, listener);
-  }
-
-  public removeListener(event: string, listener: any) {
-    this.events.removeListener(event, listener);
-  }
-
-  public async transportDisconnect() {
-    if (this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected)) {
-      await createExpiringPromise(this.provider.disconnect(), 2000, "provider.disconnect()").catch(
-        () => this.onProviderDisconnect(),
-      );
-    } else {
-      this.onProviderDisconnect();
-    }
-  }
-
-  public async transportClose() {
-    this.transportExplicitlyClosed = true;
-    await this.transportDisconnect();
-  }
-
-  async transportOpen(relayUrl?: string) {
-    if (!this.subscriber.hasAnyTopics) {
-      this.logger.warn(
-        "Starting WS connection skipped because the client has no topics to work with.",
-      );
-      return;
-    }
-
-    if (this.connectPromise) {
-      this.logger.debug({}, `Waiting for existing connection attempt to resolve...`);
-      await this.connectPromise;
-      this.logger.debug({}, `Existing connection attempt resolved`);
-    } else {
-      this.connectPromise = new Promise(async (resolve, reject) => {
-        await this.connect(relayUrl)
-          .then(resolve)
-          .catch(reject)
-          .finally(() => {
-            this.connectPromise = undefined;
-          });
-      });
-      await this.connectPromise;
-    }
-    if (!this.connected) {
-      throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
-    }
-  }
-
-  public async restartTransport(relayUrl?: string) {
-    this.logger.debug({}, "Restarting transport...");
-    if (this.connectionAttemptInProgress) return;
-    this.relayUrl = relayUrl || this.relayUrl;
-    await this.confirmOnlineStateOrThrow();
-    await this.transportClose();
-    await this.transportOpen();
-  }
-
-  public async confirmOnlineStateOrThrow() {
-    if (await isOnline()) return;
-    throw new Error("No internet connection detected. Please restart your network and try again.");
-  }
-
-  public async handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]) {
-    if (messages?.length === 0) {
-      this.logger.trace("Batch message events is empty. Ignoring...");
-      return;
-    }
-    const sortedMessages = messages.sort((a, b) => a.publishedAt - b.publishedAt);
-    this.logger.debug(`Batch of ${sortedMessages.length} message events sorted`);
-    for (const message of sortedMessages) {
-      try {
-        await this.onMessageEvent(message);
-      } catch (e) {
-        this.logger.warn(e, "Error while processing batch message event: " + (e as Error)?.message);
-      }
-    }
-    this.logger.trace(`Batch of ${sortedMessages.length} message events processed`);
-  }
-
-  public async onLinkMessageEvent(
-    messageEvent: RelayerTypes.MessageEvent,
-    opts: { sessionExists: boolean },
-  ) {
-    const { topic } = messageEvent;
-
-    if (!opts.sessionExists) {
-      const expiry = calcExpiry(FIVE_MINUTES);
-      const pairing = { topic, expiry, relay: { protocol: "irn" }, active: false };
-      await this.core.pairing.pairings.set(topic, pairing);
-    }
-
-    this.events.emit(RELAYER_EVENTS.message, messageEvent);
-    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);
-  }
-
-  // ---------- Private ----------------------------------------------- //
-
-  private async connect(relayUrl?: string) {
-    await this.confirmOnlineStateOrThrow();
-    if (relayUrl && relayUrl !== this.relayUrl) {
-      this.relayUrl = relayUrl;
-      await this.transportDisconnect();
-    }
-
-    this.connectionAttemptInProgress = true;
-    this.transportExplicitlyClosed = false;
-    let attempt = 1;
-    while (attempt < 6) {
-      try {
-        if (this.transportExplicitlyClosed) {
-          break;
-        }
-        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${attempt}...`);
-        // Always create new socket instance when trying to connect because if the socket was dropped due to `socket hang up` exception
-        // It wont be able to reconnect
-        await this.createProvider();
-
-        await new Promise<void>(async (resolve, reject) => {
-          const onDisconnect = () => {
-            reject(new Error(`Connection interrupted while trying to subscribe`));
-          };
-          this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
-
-          await createExpiringPromise(
-            new Promise((resolve, reject) => {
-              this.provider.connect().then(resolve).catch(reject);
-            }),
-            this.connectTimeout,
-            `Socket stalled when trying to connect to ${this.relayUrl}`,
-          )
-            .catch((e) => {
-              reject(e);
-            })
-            .finally(() => {
-              this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
-              clearTimeout(this.reconnectTimeout);
-            });
-          await new Promise(async (resolve, reject) => {
-            const onDisconnect = () => {
-              reject(new Error(`Connection interrupted while trying to subscribe`));
-            };
-            this.provider.once(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
-            await this.subscriber
-              .start()
-              .then(resolve)
-              .catch(reject)
-              .finally(() => {
-                this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, onDisconnect);
-              });
-          });
-          this.hasExperiencedNetworkDisruption = false;
-          resolve();
-        });
-      } catch (e) {
-        await this.subscriber.stop();
-        const error = e as Error;
-        this.logger.warn({}, error.message);
-        this.hasExperiencedNetworkDisruption = true;
-      } finally {
-        this.connectionAttemptInProgress = false;
-      }
-
-      if (this.connected) {
-        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${attempt}`);
-        break;
-      }
-
-      await new Promise((resolve) => setTimeout(resolve, toMiliseconds(attempt * 1)));
-      attempt++;
-    }
-  }
-
-  /*
-   * In Node, we must detect when the connection is stalled and terminate it.
-   * The logic is, if we don't receive ping from the relay within a certain time, we terminate the connection.
-   * The timer is refreshed on every message received from the relay.
-   *
-   * In the browser, ping/pong events are not exposed, so the above behaviour is handled by `subscribeToNetworkChange` and `isOnline` functions.
-   */
-  private startPingTimeout() {
-    if (!isNode()) return;
-    try {
-      //@ts-expect-error - Types are divergent between the node and browser WS API
-      if (this.provider?.connection?.socket) {
-        //@ts-expect-error
-        this.provider?.connection?.socket?.on("ping", () => {
-          this.resetPingTimeout();
-        });
-      }
-      this.resetPingTimeout();
-    } catch (e) {
-      this.logger.warn(e, (e as Error)?.message);
-    }
-  }
-
-  private resetPingTimeout = () => {
-    if (!isNode()) return;
-    clearTimeout(this.pingTimeout);
-    this.pingTimeout = setTimeout(() => {
-      try {
-        this.logger.debug({}, "pingTimeout: Connection stalled, terminating...");
-        //@ts-expect-error
-        this.provider?.connection?.socket?.terminate?.();
-      } catch (e) {
-        this.logger.warn(e, (e as Error)?.message);
-      }
-    }, this.heartBeatTimeout);
-  };
-
-  private async createProvider() {
-    if (this.provider.connection) {
-      this.unregisterProviderListeners();
-    }
-    const auth = await this.core.crypto.signJWT(this.relayUrl);
-
-    this.provider = new JsonRpcProvider(
-      new WsConnection(
-        formatRelayRpcUrl({
-          sdkVersion: RELAYER_SDK_VERSION,
-          protocol: this.protocol,
-          version: this.version,
-          relayUrl: this.relayUrl,
-          projectId: this.projectId,
-          auth,
-          useOnCloseEvent: true,
-          bundleId: this.bundleId,
-          packageName: this.packageName,
-        }),
-      ),
-    );
-    this.registerProviderListeners();
-  }
-
-  private async recordMessageEvent(
-    messageEvent: RelayerTypes.MessageEvent,
-    direction?: RelayerTypes.MessageDirection,
-  ) {
-    const { topic, message } = messageEvent;
-    await this.messages.set(topic, message, direction);
-  }
-
-  private async shouldIgnoreMessageEvent(
-    messageEvent: RelayerTypes.MessageEvent,
-  ): Promise<boolean> {
-    const { topic, message } = messageEvent;
-
-    // Ignore if incoming `message` is clearly invalid.
-    if (!message || message.length === 0) {
-      this.logger.warn(`Ignoring invalid/empty message: ${message}`);
-      return true;
-    }
-
-    // Ignore if `topic` is not known to the subscriber.
-    if (!(await this.subscriber.isKnownTopic(topic))) {
-      this.logger.warn(`Ignoring message for unknown topic ${topic}`);
-      return true;
-    }
-
-    // Ignore if `message` is a duplicate.
-    const exists = this.messages.has(topic, message);
-    if (exists) {
-      this.logger.warn(`Ignoring duplicate message: ${message}`);
-    }
-    return exists;
-  }
-
-  private async onProviderPayload(payload: JsonRpcPayload) {
-    this.logger.debug(`Incoming Relay Payload`);
-    this.logger.trace({ type: "payload", direction: "incoming", payload });
-    if (isJsonRpcRequest(payload)) {
-      if (!payload.method.endsWith(RELAYER_SUBSCRIBER_SUFFIX)) return;
-      const event = (payload as JsonRpcRequest<RelayJsonRpc.SubscriptionParams>).params;
-      const { topic, message, publishedAt, attestation } = event.data;
-      const messageEvent: RelayerTypes.MessageEvent = {
-        topic,
-        message,
-        publishedAt,
-        transportType: TRANSPORT_TYPES.relay,
-        attestation,
-      };
-      this.logger.debug(`Emitting Relayer Payload`);
-      this.logger.trace({ type: "event", event: event.id, ...messageEvent });
-      this.events.emit(event.id, messageEvent);
-      await this.acknowledgePayload(payload);
-      await this.onMessageEvent(messageEvent);
-    } else if (isJsonRpcResponse(payload)) {
-      this.events.emit(RELAYER_EVENTS.message_ack, payload);
-    }
-  }
-
-  private async onMessageEvent(messageEvent: RelayerTypes.MessageEvent) {
-    if (await this.shouldIgnoreMessageEvent(messageEvent)) {
-      return;
-    }
-    await this.recordMessageEvent(messageEvent, MESSAGE_DIRECTION.inbound);
-    this.events.emit(RELAYER_EVENTS.message, messageEvent);
-  }
-
-  private async acknowledgePayload(payload: JsonRpcPayload) {
-    const response = formatJsonRpcResult(payload.id, true);
-    await this.provider.connection.send(response);
-  }
-
-  // ---------- Events Handlers ----------------------------------------------- //
-  private onPayloadHandler = (payload: JsonRpcPayload) => {
-    this.onProviderPayload(payload);
-    this.resetPingTimeout();
-  };
-
-  private onConnectHandler = () => {
-    this.logger.warn({}, "Relayer connected ");
-    this.startPingTimeout();
-    this.events.emit(RELAYER_EVENTS.connect);
-  };
-
-  private onDisconnectHandler = () => {
-    this.logger.warn({}, `Relayer disconnected `);
-    this.requestsInFlight = [];
-    this.onProviderDisconnect();
-  };
-
-  private onProviderErrorHandler = (error: Error) => {
-    this.logger.fatal(`Fatal socket error: ${error.message}`);
-    this.events.emit(RELAYER_EVENTS.error, error);
-    // close the transport when a fatal error is received as there's no way to recover from it
-    // usual cases are missing/invalid projectId, expired jwt token, invalid origin etc
-    this.logger.fatal("Fatal socket error received, closing transport");
-    this.transportClose();
-  };
-
-  private registerProviderListeners = () => {
-    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);
-    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);
-    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);
-    this.provider.on(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);
-  };
-
-  private unregisterProviderListeners() {
-    this.provider.off(RELAYER_PROVIDER_EVENTS.payload, this.onPayloadHandler);
-    this.provider.off(RELAYER_PROVIDER_EVENTS.connect, this.onConnectHandler);
-    this.provider.off(RELAYER_PROVIDER_EVENTS.disconnect, this.onDisconnectHandler);
-    this.provider.off(RELAYER_PROVIDER_EVENTS.error, this.onProviderErrorHandler);
-    clearTimeout(this.pingTimeout);
-  }
-
-  private async registerEventListeners() {
-    let lastConnectedState = await isOnline();
-    subscribeToNetworkChange(async (connected: boolean) => {
-      // sometimes the network change event is triggered multiple times so avoid reacting to the samFe value
-      if (lastConnectedState === connected) return;
-
-      lastConnectedState = connected;
-      if (!connected) {
-        // when the device network is restarted, the socket might stay in false `connected` state
-        this.hasExperiencedNetworkDisruption = true;
-        await this.transportDisconnect();
-        this.transportExplicitlyClosed = false;
-      } else {
-        await this.transportOpen().catch((error) =>
-          this.logger.error(error, (error as Error)?.message),
-        );
-      }
-    });
-  }
-
-  private async onProviderDisconnect() {
-    clearTimeout(this.pingTimeout);
-    this.events.emit(RELAYER_EVENTS.disconnect);
-    this.connectionAttemptInProgress = false;
-    if (this.reconnectInProgress) return;
-
-    this.reconnectInProgress = true;
-    await this.subscriber.stop();
-
-    if (!this.subscriber.hasAnyTopics) return;
-    if (this.transportExplicitlyClosed) return;
-
-    this.reconnectTimeout = setTimeout(async () => {
-      await this.transportOpen().catch((error) =>
-        this.logger.error(error, (error as Error)?.message),
-      );
-      this.reconnectTimeout = undefined;
-      this.reconnectInProgress = false;
-    }, toMiliseconds(RELAYER_RECONNECT_TIMEOUT));
-  }
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-
-  private async toEstablishConnection() {
-    await this.confirmOnlineStateOrThrow();
-    if (this.connected) return;
-    await this.connect();
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/store.ts">
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { ICore, IStore } from "@walletconnect/types";
-import {
-  getInternalError,
-  isProposalStruct,
-  isSessionStruct,
-  isUndefined,
-} from "@walletconnect/utils";
-import { CORE_STORAGE_PREFIX, STORE_STORAGE_VERSION } from "../constants";
-import { isEqual } from "es-toolkit/compat";
-
-export class Store<Key, Data extends Record<string, any>> extends IStore<Key, Data> {
-  public map = new Map<Key, Data>();
-  public version = STORE_STORAGE_VERSION;
-
-  private cached: Data[] = [];
-  private initialized = false;
-
-  /**
-   * Regenerates the value key to retrieve it from cache
-   */
-  private getKey: ((data: Data) => Key) | undefined;
-
-  private storagePrefix = CORE_STORAGE_PREFIX;
-
-  // stores recently deleted key to return different rejection message when key is not found
-  private recentlyDeleted: Key[] = [];
-  private recentlyDeletedLimit = 200;
-
-  /**
-   * @param {ICore} core Core
-   * @param {Logger} logger Logger
-   * @param {string} name Store's name
-   * @param {Store<Key, Data>["getKey"]} getKey Regenerates the value key to retrieve it from cache
-   * @param {string} storagePrefix Prefixes value keys
-   */
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    public name: string,
-    storagePrefix: string = CORE_STORAGE_PREFIX,
-    getKey: Store<Key, Data>["getKey"] = undefined,
-  ) {
-    super(core, logger, name, storagePrefix);
-    this.logger = generateChildLogger(logger, this.name);
-    this.storagePrefix = storagePrefix;
-    this.getKey = getKey;
-  }
-
-  public init: IStore<Key, Data>["init"] = async () => {
-    if (!this.initialized) {
-      this.logger.trace(`Initialized`);
-
-      await this.restore();
-
-      this.cached.forEach((value) => {
-        if (this.getKey && value !== null && !isUndefined(value)) {
-          this.map.set(this.getKey(value), value);
-        } else if (isProposalStruct(value)) {
-          // TODO(pedro) revert type casting as any
-          this.map.set(value.id as any, value);
-        } else if (isSessionStruct(value)) {
-          // TODO(pedro) revert type casting as any
-          this.map.set(value.topic as any, value);
-        }
-      });
-
-      this.cached = [];
-      this.initialized = true;
-    }
-  };
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  get storageKey() {
-    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
-  }
-
-  get length() {
-    return this.map.size;
-  }
-
-  get keys() {
-    return Array.from(this.map.keys());
-  }
-
-  get values() {
-    return Array.from(this.map.values());
-  }
-
-  public set: IStore<Key, Data>["set"] = async (key, value) => {
-    this.isInitialized();
-    if (this.map.has(key)) {
-      await this.update(key, value);
-    } else {
-      this.logger.debug(`Setting value`);
-      this.logger.trace({ type: "method", method: "set", key, value });
-      this.map.set(key, value);
-      await this.persist();
-    }
-  };
-
-  public get: IStore<Key, Data>["get"] = (key) => {
-    this.isInitialized();
-    this.logger.debug(`Getting value`);
-    this.logger.trace({ type: "method", method: "get", key });
-    const value = this.getData(key);
-    return value;
-  };
-
-  public getAll: IStore<Key, Data>["getAll"] = (filter) => {
-    this.isInitialized();
-    if (!filter) return this.values;
-
-    return this.values.filter((value) =>
-      Object.keys(filter).every((key) => isEqual(value[key], filter[key])),
-    );
-  };
-
-  public update: IStore<Key, Data>["update"] = async (key, update) => {
-    this.isInitialized();
-    this.logger.debug(`Updating value`);
-    this.logger.trace({ type: "method", method: "update", key, update });
-    const value = { ...this.getData(key), ...update };
-    this.map.set(key, value);
-    await this.persist();
-  };
-
-  public delete: IStore<Key, Data>["delete"] = async (key, reason) => {
-    this.isInitialized();
-    if (!this.map.has(key)) return;
-    this.logger.debug(`Deleting value`);
-    this.logger.trace({ type: "method", method: "delete", key, reason });
-    this.map.delete(key);
-    this.addToRecentlyDeleted(key);
-    await this.persist();
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private addToRecentlyDeleted(key: Key) {
-    this.recentlyDeleted.push(key);
-    // limit the size of the recentlyDeleted array, truncate the 100 oldest entries.
-    if (this.recentlyDeleted.length >= this.recentlyDeletedLimit) {
-      this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
-    }
-  }
-
-  private async setDataStore(value: Data[]) {
-    await this.core.storage.setItem<Data[]>(this.storageKey, value);
-  }
-
-  private async getDataStore() {
-    const value = await this.core.storage.getItem<Data[]>(this.storageKey);
-    return value;
-  }
-
-  private getData(key: Key) {
-    const value = this.map.get(key);
-    if (!value) {
-      if (this.recentlyDeleted.includes(key)) {
-        const { message } = getInternalError(
-          "MISSING_OR_INVALID",
-          `Record was recently deleted - ${this.name}: ${key}`,
-        );
-        this.logger.error(message);
-        throw new Error(message);
-      }
-
-      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${key}`);
-      this.logger.error(message);
-      throw new Error(message);
-    }
-    return value;
-  }
-
-  private async persist() {
-    await this.setDataStore(this.values);
-  }
-
-  private async restore() {
-    try {
-      const persisted = await this.getDataStore();
-      if (typeof persisted === "undefined") return;
-      if (!persisted.length) return;
-      if (this.map.size) {
-        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
-        this.logger.error(message);
-        throw new Error(message);
-      }
-      this.cached = persisted;
-      this.logger.debug(`Successfully Restored value for ${this.name}`);
-      this.logger.trace({ type: "method", method: "restore", value: this.values });
-    } catch (e) {
-      this.logger.debug(`Failed to Restore value for ${this.name}`);
-      this.logger.error(e as any);
-    }
-  }
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/subscriber.ts">
-import { EventEmitter } from "events";
-import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
-import { ErrorResponse, RequestArguments } from "@walletconnect/jsonrpc-types";
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { RelayJsonRpc } from "@walletconnect/relay-api";
-import { ONE_SECOND, ONE_MINUTE, toMiliseconds } from "@walletconnect/time";
-import {
-  IRelayer,
-  ISubscriber,
-  RelayerTypes,
-  SubscriberEvents,
-  SubscriberTypes,
-} from "@walletconnect/types";
-import {
-  getSdkError,
-  getInternalError,
-  getRelayProtocolApi,
-  getRelayProtocolName,
-  createExpiringPromise,
-  hashMessage,
-  sleep,
-} from "@walletconnect/utils";
-import {
-  CORE_STORAGE_PREFIX,
-  SUBSCRIBER_CONTEXT,
-  SUBSCRIBER_EVENTS,
-  SUBSCRIBER_STORAGE_VERSION,
-  RELAYER_EVENTS,
-  TRANSPORT_TYPES,
-} from "../constants";
-import { SubscriberTopicMap } from "./topicmap";
-
-export class Subscriber extends ISubscriber {
-  public subscriptions = new Map<string, SubscriberTypes.Active>();
-  public topicMap = new SubscriberTopicMap();
-  public events = new EventEmitter();
-  public name = SUBSCRIBER_CONTEXT;
-  public version = SUBSCRIBER_STORAGE_VERSION;
-  public pending = new Map<string, SubscriberTypes.Params>();
-
-  private cached: SubscriberTypes.Active[] = [];
-  private initialized = false;
-  private storagePrefix = CORE_STORAGE_PREFIX;
-  private subscribeTimeout = toMiliseconds(ONE_MINUTE);
-  private initialSubscribeTimeout = toMiliseconds(ONE_SECOND * 15);
-  private clientId: string;
-  private batchSubscribeTopicsLimit = 500;
-
-  constructor(
-    public relayer: IRelayer,
-    public logger: Logger,
-  ) {
-    super(relayer, logger);
-    this.relayer = relayer;
-    this.logger = generateChildLogger(logger, this.name);
-    this.clientId = ""; // assigned when calling this.getClientId()
-  }
-
-  public init: ISubscriber["init"] = async () => {
-    if (!this.initialized) {
-      this.logger.trace(`Initialized`);
-      this.registerEventListeners();
-      await this.restore();
-    }
-    this.initialized = true;
-  };
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  get storageKey() {
-    return (
-      this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
-    );
-  }
-
-  get length() {
-    return this.subscriptions.size;
-  }
-
-  get ids() {
-    return Array.from(this.subscriptions.keys());
-  }
-
-  get values() {
-    return Array.from(this.subscriptions.values());
-  }
-
-  get topics() {
-    return this.topicMap.topics;
-  }
-
-  get hasAnyTopics() {
-    return (
-      this.topicMap.topics.length > 0 ||
-      this.pending.size > 0 ||
-      this.cached.length > 0 ||
-      this.subscriptions.size > 0
-    );
-  }
-
-  public subscribe: ISubscriber["subscribe"] = async (topic, opts) => {
-    this.isInitialized();
-    this.logger.debug(`Subscribing Topic`);
-    this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
-    try {
-      const relay = getRelayProtocolName(opts);
-      const params = { topic, relay, transportType: opts?.transportType };
-      this.pending.set(topic, params);
-      const id = await this.rpcSubscribe(topic, relay, opts);
-      if (typeof id === "string") {
-        this.onSubscribe(id, params);
-        this.logger.debug(`Successfully Subscribed Topic`);
-        this.logger.trace({ type: "method", method: "subscribe", params: { topic, opts } });
-      }
-      return id;
-    } catch (e) {
-      this.logger.debug(`Failed to Subscribe Topic`);
-      this.logger.error(e as any);
-      throw e;
-    }
-  };
-
-  public unsubscribe: ISubscriber["unsubscribe"] = async (topic, opts) => {
-    this.isInitialized();
-    if (typeof opts?.id !== "undefined") {
-      await this.unsubscribeById(topic, opts.id, opts);
-    } else {
-      await this.unsubscribeByTopic(topic, opts);
-    }
-  };
-
-  /**
-   * returns `true` only if the topic is actively subscribed to i.e. not pending or cached
-   */
-  public isSubscribed: ISubscriber["isSubscribed"] = (topic: string) => {
-    return new Promise((resolve) => {
-      resolve(this.topicMap.topics.includes(topic));
-    });
-  };
-
-  /**
-   * returns `true` if the topic is known to the subscriber i.e. it is actively subscribed, pending, cached or in the topic map
-   */
-  public isKnownTopic: ISubscriber["isKnownTopic"] = (topic: string) => {
-    return new Promise((resolve) => {
-      resolve(
-        this.topicMap.topics.includes(topic) ||
-          this.pending.has(topic) ||
-          this.cached.some((s) => s.topic === topic),
-      );
-    });
-  };
-
-  public on: ISubscriber["on"] = (event, listener) => {
-    this.events.on(event, listener);
-  };
-
-  public once: ISubscriber["once"] = (event, listener) => {
-    this.events.once(event, listener);
-  };
-
-  public off: ISubscriber["off"] = (event, listener) => {
-    this.events.off(event, listener);
-  };
-
-  public removeListener: ISubscriber["removeListener"] = (event, listener) => {
-    this.events.removeListener(event, listener);
-  };
-
-  public start: ISubscriber["start"] = async () => {
-    await this.onConnect();
-  };
-
-  public stop: ISubscriber["stop"] = async () => {
-    await this.onDisconnect();
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private hasSubscription(id: string, topic: string) {
-    let result = false;
-    try {
-      const subscription = this.getSubscription(id);
-      result = subscription.topic === topic;
-    } catch (e) {
-      // ignore error
-    }
-    return result;
-  }
-
-  private reset() {
-    this.cached = [];
-    this.initialized = true;
-  }
-
-  private onDisable() {
-    this.cached = this.values;
-    this.subscriptions.clear();
-    this.topicMap.clear();
-  }
-
-  private async unsubscribeByTopic(topic: string, opts?: RelayerTypes.UnsubscribeOptions) {
-    const ids = this.topicMap.get(topic);
-    await Promise.all(ids.map(async (id) => await this.unsubscribeById(topic, id, opts)));
-  }
-
-  private async unsubscribeById(topic: string, id: string, opts?: RelayerTypes.UnsubscribeOptions) {
-    this.logger.debug(`Unsubscribing Topic`);
-    this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
-
-    try {
-      const relay = getRelayProtocolName(opts);
-      await this.restartToComplete({ topic, id, relay });
-      await this.rpcUnsubscribe(topic, id, relay);
-      const reason = getSdkError("USER_DISCONNECTED", `${this.name}, ${topic}`);
-      await this.onUnsubscribe(topic, id, reason);
-      this.logger.debug(`Successfully Unsubscribed Topic`);
-      this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
-    } catch (e) {
-      this.logger.debug(`Failed to Unsubscribe Topic`);
-      this.logger.error(e as any);
-      throw e;
-    }
-  }
-
-  private async rpcSubscribe(
-    topic: string,
-    relay: RelayerTypes.ProtocolOptions,
-    opts?: RelayerTypes.SubscribeOptions,
-  ) {
-    if (!opts || opts?.transportType === TRANSPORT_TYPES.relay) {
-      await this.restartToComplete({ topic, id: topic, relay });
-    }
-    const api = getRelayProtocolApi(relay.protocol);
-    const request: RequestArguments<RelayJsonRpc.SubscribeParams> = {
-      method: api.subscribe,
-      params: {
-        topic,
-      },
-    };
-    this.logger.debug(`Outgoing Relay Payload`);
-    this.logger.trace({ type: "payload", direction: "outgoing", request });
-    const shouldThrow = opts?.internal?.throwOnFailedPublish;
-    try {
-      const subId = await this.getSubscriptionId(topic);
-      // in link mode, allow the app to update its network state (i.e. active airplane mode) with small delay before attempting to subscribe
-      if (opts?.transportType === TRANSPORT_TYPES.link_mode) {
-        setTimeout(() => {
-          if (this.relayer.connected || this.relayer.connecting) {
-            this.relayer.request(request).catch((e) => this.logger.warn(e));
-          }
-        }, toMiliseconds(ONE_SECOND));
-        return subId;
-      }
-      const subscribePromise = new Promise(async (resolve) => {
-        const onSubscribe = (subscription: SubscriberEvents.Created) => {
-          if (subscription.topic === topic) {
-            this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);
-            resolve(subscription.id);
-          }
-        };
-        this.events.on(SUBSCRIBER_EVENTS.created, onSubscribe);
-        try {
-          const result = await createExpiringPromise(
-            new Promise((resolve, reject) => {
-              this.relayer
-                .request(request)
-                .catch((e) => {
-                  this.logger.warn(e, e?.message);
-                  reject(e);
-                })
-                .then(resolve);
-            }),
-            this.initialSubscribeTimeout,
-            `Subscribing to ${topic} failed, please try again`,
-          );
-          this.events.removeListener(SUBSCRIBER_EVENTS.created, onSubscribe);
-          resolve(result);
-        } catch (err) {}
-      });
-
-      const subscribe = createExpiringPromise(
-        subscribePromise,
-        this.subscribeTimeout,
-        `Subscribing to ${topic} failed, please try again`,
-      );
-
-      const result = await subscribe;
-      if (!result && shouldThrow) {
-        throw new Error(`Subscribing to ${topic} failed, please try again`);
-      }
-      // return null to indicate that the subscription failed
-      return result ? subId : null;
-    } catch (err) {
-      this.logger.debug(`Outgoing Relay Subscribe Payload stalled`);
-      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
-      if (shouldThrow) {
-        throw err;
-      }
-    }
-    return null;
-  }
-
-  private async rpcBatchSubscribe(subscriptions: SubscriberTypes.Params[]) {
-    if (!subscriptions.length) return;
-    const relay = subscriptions[0].relay;
-    const api = getRelayProtocolApi(relay!.protocol);
-    const request: RequestArguments<RelayJsonRpc.BatchSubscribeParams> = {
-      method: api.batchSubscribe,
-      params: {
-        topics: subscriptions.map((s) => s.topic),
-      },
-    };
-    this.logger.debug(`Outgoing Relay Payload`);
-    this.logger.trace({ type: "payload", direction: "outgoing", request });
-    try {
-      const subscribe = await createExpiringPromise(
-        new Promise((resolve) => {
-          this.relayer
-            .request(request)
-            .catch((e) => this.logger.warn(e))
-            .then(resolve);
-        }),
-        this.subscribeTimeout,
-        "rpcBatchSubscribe failed, please try again",
-      );
-      await subscribe;
-    } catch (err) {
-      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
-    }
-  }
-
-  private async rpcBatchFetchMessages(subscriptions: SubscriberTypes.Params[]) {
-    if (!subscriptions.length) return;
-    const relay = subscriptions[0].relay;
-    const api = getRelayProtocolApi(relay!.protocol);
-    const request: RequestArguments<RelayJsonRpc.BatchFetchMessagesParams> = {
-      method: api.batchFetchMessages,
-      params: {
-        topics: subscriptions.map((s) => s.topic),
-      },
-    };
-    this.logger.debug(`Outgoing Relay Payload`);
-    this.logger.trace({ type: "payload", direction: "outgoing", request });
-    let result;
-    try {
-      const fetchMessagesPromise = await createExpiringPromise(
-        new Promise((resolve, reject) => {
-          this.relayer
-            .request(request)
-            .catch((e) => {
-              this.logger.warn(e);
-              reject(e);
-            })
-            .then(resolve);
-        }),
-        this.subscribeTimeout,
-        "rpcBatchFetchMessages failed, please try again",
-      );
-      result = (await fetchMessagesPromise) as {
-        messages: RelayerTypes.MessageEvent[];
-      };
-    } catch (err) {
-      this.relayer.events.emit(RELAYER_EVENTS.connection_stalled);
-    }
-    return result;
-  }
-
-  private rpcUnsubscribe(topic: string, id: string, relay: RelayerTypes.ProtocolOptions) {
-    const api = getRelayProtocolApi(relay.protocol);
-    const request: RequestArguments<RelayJsonRpc.UnsubscribeParams> = {
-      method: api.unsubscribe,
-      params: {
-        topic,
-        id,
-      },
-    };
-    this.logger.debug(`Outgoing Relay Payload`);
-    this.logger.trace({ type: "payload", direction: "outgoing", request });
-    return this.relayer.request(request);
-  }
-
-  private onSubscribe(id: string, params: SubscriberTypes.Params) {
-    this.setSubscription(id, { ...params, id });
-    this.pending.delete(params.topic);
-  }
-
-  private onBatchSubscribe(subscriptions: SubscriberTypes.Active[]) {
-    if (!subscriptions.length) return;
-    subscriptions.forEach((subscription) => {
-      this.setSubscription(subscription.id, { ...subscription });
-      this.pending.delete(subscription.topic);
-    });
-  }
-
-  private async onUnsubscribe(topic: string, id: string, reason: ErrorResponse) {
-    this.events.removeAllListeners(id);
-    if (this.hasSubscription(id, topic)) {
-      this.deleteSubscription(id, reason);
-    }
-    await this.relayer.messages.del(topic);
-  }
-
-  private async setRelayerSubscriptions(subscriptions: SubscriberTypes.Active[]) {
-    await this.relayer.core.storage.setItem<SubscriberTypes.Active[]>(
-      this.storageKey,
-      subscriptions,
-    );
-  }
-
-  private async getRelayerSubscriptions() {
-    const subscriptions = await this.relayer.core.storage.getItem<SubscriberTypes.Active[]>(
-      this.storageKey,
-    );
-    return subscriptions;
-  }
-
-  private setSubscription(id: string, subscription: SubscriberTypes.Active) {
-    this.logger.debug(`Setting subscription`);
-    this.logger.trace({ type: "method", method: "setSubscription", id, subscription });
-    this.addSubscription(id, subscription);
-  }
-
-  private addSubscription(id: string, subscription: SubscriberTypes.Active) {
-    this.subscriptions.set(id, { ...subscription });
-    this.topicMap.set(subscription.topic, id);
-    this.events.emit(SUBSCRIBER_EVENTS.created, subscription);
-  }
-
-  private getSubscription(id: string) {
-    this.logger.debug(`Getting subscription`);
-    this.logger.trace({ type: "method", method: "getSubscription", id });
-    const subscription = this.subscriptions.get(id);
-    if (!subscription) {
-      const { message } = getInternalError("NO_MATCHING_KEY", `${this.name}: ${id}`);
-      throw new Error(message);
-    }
-    return subscription;
-  }
-
-  private deleteSubscription(id: string, reason: ErrorResponse) {
-    this.logger.debug(`Deleting subscription`);
-    this.logger.trace({ type: "method", method: "deleteSubscription", id, reason });
-    const subscription = this.getSubscription(id);
-    this.subscriptions.delete(id);
-    this.topicMap.delete(subscription.topic, id);
-    this.events.emit(SUBSCRIBER_EVENTS.deleted, {
-      ...subscription,
-      reason,
-    } as SubscriberEvents.Deleted);
-  }
-
-  private restart = async () => {
-    await this.restore();
-    await this.onRestart();
-  };
-
-  private async persist() {
-    await this.setRelayerSubscriptions(this.values);
-    this.events.emit(SUBSCRIBER_EVENTS.sync);
-  }
-
-  private async onRestart() {
-    if (this.cached.length) {
-      const subs = [...this.cached];
-      const numOfBatches = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
-      for (let i = 0; i < numOfBatches; i++) {
-        const batch = subs.splice(0, this.batchSubscribeTopicsLimit);
-        await this.batchSubscribe(batch);
-      }
-    }
-    this.events.emit(SUBSCRIBER_EVENTS.resubscribed);
-  }
-
-  private async restore() {
-    try {
-      const persisted = await this.getRelayerSubscriptions();
-      if (typeof persisted === "undefined") return;
-      if (!persisted.length) return;
-      if (this.subscriptions.size) {
-        const { message } = getInternalError("RESTORE_WILL_OVERRIDE", this.name);
-        this.logger.error(message);
-        this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`);
-        throw new Error(message);
-      }
-      this.cached = persisted;
-      this.logger.debug(`Successfully Restored subscriptions for ${this.name}`);
-      this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
-    } catch (e) {
-      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`);
-      this.logger.error(e as any);
-    }
-  }
-
-  private async batchSubscribe(subscriptions: SubscriberTypes.Params[]) {
-    if (!subscriptions.length) return;
-
-    await this.rpcBatchSubscribe(subscriptions);
-    this.onBatchSubscribe(
-      await Promise.all(
-        subscriptions.map(async (s) => {
-          return { ...s, id: await this.getSubscriptionId(s.topic) };
-        }),
-      ),
-    );
-  }
-
-  // @ts-ignore
-  private async batchFetchMessages(subscriptions: SubscriberTypes.Params[]) {
-    if (!subscriptions.length) return;
-    this.logger.trace(`Fetching batch messages for ${subscriptions.length} subscriptions`);
-    const response = await this.rpcBatchFetchMessages(subscriptions);
-    if (response && response.messages) {
-      await sleep(toMiliseconds(ONE_SECOND));
-      await this.relayer.handleBatchMessageEvents(response.messages);
-    }
-  }
-
-  private async onConnect() {
-    await this.restart();
-    this.reset();
-  }
-
-  private onDisconnect() {
-    this.onDisable();
-  }
-
-  private checkPending = async () => {
-    if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) {
-      return;
-    }
-    const pendingSubscriptions: SubscriberTypes.Params[] = [];
-    this.pending.forEach((params) => {
-      pendingSubscriptions.push(params);
-    });
-
-    await this.batchSubscribe(pendingSubscriptions);
-  };
-
-  private registerEventListeners = () => {
-    this.relayer.core.heartbeat.on(HEARTBEAT_EVENTS.pulse, async () => {
-      await this.checkPending();
-    });
-    this.events.on(SUBSCRIBER_EVENTS.created, async (createdEvent: SubscriberEvents.Created) => {
-      const eventName = SUBSCRIBER_EVENTS.created;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, data: createdEvent });
-      await this.persist();
-    });
-    this.events.on(SUBSCRIBER_EVENTS.deleted, async (deletedEvent: SubscriberEvents.Deleted) => {
-      const eventName = SUBSCRIBER_EVENTS.deleted;
-      this.logger.info(`Emitting ${eventName}`);
-      this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
-      await this.persist();
-    });
-  };
-
-  private isInitialized() {
-    if (!this.initialized) {
-      const { message } = getInternalError("NOT_INITIALIZED", this.name);
-      throw new Error(message);
-    }
-  }
-
-  private async restartToComplete(subscription: SubscriberTypes.Active) {
-    if (!this.relayer.connected && !this.relayer.connecting) {
-      this.cached.push(subscription);
-      await this.relayer.transportOpen();
-    }
-  }
-
-  private async getClientId() {
-    if (!this.clientId) {
-      this.clientId = await this.relayer.core.crypto.getClientId();
-    }
-    return this.clientId;
-  }
-
-  private async getSubscriptionId(topic: string) {
-    return hashMessage(topic + (await this.getClientId()));
-  }
-}
-</file>
-
-<file path="packages/core/src/controllers/topicmap.ts">
-import { ISubscriberTopicMap } from "@walletconnect/types";
-
-export class SubscriberTopicMap implements ISubscriberTopicMap {
-  public map = new Map<string, string[]>();
-
-  get topics(): string[] {
-    return Array.from(this.map.keys());
-  }
-
-  public set: ISubscriberTopicMap["set"] = (topic, id) => {
-    const ids = this.get(topic);
-    if (this.exists(topic, id)) return;
-    this.map.set(topic, [...ids, id]);
-  };
-
-  public get: ISubscriberTopicMap["get"] = (topic) => {
-    const ids = this.map.get(topic);
-    return ids || [];
-  };
-
-  public exists: ISubscriberTopicMap["exists"] = (topic, id) => {
-    const ids = this.get(topic);
-    return ids.includes(id);
-  };
-
-  public delete: ISubscriberTopicMap["delete"] = (topic, id) => {
-    if (typeof id === "undefined") {
-      this.map.delete(topic);
-      return;
-    }
-    if (!this.map.has(topic)) return;
-    const ids = this.get(topic);
-    if (!this.exists(topic, id)) return;
-    const remaining = ids.filter((x) => x !== id);
-    if (!remaining.length) {
-      this.map.delete(topic);
-      return;
-    }
-    this.map.set(topic, remaining);
-  };
-
-  public clear: ISubscriberTopicMap["clear"] = () => {
-    this.map.clear();
-  };
-}
-</file>
-
-<file path="packages/core/src/controllers/verify.ts">
-import { generateChildLogger, getLoggerContext, Logger } from "@walletconnect/logger";
-import { ICore, IVerify } from "@walletconnect/types";
-import { isBrowser, isTestRun, P256KeyDataType, verifyP256Jwt } from "@walletconnect/utils";
-import { FIVE_SECONDS, ONE_SECOND, toMiliseconds } from "@walletconnect/time";
-import { getDocument } from "@walletconnect/window-getters";
-import { decodeJWT } from "@walletconnect/relay-auth";
-
-import {
-  CORE_STORAGE_PREFIX,
-  CORE_VERSION,
-  TRUSTED_VERIFY_URLS,
-  VERIFY_CONTEXT,
-  VERIFY_SERVER,
-  VERIFY_SERVER_V3,
-} from "../constants";
-import { IKeyValueStorage } from "@walletconnect/keyvaluestorage";
-
-type Jwk = {
-  publicKey: P256KeyDataType;
-  expiresAt: number;
-};
-type JwkPayload = {
-  exp: number;
-  id: string;
-  origin: string;
-  isScam: boolean;
-  isVerified: boolean;
-};
-export class Verify extends IVerify {
-  public name = VERIFY_CONTEXT;
-  private abortController: AbortController;
-  private isDevEnv;
-  private verifyUrlV3 = VERIFY_SERVER_V3;
-  private storagePrefix = CORE_STORAGE_PREFIX;
-  private version = CORE_VERSION;
-  private publicKey?: Jwk;
-  private fetchPromise?: Promise<Jwk>;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    public store: IKeyValueStorage,
-  ) {
-    super(core, logger, store);
-    this.logger = generateChildLogger(logger, this.name);
-    this.abortController = new AbortController();
-    this.isDevEnv = isTestRun();
-    this.init();
-  }
-
-  get storeKey(): string {
-    return (
-      this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + `verify:public:key`
-    );
-  }
-
-  public init = async () => {
-    if (this.isDevEnv) return;
-    this.publicKey = await this.store.getItem(this.storeKey);
-    if (this.publicKey && toMiliseconds(this.publicKey?.expiresAt) < Date.now()) {
-      this.logger.debug("verify v2 public key expired");
-      await this.removePublicKey();
-    }
-  };
-
-  public register: IVerify["register"] = async (params) => {
-    if (!isBrowser() || this.isDevEnv) return;
-    const origin = window.location.origin;
-    const { id, decryptedId } = params;
-    const src = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${origin}&id=${id}&decryptedId=${decryptedId}`;
-    try {
-      const document = getDocument() as Document;
-      const abortTimeout = this.startAbortTimer(ONE_SECOND * 5);
-      const attestationJwt = await new Promise((resolve, reject) => {
-        const abortListener = () => {
-          window.removeEventListener("message", listener);
-          document.body.removeChild(iframe);
-          reject("attestation aborted");
-        };
-        this.abortController.signal.addEventListener("abort", abortListener);
-        const iframe = document.createElement("iframe");
-        iframe.src = src;
-        iframe.style.display = "none";
-        iframe.addEventListener("error", abortListener, { signal: this.abortController.signal });
-        const listener = (event: MessageEvent) => {
-          if (!event.data) return;
-          if (typeof event.data !== "string") return;
-          try {
-            const data = JSON.parse(event.data);
-            if (data.type === "verify_attestation") {
-              const decoded = decodeJWT(data.attestation) as unknown as { payload: JwkPayload };
-              if (decoded.payload.id !== id) return;
-
-              clearInterval(abortTimeout);
-              document.body.removeChild(iframe);
-              this.abortController.signal.removeEventListener("abort", abortListener);
-              window.removeEventListener("message", listener);
-              resolve(data.attestation === null ? "" : data.attestation);
-            }
-          } catch (e) {
-            this.logger.warn(e);
-          }
-        };
-        document.body.appendChild(iframe);
-        window.addEventListener("message", listener, { signal: this.abortController.signal });
-      });
-      this.logger.debug("jwt attestation", attestationJwt);
-      return attestationJwt as string;
-    } catch (e) {
-      this.logger.warn(e);
-    }
-    return "";
-  };
-
-  public resolve: IVerify["resolve"] = async (params) => {
-    if (this.isDevEnv) return "";
-    const { attestationId, hash, encryptedId } = params;
-    if (attestationId === "") {
-      this.logger.debug("resolve: attestationId is empty, skipping");
-      return;
-    }
-
-    if (attestationId) {
-      const decoded = decodeJWT(attestationId) as unknown as { payload: JwkPayload };
-      if (decoded.payload.id !== encryptedId) return;
-      const validation = await this.isValidJwtAttestation(attestationId);
-      if (validation) {
-        if (!validation.isVerified) {
-          this.logger.warn("resolve: jwt attestation: origin url not verified");
-          return;
-        }
-        return validation;
-      }
-    }
-    if (!hash) return;
-    const verifyUrl = this.getVerifyUrl(params?.verifyUrl);
-    return this.fetchAttestation(hash, verifyUrl);
-  };
-
-  get context(): string {
-    return getLoggerContext(this.logger);
-  }
-
-  private fetchAttestation = async (attestationId: string, url: string) => {
-    this.logger.debug(`resolving attestation: ${attestationId} from url: ${url}`);
-    // set artificial timeout to prevent hanging
-    const timeout = this.startAbortTimer(ONE_SECOND * 5);
-    const result = await fetch(`${url}/attestation/${attestationId}?v2Supported=true`, {
-      signal: this.abortController.signal,
-    });
-    clearTimeout(timeout);
-    return result.status === 200 ? await result.json() : undefined;
-  };
-
-  private startAbortTimer(timer: number) {
-    this.abortController = new AbortController();
-    return setTimeout(() => this.abortController.abort(), toMiliseconds(timer));
-  }
-
-  private getVerifyUrl = (verifyUrl?: string) => {
-    let url = verifyUrl || VERIFY_SERVER;
-    if (!TRUSTED_VERIFY_URLS.includes(url)) {
-      this.logger.info(
-        `verify url: ${url}, not included in trusted list, assigning default: ${VERIFY_SERVER}`,
-      );
-      url = VERIFY_SERVER;
-    }
-    return url;
-  };
-
-  private fetchPublicKey = async () => {
-    try {
-      this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
-      const timeout = this.startAbortTimer(FIVE_SECONDS);
-      const result = await fetch(`${this.verifyUrlV3}/public-key`, {
-        signal: this.abortController.signal,
-      });
-      clearTimeout(timeout);
-      return (await result.json()) as Jwk;
-    } catch (e) {
-      this.logger.warn(e);
-    }
-    return undefined;
-  };
-
-  private persistPublicKey = async (publicKey: Jwk) => {
-    this.logger.debug(`persisting public key to local storage`, publicKey);
-    await this.store.setItem(this.storeKey, publicKey);
-    this.publicKey = publicKey;
-  };
-
-  private removePublicKey = async () => {
-    this.logger.debug(`removing verify v2 public key from storage`);
-    await this.store.removeItem(this.storeKey);
-    this.publicKey = undefined;
-  };
-
-  private isValidJwtAttestation = async (attestation: string) => {
-    const key = await this.getPublicKey();
-    try {
-      if (key) {
-        const validation = this.validateAttestation(attestation, key);
-        return validation;
-      }
-    } catch (e) {
-      this.logger.error(e);
-      this.logger.warn("error validating attestation");
-    }
-    const newKey = await this.fetchAndPersistPublicKey();
-    try {
-      if (newKey) {
-        const validation = this.validateAttestation(attestation, newKey);
-        return validation;
-      }
-    } catch (e) {
-      this.logger.error(e);
-      this.logger.warn("error validating attestation");
-    }
-    return undefined;
-  };
-
-  private getPublicKey = async () => {
-    if (this.publicKey) return this.publicKey;
-    return await this.fetchAndPersistPublicKey();
-  };
-
-  private fetchAndPersistPublicKey = async () => {
-    if (this.fetchPromise) {
-      await this.fetchPromise;
-      return this.publicKey;
-    }
-    this.fetchPromise = new Promise(async (resolve) => {
-      const key = await this.fetchPublicKey();
-      if (!key) return;
-      await this.persistPublicKey(key);
-      resolve(key);
-    });
-    const key = await this.fetchPromise;
-    this.fetchPromise = undefined;
-    return key;
-  };
-
-  private validateAttestation = (attestation: string, key: Jwk) => {
-    const result = verifyP256Jwt<JwkPayload>(attestation, key.publicKey);
-    const validation = {
-      hasExpired: toMiliseconds(result.exp) < Date.now(),
-      payload: result,
-    };
-
-    if (validation.hasExpired) {
-      this.logger.warn("resolve: jwt attestation expired");
-      throw new Error("JWT attestation expired");
-    }
-
-    return {
-      origin: validation.payload.origin,
-      isScam: validation.payload.isScam,
-      isVerified: validation.payload.isVerified,
-    };
-  };
-}
-</file>
-
-<file path="packages/core/src/core.ts">
-import { EventEmitter } from "events";
-
-import { HeartBeat } from "@walletconnect/heartbeat";
-import KeyValueStorage from "@walletconnect/keyvaluestorage";
-import {
-  ChunkLoggerController,
-  generateChildLogger,
-  generatePlatformLogger,
-  getDefaultLoggerOptions,
-  getLoggerContext,
-} from "@walletconnect/logger";
-import { CoreTypes, ICore } from "@walletconnect/types";
-
-import {
-  CORE_CONTEXT,
-  CORE_DEFAULT,
-  CORE_PROTOCOL,
-  CORE_STORAGE_OPTIONS,
-  CORE_VERSION,
-  RELAYER_DEFAULT_RELAY_URL,
-  TRANSPORT_TYPES,
-  WALLETCONNECT_CLIENT_ID,
-  WALLETCONNECT_LINK_MODE_APPS,
-} from "./constants";
-import {
-  Crypto,
-  EchoClient,
-  EventClient,
-  Expirer,
-  JsonRpcHistory,
-  Pairing,
-  Relayer,
-  Verify,
-} from "./controllers";
-
-export class Core extends ICore {
-  public readonly protocol = CORE_PROTOCOL;
-  public readonly version = CORE_VERSION;
-
-  public readonly name: ICore["name"] = CORE_CONTEXT;
-  public readonly relayUrl: ICore["relayUrl"];
-  public readonly projectId: ICore["projectId"];
-  public readonly customStoragePrefix: ICore["customStoragePrefix"];
-  public events: ICore["events"] = new EventEmitter();
-  public logger: ICore["logger"];
-  public heartbeat: ICore["heartbeat"];
-  public relayer: ICore["relayer"];
-  public crypto: ICore["crypto"];
-  public storage: ICore["storage"];
-  public history: ICore["history"];
-  public expirer: ICore["expirer"];
-  public pairing: ICore["pairing"];
-  public verify: ICore["verify"];
-  public echoClient: ICore["echoClient"];
-  public linkModeSupportedApps: ICore["linkModeSupportedApps"];
-  public eventClient: ICore["eventClient"];
-
-  private initialized = false;
-  private logChunkController: ChunkLoggerController | null;
-
-  static async init(opts?: CoreTypes.Options) {
-    const core = new Core(opts);
-    await core.initialize();
-    const clientId = await core.crypto.getClientId();
-    await core.storage.setItem(WALLETCONNECT_CLIENT_ID, clientId);
-
-    return core;
-  }
-
-  constructor(opts?: CoreTypes.Options) {
-    super(opts);
-
-    const globalCore = this.getGlobalCore(opts?.customStoragePrefix);
-    if (globalCore) {
-      try {
-        this.customStoragePrefix = globalCore.customStoragePrefix;
-        this.logger = globalCore.logger;
-        this.heartbeat = globalCore.heartbeat;
-        this.crypto = globalCore.crypto;
-        this.history = globalCore.history;
-        this.expirer = globalCore.expirer;
-        this.storage = globalCore.storage;
-        this.relayer = globalCore.relayer;
-        this.pairing = globalCore.pairing;
-        this.verify = globalCore.verify;
-        this.echoClient = globalCore.echoClient;
-        this.linkModeSupportedApps = globalCore.linkModeSupportedApps;
-        this.eventClient = globalCore.eventClient;
-        this.initialized = globalCore.initialized;
-        this.logChunkController = globalCore.logChunkController;
-        return globalCore;
-      } catch (error) {
-        console.warn("Failed to copy global core", error);
-      }
-    }
-
-    this.projectId = opts?.projectId;
-    this.relayUrl = opts?.relayUrl || RELAYER_DEFAULT_RELAY_URL;
-    this.customStoragePrefix = opts?.customStoragePrefix ? `:${opts.customStoragePrefix}` : "";
-
-    const loggerOptions = getDefaultLoggerOptions({
-      level: typeof opts?.logger === "string" && opts.logger ? opts.logger : CORE_DEFAULT.logger,
-      name: CORE_CONTEXT,
-    });
-
-    const { logger, chunkLoggerController } = generatePlatformLogger({
-      opts: loggerOptions,
-      maxSizeInBytes: opts?.maxLogBlobSizeInBytes,
-      loggerOverride: opts?.logger,
-    });
-
-    this.logChunkController = chunkLoggerController;
-
-    if (this.logChunkController?.downloadLogsBlobInBrowser) {
-      // @ts-ignore
-      window.downloadLogsBlobInBrowser = async () => {
-        // Have to null check twice becquse there is no guarantee
-        // this.logChunkController.downloadLogsBlobInBrowser is always truthy
-        if (this.logChunkController?.downloadLogsBlobInBrowser) {
-          this.logChunkController?.downloadLogsBlobInBrowser({
-            clientId: await this.crypto.getClientId(),
-          });
-        }
-      };
-    }
-
-    this.logger = generateChildLogger(logger, this.name);
-    this.heartbeat = new HeartBeat();
-    this.crypto = new Crypto(this, this.logger, opts?.keychain);
-    this.history = new JsonRpcHistory(this, this.logger);
-    this.expirer = new Expirer(this, this.logger);
-    this.storage = opts?.storage
-      ? opts.storage
-      : new KeyValueStorage({ ...CORE_STORAGE_OPTIONS, ...opts?.storageOptions });
-    this.relayer = new Relayer({
-      core: this,
-      logger: this.logger,
-      relayUrl: this.relayUrl,
-      projectId: this.projectId,
-    });
-    this.pairing = new Pairing(this, this.logger);
-    this.verify = new Verify(this, this.logger, this.storage);
-    this.echoClient = new EchoClient(this.projectId || "", this.logger);
-    this.linkModeSupportedApps = [];
-    this.eventClient = new EventClient(this, this.logger, opts?.telemetryEnabled);
-    this.setGlobalCore(this);
-  }
-
-  get context() {
-    return getLoggerContext(this.logger);
-  }
-
-  // ---------- Public ----------------------------------------------- //
-
-  public async start() {
-    if (this.initialized) return;
-    await this.initialize();
-  }
-
-  public async getLogsBlob() {
-    return this.logChunkController?.logsToBlob({
-      clientId: await this.crypto.getClientId(),
-    });
-  }
-
-  public async addLinkModeSupportedApp(universalLink: string) {
-    if (this.linkModeSupportedApps.includes(universalLink)) return;
-    this.linkModeSupportedApps.push(universalLink);
-    await this.storage.setItem(WALLETCONNECT_LINK_MODE_APPS, this.linkModeSupportedApps);
-  }
-
-  // ---------- Events ----------------------------------------------- //
-
-  public on = (name: any, listener: any) => {
-    return this.events.on(name, listener);
-  };
-
-  public once = (name: any, listener: any) => {
-    return this.events.once(name, listener);
-  };
-
-  public off = (name: any, listener: any) => {
-    return this.events.off(name, listener);
-  };
-
-  public removeListener = (name: any, listener: any) => {
-    return this.events.removeListener(name, listener);
-  };
-
-  // ---------- Link-mode ----------------------------------------------- //
-
-  public dispatchEnvelope = ({
-    topic,
-    message,
-    sessionExists,
-  }: {
-    topic: string;
-    message: string;
-    sessionExists: boolean;
-  }) => {
-    if (!topic || !message) return;
-
-    const payload = {
-      topic,
-      message,
-      publishedAt: Date.now(),
-      transportType: TRANSPORT_TYPES.link_mode,
-    };
-
-    this.relayer.onLinkMessageEvent(payload, { sessionExists });
-  };
-
-  // ---------- Private ----------------------------------------------- //
-
-  private async initialize() {
-    this.logger.trace(`Initialized`);
-    try {
-      await this.crypto.init();
-      await this.history.init();
-      await this.expirer.init();
-      await this.relayer.init();
-      await this.heartbeat.init();
-      await this.pairing.init();
-      this.linkModeSupportedApps = (await this.storage.getItem(WALLETCONNECT_LINK_MODE_APPS)) || [];
-
-      this.initialized = true;
-      this.logger.info(`Core Initialization Success`);
-    } catch (error) {
-      this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, error);
-      this.logger.error((error as any).message);
-      throw error;
-    }
-  }
-
-  private getGlobalCore(customStoragePrefix = ""): Core | undefined {
-    try {
-      if (this.isGlobalCoreDisabled()) {
-        return undefined;
-      }
-      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;
-
-      const counterKey = `${globalCorePrefix}_count`;
-      globalThis[counterKey] = (globalThis[counterKey] || 0) + 1;
-      if (globalThis[counterKey] > 1) {
-        console.warn(
-          `WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[counterKey]} times.`,
-        );
-      }
-
-      return globalThis[globalCorePrefix];
-    } catch (error) {
-      console.warn("Failed to get global WalletConnect core", error);
-      return undefined;
-    }
-  }
-
-  private setGlobalCore(core: Core) {
-    try {
-      if (this.isGlobalCoreDisabled()) {
-        return;
-      }
-      const customStoragePrefix = core.opts?.customStoragePrefix || "";
-      const globalCorePrefix = `_walletConnectCore_${customStoragePrefix}`;
-      globalThis[globalCorePrefix] = core;
-    } catch (error) {
-      console.warn("Failed to set global WalletConnect core", error);
-    }
-  }
-
-  private isGlobalCoreDisabled() {
-    try {
-      return typeof process !== "undefined" && process.env.DISABLE_GLOBAL_CORE === "true";
-    } catch (error) {
-      return true;
-    }
-  }
-}
-</file>
-
-<file path="packages/core/src/index.ts">
-import { Core as WalletConnectCore } from "./core";
-
-export * from "./constants";
-export * from "./controllers";
-
-export const Core = WalletConnectCore;
-export default WalletConnectCore;
-</file>
-
-<file path="packages/core/test/shared/helpers.ts">
-import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
-import { CoreTypes, ICore } from "@walletconnect/types";
-import { DEFAULT_DB_NAME, MOCK_STORE_NAME, TEST_CORE_OPTIONS, storeTestValues } from "./values";
-import { Core, Store } from "../../src";
-
-export type MockStoreValue = { id: string; value: string };
-
-export async function throttle(timeout: number) {
-  return await new Promise<void>((resolve) =>
-    setTimeout(() => {
-      resolve();
-    }, timeout),
-  );
-}
-
-/**
- * Initializes a core instance with default options
- * Default uses custom db to isolate persistence tests
- * @param customOpts = custom core init opts
- * @returns Initialized core instance
- */
-export const initCore = async (
-  customOpts: CoreTypes.Options = { storageOptions: { database: DEFAULT_DB_NAME } },
-) => {
-  const coreOptions = {
-    ...TEST_CORE_OPTIONS,
-    ...customOpts,
-  };
-  const core = new Core(coreOptions);
-  await core.start();
-  return core;
-};
-
-/**
- * Initializes a store instance with default options
- * @param core = core to use for store
- * @returns Initialized store instance
- */
-export const initStore = async (core: ICore) => {
-  const logger = pino(getDefaultLoggerOptions({ level: "fatal" }));
-
-  const store = new Store<string, MockStoreValue>(
-    core,
-    logger,
-    MOCK_STORE_NAME,
-    undefined,
-    (val) => val.value,
-  );
-  await store.init();
-  storeTestValues.forEach((val) => store.set(val.id, val));
-  return store;
-};
-
-/**
- * Prevents gross code duplication in tests that require restarting core
- * @param beforeRestart function to run before each restart
- * @param afterRestart function to run after each restart
- * @param n_restarts number of times to restart core
- * @param customOpts custom core options
- */
-export const restartCore = async (
-  beforeRestart?: () => Promise<void>,
-  afterRestart?: () => Promise<void>,
-  n_restarts = 1,
-  customOpts = { storageOptions: { database: DEFAULT_DB_NAME } },
-) => {
-  for (let i = 0; i < n_restarts; i++) {
-    if (beforeRestart) await beforeRestart();
-    await initCore(customOpts);
-    if (afterRestart) await afterRestart();
-  }
-};
-
-/**
- * Search for a topic in a list of records
- * @param records
- * @param topic
- * @returns true if topic is found, false otherwise
- */
-export const searchRecords = (records: any, topic: string) => {
-  for (const [_, record] of records.entries()) {
-    if (record.topic === topic) return true;
-  }
-  return false;
-};
-
-export const waitForEvent = async (checkForEvent: (...args: any[]) => boolean) => {
-  await new Promise((resolve) => {
-    const intervalId = setInterval(() => {
-      if (checkForEvent()) {
-        clearInterval(intervalId);
-        resolve({});
-      }
-    }, 100);
-  });
-};
-</file>
-
-<file path="packages/core/test/shared/index.ts">
-export * from "./values";
-export * from "./ws";
-export * from "./helpers";
-</file>
-
-<file path="packages/core/test/shared/values.ts">
-import { CoreTypes } from "@walletconnect/types";
-
-export const TEST_RELAY_URL = process.env.TEST_RELAY_URL
-  ? process.env.TEST_RELAY_URL
-  : "ws://0.0.0.0:5555";
-
-export const TEST_PROJECT_ID = process.env.TEST_PROJECT_ID
-  ? process.env.TEST_PROJECT_ID
-  : undefined;
-
-export const TEST_PROJECT_ID_MOBILE = process.env.TEST_PROJECT_ID_MOBILE
-  ? process.env.TEST_PROJECT_ID_MOBILE
-  : undefined;
-
-export const TEST_CORE_OPTIONS: CoreTypes.Options = {
-  logger: "fatal",
-  relayUrl: TEST_RELAY_URL,
-  projectId: TEST_PROJECT_ID,
-  storageOptions: {
-    database: ":memory:",
-  },
-};
-
-export const TEST_MOBILE_APP_ID = process.env.TEST_MOBILE_APP_ID
-  ? process.env.TEST_MOBILE_APP_ID
-  : undefined;
-
-// default db name for persistent storage tests
-export const DEFAULT_DB_NAME = "./test/tmp/persistent-test.db";
-
-// default store name for persistent storage tests
-export const MOCK_STORE_NAME = "persistent-store";
-
-// default test values for persistent storage tests
-export const storeTestValues = [
-  { id: "1", value: "foo" },
-  { id: "2", value: "bar" },
-  { id: "3", value: "baz" },
-];
-</file>
-
-<file path="packages/core/test/shared/ws.ts">
-import { IRelayer } from "@walletconnect/types";
-
-export async function disconnectSocket(relayer: IRelayer) {
-  if (relayer && relayer.connected) {
-    await relayer.transportClose();
-  }
-}
-</file>
-
-<file path="packages/core/test/core.spec.ts">
-import { expect, describe, it } from "vitest";
-import sinon from "sinon";
-import Core from "../src";
-import { TEST_CORE_OPTIONS } from "./shared";
-
-describe("Core", () => {
-  it("does not duplicate initialization if `Core.start()` is called repeatedly", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    const cryptoInitSpy = sinon.spy();
-    const relayerInitSpy = sinon.spy();
-    const heartbeatInitSpy = sinon.spy();
-    // Spy on subcontroller `init` as a proxy to the private `Core.initialize`.
-    core.crypto.init = cryptoInitSpy;
-    core.relayer.init = relayerInitSpy;
-    core.heartbeat.init = heartbeatInitSpy;
-    await core.start();
-    await core.start();
-    expect(cryptoInitSpy.callCount).to.equal(1);
-    expect(relayerInitSpy.callCount).to.equal(1);
-    expect(heartbeatInitSpy.callCount).to.equal(1);
-  });
-  it("saves core instance in global scope", async () => {
-    process.env.DISABLE_GLOBAL_CORE = "false";
-    const core = await Core.init(TEST_CORE_OPTIONS);
-    expect(globalThis._walletConnectCore_).to.deep.equal(core);
-    globalThis._walletConnectCore_ = undefined;
-    process.env.DISABLE_GLOBAL_CORE = "true";
-  });
-  it("saves core instance in global scope with custom storage prefix", async () => {
-    process.env.DISABLE_GLOBAL_CORE = "false";
-    const core = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-    expect(globalThis._walletConnectCore_test).to.deep.equal(core);
-    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
-    globalThis._walletConnectCore_test = undefined;
-    process.env.DISABLE_GLOBAL_CORE = "true";
-  });
-  it("does not save core instance in global scope if disabled", async () => {
-    process.env.DISABLE_GLOBAL_CORE = "true";
-    await Core.init(TEST_CORE_OPTIONS);
-    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
-  });
-  it("does not save core instance in global scope if disabled with custom storage prefix", async () => {
-    process.env.DISABLE_GLOBAL_CORE = "true";
-    await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-    expect(globalThis._walletConnectCore_test).to.deep.equal(undefined);
-    expect(globalThis._walletConnectCore_).to.deep.equal(undefined);
-  });
-  it("saves multiple core instances in global scope", async () => {
-    process.env.DISABLE_GLOBAL_CORE = "false";
-    const core1 = await Core.init(TEST_CORE_OPTIONS);
-    const core2 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-    expect(globalThis._walletConnectCore_).to.deep.equal(core1);
-    expect(globalThis._walletConnectCore_test).to.deep.equal(core2);
-    globalThis._walletConnectCore_ = undefined;
-    globalThis._walletConnectCore_test = undefined;
-    process.env.DISABLE_GLOBAL_CORE = "true";
-  });
-  it("saves multiple core instances in global scope with custom storage prefix", async () => {
-    process.env.DISABLE_GLOBAL_CORE = "false";
-    const core1 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test1" });
-    const core2 = await Core.init({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test2" });
-    expect(globalThis._walletConnectCore_test1).to.deep.equal(core1);
-    expect(globalThis._walletConnectCore_test2).to.deep.equal(core2);
-    globalThis._walletConnectCore_test1 = undefined;
-    globalThis._walletConnectCore_test2 = undefined;
-    process.env.DISABLE_GLOBAL_CORE = "true";
-  });
-});
-</file>
-
-<file path="packages/core/test/crypto.spec.ts">
-import { expect, describe, it, beforeEach } from "vitest";
-import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
-import * as utils from "@walletconnect/utils";
-import Sinon from "sinon";
-import { Core, CORE_DEFAULT, Crypto } from "../src";
-import { TEST_CORE_OPTIONS } from "./shared";
-
-describe("Crypto", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
-  const core = new Core(TEST_CORE_OPTIONS);
-
-  let crypto: Crypto;
-
-  beforeEach(async () => {
-    crypto = new Crypto(core, logger);
-    await crypto.init();
-  });
-
-  it("initializes the keychain subcontroller a single time", async () => {
-    const spy = Sinon.spy();
-    const _crypto = new Crypto(core, logger);
-    _crypto.keychain.init = spy;
-    await _crypto.init();
-    await _crypto.init();
-    expect(spy.callCount).to.equal(1);
-  });
-
-  describe("generateKeyPair", () => {
-    it("throws if not initialized", () => {
-      const invalidCrypto = new Crypto(core, logger);
-      expect(() => invalidCrypto.generateKeyPair()).to.throw("Not initialized. crypto");
-    });
-    it("generates a keyPair, sets it in the keychain and returns publicKey", async () => {
-      const privateKey = utils.generateRandomBytes32();
-      const publicKey = utils.generateRandomBytes32();
-      // Stub `utils.generateKeyPair` to return predictable values.
-      Sinon.stub(utils, "generateKeyPair").returns({ publicKey, privateKey });
-      const keychainSpy = Sinon.spy();
-      crypto.keychain.set = keychainSpy;
-      const returnedPublicKey = await crypto.generateKeyPair();
-      const [calledPublicKey, calledPrivateKey] = keychainSpy.getCall(0).args;
-      expect(calledPublicKey).to.equal(publicKey);
-      expect(calledPrivateKey).to.equal(privateKey);
-      expect(returnedPublicKey).to.equal(publicKey);
-    });
-  });
-
-  describe("generateSharedKey", () => {
-    it("throws if not initialized", () => {
-      const invalidCrypto = new Crypto(core, logger);
-      expect(() => invalidCrypto.generateSharedKey("a", "b")).to.throw("Not initialized. crypto");
-    });
-    it("generates a shared symKey, sets it in the keychain and returns the topic", async () => {
-      const overrideTopic = utils.generateRandomBytes32();
-      const peerPublicKey = utils.generateRandomBytes32();
-      const selfPublicKey = await crypto.generateKeyPair();
-      const selfPrivateKey = crypto.keychain.get(selfPublicKey);
-      const expectedSymKey = utils.deriveSymKey(selfPrivateKey, peerPublicKey);
-      const spy = Sinon.spy();
-      crypto.setSymKey = spy;
-      await crypto.generateSharedKey(selfPublicKey, peerPublicKey, overrideTopic);
-      const [calledSymKey, calledOverrideTopic] = spy.getCall(0).args;
-      expect(calledSymKey).to.equal(expectedSymKey);
-      expect(calledOverrideTopic).to.equal(overrideTopic);
-    });
-  });
-
-  describe("setSymKey", () => {
-    it("throws if not initialized", async () => {
-      const invalidCrypto = new Crypto(core, logger);
-      await expect(invalidCrypto.setSymKey("key")).rejects.toThrow("Not initialized. crypto");
-    });
-    it("sets expected topic-symKey pair in keychain, returns topic", async () => {
-      const spy = Sinon.spy();
-      crypto.keychain.set = spy;
-      const fakeSymKey = utils.generateRandomBytes32();
-      const topic = utils.hashKey(fakeSymKey);
-      const returnedTopic = await crypto.setSymKey(fakeSymKey);
-      const [calledTopic, calledSymKey] = spy.getCall(0).args;
-      expect(calledTopic).to.equal(topic);
-      expect(calledSymKey).to.equal(fakeSymKey);
-      expect(returnedTopic).to.equal(topic);
-    });
-    it("sets expected topic-symKey pair in keychain if overrideTopic is passed", async () => {
-      const spy = Sinon.spy();
-      crypto.keychain.set = spy;
-      const fakeSymKey = utils.generateRandomBytes32();
-      const topic = utils.generateRandomBytes32();
-      const returnedTopic = await crypto.setSymKey(fakeSymKey, topic);
-      const [calledTopic, calledSymKey] = spy.getCall(0).args;
-      expect(calledTopic).to.equal(topic);
-      expect(calledSymKey).to.equal(fakeSymKey);
-      expect(returnedTopic).to.equal(topic);
-    });
-  });
-
-  describe("deleteKeyPair", () => {
-    it("throws if not initialized", async () => {
-      const invalidCrypto = new Crypto(core, logger);
-      await expect(invalidCrypto.deleteKeyPair("key")).rejects.toThrow("Not initialized. crypto");
-    });
-    it("deletes the expected topic-symKey pair from keychain", async () => {
-      const publicKey = utils.generateRandomBytes32();
-      const spy = Sinon.spy();
-      crypto.keychain.del = spy;
-      await crypto.deleteKeyPair(publicKey);
-      const [calledTopic] = spy.getCall(0).args;
-      expect(calledTopic).to.equal(publicKey);
-    });
-  });
-
-  describe("deleteSymKey", () => {
-    it("throws if not initialized", async () => {
-      const invalidCrypto = new Crypto(core, logger);
-      await expect(invalidCrypto.deleteSymKey("key")).rejects.toThrow("Not initialized. crypto");
-    });
-    it("deletes the expected topic-symKey pair from keychain", async () => {
-      const topic = utils.generateRandomBytes32();
-      const spy = Sinon.spy();
-      crypto.keychain.del = spy;
-      await crypto.deleteSymKey(topic);
-      const [calledTopic] = spy.getCall(0).args;
-      expect(calledTopic).to.equal(topic);
-    });
-  });
-
-  describe("encode", () => {
-    const symKey = "5720435e682cd03ee45b484f9a213f0e3246a0ccc2cca183b72ab1cbfbefb702";
-    const payload = { id: 1, jsonrpc: "2.0", result: "result" };
-    // const encoded =
-    //   "AG7iJl9mMl9K04REnuWaKLQU6kwMcQWUd69OxGOJ5/A+VRRKkxnKhBeIAl4JRaIft3qZKEfnBvc7/Fife1DWcERqAfJwzPI=";
-
-    it("throws if not initialized", async () => {
-      const invalidCrypto = new Crypto(core, logger);
-      await expect(invalidCrypto.encode("topic", payload)).rejects.toThrow(
-        "Not initialized. crypto",
-      );
-    });
-    it.skip("encrypts `payload` if the passed topic is known", async () => {
-      const topic = await crypto.setSymKey(symKey);
-      // FIXME: needs to be tested dynamically because of random IV generation
-      await crypto.encode(topic, payload);
-    });
-  });
-
-  describe("decode", () => {
-    const symKey = "5720435e682cd03ee45b484f9a213f0e3246a0ccc2cca183b72ab1cbfbefb702";
-    const payload = { id: 1, jsonrpc: "2.0", result: "result" };
-    const encoded =
-      "AG7iJl9mMl9K04REnuWaKLQU6kwMcQWUd69OxGOJ5/A+VRRKkxnKhBeIAl4JRaIft3qZKEfnBvc7/Fife1DWcERqAfJwzPI=";
-
-    it("throws if not initialized", async () => {
-      const invalidCrypto = new Crypto(core, logger);
-      await expect(invalidCrypto.decode("topic", "encoded")).rejects.toThrow(
-        "Not initialized. crypto",
-      );
-    });
-    it("decrypts `payload` if the passed topic is known", async () => {
-      const topic = await crypto.setSymKey(symKey);
-      const decoded = await crypto.decode(topic, encoded);
-      expect(decoded).to.eql(payload);
-    });
-    it("should not throw on failed decrypt", async () => {
-      const decoded = await crypto.decode("non-existent-topic", "dummymessage");
-      expect(decoded).to.eql(undefined);
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/events.spec.ts">
-import { expect, describe, it } from "vitest";
-import Core, {
-  EVENTS_STORAGE_CLEANUP_INTERVAL,
-  EVENT_CLIENT_CONTEXT,
-  EVENT_CLIENT_PAIRING_ERRORS,
-} from "../src";
-import { TEST_CORE_OPTIONS } from "./shared";
-import { toMiliseconds } from "@walletconnect/time";
-
-describe("Events Client", () => {
-  it("Init events client", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    expect(core.eventClient).toBeDefined();
-    expect(core.eventClient.context).toBe(EVENT_CLIENT_CONTEXT);
-    expect(core.eventClient.core).toBe(core);
-    // @ts-expect-error - accessing private properties for testing
-    expect(core.eventClient.events.size).toBe(0);
-  });
-  it("should create event", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
-    const topic = "test topic";
-    const trace = ["test trace", "test trace 2"];
-    const eventType = "ERROR";
-    const event = core.eventClient.createEvent({
-      event: eventType,
-      type,
-      properties: {
-        topic,
-        trace,
-      },
-    });
-    expect(event).toBeDefined();
-    expect(event.props.event).toBe(eventType);
-    expect(event.props.type).toBe(type);
-    expect(event.props.properties.topic).toBe(topic);
-    expect(event.props.properties.trace).toBe(trace);
-    // @ts-expect-error - accessing private properties for testing
-    expect(core.eventClient.events.size).toBe(1);
-  });
-
-  it("should create multiple events", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
-    const eventsToCreate = 10;
-    for (let i = 0; i < eventsToCreate; i++) {
-      const topic = "test topic";
-      const trace = ["test trace", "test trace 2"];
-      const eventType = "ERROR";
-      const event = core.eventClient.createEvent({
-        event: eventType,
-        type,
-        properties: {
-          topic,
-          trace,
-        },
-      });
-      expect(event).toBeDefined();
-      expect(event.props.event).toBe(eventType);
-      expect(event.props.type).toBe(type);
-      expect(event.props.properties.topic).toBe(topic);
-      expect(event.props.properties.trace).toBe(trace);
-    }
-    // @ts-expect-error - accessing private properties for testing
-    expect(core.eventClient.events.size).toBe(eventsToCreate);
-  });
-  it("should create & delete event", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
-    const topic = "test topic";
-    const trace = ["test trace", "test trace 2"];
-    const eventType = "ERROR";
-    const event = core.eventClient.createEvent({
-      event: eventType,
-      type,
-      properties: {
-        topic,
-        trace,
-      },
-    });
-    expect(event).toBeDefined();
-    expect(event.props.event).toBe(eventType);
-    expect(event.props.type).toBe(type);
-    expect(event.props.properties.topic).toBe(topic);
-    expect(event.props.properties.trace).toBe(trace);
-    // @ts-expect-error - accessing private properties for testing
-    expect(core.eventClient.events.size).toBe(1);
-
-    core.eventClient.deleteEvent({ eventId: event.eventId });
-
-    // @ts-expect-error - accessing private properties for testing
-    expect(core.eventClient.events.size).toBe(0);
-  });
-  it("should add trace", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
-    const topic = "test topic";
-    const trace = ["test trace", "test trace 2"];
-    const eventType = "ERROR";
-    const event = core.eventClient.createEvent({
-      event: eventType,
-      type,
-      properties: {
-        topic,
-        trace,
-      },
-    });
-    expect(event).toBeDefined();
-    expect(event.props.event).toBe(eventType);
-    expect(event.props.type).toBe(type);
-    expect(event.props.properties.topic).toBe(topic);
-    expect(event.props.properties.trace).toBe(trace);
-    expect(event.addTrace).to.exist;
-    expect(event.setError).to.exist;
-
-    const additionalTrace = ["test trace 3", "test trace 4"];
-    const additionlTraceLenght = additionalTrace.length;
-    const defaultTraceLength = trace.length;
-    event.addTrace(additionalTrace[0]);
-    event.addTrace(additionalTrace[1]);
-    expect(event.props.properties.trace.length).toEqual(defaultTraceLength + additionlTraceLenght);
-    expect(event.props.properties.trace).toContain(additionalTrace[0]);
-    expect(event.props.properties.trace).toContain(additionalTrace[1]);
-  });
-  it("should set error type", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    const topic = "test topic";
-    const trace = ["test trace", "test trace 2"];
-    const eventType = "ERROR";
-    const event = core.eventClient.createEvent({
-      event: eventType,
-      properties: {
-        topic,
-        trace,
-      },
-    });
-    expect(event).toBeDefined();
-    expect(event.props.event).toBe(eventType);
-    expect(event.props.type).toBe("");
-    expect(event.props.properties.topic).toBe(topic);
-    expect(event.props.properties.trace).toBe(trace);
-    expect(event.addTrace).to.exist;
-    expect(event.setError).to.exist;
-
-    event.setError(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);
-
-    expect(event.props.type).toBe(EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists);
-  });
-  it("should clean up old events", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
-    const topic = "test topic";
-    const trace = ["test trace", "test trace 2"];
-    const eventType = "ERROR";
-    const event = core.eventClient.createEvent({
-      event: eventType,
-      type,
-      properties: {
-        topic,
-        trace,
-      },
-    });
-
-    event.timestamp = Date.now() - toMiliseconds(EVENTS_STORAGE_CLEANUP_INTERVAL);
-    // @ts-expect-error - accessing private properties
-    expect(core.eventClient.events.size).toBe(1);
-    await new Promise((resolve) => setTimeout(resolve, 5000));
-    // @ts-expect-error - accessing private properties
-    expect(core.eventClient.events.size).toBe(0);
-  });
-  it("should not store events when telemetry is disabled", async () => {
-    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
-    await core.start();
-    const type = EVENT_CLIENT_PAIRING_ERRORS.active_pairing_already_exists;
-    const topic = "test topic";
-    const trace = ["test trace", "test trace 2"];
-    const eventType = "ERROR";
-    core.eventClient.createEvent({
-      event: eventType,
-      type,
-      properties: {
-        topic,
-        trace,
-      },
-    });
-    // @ts-expect-error - accessing private properties
-    expect(core.eventClient.events.size).toBe(0);
-  });
-
-  it("should not send automatic init event", async () => {
-    process.env.IS_VITEST = false as any;
-    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
-    let initCalled = false;
-    // @ts-expect-error - accessing private properties
-    core.eventClient.sendEvent = async (payload: any) => {
-      initCalled = true;
-      expect(payload).toBeDefined();
-      expect(payload.length).to.eql(1);
-      expect(payload[0].props.event).to.eql("INIT");
-      expect(payload[0].props.properties.client_id).to.eql(await core.crypto.getClientId());
-    };
-    await core.start();
-    await new Promise((resolve) => setTimeout(resolve, 500));
-    expect(initCalled).to.eql(false);
-    process.env.IS_VITEST = true as any;
-  });
-
-  it("should send init event", async () => {
-    process.env.IS_VITEST = false as any;
-    const core = new Core({ ...TEST_CORE_OPTIONS, telemetryEnabled: false });
-    let initCalled = false;
-    // @ts-expect-error - accessing private properties
-    core.eventClient.sendEvent = async (payload: any) => {
-      initCalled = true;
-      expect(payload).toBeDefined();
-      expect(payload.length).to.eql(1);
-      expect(payload[0].props.event).to.eql("INIT");
-      expect(payload[0].props.properties.client_id).to.eql(await core.crypto.getClientId());
-    };
-    await core.start();
-    await new Promise((resolve) => setTimeout(resolve, 500));
-
-    expect(initCalled).to.eql(false);
-    await core.eventClient.init();
-    expect(initCalled).to.eql(true);
-    if (!initCalled) {
-      throw new Error("init not called");
-    }
-    process.env.IS_VITEST = true as any;
-  });
-});
-</file>
-
-<file path="packages/core/test/expirer.spec.ts">
-import { pino, getDefaultLoggerOptions } from "@walletconnect/logger";
-import { expect, describe, it } from "vitest";
-import { calcExpiry, formatExpirerTarget } from "@walletconnect/utils";
-import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
-
-import {
-  Core,
-  Expirer,
-  EXPIRER_EVENTS,
-  CORE_STORAGE_PREFIX,
-  EXPIRER_STORAGE_VERSION,
-  EXPIRER_CONTEXT,
-  CORE_DEFAULT,
-} from "../src";
-import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";
-import { generateRandomBytes32 } from "../../utils/src";
-
-describe("Expirer", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
-
-  describe("storageKey", () => {
-    it("provides the expected default `storageKey` format", () => {
-      const core = new Core(TEST_CORE_OPTIONS);
-      const expirer = new Expirer(core, logger);
-      expect(expirer.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + EXPIRER_STORAGE_VERSION + "//" + EXPIRER_CONTEXT,
-      );
-    });
-    it("provides the expected custom `storageKey` format", () => {
-      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-      const expirer = new Expirer(core, logger);
-      expect(expirer.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + EXPIRER_STORAGE_VERSION + ":test" + "//" + EXPIRER_CONTEXT,
-      );
-    });
-  });
-
-  it("should expire payload", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    await core.relayer.subscribe(generateRandomBytes32());
-    // confirm the expirer is empty
-    expect(core.expirer.length).to.eq(0);
-    // set a payload
-    const topic = "test";
-    core.expirer.set(topic, calcExpiry(1));
-    // confirm the expirer is not empty
-    expect(core.expirer.length).to.eq(1);
-    setTimeout(() => {
-      // emit heartbeat pulse event to trigger expirer
-      core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
-    }, 1_000);
-    await new Promise<void>((resolve) => {
-      core.expirer.on(EXPIRER_EVENTS.expired, (payload: any) => {
-        expect(payload.target).to.eq(formatExpirerTarget("topic", topic));
-        // confirm the expirer is empty again
-        expect(core.expirer.length).to.eq(0);
-        resolve();
-      });
-    });
-    await disconnectSocket(core.relayer);
-  });
-});
-</file>
-
-<file path="packages/core/test/history.spec.ts">
-import { pino, getDefaultLoggerOptions } from "@walletconnect/logger";
-import { vi, expect, describe, it, beforeEach, afterEach } from "vitest";
-import { calcExpiry } from "@walletconnect/utils";
-import { THIRTY_DAYS, toMiliseconds } from "@walletconnect/time";
-import { ICore, JsonRpcRecord } from "@walletconnect/types";
-
-import {
-  Core,
-  CORE_DEFAULT,
-  CORE_STORAGE_PREFIX,
-  HISTORY_STORAGE_VERSION,
-  HISTORY_CONTEXT,
-  HISTORY_EVENTS,
-  JsonRpcHistory,
-} from "../src";
-import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";
-
-describe("history", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
-  let core: ICore;
-
-  beforeEach(async () => {
-    core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-  });
-  afterEach(async () => {
-    await disconnectSocket(core.relayer);
-  });
-
-  describe("storageKey", () => {
-    it("provides the expected default `storageKey` format", () => {
-      const core = new Core(TEST_CORE_OPTIONS);
-      const history = new JsonRpcHistory(core, logger);
-      expect(history.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + HISTORY_STORAGE_VERSION + "//" + HISTORY_CONTEXT,
-      );
-    });
-    it("provides the expected custom `storageKey` format", () => {
-      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-      const history = new JsonRpcHistory(core, logger);
-      expect(history.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + HISTORY_STORAGE_VERSION + ":test" + "//" + HISTORY_CONTEXT,
-      );
-    });
-  });
-
-  it("should set a record expiry", async () => {
-    expect(core.history.records.size).to.eq(0);
-    const request = {
-      id: 1687958477400360,
-      topic: "24fd0e137c4ccc655ca9e1b9d0e2481bb3d028dc307edc62d2a5190bb081c1b9",
-      jsonrpc: "2.0",
-      method: "test",
-      params: {
-        request: {
-          method: "personal_sign",
-          params: [
-            "0x4d7920656d61696c206973206a6f686e40646f652e636f6d202d2031363837393538343737333838",
-            "0x7770471b86c6dd889a6D81DA53Fb7eeE1F9a2ba7",
-          ],
-        },
-        chainId: "eip155:5",
-      },
-    };
-    core.history.set(request.topic, request);
-    expect(core.history.records.size).to.eq(1);
-    const record = core.history.records.get(request.id);
-    expect(record).to.not.be.undefined;
-    expect(record?.expiry).to.not.be.undefined;
-    expect(record?.expiry).to.be.greaterThan(0);
-    expect(toMiliseconds(record?.expiry || 0)).to.be.approximately(
-      toMiliseconds(calcExpiry(THIRTY_DAYS)),
-      10,
-    ); // delta ~10ms execution variance
-
-    vi.useFakeTimers();
-    vi.advanceTimersByTime(toMiliseconds(calcExpiry(THIRTY_DAYS)));
-    // move time forward to force expiry and wait for heartbeat to delete the record
-    await new Promise<void>((resolve) => {
-      core.history.on(HISTORY_EVENTS.deleted, (record: JsonRpcRecord) => {
-        expect(record).to.not.be.undefined;
-        expect(record.id).to.eq(request.id);
-        resolve();
-      });
-    });
-    vi.useRealTimers();
-    expect(core.history.records.size).to.eq(0);
-  });
-});
-</file>
-
-<file path="packages/core/test/keychain.spec.ts">
-import { expect, describe, it } from "vitest";
-import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
-
-import {
-  Core,
-  CORE_DEFAULT,
-  CORE_STORAGE_PREFIX,
-  KeyChain,
-  KEYCHAIN_CONTEXT,
-  KEYCHAIN_STORAGE_VERSION,
-} from "../src";
-import { TEST_CORE_OPTIONS } from "./shared";
-
-describe("Keychain", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
-
-  describe("storageKey", () => {
-    it("provides the expected default `storageKey` format", () => {
-      const core = new Core(TEST_CORE_OPTIONS);
-      const keychain = new KeyChain(core, logger);
-      expect(keychain.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + KEYCHAIN_STORAGE_VERSION + "//" + KEYCHAIN_CONTEXT,
-      );
-    });
-    it("provides the expected custom `storageKey` format", () => {
-      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-      const keychain = new KeyChain(core, logger);
-      expect(keychain.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + KEYCHAIN_STORAGE_VERSION + ":test" + "//" + KEYCHAIN_CONTEXT,
-      );
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/messages.spec.ts">
-import { expect, describe, it, beforeEach } from "vitest";
-import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
-import { generateRandomBytes32, hashMessage } from "@walletconnect/utils";
-
-import {
-  Core,
-  CORE_DEFAULT,
-  CORE_STORAGE_PREFIX,
-  MESSAGE_DIRECTION,
-  MESSAGES_CONTEXT,
-  MESSAGES_STORAGE_VERSION,
-  MessageTracker,
-} from "../src";
-import { TEST_CORE_OPTIONS } from "./shared";
-
-describe("Messages", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
-
-  let messageTracker: MessageTracker;
-  let topic: string;
-
-  beforeEach(async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    messageTracker = new MessageTracker(logger, core);
-    topic = generateRandomBytes32();
-    await messageTracker.init();
-  });
-
-  describe("storageKey", () => {
-    it("provides the expected default `storageKey` format", () => {
-      expect(messageTracker.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + "//" + MESSAGES_CONTEXT,
-      );
-    });
-    it("provides the expected custom `storageKey` format", () => {
-      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-      const messageTracker = new MessageTracker(logger, core);
-      expect(messageTracker.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + ":test" + "//" + MESSAGES_CONTEXT,
-      );
-    });
-  });
-
-  describe("set", () => {
-    it("throws if not initialized", async () => {
-      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
-      await expect(invalidMessageTracker.set(topic, "some message")).rejects.toThrow(
-        "Not initialized. messages",
-      );
-    });
-    it("sets an entry on the messages map for a new topic-message pair", async () => {
-      const mockMessage = "test message";
-      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
-      const key = hashMessage(mockMessage);
-      const message = messageTracker.messages.get(topic) ?? {};
-      expect(message[key]).to.equal(mockMessage);
-      const messagesWithoutClientAck = messageTracker.messagesWithoutClientAck.get(topic) ?? {};
-      expect(messagesWithoutClientAck[key]).to.equal(mockMessage);
-    });
-  });
-
-  describe("get", () => {
-    it("throws if not initialized", () => {
-      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
-      expect(() => invalidMessageTracker.get(topic)).to.throw("Not initialized. messages");
-    });
-    it("returns an empty object for an unknown topic", () => {
-      const message = messageTracker.get("fakeTopic");
-      expect(message).to.deep.equal({});
-    });
-    it("returns the expected message based on the topic", async () => {
-      const mockMessage = "test message";
-      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
-      expect(messageTracker.get(topic)).to.deep.equal({ [hashMessage(mockMessage)]: mockMessage });
-      const messagesWithoutClientAck = messageTracker.messagesWithoutClientAck.get(topic) ?? {};
-      expect(messagesWithoutClientAck[hashMessage(mockMessage)]).to.equal(mockMessage);
-    });
-  });
-
-  describe("has", () => {
-    it("throws if not initialized", () => {
-      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
-      expect(() => invalidMessageTracker.has(topic, "message")).to.throw(
-        "Not initialized. messages",
-      );
-    });
-    it("returns `false` by default", () => {
-      expect(messageTracker.has("fakeTopic", "message")).to.be.false;
-    });
-    it("returns `true` if provided topic-message pair exists", async () => {
-      const mockMessage = "test message";
-      await messageTracker.set(topic, mockMessage);
-      expect(messageTracker.has(topic, mockMessage)).to.be.true;
-    });
-  });
-
-  describe("del", () => {
-    it("throws if not initialized", async () => {
-      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
-      await expect(invalidMessageTracker.del(topic)).rejects.toThrow("Not initialized. messages");
-    });
-    it("removes the matching topic-message pair for the provided topic", async () => {
-      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.inbound);
-      expect(messageTracker.messages.size).to.equal(1);
-      expect(messageTracker.messagesWithoutClientAck.size).to.equal(1);
-      await messageTracker.del(topic);
-      expect(messageTracker.messages.size).to.equal(0);
-      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
-    });
-  });
-
-  describe("ack", () => {
-    it("throws if not initialized", async () => {
-      const invalidMessageTracker = new MessageTracker(logger, new Core(TEST_CORE_OPTIONS));
-      await expect(invalidMessageTracker.ack(topic, "message")).rejects.toThrow(
-        "Not initialized. messages",
-      );
-    });
-    it("removes the the topic-message pair from `messagesWithoutClientAck` when acknowledged", async () => {
-      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.inbound);
-      await messageTracker.ack(topic, "message");
-      expect(messageTracker.messages.size).to.equal(1);
-      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
-    });
-
-    it("doesn't store outbound messages in `messagesWithoutClientAck`", async () => {
-      await messageTracker.set(topic, "message", MESSAGE_DIRECTION.outbound);
-      expect(messageTracker.messages.size).to.equal(1);
-      expect(messageTracker.messagesWithoutClientAck.size).to.equal(0);
-    });
-
-    it("doesn't throw if the topic-message pair doesn't exist", async () => {
-      expect(await messageTracker.ack(topic, "message")).to.be.undefined;
-    });
-  });
-
-  describe("getWithoutAck", () => {
-    it("returns an empty map if no topics are provided", () => {
-      expect(messageTracker.getWithoutAck([])).to.deep.equal({});
-    });
-
-    it("returns empty map if no messages are available for the provided topic", () => {
-      expect(messageTracker.getWithoutAck([topic])).to.deep.equal({ [topic]: [] });
-    });
-    it("returns correct messages for the provided topic", async () => {
-      const mockMessage = "test message";
-      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
-      expect(messageTracker.getWithoutAck([topic])).to.deep.equal({
-        [topic]: [mockMessage],
-      });
-    });
-    it("returns correct messages for multiple provided topics", async () => {
-      const mockMessage = "test message";
-      const topic2 = generateRandomBytes32();
-      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
-      await messageTracker.set(topic2, mockMessage, MESSAGE_DIRECTION.inbound);
-      expect(messageTracker.getWithoutAck([topic, topic2])).to.deep.equal({
-        [topic]: [mockMessage],
-        [topic2]: [mockMessage],
-      });
-    });
-    it("returns correct messages for multiple provided topics. Test 2", async () => {
-      const mockMessage = "test message";
-      const mockMessage2 = "test message 2";
-      const mockMessage3 = "test message 3";
-      const topic2 = generateRandomBytes32();
-      const topic3 = generateRandomBytes32();
-      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
-      await messageTracker.set(topic2, mockMessage2, MESSAGE_DIRECTION.inbound);
-      await messageTracker.set(topic3, mockMessage3, MESSAGE_DIRECTION.inbound);
-      expect(messageTracker.getWithoutAck([topic2, topic3])).to.deep.equal({
-        [topic2]: [mockMessage2],
-        [topic3]: [mockMessage3],
-      });
-    });
-    it("returns correct messages for multiple provided topics. Test 3", async () => {
-      const mockMessage = "test message";
-      const mockMessage2 = "test message 2";
-      const mockMessage3 = "test message 3";
-      const topic2 = generateRandomBytes32();
-      const topic3 = generateRandomBytes32();
-      await messageTracker.set(topic, mockMessage, MESSAGE_DIRECTION.inbound);
-      await messageTracker.set(topic, mockMessage2, MESSAGE_DIRECTION.inbound);
-      await messageTracker.set(topic2, mockMessage3, MESSAGE_DIRECTION.inbound);
-      expect(messageTracker.getWithoutAck([topic, topic2, topic3])).to.deep.equal({
-        [topic]: [mockMessage, mockMessage2],
-        [topic2]: [mockMessage3],
-        [topic3]: [],
-      });
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/pairing.spec.ts">
-import { expect, describe, it, beforeEach, afterEach } from "vitest";
-import { ICore } from "@walletconnect/types";
-import { Core, CORE_PROTOCOL, CORE_VERSION, PAIRING_EVENTS, SUBSCRIBER_EVENTS } from "../src";
-import { TEST_CORE_OPTIONS, disconnectSocket, waitForEvent } from "./shared";
-import { calcExpiry, generateRandomBytes32, parseUri, toBase64 } from "@walletconnect/utils";
-import { FIVE_MINUTES } from "@walletconnect/time";
-
-const createCoreClients: () => Promise<{ coreA: ICore; coreB: ICore }> = async () => {
-  const coreA = new Core(TEST_CORE_OPTIONS);
-  const coreB = new Core(TEST_CORE_OPTIONS);
-  await coreA.start();
-  await coreB.start();
-  return { coreA, coreB };
-};
-
-describe("Pairing", () => {
-  let coreA: ICore;
-  let coreB: ICore;
-
-  beforeEach(async () => {
-    const coreClients = await createCoreClients();
-    coreA = coreClients.coreA;
-    coreB = coreClients.coreB;
-  });
-
-  afterEach(async () => {
-    await disconnectSocket(coreA.relayer);
-    await disconnectSocket(coreB.relayer);
-  });
-
-  describe("init", () => {
-    it("initializes", () => {
-      expect(coreA.pairing.pairings).toBeDefined();
-      expect(coreB.pairing.pairings).toBeDefined();
-    });
-  });
-
-  describe("create", () => {
-    it("returns the pairing topic and URI in expected format", async () => {
-      const { topic, uri } = await coreA.pairing.create();
-      expect(topic.length).toBe(64);
-      expect(uri.startsWith(`${CORE_PROTOCOL}:${topic}@${CORE_VERSION}`)).toBe(true);
-    });
-  });
-
-  describe("pair", () => {
-    it("can pair via provided URI", async () => {
-      const { uri } = await coreA.pairing.create();
-      await coreB.pairing.pair({ uri });
-
-      expect(coreA.pairing.pairings.keys.length).toBe(1);
-      expect(coreB.pairing.pairings.keys.length).toBe(1);
-      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
-      expect(coreA.pairing.getPairings()[0].active).toBe(false);
-      expect(coreB.pairing.getPairings()[0].active).toBe(false);
-    });
-    it("can pair via base64 provided URI", async () => {
-      const { uri } = await coreA.pairing.create();
-      const encodedUri = toBase64(uri, true);
-      await coreB.pairing.pair({ uri: encodedUri });
-
-      expect(coreA.pairing.pairings.keys.length).toBe(1);
-      expect(coreB.pairing.pairings.keys.length).toBe(1);
-      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
-      expect(coreA.pairing.getPairings()[0].active).toBe(false);
-      expect(coreB.pairing.getPairings()[0].active).toBe(false);
-    });
-
-    it("can pair via provided android deeplink URI", async () => {
-      const { uri } = await coreA.pairing.create();
-      await coreB.pairing.pair({ uri: `wc://${uri}` });
-
-      expect(coreA.pairing.pairings.keys.length).toBe(1);
-      expect(coreB.pairing.pairings.keys.length).toBe(1);
-      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
-      expect(coreA.pairing.getPairings()[0].active).toBe(false);
-      expect(coreB.pairing.getPairings()[0].active).toBe(false);
-    });
-
-    it("can pair via provided iOS deeplink URI", async () => {
-      const { uri } = await coreA.pairing.create();
-      await coreB.pairing.pair({ uri: `wc:${uri}` });
-
-      expect(coreA.pairing.pairings.keys.length).toBe(1);
-      expect(coreB.pairing.pairings.keys.length).toBe(1);
-      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
-      expect(coreA.pairing.getPairings()[0].active).toBe(false);
-      expect(coreB.pairing.getPairings()[0].active).toBe(false);
-    });
-
-    it("can auto-activate the pairing on pair step", async () => {
-      const { uri } = await coreA.pairing.create();
-      await coreB.pairing.pair({ uri, activatePairing: true });
-
-      expect(coreA.pairing.getPairings()[0].active).toBe(false);
-      expect(coreB.pairing.getPairings()[0].active).toBe(true);
-    });
-
-    it("throws when pairing is attempted on topic that already exists", async () => {
-      const { topic, uri } = await coreA.pairing.create();
-      coreA.pairing.pairings.get(topic).active = true;
-      await expect(coreA.pairing.pair({ uri })).rejects.toThrowError(
-        `Pairing already exists: ${topic}`,
-      );
-    });
-
-    it("should not override existing keychain values", async () => {
-      const keychainTopic = generateRandomBytes32();
-      const keychainValue = generateRandomBytes32();
-      let { topic, uri } = await coreA.pairing.create();
-      coreA.crypto.keychain.set(keychainTopic, keychainValue);
-      uri = uri.replace(topic, keychainTopic);
-      await coreA.pairing.pair({ uri });
-      expect(coreA.crypto.keychain.get(keychainTopic)).toBe(keychainValue);
-    });
-  });
-
-  describe("activate", () => {
-    it("can activate a pairing", async () => {
-      const { topic } = await coreA.pairing.create();
-
-      const inactivePairing = coreA.pairing.pairings.get(topic);
-      expect(inactivePairing.active).toBe(false);
-      await coreA.pairing.activate({ topic });
-      const activePairing = coreA.pairing.pairings.get(topic);
-      expect(activePairing.active).toBe(true);
-      // inactive pairing should have an expiry of 5 minutes
-      expect(inactivePairing.expiry).to.be.approximately(calcExpiry(FIVE_MINUTES), 5);
-      // active pairing should still have an expiry of 5 minutes
-      expect(activePairing.expiry).to.be.approximately(calcExpiry(FIVE_MINUTES), 5);
-    });
-  });
-
-  describe("updateExpiry", () => {
-    it("can update a pairing's expiry", async () => {
-      const mockExpiry = 11111111;
-      const { topic } = await coreA.pairing.create();
-
-      await coreA.pairing.updateExpiry({ topic, expiry: mockExpiry });
-      expect(coreA.pairing.pairings.get(topic).expiry).toBe(mockExpiry);
-    });
-  });
-
-  describe("updateMetadata", () => {
-    it("can update a pairing's `peerMetadata`", async () => {
-      const mockMetadata = {
-        name: "Mock",
-        description: "Mock Metadata",
-        url: "https://mockurl.com",
-        icons: [],
-      };
-      const { topic } = await coreA.pairing.create();
-
-      expect(coreA.pairing.pairings.get(topic).peerMetadata).toBeUndefined();
-      await coreA.pairing.updateMetadata({ topic, metadata: mockMetadata });
-      expect(coreA.pairing.pairings.get(topic).peerMetadata).toEqual(mockMetadata);
-    });
-  });
-
-  describe("formatUriFromPairing", () => {
-    it("should generate pairing uri from pairing", async () => {
-      let generatedUri = "";
-      coreA.pairing.events.once("pairing_create", (payload) => {
-        generatedUri = coreA.pairing.formatUriFromPairing(payload);
-      });
-      const { uri } = await coreA.pairing.create({
-        methods: ["eth_sendTransaction", "personal_sign"],
-      });
-      expect(generatedUri).to.be.eq(uri);
-      const parsedUri = parseUri(uri);
-      const parsedGeneratedUri = parseUri(generatedUri);
-      expect(parsedGeneratedUri).to.deep.equal(parsedUri);
-    });
-  });
-
-  describe("ping", () => {
-    it("clients can ping each other", async () => {
-      const { uri, topic } = await coreA.pairing.create();
-      let gotPing = false;
-
-      coreB.pairing.events.on("pairing_ping", () => {
-        gotPing = true;
-      });
-
-      await coreB.pairing.pair({ uri });
-      await coreA.pairing.ping({ topic });
-      await waitForEvent(() => gotPing);
-
-      expect(gotPing).toBe(true);
-    });
-  });
-
-  describe("disconnect", () => {
-    it("can disconnect a known pairing", async () => {
-      const { uri, topic } = await coreA.pairing.create();
-      let hasDeleted = false;
-
-      coreA.pairing.events.on("pairing_delete", () => {
-        hasDeleted = true;
-      });
-
-      await coreB.pairing.pair({ uri });
-      await coreB.pairing.disconnect({ topic });
-      await waitForEvent(() => hasDeleted);
-
-      expect(coreA.pairing.pairings.keys.length).toBe(0);
-      expect(coreB.pairing.pairings.keys.length).toBe(0);
-      expect(coreA.pairing.pairings.keys).to.deep.equal(coreB.pairing.pairings.keys);
-    });
-  });
-
-  describe("validations", () => {
-    describe("pair", () => {
-      it("throws when no params are passed", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.pair()).rejects.toThrowError(
-          "Missing or invalid. pair() params: undefined",
-        );
-      });
-
-      it("throws when empty uri is provided", async () => {
-        await expect(coreA.pairing.pair({ uri: "" })).rejects.toThrowError(
-          "Missing or invalid. pair() uri: ",
-        );
-      });
-
-      it("throws when invalid uri is provided", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.pair({ uri: 123 })).rejects.toThrowError(
-          "Missing or invalid. pair() uri: 123",
-        );
-      });
-
-      it("throws when no uri is provided", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.pair({ uri: undefined })).rejects.toThrowError(
-          "Missing or invalid. pair() uri: undefined",
-        );
-      });
-      it("throws when uri missing relay protocol is provided", async () => {
-        // Using v1 pairing URI as it is unsupported
-        const v1PairingUri =
-          "wc:e9d6ef98-6b65-490b-8726-a21e1afb181d@1?bridge=https%3A%2F%2Fwalletconnect.com&key=73f096cb97aaee97b3d9871ced35fdce1668e652db3d39423ea6cd22e14528bf";
-        await expect(
-          coreA.pairing.pair({
-            uri: v1PairingUri,
-          }),
-        ).rejects.toThrowError("Missing or invalid. pair() uri#relay-protocol");
-      });
-      it("throws when uri missing relay protocol is provided", async () => {
-        await expect(
-          coreA.pairing.pair({
-            uri: "wc:e9d6ef98-6b65-490b-8726-a21e1afb181d@1?bridge=https%3A%2F%2Fwalletconnect.com&relay-protocol=irn",
-          }),
-        ).rejects.toThrowError("Missing or invalid. pair() uri#symKey");
-      });
-    });
-
-    describe("ping", () => {
-      it("throws when no params are passed", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.ping()).rejects.toThrowError(
-          "Missing or invalid. ping() params: undefined",
-        );
-      });
-
-      it("throws when invalid topic is provided", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.ping({ topic: 123 })).rejects.toThrowError(
-          "Missing or invalid. pairing topic should be a string: 123",
-        );
-      });
-
-      it("throws when empty topic is provided", async () => {
-        await expect(coreA.pairing.ping({ topic: "" })).rejects.toThrowError(
-          "Missing or invalid. pairing topic should be a string: ",
-        );
-      });
-
-      it("throws when no topic is provided", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.ping({ topic: undefined })).rejects.toThrowError(
-          "Missing or invalid. pairing topic should be a string: undefined",
-        );
-      });
-
-      it("throws when non existent topic is provided", async () => {
-        await expect(coreA.pairing.ping({ topic: "none" })).rejects.toThrowError(
-          "No matching key. pairing topic doesn't exist: none",
-        );
-      });
-    });
-
-    describe("disconnect", () => {
-      it("throws when no params are passed", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.disconnect()).rejects.toThrowError(
-          "Missing or invalid. disconnect() params: undefined",
-        );
-      });
-
-      it("throws when invalid topic is provided", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.disconnect({ topic: 123 })).rejects.toThrowError(
-          "Missing or invalid. pairing topic should be a string: 123",
-        );
-      });
-
-      it("throws when empty topic is provided", async () => {
-        await expect(coreA.pairing.disconnect({ topic: "" })).rejects.toThrowError(
-          "Missing or invalid. pairing topic should be a string: ",
-        );
-      });
-
-      it("throws when no topic is provided", async () => {
-        // @ts-expect-error - ignore TS error to test runtime validation
-        await expect(coreA.pairing.disconnect({ topic: undefined })).rejects.toThrowError(
-          "Missing or invalid. pairing topic should be a string: undefined",
-        );
-      });
-
-      it("throws when non existent topic is provided", async () => {
-        await expect(coreA.pairing.disconnect({ topic: "none" })).rejects.toThrowError(
-          "No matching key. pairing topic doesn't exist: none",
-        );
-      });
-    });
-  });
-  describe("events", () => {
-    it("should emit 'pairing_create' event", async () => {
-      let pairingCreatedEvent = false;
-      coreB.pairing.events.on(PAIRING_EVENTS.create, () => (pairingCreatedEvent = true));
-      const { uri } = await coreA.pairing.create();
-      coreB.pairing.pair({ uri });
-      await waitForEvent(() => pairingCreatedEvent);
-    });
-    it("should store pairing before subscribing to its topic", async () => {
-      let pairingCreatedEvent = false;
-      let pairingCreatedEventTime = 0;
-      let subscriptionCreatedEvent = false;
-      let subscriptionCreatedEventTime = 0;
-      const { uri } = await coreA.pairing.create();
-      const { topic } = parseUri(uri);
-      coreB.pairing.events.on(PAIRING_EVENTS.create, () => {
-        pairingCreatedEventTime = performance.now();
-        pairingCreatedEvent = true;
-      });
-
-      coreB.relayer.subscriber.events.on(SUBSCRIBER_EVENTS.created, () => {
-        subscriptionCreatedEventTime = performance.now();
-        subscriptionCreatedEvent = true;
-      });
-
-      coreB.pairing.pair({ uri });
-      await waitForEvent(() => pairingCreatedEvent);
-      await waitForEvent(() => subscriptionCreatedEvent);
-      expect(coreB.pairing.pairings.keys.length).toBe(1);
-      expect(coreB.pairing.pairings.values[0].topic).toEqual(topic);
-      expect(subscriptionCreatedEventTime).toBeGreaterThan(pairingCreatedEventTime);
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/persistence.spec.ts">
-import { expect, describe, it, beforeEach, afterEach } from "vitest";
-import { ICore, IStore } from "@walletconnect/types";
-import {
-  MockStoreValue,
-  TEST_CORE_OPTIONS,
-  disconnectSocket,
-  initCore,
-  initStore,
-  restartCore,
-  searchRecords,
-  storeTestValues,
-  waitForEvent,
-} from "./shared";
-import { Core } from "../src";
-import { generateRandomBytes32 } from "@walletconnect/utils";
-
-describe("Persistence", () => {
-  let core: ICore;
-  let store: IStore<string, MockStoreValue>;
-
-  beforeEach(async () => {
-    core = await initCore();
-  });
-
-  afterEach(async () => {
-    await disconnectSocket(core.relayer);
-  });
-
-  it("should persist store values across restarts", async () => {
-    store = await initStore(core);
-    await restartCore();
-    expect(store.getAll()).to.toMatchObject(storeTestValues);
-  });
-
-  it("should persist store values of PAIRINGS across restarts", async () => {
-    // --- setup ---
-    const coreA = core; // alias for clarity
-    const coreB = new Core(TEST_CORE_OPTIONS);
-    await coreB.start();
-
-    // --- after restart routine ---
-    const afterRestart = async () => {
-      const { uri, topic } = await coreA.pairing.create();
-      let hasDeleted = false;
-      coreA.pairing.events.on("pairing_delete", () => {
-        hasDeleted = true;
-      });
-
-      await coreB.pairing.pair({ uri });
-
-      // pairing was created
-      expect(coreA.pairing.pairings.keys.length).toBe(1);
-      expect(coreB.pairing.pairings.keys.length).toBe(1);
-
-      // topic does not exist in history
-      expect(searchRecords(coreA.history.records, topic)).toBe(false);
-      expect(searchRecords(coreB.history.records, topic)).toBe(false);
-
-      // ensure that keychain is updated
-      expect(coreA.crypto.keychain.keychain.has(topic)).toBe(true);
-      expect(coreB.crypto.keychain.keychain.has(topic)).toBe(true);
-
-      // ensure that expiry is updated
-      expect(coreA.expirer.values.length).toBe(1);
-      expect(coreB.expirer.values.length).toBe(1);
-
-      await coreB.pairing.disconnect({ topic });
-
-      await waitForEvent(() => hasDeleted);
-
-      // pairing was deleted
-      expect(coreA.pairing.pairings.keys.length).toBe(0);
-      expect(coreB.pairing.pairings.keys.length).toBe(0);
-
-      // topic was added to history
-      expect(searchRecords(coreA.history.records, topic)).toBe(true);
-      expect(searchRecords(coreB.history.records, topic)).toBe(true);
-
-      // keychain was updated
-      expect(coreA.crypto.keychain.keychain.has(topic)).toBe(false);
-      expect(coreB.crypto.keychain.keychain.has(topic)).toBe(false);
-
-      // ensure that expiry is updated
-      expect(coreA.expirer.values.length).toBe(0);
-      expect(coreB.expirer.values.length).toBe(0);
-    };
-
-    // start routine
-    await restartCore(undefined, afterRestart);
-
-    // final check of pairings
-    expect(coreA.pairing.getPairings()).to.deep.equal(coreB.pairing.getPairings());
-  });
-
-  it("should persist store values of SESSIONS across restarts", async () => {
-    // --- setup ---
-    const subscriber = core.relayer.subscriber;
-    const datashare = { topic: generateRandomBytes32() };
-
-    // --- before core restarts routine ---
-    const beforeRestart = async () => {
-      const topic = generateRandomBytes32();
-      await subscriber.subscribe(topic);
-      datashare.topic = topic;
-    };
-
-    // --- after core restarts routine ---
-    const afterRestart = async () => {
-      // check that the session, topic were restored
-      expect(subscriber.subscriptions.size).to.equal(1);
-      expect(subscriber.topics).to.contain(datashare.topic);
-
-      await subscriber.unsubscribe(datashare.topic);
-
-      // check that the session, topic were cleared correctly
-      expect(subscriber.subscriptions.size).to.equal(0);
-      expect(subscriber.topics.length).to.equal(0);
-    };
-
-    // start routine
-    await restartCore(beforeRestart, afterRestart);
-  });
-});
-</file>
-
-<file path="packages/core/test/publisher.spec.ts">
-import { expect, describe, it, beforeEach, afterEach } from "vitest";
-import Sinon from "sinon";
-import { ICore } from "@walletconnect/types";
-import { generateRandomBytes32, hashMessage } from "@walletconnect/utils";
-import { Publisher } from "../src/controllers/publisher";
-import { HEARTBEAT_EVENTS } from "@walletconnect/heartbeat";
-
-import { Core, PUBLISHER_DEFAULT_TTL, RELAYER_EVENTS } from "../src";
-import { disconnectSocket, TEST_CORE_OPTIONS, throttle } from "./shared";
-import { getBigIntRpcId } from "@walletconnect/jsonrpc-utils";
-
-const getId = () => {
-  return getBigIntRpcId().toString() as any;
-};
-
-describe("Publisher", () => {
-  let core: ICore;
-  let publisher: Publisher;
-
-  beforeEach(async () => {
-    core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    publisher = core.relayer.publisher as Publisher;
-  });
-
-  afterEach(async () => {
-    await disconnectSocket(core.relayer);
-  });
-
-  describe("init", () => {
-    it("should process queue", async () => {
-      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 0 };
-      const items = [
-        {
-          topic: generateRandomBytes32(),
-          message: "itemA",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemB",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemC",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemD",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemE",
-          opts: { ...opts, id: getId() },
-        },
-      ];
-
-      const requestSpy = Sinon.spy();
-      publisher.relayer.request = requestSpy;
-
-      // Manually set some items in the queue.
-      items.forEach((item) => publisher.queue.set(item.opts.id.toString(), item));
-      expect(publisher.queue.size).to.equal(items.length);
-      // Emit heartbeat pulse event
-      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
-
-      // Emit ACKs
-      items.forEach((item) =>
-        core.relayer.events.emit(RELAYER_EVENTS.message_ack, { id: item.opts.id }),
-      );
-
-      // -> Queue should clear after the ACKs.
-      expect(publisher.queue.size).to.equal(0);
-      // Emit heartbeat pulse event
-      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
-      await throttle(100);
-      // Emit heartbeat pulse event
-      publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
-
-      // -> Queue should still be clear after the pulses.
-      expect(publisher.queue.size).to.equal(0);
-      // -> `request` should not have been called more times than the n items regardless of the n of pulses.
-      expect(requestSpy.callCount).to.equal(items.length);
-    });
-    it("should process queue with delayed ACK", () => {
-      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 0 };
-      const items = [
-        {
-          topic: generateRandomBytes32(),
-          message: "itemA",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemB",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemC",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemD",
-          opts: { ...opts, id: getId() },
-        },
-        {
-          topic: generateRandomBytes32(),
-          message: "itemE",
-          opts: { ...opts, id: getId() },
-        },
-      ];
-
-      const requestSpy = Sinon.spy();
-      publisher.relayer.request = requestSpy;
-
-      // Manually set some items in the queue.
-      items.forEach((item) => publisher.queue.set(item.opts.id.toString(), item));
-      expect(publisher.queue.size).to.equal(items.length);
-
-      const pulsesBeforeAck = 5;
-      // emit multiple pulses to ensure queue is works correctly if ACK is delayed
-      Array.from(Array(pulsesBeforeAck).keys()).forEach(async () => {
-        publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
-        await throttle(100);
-      });
-
-      // Emit ACKs
-      items.forEach((item) =>
-        core.relayer.events.emit(RELAYER_EVENTS.message_ack, { id: item.opts.id }),
-      );
-
-      // -> Queue should clear after the ACKs.
-      expect(publisher.queue.size).to.equal(0);
-      // -> all requests should have been sent once per pulse
-      const expectedCallCount = items.length * pulsesBeforeAck;
-      expect(requestSpy.callCount).to.equal(expectedCallCount);
-
-      const pulsesAfterAck = 5;
-      // emit additional pulses
-      Array.from(Array(pulsesAfterAck).keys()).forEach(async () => {
-        publisher.relayer.core.heartbeat.events.emit(HEARTBEAT_EVENTS.pulse);
-        await throttle(100);
-      });
-
-      // request count should stay the same even after additional pulses
-      expect(requestSpy.callCount).to.equal(expectedCallCount);
-    });
-  });
-
-  describe("publish", () => {
-    let topic: string;
-    let requestSpy: Sinon.SinonSpy;
-
-    beforeEach(() => {
-      requestSpy = Sinon.spy();
-      topic = generateRandomBytes32();
-      publisher.relayer.request = requestSpy;
-    });
-
-    it("calls `provider.request` with the expected request shape", async () => {
-      const message = "test message";
-      const id = getId();
-      await publisher.publish(topic, message, { id });
-      expect(requestSpy.callCount).to.equal(1);
-      expect(requestSpy.getCall(0).args[0]).to.deep.equal({
-        method: "irn_publish",
-        params: {
-          topic,
-          message,
-          prompt: false,
-          ttl: PUBLISHER_DEFAULT_TTL,
-          tag: 0,
-          attestation: undefined,
-        },
-        id,
-      });
-    });
-    it("allows overriding of defaults via `opts` param", async () => {
-      const message = "test message";
-      const opts = { ttl: 1, prompt: true, relay: { protocol: "irn" }, tag: 1, id: getId(1) };
-      await publisher.publish(topic, message, opts);
-      expect(requestSpy.callCount).to.equal(1);
-      expect(requestSpy.getCall(0).args[0]).to.deep.equal({
-        method: "irn_publish",
-        params: {
-          topic,
-          message,
-          prompt: opts.prompt,
-          ttl: opts.ttl,
-          tag: opts.tag,
-          attestation: undefined,
-        },
-        id: opts.id,
-      });
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/relayer.spec.ts">
-import { expect, describe, it, beforeEach, afterEach, vi } from "vitest";
-import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
-import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";
-
-import {
-  Core,
-  CORE_DEFAULT,
-  Relayer,
-  RELAYER_DEFAULT_RELAY_URL,
-  RELAYER_EVENTS,
-  RELAYER_PROVIDER_EVENTS,
-  RELAYER_SUBSCRIBER_SUFFIX,
-  SUBSCRIBER_EVENTS,
-  TRANSPORT_TYPES,
-} from "../src";
-import {
-  disconnectSocket,
-  TEST_MOBILE_APP_ID,
-  TEST_CORE_OPTIONS,
-  TEST_PROJECT_ID_MOBILE,
-  throttle,
-} from "./shared";
-import { ICore, IRelayer, ISubscriber } from "@walletconnect/types";
-import Sinon from "sinon";
-import { JsonRpcRequest } from "@walletconnect/jsonrpc-utils";
-import { createExpiringPromise, generateRandomBytes32, hashMessage } from "@walletconnect/utils";
-import * as utils from "@walletconnect/utils";
-
-describe("Relayer", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
-
-  let core: ICore;
-  let relayer: IRelayer;
-  const randomTopic = generateRandomBytes32();
-
-  describe("init", () => {
-    let initSpy: Sinon.SinonSpy;
-    beforeEach(async () => {
-      initSpy = Sinon.spy();
-      core = new Core(TEST_CORE_OPTIONS);
-      relayer = core.relayer;
-      await core.start();
-      relayer.subscriber.topicMap.set(randomTopic, randomTopic);
-    });
-    afterEach(async () => {
-      await disconnectSocket(relayer);
-    });
-
-    it("should not throw unhandled on network disconnect when there is no provider instance", async () => {
-      relayer.messages.init = initSpy;
-      relayer.subscriber.topicMap.clear();
-      await relayer.init();
-      expect(relayer.provider).to.be.empty;
-      expect(relayer.connected).to.be.false;
-      // @ts-expect-error - private property
-      relayer.hasExperiencedNetworkDisruption = true;
-      // @ts-expect-error - private method
-      await relayer.transportDisconnect();
-    });
-    it("initializes a MessageTracker", async () => {
-      relayer.messages.init = initSpy;
-      await relayer.init();
-      expect(initSpy.calledOnce).to.be.true;
-    });
-    it("initializes a Subscriber", async () => {
-      relayer.subscriber.init = initSpy;
-      await relayer.init();
-      expect(initSpy.calledOnce).to.be.true;
-    });
-    it("initializes a Publisher", async () => {
-      relayer.subscriber.init = initSpy;
-      await relayer.init();
-      expect(initSpy.calledOnce).to.be.true;
-    });
-    it("initializes a JsonRpcProvider", async () => {
-      expect(relayer.provider).to.be.empty;
-      await relayer.init();
-      await relayer.transportOpen();
-      expect(relayer.provider).not.to.be.empty;
-      expect(relayer.provider instanceof JsonRpcProvider).to.be.true;
-    });
-    it("registers provider event listeners", async () => {
-      const emitSpy = Sinon.spy();
-      await relayer.init();
-      await relayer.transportOpen();
-      relayer.events.emit = emitSpy;
-      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.connect);
-      expect(emitSpy.calledOnceWith(RELAYER_EVENTS.connect)).to.be.true;
-    });
-  });
-
-  describe("publish", () => {
-    beforeEach(async () => {
-      core = new Core(TEST_CORE_OPTIONS);
-      relayer = core.relayer;
-      await core.start();
-    });
-
-    const topic = "abc123";
-    const message = "publish me";
-    it("calls `publisher.publish` with provided args", async () => {
-      const spy = Sinon.spy();
-      relayer.publisher.publish = spy;
-      await relayer.publish(topic, message);
-      expect(spy.calledOnceWith(topic, message)).to.be.true;
-    });
-    it("records a message with provided args", async () => {
-      const spy = Sinon.spy();
-      relayer.publisher.publish = () => Promise.resolve();
-      relayer.messages.set = spy;
-      await relayer.publish(topic, message);
-      expect(spy.calledOnceWith(topic, message)).to.be.true;
-    });
-  });
-
-  describe("subscribe", () => {
-    beforeEach(async () => {
-      core = new Core(TEST_CORE_OPTIONS);
-      relayer = core.relayer;
-      await core.start();
-    });
-    it("returns the id provided by calling `subscriber.subscribe` with the passed topic", async () => {
-      const spy = Sinon.spy(
-        (topic) =>
-          new Promise((resolve) => {
-            relayer.subscriber.events.emit(SUBSCRIBER_EVENTS.created, { topic });
-            resolve(topic);
-          }),
-      );
-      relayer.subscriber.subscribe = spy;
-
-      const testTopic = "abc123";
-      let id;
-      await new Promise<void>(async (resolve) => {
-        id = await relayer.subscribe(testTopic);
-        resolve();
-      });
-      // @ts-expect-error
-      expect(spy.calledOnceWith(testTopic)).to.be.true;
-      expect(id).to.eq(testTopic);
-    });
-
-    it("should subscribe multiple topics", async () => {
-      const spy = Sinon.spy(
-        (topic) =>
-          new Promise((resolve) => {
-            relayer.subscriber.events.emit(SUBSCRIBER_EVENTS.created, { topic });
-            resolve(topic);
-          }),
-      );
-      relayer.subscriber.subscribe = spy;
-      const subscriber = relayer.subscriber as ISubscriber;
-      // record the number of listeners before subscribing
-      const startNumListeners = subscriber.events.listenerCount(SUBSCRIBER_EVENTS.created);
-      const topicsToSubscribe = Array.from(Array(5).keys()).map(() => generateRandomBytes32());
-      const subscribePromises = topicsToSubscribe.map((topic) => relayer.subscribe(topic));
-      await Promise.all([...subscribePromises]);
-      // expect the number of listeners to be the same as before subscribing to confirm proper cleanup
-      expect(subscriber.events.listenerCount(SUBSCRIBER_EVENTS.created)).to.eq(startNumListeners);
-    });
-
-    it("should throw when subscribe reaches a publish timeout", async () => {
-      relayer.subscriber.subscribeTimeout = 5_000;
-      relayer.request = () => {
-        return new Promise<void>((_, reject) => {
-          setTimeout(() => {
-            reject(new Error("Subscription timeout"));
-          }, 100_000);
-        });
-      };
-      const topic = generateRandomBytes32();
-      await expect(relayer.subscribe(topic)).rejects.toThrow(
-        `Subscribing to ${topic} failed, please try again`,
-      );
-    });
-
-    it("should throw when subscribe publish fails", async () => {
-      await relayer.transportOpen();
-      await relayer.toEstablishConnection();
-      relayer.subscriber.subscribeTimeout = 5_000;
-      relayer.request = () => {
-        return new Promise<void>((resolve) => {
-          resolve();
-        });
-      };
-      const topic = generateRandomBytes32();
-      await expect(relayer.subscribe(topic)).rejects.toThrow(
-        `Subscribing to ${topic} failed, please try again`,
-      );
-    });
-
-    it("should be able to resubscribe on topic that already exists", async () => {
-      const topic = generateRandomBytes32();
-      const id = await relayer.subscribe(topic);
-      const expectedId = hashMessage(topic + (await core.crypto.getClientId()));
-      const a = await relayer.subscribe(topic);
-      const b = await relayer.subscribe(topic);
-      const c = await relayer.subscribe(topic);
-      expect(a).to.equal(id);
-      expect(a).to.equal(b);
-      expect(b).to.equal(c);
-      expect(a).to.equal(expectedId);
-      expect(b).to.equal(expectedId);
-      expect(c).to.equal(expectedId);
-      expect(id).to.equal(expectedId);
-    });
-  });
-
-  describe("unsubscribe", () => {
-    beforeEach(async () => {
-      core = new Core(TEST_CORE_OPTIONS);
-      relayer = core.relayer;
-      await core.start();
-      relayer.subscriber.topicMap.set(randomTopic, randomTopic);
-      await relayer.transportOpen();
-    });
-    it("calls `subscriber.unsubscribe` with the passed topic", async () => {
-      const spy = Sinon.spy();
-      relayer.subscriber.unsubscribe = spy;
-      await relayer.unsubscribe("abc123");
-      expect(spy.calledOnceWith("abc123")).to.be.true;
-    });
-
-    describe("onProviderPayload", () => {
-      const validPayload: JsonRpcRequest = {
-        id: 123,
-        jsonrpc: "2.0",
-        method: "mock" + RELAYER_SUBSCRIBER_SUFFIX,
-        params: {
-          id: "abc123",
-          data: {
-            topic: "ababab",
-            message: "deadbeef",
-            publishedAt: 1677151760537,
-            transportType: TRANSPORT_TYPES.relay,
-            attestation: undefined,
-          },
-        },
-      };
-
-      it("does nothing if payload is not a valid JsonRpcRequest.", () => {
-        const spy = Sinon.spy();
-        relayer.events.emit = spy;
-        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, {});
-        expect(spy.notCalled).to.be.true;
-      });
-      it(`does nothing if payload.method does not have the ${RELAYER_SUBSCRIBER_SUFFIX} suffix`, () => {
-        const spy = Sinon.spy();
-        relayer.events.emit = spy;
-        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, {
-          ...validPayload,
-          method: "mock",
-        });
-        expect(spy.notCalled).to.be.true;
-      });
-      it("emits an event based on `payload.params.id`", () => {
-        const spy = Sinon.spy();
-        relayer.events.emit = spy;
-        relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.payload, validPayload);
-        expect(
-          spy.calledOnceWith(validPayload.params.id, {
-            topic: validPayload.params.data.topic,
-            message: validPayload.params.data.message,
-            publishedAt: validPayload.params.data.publishedAt,
-            transportType: validPayload.params.data.transportType,
-            attestation: validPayload.params.data.attestation,
-          }),
-        ).to.be.true;
-      });
-    });
-    describe("transport", () => {
-      beforeEach(async () => {
-        core = new Core(TEST_CORE_OPTIONS);
-        relayer = core.relayer;
-        await core.start();
-        relayer.subscriber.subscriptions.set(randomTopic, {
-          topic: randomTopic,
-          id: randomTopic,
-          relay: { protocol: "irn" },
-        });
-      });
-      it("should restart transport after connection drop", async () => {
-        const randomSessionIdentifier = relayer.core.crypto.randomSessionIdentifier;
-        await relayer.transportOpen();
-        const timeout = setTimeout(() => {
-          throw new Error("Connection did not restart after disconnect");
-        }, 5_001);
-        await Promise.all([
-          new Promise<void>((resolve) => {
-            relayer.once(RELAYER_EVENTS.connect, () => {
-              expect(relayer.connected).to.be.true;
-              resolve();
-            });
-          }),
-          new Promise<void>((resolve) => {
-            relayer.once(RELAYER_EVENTS.disconnect, () => {
-              expect(relayer.connected).to.be.false;
-              resolve();
-            });
-          }),
-          relayer.provider.connection.close(),
-        ]);
-        clearTimeout(timeout);
-        // the identifier should be the same
-        expect(relayer.core.crypto.randomSessionIdentifier).to.eq(randomSessionIdentifier);
-      });
-      it("should connect once regardless of the number of disconnect events", async () => {
-        const disconnectsToEmit = 10;
-        let disconnectsReceived = 0;
-        let connectReceived = 0;
-        relayer.on(RELAYER_EVENTS.connect, () => {
-          connectReceived++;
-        });
-        relayer.on(RELAYER_EVENTS.disconnect, () => {
-          disconnectsReceived++;
-        });
-        await Promise.all(
-          Array.from(Array(disconnectsToEmit).keys()).map(() => relayer.onDisconnectHandler()),
-        );
-        await throttle(5_000);
-        expect(connectReceived).to.eq(1);
-        expect(disconnectsReceived).to.eq(disconnectsToEmit);
-      });
-
-      it("should not start wss connection on init without subscriber topics", async () => {
-        relayer = new Relayer({
-          core,
-          relayUrl: TEST_CORE_OPTIONS.relayUrl,
-          projectId: TEST_CORE_OPTIONS.projectId,
-        });
-        await relayer.init();
-        await throttle(1_000); // +1 sec buffer
-        expect(relayer.connected).to.be.false;
-      });
-
-      it("should start transport on subscribe attempt", async () => {
-        relayer = new Relayer({
-          core,
-          relayUrl: TEST_CORE_OPTIONS.relayUrl,
-          projectId: TEST_CORE_OPTIONS.projectId,
-        });
-        await relayer.init();
-        expect(relayer.connected).to.be.false;
-        const topic = generateRandomBytes32();
-        await relayer.subscribe(topic);
-        await throttle(1_000); // +1 sec buffer
-        expect(relayer.connected).to.be.true;
-      });
-      it(`should connect to ${RELAYER_DEFAULT_RELAY_URL} relay url`, async () => {
-        relayer = new Relayer({
-          core,
-          projectId: TEST_CORE_OPTIONS.projectId,
-        });
-        await relayer.init();
-        relayer.subscriber.subscriptions.set(randomTopic, {
-          topic: randomTopic,
-          id: randomTopic,
-          relay: { protocol: "irn" },
-        });
-        await relayer.transportOpen();
-        const wsConnection = relayer.provider.connection as unknown as WebSocket;
-        expect(relayer.connected).to.be.true;
-        expect(wsConnection.url.startsWith(RELAYER_DEFAULT_RELAY_URL)).to.be.true;
-      });
-      it("should not throw an error if terminate() is not available", async () => {
-        const relayer = new Relayer({
-          core,
-          relayUrl: TEST_CORE_OPTIONS.relayUrl,
-          projectId: TEST_CORE_OPTIONS.projectId,
-        });
-        await relayer.init();
-        relayer.subscriber.subscriptions.set(randomTopic, {
-          topic: randomTopic,
-          id: randomTopic,
-          relay: { protocol: "irn" },
-        });
-        await relayer.transportOpen();
-        expect(relayer.connected).to.be.true;
-        //@ts-expect-error - private property
-        relayer.provider.connection.socket.terminate = undefined;
-        //@ts-expect-error - private property
-        relayer.heartBeatTimeout = 1000;
-        //@ts-expect-error - private method
-        relayer.resetPingTimeout();
-        await throttle(2000);
-        await relayer.transportClose();
-        expect(relayer.connected).to.be.false;
-      });
-    });
-  });
-  describe("packageName and bundleId validations", () => {
-    beforeEach(async () => {
-      core = new Core({ ...TEST_CORE_OPTIONS, projectId: TEST_PROJECT_ID_MOBILE });
-      relayer = core.relayer;
-      await core.start();
-    });
-
-    it("[Android] packageName included in Cloud Settings - should connect", async () => {
-      // Mock Android environment
-      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
-      vi.spyOn(utils, "isIos").mockReturnValue(false);
-      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);
-
-      relayer = new Relayer({
-        core,
-        relayUrl: TEST_CORE_OPTIONS.relayUrl,
-        projectId: TEST_PROJECT_ID_MOBILE,
-      });
-
-      await relayer.init();
-      await relayer.subscribe(randomTopic);
-
-      // @ts-expect-error - accessing private property for testing
-      const wsUrl = relayer.provider.connection.url;
-      expect(wsUrl).to.include(`packageName=${TEST_MOBILE_APP_ID}`);
-      expect(relayer.connected).to.be.true;
-    });
-
-    it("[Android] packageName undefined - should connect", async () => {
-      // Mock Android environment
-      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
-      vi.spyOn(utils, "isIos").mockReturnValue(false);
-      vi.spyOn(utils, "getAppId").mockReturnValue(undefined);
-
-      relayer = new Relayer({
-        core,
-        relayUrl: TEST_CORE_OPTIONS.relayUrl,
-        projectId: TEST_PROJECT_ID_MOBILE,
-      });
-
-      await relayer.init();
-      await relayer.subscribe(randomTopic);
-
-      // @ts-expect-error - accessing private property for testing
-      const wsUrl = relayer.provider.connection.url;
-      expect(wsUrl).not.to.include("packageName=");
-      expect(relayer.connected).to.be.true;
-    });
-
-    it("[Android] packageName not included in Cloud Settings - should fail", async () => {
-      // Mock Android environment
-      vi.spyOn(utils, "isAndroid").mockReturnValue(true);
-      vi.spyOn(utils, "isIos").mockReturnValue(false);
-      vi.spyOn(utils, "getAppId").mockReturnValue("com.example.wrong");
-
-      relayer = new Relayer({
-        core,
-        relayUrl: TEST_CORE_OPTIONS.relayUrl,
-        projectId: TEST_PROJECT_ID_MOBILE,
-      });
-
-      await relayer.init();
-
-      relayer.subscriber.subscriptions.set(randomTopic, {
-        topic: randomTopic,
-        id: randomTopic,
-        relay: { protocol: "irn" },
-      });
-
-      let errorReceived = false;
-      relayer.on(RELAYER_EVENTS.error, (payload) => {
-        expect(payload.message).to.include("Unauthorized: origin not allowed");
-        errorReceived = true;
-      });
-      await relayer.transportOpen().catch((e) => {});
-      await throttle(1000);
-      expect(errorReceived).to.be.true;
-    });
-
-    it("[iOS] bundleId included in Cloud Settings - should connect", async () => {
-      // Mock iOS environment
-      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
-      vi.spyOn(utils, "isIos").mockReturnValue(true);
-      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);
-
-      relayer = new Relayer({
-        core,
-        relayUrl: TEST_CORE_OPTIONS.relayUrl,
-        projectId: TEST_PROJECT_ID_MOBILE,
-      });
-
-      await relayer.init();
-      await relayer.subscribe(randomTopic);
-
-      // @ts-expect-error - accessing private property for testing
-      const wsUrl = relayer.provider.connection.url;
-      expect(wsUrl).to.include(`bundleId=${TEST_MOBILE_APP_ID}`);
-    });
-
-    it("[iOS] bundleId undefined - should connect", async () => {
-      // Mock iOS environment
-      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
-      vi.spyOn(utils, "isIos").mockReturnValue(true);
-      vi.spyOn(utils, "getAppId").mockReturnValue(undefined);
-
-      relayer = new Relayer({
-        core,
-        relayUrl: TEST_CORE_OPTIONS.relayUrl,
-        projectId: TEST_PROJECT_ID_MOBILE,
-      });
-
-      await relayer.init();
-      relayer.subscriber.subscriptions.set(randomTopic, {
-        topic: randomTopic,
-        id: randomTopic,
-        relay: { protocol: "irn" },
-      });
-      await relayer.transportOpen();
-
-      // @ts-expect-error - accessing private property for testing
-      const wsUrl = relayer.provider.connection.url;
-      expect(wsUrl).not.to.include("bundleId=");
-      expect(relayer.connected).to.be.true;
-    });
-
-    it("[iOS] bundleId not included in Cloud Settings - should fail", async () => {
-      // Mock iOS environment
-      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
-      vi.spyOn(utils, "isIos").mockReturnValue(true);
-      vi.spyOn(utils, "getAppId").mockReturnValue("com.example.wrong");
-
-      relayer = new Relayer({
-        core,
-        relayUrl: TEST_CORE_OPTIONS.relayUrl,
-        projectId: TEST_PROJECT_ID_MOBILE,
-      });
-
-      await relayer.init();
-      relayer.subscriber.subscriptions.set(randomTopic, {
-        topic: randomTopic,
-        id: randomTopic,
-        relay: { protocol: "irn" },
-      });
-
-      let errorReceived = false;
-      relayer.on(RELAYER_EVENTS.error, (payload) => {
-        expect(payload.message).to.include("Unauthorized: origin not allowed");
-        errorReceived = true;
-      });
-
-      await relayer.transportOpen().catch((e) => {});
-
-      await throttle(1000);
-      expect(errorReceived).to.be.true;
-    });
-
-    it("[Web] packageName and bundleId not set - should connect", async () => {
-      // Mock non-mobile environment
-      vi.spyOn(utils, "isAndroid").mockReturnValue(false);
-      vi.spyOn(utils, "isIos").mockReturnValue(false);
-      vi.spyOn(utils, "getAppId").mockReturnValue(TEST_MOBILE_APP_ID);
-
-      relayer = new Relayer({
-        core,
-        relayUrl: TEST_CORE_OPTIONS.relayUrl,
-        projectId: TEST_PROJECT_ID_MOBILE,
-      });
-
-      await relayer.init();
-      relayer.subscriber.subscriptions.set(randomTopic, {
-        topic: randomTopic,
-        id: randomTopic,
-        relay: { protocol: "irn" },
-      });
-      await relayer.transportOpen();
-
-      // @ts-expect-error - accessing private property for testing
-      const wsUrl = relayer.provider.connection.url;
-      expect(wsUrl).not.to.include("packageName=");
-      expect(wsUrl).not.to.include("bundleId=");
-    });
-
-    afterEach(() => {
-      vi.restoreAllMocks();
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/store.spec.ts">
-import { expect, describe, it, beforeEach } from "vitest";
-import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
-import { Core, CORE_STORAGE_PREFIX, Store, STORE_STORAGE_VERSION } from "../src";
-import { TEST_CORE_OPTIONS } from "./shared";
-import { ICore, IStore, SessionTypes } from "@walletconnect/types";
-
-const MOCK_STORE_NAME = "mock-entity";
-
-describe("Store", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: "fatal" }));
-
-  let core: ICore;
-  type MockValue = { id: string; value: string };
-  let store: IStore<any, any>;
-
-  beforeEach(async () => {
-    core = new Core(TEST_CORE_OPTIONS);
-    store = new Store(core, logger, MOCK_STORE_NAME);
-    await store.init();
-  });
-
-  describe("storageKey", () => {
-    it("provides the expected default `storageKey` format", () => {
-      const store = new Store(core, logger, MOCK_STORE_NAME);
-      expect(store.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + "//" + MOCK_STORE_NAME,
-      );
-    });
-    it("provides the expected custom `storageKey` format", () => {
-      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-      const store = new Store(core, logger, MOCK_STORE_NAME);
-      expect(store.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + ":test" + "//" + MOCK_STORE_NAME,
-      );
-    });
-  });
-
-  describe("init", () => {
-    const ids = ["1", "2", "3", "foo"];
-    const STORAGE_KEY = CORE_STORAGE_PREFIX + STORE_STORAGE_VERSION + "//" + MOCK_STORE_NAME;
-
-    beforeEach(() => {
-      const cachedValues = ids.map((id) => ({ id, value: "foo" }));
-      core.storage.setItem(STORAGE_KEY, cachedValues);
-    });
-
-    it("retrieves from cache using getKey", async () => {
-      const store = new Store<string, MockValue>(
-        core,
-        logger,
-        MOCK_STORE_NAME,
-        undefined,
-        (val) => val.id,
-      );
-      await store.init();
-      for (const id of ids) {
-        expect(store.keys).includes(id);
-      }
-    });
-
-    it("safely overwrites values when retrieving from cache using getKey", async () => {
-      const store = new Store<string, MockValue>(
-        core,
-        logger,
-        MOCK_STORE_NAME,
-        undefined,
-        (val) => val.value,
-      );
-      await store.init();
-      expect(store.keys).to.eql(["foo"]);
-    });
-
-    it("handles null and undefined cases", async () => {
-      core.storage.setItem(STORAGE_KEY, [undefined, null, { id: 1, value: "foo" }]);
-      const store = new Store<string, MockValue>(
-        core,
-        logger,
-        MOCK_STORE_NAME,
-        undefined,
-        (val) => val.value,
-      );
-      await store.init();
-      expect(store.keys).to.eql(["foo"]);
-    });
-  });
-
-  describe("set", () => {
-    it("creates a new entry for a new key", async () => {
-      const key = "newKey";
-      const value = {
-        topic: "abc123",
-        expiry: 1000,
-      } as SessionTypes.Struct;
-      await store.set(key, value);
-      expect(store.length).to.equal(1);
-      expect(store.keys.includes(key)).to.be.true;
-      expect(store.values.includes(value)).to.be.true;
-    });
-    it("updates an existing entry for a known key", async () => {
-      const key = "key";
-      const value = {
-        topic: "111",
-        expiry: 1000,
-      } as SessionTypes.Struct;
-      const updatedValue = {
-        topic: "222",
-        expiry: 1000,
-      } as SessionTypes.Struct;
-      await store.set(key, value);
-      await store.set(key, updatedValue);
-      expect(store.length).to.equal(1);
-      expect(store.map.has(key)).to.be.true;
-      expect(store.values.some((val: any) => val.topic === updatedValue.topic)).to.be.true;
-    });
-  });
-
-  describe("get", () => {
-    it("returns the value for a known key", async () => {
-      const key = "key";
-      const value = {
-        topic: "abc123",
-        expiry: 1000,
-      } as SessionTypes.Struct;
-      await store.set(key, value);
-      expect(await store.get(key)).to.equal(value);
-    });
-    it("throws with expected error if passed an unknown key", () => {
-      const unknownKey = "unknown";
-      expect(() => store.get(unknownKey)).to.throw(
-        `No matching key. ${MOCK_STORE_NAME}: ${unknownKey}`,
-      );
-    });
-  });
-
-  describe("delete", () => {
-    it("removes a known key from the map", async () => {
-      const key = "key";
-      const value = {
-        topic: "abc123",
-        expiry: 1000,
-      } as SessionTypes.Struct;
-      await store.set(key, value);
-      expect(store.length).to.equal(1);
-      await store.delete(key, { code: 0, message: "reason" });
-      expect(store.length).to.equal(0);
-    });
-    it("does nothing if key is unknown", async () => {
-      await store.delete("key", { code: 0, message: "reason" });
-      expect(store.length).to.equal(0);
-    });
-    it("should add deleted key to the recentlyDeleted list", async () => {
-      const key = "key";
-      const value = "value";
-      await store.set(key, value);
-      await store.delete(key, { code: 0, message: "reason" });
-      try {
-        await store.get(key);
-      } catch (e) {
-        expect(e.message).to.equal(
-          `Missing or invalid. Record was recently deleted - mock-entity: ${key}`,
-        );
-      }
-    });
-    it("should cleanup recentlyDeleted when size limit is reached", async () => {
-      //@ts-expect-error
-      const itemsToDelete = store.recentlyDeletedLimit - 1;
-      // populate recentlyDeleted just below the limit
-      for (let i = 0; i < itemsToDelete; i++) {
-        const key = `key${i}`;
-        const value = `value${i}`;
-        await store.set(key, value);
-        await store.delete(key, { code: 0, message: "reason" });
-      }
-      //@ts-expect-error
-      expect(store.recentlyDeleted?.length).to.be.greaterThan(1);
-      //@ts-expect-error
-      expect(store.recentlyDeleted?.length).to.equal(itemsToDelete);
-      // add one more to reach the limit
-      await store.set("test", "test");
-      await store.delete("test", { code: 0, message: "reason" });
-
-      // check that the recentlyDeleted list has been halved
-      //@ts-expect-error
-      expect(store.recentlyDeleted?.length).to.be.greaterThan(1);
-      //@ts-expect-error
-      expect(store.recentlyDeleted?.length).to.equal(store.recentlyDeletedLimit / 2);
-    });
-  });
-
-  describe("getAll", () => {
-    const key1 = "key1";
-    const key2 = "key2";
-    const value1 = { topic: "abc123", expiry: 1000, active: false };
-    const value2 = { topic: "abc456", expiry: 1000, active: true };
-
-    it("returns all values if no filter was provided", async () => {
-      await store.set(key1, value1);
-      await store.set(key2, value2);
-      const all = store.getAll();
-      expect(all.length).to.equal(2);
-    });
-    it("only returns values that satisfy filter", async () => {
-      await store.set(key1, value1);
-      await store.set(key2, value2);
-      const filtered = store.getAll({ active: true });
-      expect(filtered.length).to.equal(1);
-      expect(filtered[0].active).to.equal(true);
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/subscriber.spec.ts">
-import { expect, describe, it, beforeEach, afterAll, afterEach } from "vitest";
-import Sinon from "sinon";
-import { getDefaultLoggerOptions, pino } from "@walletconnect/logger";
-import { ICore, IRelayer, ISubscriber } from "@walletconnect/types";
-import { generateRandomBytes32, getRelayProtocolName, hashMessage } from "@walletconnect/utils";
-
-import {
-  Core,
-  CORE_DEFAULT,
-  CORE_STORAGE_PREFIX,
-  MESSAGES_STORAGE_VERSION,
-  RELAYER_PROVIDER_EVENTS,
-  Subscriber,
-  SUBSCRIBER_CONTEXT,
-} from "../src";
-import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";
-
-describe("Subscriber", () => {
-  const logger = pino(getDefaultLoggerOptions({ level: CORE_DEFAULT.logger }));
-
-  let relayer: IRelayer;
-  let subscriber: ISubscriber;
-  let core: ICore;
-
-  beforeEach(async () => {
-    core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-    relayer = core.relayer;
-    subscriber = relayer.subscriber;
-    subscriber.relayer.provider.request = () => Promise.resolve({} as any);
-  });
-
-  afterEach(async () => {
-    await disconnectSocket(core.relayer);
-  });
-
-  describe("init", () => {
-    it.skip("should call batch fetch messages on init when it has cached topics", async () => {
-      const requestSpy: Sinon.SinonSpy = Sinon.spy(() => {
-        return Promise.resolve({} as any);
-      });
-      subscriber.relayer.provider.request = requestSpy;
-
-      const topic = generateRandomBytes32();
-      // manually switch off the subscriber
-      // @ts-expect-error
-      subscriber.onDisconnect();
-      // add a topic to the subscriber as if it was loaded from persistence
-      // @ts-expect-error
-      subscriber.cached = [{ topic, relay: { protocol: "irn" } }];
-
-      // restart the subscriber
-      // @ts-expect-error
-      subscriber.onConnect();
-
-      await new Promise((resolve) => setTimeout(resolve, 2000));
-
-      // first req should be the batch fetch messages call followed by the batch subscribe call
-      expect(requestSpy.getCalls().length).toBe(2);
-      expect(requestSpy.getCalls()[0].args[0].method).toBe("irn_batchFetchMessages");
-      expect(requestSpy.getCalls()[1].args[0].method).toBe("irn_batchSubscribe");
-      expect(
-        requestSpy.calledWith(
-          Sinon.match({
-            method: "irn_batchFetchMessages",
-            params: {
-              topics: [topic],
-            },
-          }),
-        ),
-      ).to.be.true;
-
-      expect(
-        requestSpy.calledWith(
-          Sinon.match({
-            method: "irn_batchSubscribe",
-            params: {
-              topics: [topic],
-            },
-          }),
-        ),
-      ).to.be.true;
-    });
-  });
-
-  describe("storageKey", () => {
-    it("provides the expected default `storageKey` format", () => {
-      const subscriber = new Subscriber(relayer, logger);
-      expect(subscriber.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + "//" + SUBSCRIBER_CONTEXT,
-      );
-    });
-    it("provides the expected custom `storageKey` format", () => {
-      const core = new Core({ ...TEST_CORE_OPTIONS, customStoragePrefix: "test" });
-      const subscriber = new Subscriber(core.relayer, logger);
-      expect(subscriber.storageKey).to.equal(
-        CORE_STORAGE_PREFIX + MESSAGES_STORAGE_VERSION + ":test" + "//" + SUBSCRIBER_CONTEXT,
-      );
-    });
-  });
-
-  describe("init", () => {
-    it("registers event listeners", async () => {
-      expect(subscriber.clientId).to.equal("");
-
-      const topic = generateRandomBytes32();
-      const emitSpy = Sinon.spy();
-      subscriber.events.emit = emitSpy;
-      // subscribe to a topic
-      await subscriber.subscribe(topic);
-      expect(subscriber.subscriptions.size).to.equal(1);
-      expect(subscriber.topics.length).to.equal(1);
-      // relayer.provider emits a `disconnect` event -> should clear both subscriptions and topics.
-      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.disconnect);
-      expect(subscriber.subscriptions.size).to.equal(0);
-      expect(subscriber.topics.length).to.equal(0);
-
-      expect(subscriber.clientId).to.not.equal("");
-    });
-
-    it("should set hasAnyTopics", async () => {
-      const topic = generateRandomBytes32();
-      expect(subscriber.hasAnyTopics).toBe(false);
-      subscriber.topicMap.set(topic, topic);
-      expect(subscriber.hasAnyTopics).toBe(true);
-      subscriber.topicMap.clear();
-      expect(subscriber.hasAnyTopics).toBe(false);
-      // @ts-expect-error - private property
-      subscriber.cached = [{ topic }];
-      expect(subscriber.hasAnyTopics).toBe(true);
-      // @ts-expect-error - private property
-      subscriber.cached = [];
-      expect(subscriber.hasAnyTopics).toBe(false);
-      subscriber.pending.set(topic, { topic });
-      expect(subscriber.hasAnyTopics).toBe(true);
-      subscriber.pending.clear();
-      expect(subscriber.hasAnyTopics).toBe(false);
-    });
-  });
-
-  describe("subscribe", () => {
-    let topic: string;
-    let requestSpy: Sinon.SinonSpy;
-
-    beforeEach(async () => {
-      await relayer.connect();
-      requestSpy = Sinon.spy(() => Promise.resolve(["test-id"]));
-      topic = generateRandomBytes32();
-      subscriber.relayer.provider.request = requestSpy;
-    });
-
-    it("throws if Subscriber was not initialized", async () => {
-      const subscriber = new Subscriber(relayer, logger);
-      await expect(subscriber.subscribe(topic)).rejects.toThrow("Not initialized. subscription");
-    });
-    it("calls `provider.request` with the expected request shape", async () => {
-      await subscriber.subscribe(topic);
-      expect(
-        requestSpy.calledOnceWith(
-          Sinon.match({
-            method: "irn_subscribe",
-            params: {
-              topic,
-            },
-          }),
-        ),
-      ).to.be.true;
-    });
-    it("returns the subscription id", async () => {
-      const id = await subscriber.subscribe(topic);
-      const expectedId = hashMessage(topic + (await core.crypto.getClientId()));
-      expect(id).to.equal(expectedId);
-    });
-    it("should subscribe a topic immediately after connect", async () => {
-      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.disconnect);
-      expect(subscriber.subscriptions.size).to.equal(0);
-      expect(subscriber.topics.length).to.equal(0);
-      relayer.provider.events.emit(RELAYER_PROVIDER_EVENTS.connect);
-      await relayer.subscriber.subscribe(generateRandomBytes32());
-      expect(subscriber.subscriptions.size).to.equal(1);
-      expect(subscriber.topics.length).to.equal(1);
-    });
-  });
-
-  describe("unsubscribe", () => {
-    let topic: string;
-    let requestSpy: Sinon.SinonSpy;
-    let messageDeleteSpy: Sinon.SinonSpy;
-
-    beforeEach(async () => {
-      await relayer.connect();
-      requestSpy = Sinon.spy(() => Promise.resolve(["test-id"]));
-      messageDeleteSpy = Sinon.spy();
-      topic = generateRandomBytes32();
-      subscriber.relayer.provider.request = requestSpy;
-      subscriber.relayer.messages.del = messageDeleteSpy;
-    });
-    it("throws if Subscriber was not initialized", async () => {
-      const subscriber = new Subscriber(relayer, logger);
-      await expect(subscriber.unsubscribe(topic)).rejects.toThrow("Not initialized. subscription");
-    });
-    it("unsubscribes by individual id if `opts.id` is provided", async () => {
-      const id = "test-id";
-      await subscriber.unsubscribe(topic, { id, relay: getRelayProtocolName() });
-      expect(messageDeleteSpy.calledOnceWith(topic)).to.be.true;
-      expect(
-        requestSpy.calledOnceWith(
-          Sinon.match({
-            method: "irn_unsubscribe",
-            params: {
-              topic,
-            },
-          }),
-        ),
-      ).to.be.true;
-    });
-    it("unsubscribes by topic by default", async () => {
-      await subscriber.subscribe(topic);
-      expect(subscriber.topics.length).to.equal(1);
-      await subscriber.unsubscribe(topic);
-      expect(subscriber.topics.length).to.equal(0);
-      expect(
-        requestSpy.getCall(1).calledWith(
-          Sinon.match({
-            method: "irn_unsubscribe",
-            params: {
-              topic,
-            },
-          }),
-        ),
-      ).to.be.true;
-    });
-  });
-});
-</file>
-
-<file path="packages/core/test/verify.spec.ts">
-import { expect, describe, it } from "vitest";
-import { hashMessage } from "@walletconnect/utils";
-
-import { Core, VERIFY_SERVER } from "../src";
-import { disconnectSocket, TEST_CORE_OPTIONS } from "./shared";
-
-// TODO: re-enable this suite when we have a way to provide/mock CSRF token now required by the server.
-describe.skip("verify", () => {
-  it("should register attestation", async () => {
-    const core = new Core(TEST_CORE_OPTIONS);
-    await core.start();
-
-    expect(core.expirer.length).to.eq(0);
-
-    const POST_URL = `${VERIFY_SERVER}/attestation`;
-    const attestationId = hashMessage("some");
-    const origin = "localhost";
-
-    const postResponse = await fetch(POST_URL, {
-      method: "POST",
-      body: JSON.stringify({ attestationId, origin }),
-      headers: { "Content-Type": "application/json" },
-    });
-
-    expect(postResponse.status).toBe(200);
-
-    const getResponse = await fetch(`${VERIFY_SERVER}/attestation/${attestationId}`);
-    const result: any = await getResponse.json();
-
-    expect(getResponse.status).toBe(200);
-    expect(result.origin).toBe(origin);
-    expect(result.attestationId).toBe(attestationId);
-
-    await disconnectSocket(core.relayer);
-  });
-});
-</file>
-
-<file path="packages/core/.npmignore">
-*.log
-npm-debug.log*
-
-# Coverage directory used by tools like istanbul
-coverage
-.nyc_output
-
-# Dependency directories
-node_modules
-
-# npm package lock
-package-lock.json
-yarn.lock
-
-# project files
-src
-test
-CHANGELOG.md
-.travis.yml
-.editorconfig
-.eslintignore
-.eslintrc
-.babelrc
-.gitignore
-.watchmanconfig
-</file>
-
-<file path="packages/core/CHANGELOG.md">
-# @walletconnect/core
-
-## 2.20.0
-
-### Patch Changes
-
-- Updated dependencies []:
-  - @walletconnect/utils@2.20.0
-  - @walletconnect/types@2.20.0
-
-## 2.19.4
-
-### Patch Changes
-
-- Updated dependencies []:
-  - @walletconnect/utils@2.19.4
-  - @walletconnect/types@2.19.4
-
-## 2.19.3
-
-### Patch Changes
-
-- Updated dependencies []:
-  - @walletconnect/utils@2.19.3
-  - @walletconnect/types@2.19.3
-</file>
-
-<file path="packages/core/LICENSE">
-Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   Copyright 2021 WalletConnect, Inc.
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-</file>
-
-<file path="packages/core/package.json">
-{
-  "name": "@walletconnect/core",
-  "description": "Core for WalletConnect Protocol",
-  "version": "2.20.0",
-  "author": "WalletConnect, Inc. <walletconnect.com>",
-  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
-  "license": "Apache-2.0",
-  "main": "dist/index.cjs.js",
-  "module": "dist/index.es.js",
-  "unpkg": "dist/index.umd.js",
-  "types": "dist/types/index.d.ts",
-  "sideEffects": false,
-  "files": [
-    "dist"
-  ],
-  "keywords": [
-    "wallet",
-    "walletconnect"
-  ],
-  "scripts": {
-    "clean": "rm -rf dist",
-    "build:pre": "npm run clean",
-    "build:types": "tsc",
-    "build:source": "rollup --config rollup.config.js",
-    "build": "npm run build:pre; npm run build:source; npm run build:types",
-    "test:pre": "rm -rf ./test/tmp",
-    "test:run": "vitest run --dir test",
-    "test": "npm run test:pre; npm run test:run",
-    "test:ignoreUnhandled": "npm run test:pre; npm run test:run -- --dangerouslyIgnoreUnhandledErrors",
-    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
-    "prettier": "prettier --check '{src,test}/**/*.{js,ts,jsx,tsx}'"
-  },
-  "dependencies": {
-    "@walletconnect/heartbeat": "1.2.2",
-    "@walletconnect/jsonrpc-provider": "1.0.14",
-    "@walletconnect/jsonrpc-types": "1.0.4",
-    "@walletconnect/jsonrpc-utils": "1.0.8",
-    "@walletconnect/jsonrpc-ws-connection": "1.0.16",
-    "@walletconnect/keyvaluestorage": "1.1.1",
-    "@walletconnect/logger": "2.1.2",
-    "@walletconnect/relay-api": "1.0.11",
-    "@walletconnect/relay-auth": "1.1.0",
-    "@walletconnect/safe-json": "1.0.2",
-    "@walletconnect/time": "1.0.2",
-    "@walletconnect/types": "2.20.0",
-    "@walletconnect/utils": "2.20.0",
-    "@walletconnect/window-getters": "1.0.1",
-    "es-toolkit": "1.33.0",
-    "events": "3.3.0",
-    "uint8arrays": "3.1.0"
-  },
-  "engines": {
-    "node": ">=18"
-  }
-}
-</file>
-
-<file path="packages/core/README.md">
-# @walletconnect/core
-
-Core for WalletConnect Protocol
-
-## License
-
-Apache 2.0
-</file>
-
-<file path="packages/core/rollup.config.js">
-import { name, dependencies } from "./package.json";
-import createConfig from "../../rollup.config";
-
-export default createConfig(name, Object.keys(dependencies));
-</file>
-
-<file path="packages/core/tsconfig.json">
-{
-  "extends": "../../tsconfig.json",
-  "include": ["./src/**/*"],
-  "compilerOptions": {
-    "rootDir": "src",
-    "outDir": "./dist/types",
-    "emitDeclarationOnly": true
-  }
-}
-</file>
-
-<file path="packages/types/src/core/core.ts">
-import { IEvents } from "@walletconnect/events";
-import { IHeartBeat } from "@walletconnect/heartbeat";
-import { IKeyValueStorage, KeyValueStorageOptions } from "@walletconnect/keyvaluestorage";
-
-import { ICrypto } from "./crypto";
-import { IRelayer } from "./relayer";
-import { IKeyChain } from "./keychain";
-import { IJsonRpcHistory } from "./history";
-import { IExpirer } from "./expirer";
-import { IPairing } from "./pairing";
-import { Logger } from "@walletconnect/logger";
-import { IVerify } from "./verify";
-import { IEchoClient } from "./echo";
-import { IEventClient } from "./events";
-export declare namespace CoreTypes {
-  interface Options {
-    projectId?: string;
-    name?: string;
-    relayUrl?: string;
-    logger?: string | Logger;
-    keychain?: IKeyChain;
-    storage?: IKeyValueStorage;
-    storageOptions?: KeyValueStorageOptions;
-    maxLogBlobSizeInBytes?: number;
-    customStoragePrefix?: string;
-    telemetryEnabled?: boolean;
-  }
-
-  interface Metadata {
-    name: string;
-    description: string;
-    url: string;
-    icons: string[];
-    verifyUrl?: string;
-    redirect?: {
-      native?: string;
-      universal?: string;
-      linkMode?: boolean;
-    };
-  }
-}
-
-export abstract class ICore extends IEvents {
-  public readonly protocol = "wc";
-  public readonly version = 2;
-
-  public abstract readonly name: string;
-  public abstract readonly context: string;
-  public abstract readonly relayUrl?: string;
-  public abstract readonly projectId?: string;
-  public abstract readonly customStoragePrefix: string;
-
-  public abstract logger: Logger;
-  public abstract heartbeat: IHeartBeat;
-  public abstract crypto: ICrypto;
-  public abstract relayer: IRelayer;
-  public abstract storage: IKeyValueStorage;
-  public abstract history: IJsonRpcHistory;
-  public abstract expirer: IExpirer;
-  public abstract pairing: IPairing;
-  public abstract verify: IVerify;
-  public abstract echoClient: IEchoClient;
-  public abstract linkModeSupportedApps: string[];
-  public abstract eventClient: IEventClient;
-
-  constructor(public opts?: CoreTypes.Options) {
-    super();
-  }
-
-  public abstract start(): Promise<void>;
-  public abstract dispatchEnvelope(params: {
-    topic: string;
-    message: string;
-    sessionExists: boolean;
-  }): void;
-
-  public abstract addLinkModeSupportedApp(universalLink: string): void;
-}
-</file>
-
-<file path="packages/types/src/core/crypto.ts">
-import { JsonRpcPayload } from "@walletconnect/jsonrpc-types";
-import { Logger } from "@walletconnect/logger";
-import { ICore } from "./core";
-import { IKeyChain } from "./keychain";
-
-export declare namespace CryptoTypes {
-  export type EncodingType = "base64pad" | "base64url";
-
-  export interface Participant {
-    publicKey: string;
-  }
-
-  export interface KeyPair {
-    privateKey: string;
-    publicKey: string;
-  }
-
-  export interface EncryptParams {
-    message: string;
-    symKey: string;
-    type?: number;
-    iv?: string;
-    senderPublicKey?: string;
-    encoding?: EncodingType;
-  }
-
-  export interface DecryptParams {
-    symKey: string;
-    encoded: string;
-    encoding?: EncodingType;
-  }
-
-  export interface EncodingParams {
-    type: Uint8Array;
-    sealed: Uint8Array;
-    iv: Uint8Array;
-    senderPublicKey?: Uint8Array;
-    encoding?: EncodingType;
-  }
-
-  export interface DecodingParams {
-    encoded: string;
-    encoding?: EncodingType;
-  }
-
-  export interface EncodeOptions {
-    type?: number;
-    senderPublicKey?: string;
-    receiverPublicKey?: string;
-    encoding?: EncodingType;
-  }
-
-  export interface DecodeOptions {
-    receiverPublicKey?: string;
-    encoding?: EncodingType;
-  }
-
-  export interface EncodingValidation {
-    type: number;
-    senderPublicKey?: string;
-    receiverPublicKey?: string;
-  }
-
-  export interface TypeOneParams {
-    type: 1;
-    senderPublicKey: string;
-    receiverPublicKey: string;
-  }
-}
-
-export abstract class ICrypto {
-  public abstract name: string;
-
-  public abstract readonly context: string;
-
-  public abstract keychain: IKeyChain;
-
-  public abstract readonly randomSessionIdentifier: string;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    // @ts-ignore
-    keychain?: IKeyChain,
-  ) {}
-
-  public abstract init(): Promise<void>;
-
-  public abstract hasKeys(tag: string): boolean;
-
-  public abstract getClientId(): Promise<string>;
-
-  public abstract generateKeyPair(): Promise<string>;
-
-  public abstract generateSharedKey(
-    selfPublicKey: string,
-    peerPublicKey: string,
-    overrideTopic?: string,
-  ): Promise<string>;
-
-  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;
-
-  public abstract deleteKeyPair(publicKey: string): Promise<void>;
-
-  public abstract deleteSymKey(topic: string): Promise<void>;
-
-  public abstract encode(
-    topic: string,
-    payload: JsonRpcPayload,
-    opts?: CryptoTypes.EncodeOptions,
-  ): Promise<string>;
-
-  public abstract decode(
-    topic: string,
-    encoded: string,
-    opts?: CryptoTypes.DecodeOptions,
-  ): Promise<JsonRpcPayload>;
-
-  public abstract signJWT(aud: string): Promise<string>;
-  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;
-  public abstract getPayloadSenderPublicKey(
-    encoded: string,
-    encoding?: CryptoTypes.EncodingType,
-  ): string | undefined;
-}
-</file>
-
-<file path="packages/types/src/core/echo.ts">
-import { Logger } from "@walletconnect/logger";
-
-export declare namespace EchoClientTypes {
-  type RegisterDeviceTokenParams = {
-    clientId: string;
-    token: string;
-    notificationType: "fcm" | "apns" | "apns-sandbox" | "noop";
-    enableEncrypted?: boolean;
-  };
-}
-export abstract class IEchoClient {
-  public abstract readonly context: string;
-  constructor(
-    public projectId: string,
-    public logger: Logger,
-  ) {}
-
-  public abstract registerDeviceToken(
-    params: EchoClientTypes.RegisterDeviceTokenParams,
-  ): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/events.ts">
-import { Logger } from "@walletconnect/logger";
-import { ICore } from "./core";
-
-export declare namespace EventClientTypes {
-  export interface Event {
-    eventId: string;
-    bundleId: string;
-    timestamp: number;
-    props: Props;
-    addTrace: (trace: string) => void;
-    setError: (error: string) => void;
-  }
-
-  export interface Props {
-    event: string;
-    type: string;
-    properties: Properties;
-  }
-
-  export interface Properties {
-    topic: string;
-    trace: Trace;
-  }
-
-  export type Trace = string[];
-}
-
-export abstract class IEventClient {
-  public abstract readonly context: string;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    public telemetryEnabled: boolean,
-  ) {}
-
-  public abstract init(): Promise<void>;
-
-  public abstract createEvent(params: {
-    event?: "ERROR";
-    type?: string;
-    properties: {
-      topic: string;
-      trace: EventClientTypes.Trace;
-    };
-  }): EventClientTypes.Event;
-
-  public abstract getEvent(params: {
-    eventId?: string;
-    topic?: string;
-  }): EventClientTypes.Event | undefined;
-
-  public abstract deleteEvent(params: { eventId: string }): void;
-}
-</file>
-
-<file path="packages/types/src/core/expirer.ts">
-import { IEvents } from "@walletconnect/events";
-import { Logger } from "@walletconnect/logger";
-
-import { ICore } from "./core";
-
-export declare namespace ExpirerTypes {
-  interface Expiration {
-    target: string;
-    expiry: number;
-  }
-
-  interface Created {
-    target: string;
-    expiration: Expiration;
-  }
-
-  interface Deleted {
-    target: string;
-    expiration: Expiration;
-  }
-
-  interface Expired {
-    target: string;
-    expiration: Expiration;
-  }
-}
-
-export abstract class IExpirer extends IEvents {
-  public abstract name: string;
-
-  public abstract readonly context: string;
-
-  public abstract readonly length: number;
-
-  public abstract readonly keys: string[];
-
-  public abstract readonly values: ExpirerTypes.Expiration[];
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-  ) {
-    super();
-  }
-
-  public abstract init(): Promise<void>;
-
-  public abstract has(key: string | number): boolean;
-
-  public abstract set(key: string | number, expiry: number): void;
-
-  public abstract get(key: string | number): ExpirerTypes.Expiration;
-
-  public abstract del(key: string | number): void;
-}
-</file>
-
-<file path="packages/types/src/core/history.ts">
-import { IEvents } from "@walletconnect/events";
-import {
-  ErrorResponse,
-  JsonRpcRequest,
-  JsonRpcResponse,
-  RequestArguments,
-} from "@walletconnect/jsonrpc-types";
-import { Logger } from "@walletconnect/logger";
-
-import { ICore } from "./core";
-
-export interface JsonRpcRecord {
-  id: number;
-  topic: string;
-  request: RequestArguments;
-  chainId?: string;
-  response?: { result: any } | { error: ErrorResponse };
-  expiry?: number;
-}
-
-export interface RequestEvent {
-  topic: string;
-  request: JsonRpcRequest;
-  chainId?: string;
-}
-
-export abstract class IJsonRpcHistory extends IEvents {
-  public records = new Map<number, JsonRpcRecord>();
-
-  public abstract readonly context: string;
-
-  public abstract readonly size: number;
-
-  public abstract readonly keys: number[];
-
-  public abstract readonly values: JsonRpcRecord[];
-
-  public abstract readonly pending: RequestEvent[];
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-  ) {
-    super();
-  }
-
-  public abstract init(): Promise<void>;
-
-  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;
-
-  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;
-
-  public abstract resolve(response: JsonRpcResponse): Promise<void>;
-
-  public abstract delete(topic: string, id?: number): void;
-
-  public abstract exists(topic: string, id: number): Promise<boolean>;
-}
-</file>
-
-<file path="packages/types/src/core/index.ts">
-export * from "./core";
-export * from "./crypto";
-export * from "./history";
-export * from "./messages";
-export * from "./publisher";
-export * from "./relayer";
-export * from "./store";
-export * from "./subscriber";
-export * from "./keychain";
-export * from "./expirer";
-export * from "./pairing";
-export * from "./verify";
-export * from "./echo";
-export * from "./events";
-</file>
-
-<file path="packages/types/src/core/keychain.ts">
-import { Logger } from "@walletconnect/logger";
-import { ICore } from "./core";
-
-export abstract class IKeyChain {
-  public abstract keychain: Map<string, string>;
-
-  public abstract name: string;
-
-  public abstract readonly context: string;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-  ) {}
-
-  public abstract init(): Promise<void>;
-
-  public abstract has(tag: string, opts?: any): boolean;
-
-  public abstract set(tag: string, key: string, opts?: any): Promise<void>;
-
-  public abstract get(tag: string, opts?: any): string;
-
-  public abstract del(tag: string, opts?: any): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/messages.ts">
-import { Logger } from "@walletconnect/logger";
-import { ICore } from "./core";
-
-export type MessageRecord = Record<string, string>;
-
-export abstract class IMessageTracker {
-  public abstract messages: Map<string, MessageRecord>;
-  public abstract messagesWithoutClientAck: Map<string, MessageRecord>;
-
-  public abstract name: string;
-
-  public abstract readonly context: string;
-
-  constructor(
-    public logger: Logger,
-    public core: ICore,
-  ) {}
-
-  public abstract init(): Promise<void>;
-
-  public abstract set(
-    topic: string,
-    message: string,
-    direction?: "inbound" | "outbound",
-  ): Promise<string>;
-
-  public abstract get(topic: string): MessageRecord;
-
-  public abstract getWithoutAck(topics: string[]): Record<string, string[]>;
-
-  public abstract has(topic: string, message: string): boolean;
-
-  public abstract del(topic: string): Promise<void>;
-
-  public abstract ack(topic: string, message: string): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/pairing.ts">
-import {
-  ErrorResponse,
-  JsonRpcRequest,
-  JsonRpcResponse,
-  JsonRpcResult,
-  JsonRpcError,
-} from "@walletconnect/jsonrpc-types";
-import EventEmitter from "events";
-
-import { ICore, CoreTypes } from "./core";
-import { IStore } from "./store";
-
-import { RelayerTypes } from "../core/relayer";
-import { Logger } from "@walletconnect/logger";
-
-export declare namespace PairingTypes {
-  interface Struct {
-    topic: string;
-    expiry: number;
-    relay: RelayerTypes.ProtocolOptions;
-    active: boolean;
-    peerMetadata?: CoreTypes.Metadata;
-    methods?: string[];
-  }
-}
-
-export declare namespace PairingJsonRpcTypes {
-  // -- core ------------------------------------------------------- //
-  type DefaultResponse = true | ErrorResponse;
-
-  type WcMethod = "wc_pairingDelete" | "wc_pairingPing";
-
-  type Error = ErrorResponse;
-
-  // -- requests --------------------------------------------------- //
-
-  interface RequestParams {
-    wc_pairingDelete: {
-      code: number;
-      message: string;
-    };
-    wc_pairingPing: Record<string, unknown>;
-  }
-
-  // -- responses -------------------------------------------------- //
-  interface Results {
-    wc_pairingDelete: true;
-    wc_pairingPing: true;
-  }
-
-  // -- events ----------------------------------------------------- //
-  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
-    topic: string;
-    payload: T;
-  }
-}
-
-export type IPairingStore = IStore<string, PairingTypes.Struct>;
-
-export abstract class IPairing {
-  public abstract name: string;
-  public abstract readonly context: string;
-  public abstract events: EventEmitter;
-  public abstract pairings: IPairingStore;
-
-  constructor(
-    public logger: Logger,
-    public core: ICore,
-  ) {}
-
-  public abstract init(): Promise<void>;
-
-  public abstract pair(params: {
-    uri: string;
-    activatePairing?: boolean;
-  }): Promise<PairingTypes.Struct>;
-
-  // for proposer to create inactive pairing
-  public abstract create(params?: {
-    methods?: string[];
-    transportType?: RelayerTypes.SubscribeOptions["transportType"];
-  }): Promise<{ topic: string; uri: string }>;
-
-  // for either to activate a previously created pairing
-  public abstract activate(params: { topic: string }): Promise<void>;
-
-  // for both to subscribe on methods requests
-  public abstract register(params: { methods: string[] }): void;
-
-  // for either to update the expiry of an existing pairing.
-  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;
-
-  // for either to update the metadata of an existing pairing.
-  public abstract updateMetadata(params: {
-    topic: string;
-    metadata: CoreTypes.Metadata;
-  }): Promise<void>;
-
-  // query pairings
-  public abstract getPairings(): PairingTypes.Struct[];
-
-  // for either to ping a peer
-  public abstract ping(params: { topic: string }): Promise<void>;
-
-  // for either peer to disconnect a pairing
-  public abstract disconnect(params: { topic: string }): Promise<void>;
-
-  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;
-}
-
-export interface IPairingPrivate {
-  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(
-    topic: string,
-    method: M,
-    params: PairingJsonRpcTypes.RequestParams[M],
-  ): Promise<number>;
-
-  sendResult<M extends PairingJsonRpcTypes.WcMethod>(
-    id: number,
-    topic: string,
-    result: PairingJsonRpcTypes.Results[M],
-  ): Promise<void>;
-
-  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;
-
-  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): Promise<void>;
-
-  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;
-
-  onPairingPingRequest(
-    topic: string,
-    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams["wc_pairingPing"]>,
-  ): Promise<void>;
-
-  onPairingPingResponse(
-    topic: string,
-    payload: JsonRpcResult<PairingJsonRpcTypes.Results["wc_pairingPing"]> | JsonRpcError,
-  ): void;
-
-  onPairingDeleteRequest(
-    topic: string,
-    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams["wc_pairingDelete"]>,
-  ): Promise<void>;
-
-  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;
-
-  onUnknownRpcMethodResponse(method: string): void;
-
-  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/publisher.ts">
-import { IEvents } from "@walletconnect/events";
-import { Logger } from "@walletconnect/logger";
-
-import { IRelayer, RelayerTypes } from "./relayer";
-
-export declare namespace PublisherTypes {
-  export interface Params {
-    topic: string;
-    message: string;
-    opts: Omit<RelayerTypes.PublishOptions, "internal">;
-  }
-}
-
-export abstract class IPublisher extends IEvents {
-  public abstract name: string;
-
-  public abstract readonly context: string;
-
-  constructor(
-    public relayer: IRelayer,
-    public logger: Logger,
-  ) {
-    super();
-  }
-
-  public abstract publish(
-    topic: string,
-    message: string,
-    opts?: RelayerTypes.PublishOptions,
-  ): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/relayer.ts">
-import { IEvents } from "@walletconnect/events";
-import { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from "@walletconnect/jsonrpc-types";
-import { Logger } from "@walletconnect/logger";
-
-import { ICore } from "./core";
-import { IMessageTracker } from "./messages";
-import { IPublisher } from "./publisher";
-import { ISubscriber } from "./subscriber";
-
-export declare namespace RelayerTypes {
-  export interface ProtocolOptions {
-    protocol: string;
-    data?: string;
-  }
-  export interface PublishOptions {
-    relay?: ProtocolOptions;
-    ttl?: number;
-    prompt?: boolean;
-    tag?: number;
-    id?: number;
-    internal?: {
-      throwOnFailedPublish?: boolean;
-    };
-    tvf?: ITVF;
-    attestation?: string;
-  }
-
-  export type TransportType = "relay" | "link_mode";
-
-  export interface SubscribeOptions {
-    relay?: ProtocolOptions;
-    transportType?: TransportType;
-    internal?: {
-      throwOnFailedPublish?: boolean;
-    };
-  }
-
-  export interface UnsubscribeOptions {
-    id?: string;
-    relay: ProtocolOptions;
-  }
-
-  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;
-
-  export interface PublishPayload {
-    topic: string;
-    message: string;
-    opts?: RelayerTypes.PublishOptions;
-  }
-  export interface MessageEvent {
-    topic: string;
-    message: string;
-    publishedAt: number;
-    transportType?: TransportType;
-    attestation?: string;
-  }
-
-  export interface RpcUrlParams {
-    protocol: string;
-    version: number;
-    auth: string;
-    relayUrl: string;
-    sdkVersion: string;
-    projectId?: string;
-    useOnCloseEvent?: boolean;
-    bundleId?: string;
-    packageName?: string;
-  }
-
-  export interface ITVF {
-    correlationId?: number;
-    rpcMethods?: string[];
-    chainId?: string;
-    txHashes?: string[];
-    contractAddresses?: string[];
-  }
-
-  export type MessageDirection = "inbound" | "outbound";
-}
-
-export interface RelayerOptions {
-  core: ICore;
-  logger?: string | Logger;
-  relayUrl?: string;
-  projectId?: string;
-}
-
-export interface RelayerClientMetadata {
-  protocol: string;
-  version: number;
-  env: string;
-  host?: string;
-}
-
-export abstract class IRelayer extends IEvents {
-  public abstract protocol: string;
-
-  public abstract version: number;
-
-  public abstract core: ICore;
-
-  public abstract logger: Logger;
-
-  public abstract subscriber: ISubscriber;
-
-  public abstract publisher: IPublisher;
-
-  public abstract messages: IMessageTracker;
-
-  public abstract provider: IJsonRpcProvider;
-
-  public abstract name: string;
-
-  public abstract transportExplicitlyClosed: boolean;
-
-  public abstract readonly context: string;
-
-  public abstract readonly connected: boolean;
-
-  public abstract readonly connecting: boolean;
-
-  constructor(
-    // @ts-ignore
-    opts: RelayerOptions,
-  ) {
-    super();
-  }
-
-  public abstract init(): Promise<void>;
-
-  public abstract publish(
-    topic: string,
-    message: string,
-    opts?: RelayerTypes.PublishOptions,
-  ): Promise<void>;
-
-  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;
-
-  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;
-
-  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;
-  public abstract transportClose(): Promise<void>;
-  public abstract transportOpen(relayUrl?: string): Promise<void>;
-  public abstract restartTransport(relayUrl?: string): Promise<void>;
-  public abstract confirmOnlineStateOrThrow(): Promise<void>;
-  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;
-  public abstract onLinkMessageEvent(
-    messageEvent: RelayerTypes.MessageEvent,
-    opts?: { sessionExists?: boolean },
-  ): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/store.ts">
-import { ErrorResponse } from "@walletconnect/jsonrpc-types";
-import { Logger } from "@walletconnect/logger";
-import { ICore } from "./core";
-
-export abstract class IStore<Key, Value> {
-  public abstract map: Map<Key, Value>;
-
-  public abstract readonly context: string;
-
-  public abstract readonly length: number;
-
-  public abstract readonly keys: Key[];
-
-  public abstract readonly values: Value[];
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    public name: string,
-    // @ts-ignore
-    storagePrefix?: string,
-  ) {}
-
-  public abstract init(): Promise<void>;
-
-  public abstract set(key: Key, value: Value): Promise<void>;
-
-  public abstract get(key: Key): Value;
-
-  public abstract getAll(filter?: Partial<Value>): Value[];
-
-  public abstract update(key: Key, update: Partial<Value>): Promise<void>;
-
-  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/subscriber.ts">
-import { IEvents } from "@walletconnect/events";
-import { ErrorResponse } from "@walletconnect/jsonrpc-types";
-import { Logger } from "@walletconnect/logger";
-
-import { IRelayer, RelayerTypes } from "./relayer";
-
-export declare namespace SubscriberTypes {
-  export interface Params extends RelayerTypes.SubscribeOptions {
-    topic: string;
-  }
-
-  export interface Active extends Params {
-    id: string;
-  }
-}
-
-export declare namespace SubscriberEvents {
-  export type Created = SubscriberTypes.Active;
-
-  export interface Deleted extends SubscriberTypes.Active {
-    reason: ErrorResponse;
-  }
-
-  export type Expired = Deleted;
-}
-
-export abstract class ISubscriberTopicMap {
-  public map = new Map<string, string[]>();
-
-  public abstract readonly topics: string[];
-
-  public abstract set(topic: string, id: string): void;
-
-  public abstract get(topic: string): string[];
-
-  public abstract exists(topic: string, id: string): boolean;
-
-  public abstract delete(topic: string, id?: string): void;
-
-  public abstract clear(): void;
-}
-
-export abstract class ISubscriber extends IEvents {
-  public abstract subscriptions: Map<string, SubscriberTypes.Active>;
-
-  public abstract topicMap: ISubscriberTopicMap;
-
-  public abstract pending: Map<string, SubscriberTypes.Params>;
-
-  public abstract readonly length: number;
-
-  public abstract readonly ids: string[];
-
-  public abstract readonly values: SubscriberTypes.Active[];
-
-  public abstract readonly topics: string[];
-
-  public abstract readonly hasAnyTopics: boolean;
-
-  public abstract name: string;
-
-  public abstract readonly context: string;
-
-  constructor(
-    public relayer: IRelayer,
-    public logger: Logger,
-  ) {
-    super();
-  }
-
-  public abstract init(): Promise<void>;
-
-  public abstract subscribe(
-    topic: string,
-    opts?: RelayerTypes.SubscribeOptions,
-  ): Promise<string | null>;
-
-  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;
-
-  public abstract isSubscribed(topic: string): Promise<boolean>;
-
-  public abstract isKnownTopic(topic: string): Promise<boolean>;
-
-  public abstract start(): Promise<void>;
-
-  public abstract stop(): Promise<void>;
-}
-</file>
-
-<file path="packages/types/src/core/verify.ts">
-import { Logger } from "@walletconnect/logger";
-import { IKeyValueStorage } from "@walletconnect/keyvaluestorage";
-import { ICore } from "./core";
-
-export declare namespace Verify {
-  export interface Context {
-    verified: {
-      origin: string;
-      validation: "UNKNOWN" | "VALID" | "INVALID";
-      verifyUrl: string;
-      isScam?: boolean;
-    };
-  }
-}
-
-export abstract class IVerify {
-  public abstract readonly context: string;
-
-  constructor(
-    public core: ICore,
-    public logger: Logger,
-    public store: IKeyValueStorage,
-  ) {}
-
-  public abstract register(params: {
-    id: string;
-    decryptedId: string;
-  }): Promise<string | undefined>;
-
-  public abstract resolve(params: {
-    attestationId?: string;
-    hash?: string;
-    encryptedId?: string;
-    verifyUrl?: string;
-  }): Promise<{ origin: string; isScam?: boolean }>;
-}
-</file>
-
-<file path="packages/types/src/sign-client/auth.ts">
-import {
-  ErrorResponse,
-  JsonRpcError,
-  JsonRpcRequest,
-  JsonRpcResponse,
-  JsonRpcResult,
-} from "@walletconnect/jsonrpc-types";
-import { CoreTypes, ICore, IStore, RelayerTypes, Verify } from "../core";
-import { SessionTypes } from "./session";
-
-export declare namespace AuthTypes {
-  type Event = "session_authenticate";
-
-  interface AuthRequestEventArgs {
-    requester: Participant;
-    authPayload: PayloadParams;
-    expiryTimestamp: number;
-    transportType?: RelayerTypes.TransportType;
-  }
-
-  type AuthResponseEventArgs =
-    | { message: string; code: number }
-    | JsonRpcResult<Cacao>
-    | JsonRpcError;
-
-  interface BaseEventArgs<T = unknown> {
-    id: number;
-    topic: string;
-    params: T;
-    verifyContext?: Verify.Context;
-  }
-
-  interface EventArguments {
-    auth_request: BaseEventArgs<AuthRequestEventArgs>;
-    auth_response: BaseEventArgs<AuthResponseEventArgs>;
-    sign_request: BaseEventArgs<{
-      request: { method: string; params: any };
-      chainId: string;
-    }>;
-    sign_response: BaseEventArgs<JsonRpcResult | JsonRpcError>;
-  }
-
-  interface Options extends CoreTypes.Options {
-    metadata: Metadata;
-    core?: ICore;
-    projectId: string;
-  }
-
-  interface Metadata {
-    name: string;
-    description: string;
-    url: string;
-    icons: string[];
-    redirect?: {
-      native?: string;
-      universal?: string;
-      linkMode?: boolean;
-    };
-    verifyUrl?: string;
-  }
-
-  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
-    topic: string;
-    payload: T;
-  }
-
-  /**
-   * `aud` is used in protocol request
-   * `uri` is more descriptive and is used in client APIs
-   * formatMessageParams should accept either `aud` or `uri` as a parameter to construct the message
-   */
-  type FormatMessageParams = {
-    aud?: string;
-    uri?: string;
-  } & Omit<BaseAuthRequestParams, "aud" | "chainId">;
-
-  interface BaseAuthRequestParams {
-    domain: string;
-    aud: string;
-    nonce: string;
-    version?: string;
-    iat?: string;
-    nbf?: string;
-    exp?: string;
-    chainId?: string;
-    statement?: string;
-    requestId?: string;
-    resources?: string[];
-    expiry?: number;
-    type?: string;
-  }
-
-  // https://github.com/ChainAgnostic/CAIPs/pull/74
-  type RequestParams = {
-    chains: string[];
-  } & BaseAuthRequestParams;
-
-  type SessionAuthenticateParams = {
-    pairingTopic?: string;
-    methods?: string[];
-    uri: string;
-  } & Omit<RequestParams, "aud">;
-
-  type PayloadParams = {
-    version: string;
-    iat: string;
-  } & RequestParams;
-
-  type CacaoPayload = {
-    iss: string;
-  } & BaseAuthRequestParams;
-
-  interface CacaoHeader {
-    t: "caip122";
-  }
-
-  interface CacaoSignature {
-    t: "eip191" | "eip1271";
-    s: string;
-    m?: string;
-  }
-
-  interface Cacao {
-    h: CacaoHeader;
-    p: CacaoPayload;
-    s: CacaoSignature;
-  }
-
-  interface PendingRequest {
-    id: number;
-    pairingTopic: string;
-    requester: Participant;
-    expiryTimestamp: number;
-    authPayload: PayloadParams;
-    verifyContext: Verify.Context;
-    transportType?: RelayerTypes.TransportType;
-  }
-
-  interface ApproveSessionAuthenticateParams {
-    id: number;
-    auths: Cacao[];
-  }
-
-  interface SessionAuthenticateResponseParams {
-    responder: Participant;
-    cacaos: Cacao[];
-  }
-
-  interface AuthErrorResponse {
-    id: number;
-    error: ErrorResponse;
-  }
-
-  type AuthResponse = SessionAuthenticateResponseParams["cacaos"];
-
-  interface Participant {
-    publicKey: string;
-    metadata: Metadata;
-  }
-
-  interface SessionAuthenticateRequestParams {
-    requester: Participant;
-    authPayload: PayloadParams;
-    expiryTimestamp: number;
-  }
-
-  interface SessionAuthenticateRequest extends SessionAuthenticateRequestParams {
-    verifyContext: Verify.Context;
-  }
-
-  type AuthenticateResponseResult = {
-    auths?: AuthTypes.AuthResponse;
-    session: SessionTypes.Struct;
-  };
-}
-
-export type IAuth = {
-  init(): Promise<void>;
-  authKeys: IStore<string, { responseTopic: string; publicKey: string }>;
-  pairingTopics: IStore<string, { topic: string; pairingTopic: string }>;
-  requests: IStore<number, AuthTypes.PendingRequest>;
-};
-</file>
-
-<file path="packages/types/src/sign-client/client.ts">
-import { Logger } from "@walletconnect/logger";
-import EventEmmiter from "events";
-import { CoreTypes, ICore } from "../core/core";
-import { IEngine } from "./engine";
-import { IPendingRequest } from "./pendingRequest";
-import { IProposal, ProposalTypes } from "./proposal";
-import { ISession, SessionTypes } from "./session";
-import { Verify } from "../core/verify";
-import { IAuth, AuthTypes } from "./auth";
-import { RelayerTypes } from "../core";
-
-export declare namespace SignClientTypes {
-  type Event =
-    | "session_proposal"
-    | "session_update"
-    | "session_extend"
-    | "session_ping"
-    | "session_delete"
-    | "session_expire"
-    | "session_request"
-    | "session_request_sent"
-    | "session_event"
-    | "session_authenticate"
-    | "proposal_expire"
-    | "session_request_expire"
-    | "session_connect";
-
-  interface BaseEventArgs<T = unknown> {
-    id: number;
-    topic: string;
-    params: T;
-  }
-  interface EventArguments {
-    session_proposal: {
-      verifyContext: Verify.Context;
-    } & Omit<BaseEventArgs<ProposalTypes.Struct>, "topic">;
-    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;
-    session_extend: Omit<BaseEventArgs, "params">;
-    session_ping: Omit<BaseEventArgs, "params">;
-    session_delete: Omit<BaseEventArgs, "params">;
-    session_expire: { topic: string };
-    session_request: {
-      verifyContext: Verify.Context;
-    } & BaseEventArgs<{
-      request: { method: string; params: any; expiryTimestamp?: number };
-      chainId: string;
-    }>;
-    session_request_sent: {
-      request: { method: string; params: any };
-      topic: string;
-      chainId: string;
-      id: number;
-    };
-    session_event: BaseEventArgs<{
-      event: { name: string; data: any };
-      chainId: string;
-    }>;
-    session_authenticate: {
-      verifyContext: Verify.Context;
-      transportType?: RelayerTypes.TransportType;
-    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;
-    proposal_expire: { id: number };
-    session_request_expire: { id: number };
-    session_connect: { session: SessionTypes.Struct };
-  }
-
-  type Metadata = CoreTypes.Metadata;
-
-  type SignConfig = {
-    disableRequestQueue?: boolean;
-  };
-
-  interface Options extends CoreTypes.Options {
-    core?: ICore;
-    metadata?: Metadata;
-    signConfig?: SignConfig;
-  }
-}
-
-export abstract class ISignClientEvents extends EventEmmiter {
-  constructor() {
-    super();
-  }
-
-  public abstract emit: <E extends SignClientTypes.Event>(
-    event: E,
-    args: SignClientTypes.EventArguments[E],
-  ) => boolean;
-
-  public abstract on: <E extends SignClientTypes.Event>(
-    event: E,
-    listener: (args: SignClientTypes.EventArguments[E]) => any,
-  ) => this;
-
-  public abstract once: <E extends SignClientTypes.Event>(
-    event: E,
-    listener: (args: SignClientTypes.EventArguments[E]) => any,
-  ) => this;
-
-  public abstract off: <E extends SignClientTypes.Event>(
-    event: E,
-    listener: (args: SignClientTypes.EventArguments[E]) => any,
-  ) => this;
-
-  public abstract removeListener: <E extends SignClientTypes.Event>(
-    event: E,
-    listener: (args: SignClientTypes.EventArguments[E]) => any,
-  ) => this;
-
-  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;
-}
-
-export abstract class ISignClient {
-  public readonly protocol = "wc";
-  public readonly version = 2;
-
-  public abstract readonly name: string;
-  public abstract readonly context: string;
-  public abstract readonly metadata: SignClientTypes.Metadata;
-
-  public abstract core: ICore;
-  public abstract logger: Logger;
-  public abstract events: ISignClientEvents;
-  public abstract engine: IEngine;
-  public abstract session: ISession;
-  public abstract proposal: IProposal;
-  public abstract pendingRequest: IPendingRequest;
-  public abstract auth: IAuth;
-  public abstract signConfig?: SignClientTypes.SignConfig;
-
-  constructor(public opts?: SignClientTypes.Options) {}
-
-  public abstract connect: IEngine["connect"];
-  public abstract pair: IEngine["pair"];
-  public abstract approve: IEngine["approve"];
-  public abstract reject: IEngine["reject"];
-  public abstract update: IEngine["update"];
-  public abstract extend: IEngine["extend"];
-  public abstract request: IEngine["request"];
-  public abstract respond: IEngine["respond"];
-  public abstract ping: IEngine["ping"];
-  public abstract emit: IEngine["emit"];
-  public abstract disconnect: IEngine["disconnect"];
-  public abstract find: IEngine["find"];
-  public abstract getPendingSessionRequests: IEngine["getPendingSessionRequests"];
-  public abstract authenticate: IEngine["authenticate"];
-  public abstract formatAuthMessage: IEngine["formatAuthMessage"];
-  public abstract approveSessionAuthenticate: IEngine["approveSessionAuthenticate"];
-  public abstract rejectSessionAuthenticate: IEngine["rejectSessionAuthenticate"];
-}
-</file>
-
-<file path="packages/types/src/sign-client/engine.ts">
-import {
-  JsonRpcResponse,
-  JsonRpcRequest,
-  ErrorResponse,
-  JsonRpcResult,
-  JsonRpcError,
-} from "@walletconnect/jsonrpc-types";
-import { ISignClient } from "./client";
-import { RelayerTypes } from "../core/relayer";
-import { SessionTypes } from "./session";
-import { ProposalTypes } from "./proposal";
-import { PairingTypes } from "../core/pairing";
-import { JsonRpcTypes } from "./jsonrpc";
-import { EventEmitter } from "events";
-import { PendingRequestTypes } from "./pendingRequest";
-import { AuthTypes } from "./auth";
-import { CryptoTypes } from "../core";
-
-export declare namespace EngineTypes {
-  type Event =
-    | "session_connect"
-    | "session_approve"
-    | "session_update"
-    | "session_extend"
-    | "session_ping"
-    | "pairing_ping"
-    | "session_request";
-
-  interface EventArguments {
-    session_connect: {
-      error?: ErrorResponse;
-      session?: SessionTypes.Struct;
-    };
-    session_approve: { error?: ErrorResponse };
-    session_update: { error?: ErrorResponse };
-    session_extend: { error?: ErrorResponse };
-    session_ping: { error?: ErrorResponse };
-    pairing_ping: { error?: ErrorResponse };
-    session_request: { error?: ErrorResponse; result?: any };
-  }
-
-  interface UriParameters {
-    protocol: string;
-    version: number;
-    topic: string;
-    symKey: string;
-    relay: RelayerTypes.ProtocolOptions;
-    methods?: string[];
-    expiryTimestamp?: number;
-  }
-
-  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {
-    topic: string;
-    payload: T;
-    transportType?: RelayerTypes.MessageEvent["transportType"];
-    attestation?: string;
-    encryptedId?: string;
-  }
-
-  interface ConnectParams {
-    requiredNamespaces?: ProposalTypes.RequiredNamespaces;
-    optionalNamespaces?: ProposalTypes.OptionalNamespaces;
-    sessionProperties?: ProposalTypes.SessionProperties;
-    scopedProperties?: ProposalTypes.ScopedProperties;
-    pairingTopic?: string;
-    relays?: RelayerTypes.ProtocolOptions[];
-  }
-
-  interface PairParams {
-    uri: string;
-  }
-
-  interface ApproveParams {
-    id: number;
-    namespaces: SessionTypes.Namespaces;
-    sessionProperties?: ProposalTypes.SessionProperties;
-    scopedProperties?: ProposalTypes.ScopedProperties;
-    sessionConfig?: SessionTypes.SessionConfig;
-    relayProtocol?: string;
-  }
-
-  interface RejectParams {
-    id: number;
-    reason: ErrorResponse;
-  }
-
-  interface UpdateParams {
-    topic: string;
-    namespaces: SessionTypes.Namespaces;
-  }
-
-  interface ExtendParams {
-    topic: string;
-  }
-
-  interface RequestParams {
-    topic: string;
-    request: {
-      method: string;
-      params: any;
-    };
-    chainId: string;
-    expiry?: number;
-  }
-
-  interface RespondParams {
-    topic: string;
-    response: JsonRpcResponse;
-  }
-
-  interface EmitParams {
-    topic: string;
-    event: {
-      name: string;
-      data: any;
-    };
-    chainId: string;
-  }
-
-  interface PingParams {
-    topic: string;
-  }
-
-  interface DisconnectParams {
-    topic: string;
-    reason: ErrorResponse;
-  }
-
-  interface FindParams {
-    requiredNamespaces: ProposalTypes.RequiredNamespaces;
-  }
-
-  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;
-
-  type SessionAuthenticateResponsePromise = {
-    uri: string;
-    response: () => Promise<AuthTypes.AuthenticateResponseResult>;
-  };
-
-  interface RpcOpts {
-    req: RelayerTypes.PublishOptions & {
-      ttl: number;
-    };
-    res: RelayerTypes.PublishOptions & {
-      ttl: number;
-    };
-    reject?: RelayerTypes.PublishOptions & {
-      ttl: number;
-    };
-    autoReject?: RelayerTypes.PublishOptions & {
-      ttl: number;
-    };
-  }
-
-  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;
-
-  type EngineQueue<T> = {
-    state: "IDLE" | "ACTIVE";
-    queue: T[];
-  };
-}
-
-export abstract class IEngineEvents extends EventEmitter {
-  constructor() {
-    super();
-  }
-
-  public abstract emit: <E extends EngineTypes.Event>(
-    event: string,
-    args: EngineTypes.EventArguments[E],
-  ) => boolean;
-
-  public abstract once: <E extends EngineTypes.Event>(
-    event: string,
-    listener: (args: EngineTypes.EventArguments[E]) => any,
-  ) => this;
-}
-
-// -- private method interface -------------------------------------- //
-
-export interface EnginePrivate {
-  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {
-    topic: string;
-    method: M;
-    params: JsonRpcTypes.RequestParams[M];
-    expiry?: number;
-    relayRpcId?: number;
-    clientRpcId?: number;
-    throwOnFailedPublish?: boolean;
-    appLink?: string;
-    tvf?: RelayerTypes.ITVF;
-  }): Promise<number>;
-
-  sendResult<M extends JsonRpcTypes.WcMethod>(args: {
-    id: number;
-    topic: string;
-    result: JsonRpcTypes.Results[M];
-    throwOnFailedPublish?: boolean;
-    encodeOpts?: CryptoTypes.EncodeOptions;
-    appLink?: string;
-  }): Promise<void>;
-
-  sendError(params: {
-    id: number;
-    topic: string;
-    error: JsonRpcTypes.Error;
-    encodeOpts?: CryptoTypes.EncodeOptions;
-    rpcOpts?: RelayerTypes.PublishOptions;
-    appLink?: string;
-  }): Promise<void>;
-
-  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): Promise<void>;
-
-  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;
-
-  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;
-
-  shouldIgnorePairingRequest(params: { topic: string; requestMethod: string }): boolean;
-
-  deleteSession(params: {
-    topic: string;
-    expirerHasDeleted?: boolean;
-    id?: number;
-    emitEvent?: boolean;
-  }): Promise<void>;
-
-  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;
-
-  setExpiry(topic: string, expiry: number): Promise<void>;
-
-  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;
-
-  setAuthRequest(
-    id: number,
-    params: {
-      request: AuthTypes.SessionAuthenticateRequest;
-      pairingTopic: string;
-      transportType?: RelayerTypes.MessageEvent["transportType"];
-    },
-  ): Promise<void>;
-
-  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;
-
-  deletePendingSessionRequest(
-    id: number,
-    reason: ErrorResponse,
-    expirerHasDeleted?: boolean,
-  ): Promise<void>;
-
-  deletePendingAuthRequest(
-    id: number,
-    reason: ErrorResponse,
-    expirerHasDeleted?: boolean,
-  ): Promise<void>;
-
-  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;
-
-  cleanup(): Promise<void>;
-
-  onSessionProposeRequest(params: {
-    topic: string;
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionPropose"]>;
-    attestation?: string;
-    encryptedId?: string;
-  }): Promise<void>;
-
-  onSessionProposeResponse(
-    topic: string,
-    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionPropose"]> | JsonRpcError,
-    transportType?: RelayerTypes.MessageEvent["transportType"],
-  ): Promise<void>;
-
-  onSessionSettleRequest(
-    topic: string,
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionSettle"]>,
-  ): Promise<void>;
-
-  onSessionSettleResponse(
-    topic: string,
-    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionSettle"]> | JsonRpcError,
-  ): Promise<void>;
-
-  onSessionUpdateRequest(
-    topic: string,
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionUpdate"]>,
-  ): Promise<void>;
-
-  onSessionUpdateResponse(
-    topic: string,
-    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionUpdate"]> | JsonRpcError,
-  ): void;
-
-  onSessionExtendRequest(
-    topic: string,
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionExtend"]>,
-  ): Promise<void>;
-
-  onSessionExtendResponse(
-    topic: string,
-    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionExtend"]> | JsonRpcError,
-  ): void;
-
-  onSessionPingRequest(
-    topic: string,
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionPing"]>,
-  ): Promise<void>;
-
-  onSessionPingResponse(
-    topic: string,
-    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionPing"]> | JsonRpcError,
-  ): void;
-
-  onSessionDeleteRequest(
-    topic: string,
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionDelete"]>,
-  ): Promise<void>;
-
-  onSessionRequest(params: {
-    topic: string;
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionRequest"]>;
-    transportType?: RelayerTypes.MessageEvent["transportType"];
-    attestation?: string;
-    encryptedId?: string;
-  }): Promise<void>;
-
-  onSessionRequestResponse(
-    topic: string,
-    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionRequest"]> | JsonRpcError,
-  ): void;
-
-  onSessionEventRequest(
-    topic: string,
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionEvent"]>,
-  ): Promise<void>;
-
-  onSessionAuthenticateRequest(params: {
-    topic: string;
-    payload: JsonRpcRequest<JsonRpcTypes.RequestParams["wc_sessionAuthenticate"]>;
-    transportType?: RelayerTypes.MessageEvent["transportType"];
-    attestation?: string;
-    encryptedId?: string;
-  }): Promise<void>;
-
-  onSessionAuthenticateResponse(
-    topic: string,
-    payload: JsonRpcResult<JsonRpcTypes.Results["wc_sessionAuthenticate"]> | JsonRpcError,
-  ): void;
-
-  // -- Validators ---------------------------------------------------- //
-  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;
-
-  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams["wc_sessionSettle"]): void;
-
-  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;
-
-  isValidReject(params: EngineTypes.RejectParams): Promise<void>;
-
-  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;
-
-  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;
-
-  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;
-
-  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;
-
-  isValidPing(params: EngineTypes.PingParams): Promise<void>;
-
-  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;
-
-  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;
-}
-
-// -- class interface ----------------------------------------------- //
-
-export abstract class IEngine {
-  constructor(public client: ISignClient) {}
-
-  public abstract init(): Promise<void>;
-
-  public abstract connect(
-    params: EngineTypes.ConnectParams,
-  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;
-
-  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;
-
-  public abstract approve(
-    params: EngineTypes.ApproveParams,
-  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;
-
-  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;
-
-  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;
-
-  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;
-
-  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;
-
-  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;
-
-  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;
-
-  public abstract ping(params: EngineTypes.PingParams): Promise<void>;
-
-  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;
-
-  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];
-
-  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];
-
-  public abstract authenticate: (
-    params: AuthTypes.SessionAuthenticateParams,
-    walletUniversalLink?: string,
-  ) => Promise<EngineTypes.SessionAuthenticateResponsePromise>;
-
-  public abstract approveSessionAuthenticate: (
-    params: AuthTypes.ApproveSessionAuthenticateParams,
-  ) => Promise<{ session: SessionTypes.Struct | undefined }>;
-
-  public abstract formatAuthMessage: (params: {
-    request: AuthTypes.BaseAuthRequestParams;
-    iss: string;
-  }) => string;
-
-  public abstract rejectSessionAuthenticate(params: EngineTypes.RejectParams): Promise<void>;
-
-  public abstract processRelayMessageCache(): void;
-}
-</file>
-
-<file path="packages/types/src/sign-client/index.ts">
-export * from "./client";
-export * from "./engine";
-export * from "./jsonrpc";
-export * from "./proposal";
-export * from "./session";
-export * from "./pendingRequest";
-export * from "./auth";
-</file>
-
-<file path="packages/types/src/sign-client/jsonrpc.ts">
-import { ErrorResponse, JsonRpcResult } from "@walletconnect/jsonrpc-types";
-import { SignClientTypes } from "./client";
-import { RelayerTypes } from "../core/relayer";
-import { SessionTypes } from "./session";
-import { ProposalTypes } from "./proposal";
-import { AuthTypes } from ".";
-
-export declare namespace JsonRpcTypes {
-  // -- core ------------------------------------------------------- //
-  export type DefaultResponse = true | ErrorResponse;
-
-  export type WcMethod =
-    | "wc_sessionPropose"
-    | "wc_sessionSettle"
-    | "wc_sessionUpdate"
-    | "wc_sessionExtend"
-    | "wc_sessionDelete"
-    | "wc_sessionPing"
-    | "wc_sessionRequest"
-    | "wc_sessionEvent"
-    | "wc_sessionAuthenticate";
-
-  // -- requests --------------------------------------------------- //
-
-  export interface RequestParams {
-    wc_pairingDelete: {
-      code: number;
-      message: string;
-    };
-    wc_pairingPing: Record<string, unknown>;
-    wc_sessionPropose: {
-      relays: RelayerTypes.ProtocolOptions[];
-      requiredNamespaces: ProposalTypes.RequiredNamespaces;
-      optionalNamespaces: ProposalTypes.OptionalNamespaces;
-      sessionProperties?: ProposalTypes.SessionProperties;
-      proposer: {
-        publicKey: string;
-        metadata: SignClientTypes.Metadata;
-      };
-      expiryTimestamp?: number;
-    };
-    wc_sessionSettle: {
-      relay: RelayerTypes.ProtocolOptions;
-      namespaces: SessionTypes.Namespaces;
-      sessionProperties?: ProposalTypes.SessionProperties;
-      scopedProperties?: ProposalTypes.ScopedProperties;
-      sessionConfig?: SessionTypes.SessionConfig;
-      expiry: number;
-      controller: {
-        publicKey: string;
-        metadata: SignClientTypes.Metadata;
-      };
-    };
-    wc_sessionUpdate: {
-      namespaces: SessionTypes.Namespaces;
-    };
-    wc_sessionExtend: Record<string, unknown>;
-    wc_sessionDelete: {
-      code: number;
-      message: string;
-    };
-    wc_sessionPing: Record<string, unknown>;
-    wc_sessionRequest: {
-      request: {
-        method: string;
-        params: any;
-        expiryTimestamp?: number;
-      };
-      chainId: string;
-    };
-    wc_sessionEvent: {
-      event: {
-        name: string;
-        data: unknown;
-      };
-      chainId: string;
-    };
-    wc_sessionAuthenticate: AuthTypes.SessionAuthenticateRequestParams;
-  }
-
-  // -- responses -------------------------------------------------- //
-  export interface Results {
-    wc_pairingDelete: true;
-    wc_pairingPing: true;
-    wc_sessionPropose: {
-      relay: RelayerTypes.ProtocolOptions;
-      responderPublicKey: string;
-    };
-    wc_sessionSettle: true;
-    wc_sessionUpdate: true;
-    wc_sessionExtend: true;
-    wc_sessionDelete: true;
-    wc_sessionPing: true;
-    wc_sessionRequest: JsonRpcResult;
-    wc_sessionEvent: true;
-    wc_sessionAuthenticate: AuthTypes.SessionAuthenticateResponseParams;
-  }
-
-  export type Error = ErrorResponse;
-}
-</file>
-
-<file path="packages/types/src/sign-client/pendingRequest.ts">
-import { IStore, Verify } from "../core";
-import { SignClientTypes } from "./";
-
-export declare namespace PendingRequestTypes {
-  export interface Struct {
-    topic: string;
-    id: number;
-    params: SignClientTypes.EventArguments["session_request"]["params"];
-    verifyContext: Verify.Context;
-  }
-}
-export type IPendingRequest = IStore<number, PendingRequestTypes.Struct>;
-</file>
-
-<file path="packages/types/src/sign-client/proposal.ts">
-import { SignClientTypes } from "./client";
-import { RelayerTypes } from "../core/relayer";
-import { IStore } from "../core/store";
-
-export declare namespace ProposalTypes {
-  interface BaseRequiredNamespace {
-    chains?: string[];
-    methods: string[];
-    events: string[];
-  }
-
-  type RequiredNamespace = BaseRequiredNamespace;
-
-  type RequiredNamespaces = Record<string, RequiredNamespace>;
-  type OptionalNamespaces = Record<string, RequiredNamespace>;
-  type SessionProperties = Record<string, string>;
-  type ScopedProperties = Record<string, unknown>;
-
-  export interface Struct {
-    id: number;
-    /**
-     * @deprecated in favor of expiryTimestamp
-     */
-    expiry?: number;
-    expiryTimestamp: number;
-    relays: RelayerTypes.ProtocolOptions[];
-    proposer: {
-      publicKey: string;
-      metadata: SignClientTypes.Metadata;
-    };
-    requiredNamespaces: RequiredNamespaces;
-    optionalNamespaces: OptionalNamespaces;
-    sessionProperties?: SessionProperties;
-    scopedProperties?: ScopedProperties;
-    pairingTopic: string;
-  }
-}
-
-export type IProposal = IStore<number, ProposalTypes.Struct>;
-</file>
-
-<file path="packages/types/src/sign-client/session.ts">
-import { RelayerTypes } from "../core/relayer";
-import { IStore } from "../core/store";
-import { SignClientTypes } from "./client";
-import { ProposalTypes } from "./proposal";
-import { AuthTypes } from "./auth";
-
-export declare namespace SessionTypes {
-  type Expiry = number;
-
-  interface BaseNamespace {
-    chains?: string[];
-    accounts: string[];
-    methods: string[];
-    events: string[];
-  }
-
-  type Namespace = BaseNamespace;
-
-  type Namespaces = Record<string, Namespace>;
-
-  type SessionProperties = ProposalTypes.SessionProperties;
-  type ScopedProperties = ProposalTypes.ScopedProperties;
-
-  interface SessionConfig {
-    disableDeepLink?: boolean;
-  }
-
-  interface Struct {
-    topic: string;
-    pairingTopic: string;
-    relay: RelayerTypes.ProtocolOptions;
-    expiry: Expiry;
-    acknowledged: boolean;
-    controller: string;
-    namespaces: Namespaces;
-    requiredNamespaces: ProposalTypes.RequiredNamespaces;
-    optionalNamespaces: ProposalTypes.OptionalNamespaces;
-    sessionProperties?: SessionProperties;
-    scopedProperties?: ScopedProperties;
-    sessionConfig?: SessionConfig;
-    self: {
-      publicKey: string;
-      metadata: SignClientTypes.Metadata;
-    };
-    peer: {
-      publicKey: string;
-      metadata: SignClientTypes.Metadata;
-    };
-    authentication?: AuthTypes.Cacao[];
-    transportType?: RelayerTypes.TransportType;
-  }
-}
-
-export type ISession = IStore<string, SessionTypes.Struct>;
-</file>
-
-<file path="packages/types/src/index.ts">
-export * from "./core";
-export * from "./sign-client";
-</file>
-
-<file path="packages/types/.npmignore">
-*.log
-npm-debug.log*
-
-# Coverage directory used by tools like istanbul
-coverage
-.nyc_output
-
-# Dependency directories
-node_modules
-
-# npm package lock
-package-lock.json
-yarn.lock
-
-# project files
-src
-test
-CHANGELOG.md
-.travis.yml
-.editorconfig
-.eslintignore
-.eslintrc
-.babelrc
-.gitignore
-.watchmanconfig
-</file>
-
-<file path="packages/types/CHANGELOG.md">
-# @walletconnect/types
-
-## 2.20.0
-
-## 2.19.4
-
-## 2.19.3
-</file>
-
-<file path="packages/types/LICENSE">
-Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   Copyright 2021 WalletConnect, Inc.
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-</file>
-
-<file path="packages/types/package.json">
-{
-  "name": "@walletconnect/types",
-  "description": "Typings for WalletConnect Protocol",
-  "version": "2.20.0",
-  "author": "WalletConnect, Inc. <walletconnect.com>",
-  "homepage": "https://github.com/walletconnect/walletconnect-monorepo/",
-  "license": "Apache-2.0",
-  "main": "dist/index.cjs.js",
-  "module": "dist/index.es.js",
-  "unpkg": "dist/index.umd.js",
-  "types": "dist/types/index.d.ts",
-  "sideEffects": false,
-  "files": [
-    "dist"
-  ],
-  "keywords": [
-    "wallet",
-    "walletconnect"
-  ],
-  "scripts": {
-    "clean": "rm -rf dist",
-    "build:pre": "npm run clean",
-    "build:types": "tsc",
-    "build:source": "rollup --config rollup.config.js",
-    "build": "npm run build:pre; npm run build:source; npm run build:types",
-    "lint": "eslint -c '../../.eslintrc' --fix './src/**/*.ts'",
-    "prettier": "prettier --check 'src/**/*.{js,ts,jsx,tsx}'"
-  },
-  "dependencies": {
-    "@walletconnect/events": "1.0.1",
-    "@walletconnect/heartbeat": "1.2.2",
-    "@walletconnect/jsonrpc-types": "1.0.4",
-    "@walletconnect/keyvaluestorage": "1.1.1",
-    "@walletconnect/logger": "2.1.2",
-    "events": "3.3.0"
-  }
-}
-</file>
-
-<file path="packages/types/README.md">
-# @walletconnect/types
-
-Typings for WalletConnect Protocol
-</file>
-
-<file path="packages/types/rollup.config.js">
-import { name, dependencies } from "./package.json";
-import createConfig from "../../rollup.config";
-
-export default createConfig(name, Object.keys(dependencies));
-</file>
-
-<file path="packages/types/tsconfig.json">
-{
-  "extends": "../../tsconfig.json",
-  "include": ["./src/**/*"],
-  "compilerOptions": {
-    "rootDir": "src",
-    "outDir": "./dist/types",
-    "emitDeclarationOnly": true
-  }
-}
-</file>
-
-</files>
diff --git a/package.json b/package.json
index 76e7330..7901fd3 100644
--- a/package.json
+++ b/package.json
@@ -3,12 +3,12 @@
   "version": "0.1.0",
   "private": true,
   "scripts": {
-    "dev": "next dev --turbopack",
+    "dev": "NODE_OPTIONS='--inspect' next dev --turbopack",
     "build": "next build",
     "start": "next start",
     "lint": "next lint",
     "prepare": "husky",
-    "generate-llms": "repomix --include \"*.*,src\" -o llms.txt",
+    "generate-llms": "repomix --include \"*.*,src\" --ignore \"llms.txt\" -o llms.txt",
     "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,css,md,json}\"",
     "format:check": "prettier --check \"src/**/*.{js,jsx,ts,tsx,css,md,json}\""
   },
diff --git a/src/components/WcConnect.tsx b/src/components/WcConnect.tsx
index 7893d18..49ea3cc 100644
--- a/src/components/WcConnect.tsx
+++ b/src/components/WcConnect.tsx
@@ -1,9 +1,10 @@
 // src/components/WcConnect.tsx
 "use client";
 
-import React, { useState, useEffect } from "react";
+import React, { useState, useEffect, useCallback, useMemo } from "react";
 import { useWalletConnect } from "@/contexts/WalletConnectProvider"; // Ensure correct path
 import Image from "next/image";
+import { isExpired } from "@walletconnect/utils"; // <-- Import isExpired utility
 
 // Default/Fallback Icon
 const FallbackIcon = () => <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs">?</div>;
@@ -65,52 +66,75 @@ export function WcConnect() {
     pendingProposal, // Get the pending proposal
     approveSession, // Get approve action
     rejectSession, // Get reject action
-    isInitializing, // <<<--- ADDED isInitializing HERE ---<<<
+    isInitializing,
   } = useWalletConnect();
   const [uri, setUri] = useState("");
+  const [isSubmitting, setIsSubmitting] = useState(false);
 
   const activeSessionTopic = Object.keys(activeSessions)[0]; // Assuming only one session for MVP
   const connectedSession = activeSessionTopic ? activeSessions[activeSessionTopic] : null;
 
-  // --- Add this useEffect ---
+  // ---> Check if proposal is expired for UI state <--- //
+  const isProposalExpired = useMemo(() => {
+    if (!pendingProposal?.params?.expiryTimestamp) return false; // No timestamp means can't determine expiry this way
+    return isExpired(pendingProposal.params.expiryTimestamp);
+  }, [pendingProposal]); // Re-calculate only when proposal changes
+  // ---> End Expiry Check <--- //
+
   useEffect(() => {
-    // If there's no connected session (either initially or after disconnect),
-    // clear the URI input field.
     if (!connectedSession) {
       setUri("");
     }
-  }, [connectedSession]); // Run this effect when connectedSession changes
-  // -------------------------
-
-  const handleConnect = () => {
-    if (!uri || !isInitialized || isLoading) return; // Check initialization and combined loading state
-    pair(uri);
-  };
-
-  const handleDisconnect = () => {
-    if (connectedSession && isInitialized && !isLoading) {
-      // Check initialization and combined loading state
-      disconnect(connectedSession.topic);
+  }, [connectedSession]);
+
+  const handleConnect = useCallback(() => {
+    if (!uri || !isInitialized || isLoading || isSubmitting) return;
+    setIsSubmitting(true);
+    pair(uri).finally(() => setIsSubmitting(false));
+  }, [uri, isInitialized, isLoading, isSubmitting, pair]);
+
+  const handleDisconnect = useCallback(() => {
+    if (connectedSession && isInitialized && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      disconnect(connectedSession.topic).finally(() => setIsSubmitting(false));
     }
-  };
-
-  const handleApprove = () => {
-    if (pendingProposal && !isLoading) {
-      approveSession();
+  }, [connectedSession, isInitialized, isLoading, isSubmitting, disconnect]);
+
+  const handleApprove = useCallback(async () => {
+    if (pendingProposal && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      try {
+        await approveSession();
+      } catch (err) {
+        console.error("Approval failed:", err);
+      } finally {
+        setIsSubmitting(false);
+      }
     }
-  };
-
-  const handleReject = () => {
-    if (pendingProposal && !isLoading) {
-      rejectSession();
+  }, [pendingProposal, isLoading, isSubmitting, approveSession]);
+
+  const handleReject = useCallback(async () => {
+    if (pendingProposal && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      try {
+        await rejectSession();
+      } catch (err) {
+        console.error("Rejection failed:", err);
+      } finally {
+        setIsSubmitting(false);
+      }
     }
-  };
+  }, [pendingProposal, isLoading, isSubmitting, rejectSession]);
+
+  // Combined loading state (context is loading OR local component is submitting)
+  const isDisabled = isLoading || isSubmitting || !isInitialized;
+  const approveDisabled = isDisabled || isProposalExpired; // <-- Disable approve if expired
 
   // Display loading states more granularly if needed, otherwise use `isLoading`
-  const connectButtonText = isPairing ? "Pairing..." : isLoading ? "Working..." : "Connect";
-  const disconnectButtonText = isLoading ? "Working..." : "Disconnect";
-  const approveButtonText = isLoading ? "Working..." : "Approve Session";
-  const rejectButtonText = isLoading ? "Working..." : "Reject Session";
+  const connectButtonText = isPairing ? "Pairing..." : isSubmitting ? "Connecting..." : isLoading ? "Working..." : "Connect";
+  const disconnectButtonText = isSubmitting ? "Working..." : isLoading ? "Working..." : "Disconnect";
+  const approveButtonText = isSubmitting ? "Approving..." : isLoading ? "Working..." : "Approve Session";
+  const rejectButtonText = isSubmitting ? "Rejecting..." : isLoading ? "Working..." : "Reject Session";
 
   // Resolve icon URLs
   const connectedDAppIconUrl = connectedSession
@@ -134,17 +158,24 @@ export function WcConnect() {
             <span className="text-sm text-gray-700">{pendingProposal.params.proposer.metadata.name}</span>
           </div>
           {/* TODO: Display requested permissions details if needed */}
+          {/* ---> Add Expiry Message <--- */}
+          {isProposalExpired && (
+            <p className="text-sm font-medium text-red-600 text-center">
+              This connection proposal has expired. Please generate a new one from the dApp.
+            </p>
+          )}
+          {/* ---> End Expiry Message <--- */}
           <div className="flex space-x-2 pt-2">
             <button
               onClick={handleApprove}
-              disabled={isLoading || !isInitialized}
+              disabled={approveDisabled} // <--- Use specific disabled state
               className="flex-1 px-3 py-1 bg-green-500 text-white text-xs font-medium rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {approveButtonText}
             </button>
             <button
               onClick={handleReject}
-              disabled={isLoading || !isInitialized}
+              disabled={isDisabled} // Reject might still be possible even if expired, or disable too: `disabled={isDisabled || isProposalExpired}`
               className="flex-1 px-3 py-1 bg-red-500 text-white text-xs font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {rejectButtonText}
@@ -170,7 +201,7 @@ export function WcConnect() {
           </p>
           <button
             onClick={handleDisconnect}
-            disabled={isLoading || !isInitialized} // Use combined loading state
+            disabled={isDisabled}
             className="w-full px-4 py-2 mt-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
           >
             {disconnectButtonText}
@@ -193,11 +224,11 @@ export function WcConnect() {
               onChange={(e) => setUri(e.target.value)}
               placeholder="wc:..."
               className="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm disabled:bg-gray-100"
-              disabled={isLoading || !isInitialized} // Use combined loading state
+              disabled={isDisabled}
             />
             <button
               onClick={handleConnect}
-              disabled={!uri || isLoading || !isInitialized} // Use combined loading state
+              disabled={!uri || isDisabled}
               className="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {connectButtonText}
@@ -207,11 +238,9 @@ export function WcConnect() {
       )}
 
       {/* --- Status/Error Messages --- */}
-      {error && !isLoading && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
+      {error && !isLoading && !isSubmitting && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
       {isPairing && <p className="text-indigo-600 text-sm mt-2">Pairing initiated, check dApp/wallet if needed...</p>}
-      {/* Check both flags here now */}
       {!isInitialized && !isInitializing && !error && <p className="text-orange-600 text-sm mt-2">WalletConnect service not ready.</p>}
-      {/* And display initializing message correctly */}
       {isInitializing && <p className="text-gray-500 text-sm mt-2">Initializing WalletConnect...</p>}
     </div>
   );
diff --git a/src/contexts/WalletConnectProvider.tsx b/src/contexts/WalletConnectProvider.tsx
index 0c1e8f6..7ac07c1 100644
--- a/src/contexts/WalletConnectProvider.tsx
+++ b/src/contexts/WalletConnectProvider.tsx
@@ -6,7 +6,7 @@ import React, { createContext, useState, useContext, ReactNode, useEffect, useCa
 import { WalletConnectService, ServiceEvents, type WalletConnectServiceEvents } from "@/services/walletConnectService";
 import { SessionTypes } from "@walletconnect/types";
 import { IWalletKit, WalletKitTypes } from "@reown/walletkit";
-import { buildApprovedNamespaces, getSdkError } from "@walletconnect/utils";
+import { buildApprovedNamespaces, getSdkError, isExpired } from "@walletconnect/utils";
 import { useLensAccount } from "./LensAccountContext";
 import { LENS_CHAIN_ID } from "@/lib/constants";
 import { JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
@@ -101,94 +101,114 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
         console.error("WalletConnectProvider Mount Effect: service.init() rejected.", initError);
       });
     }
-  }, [projectId]); // Add projectId dependency
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [projectId]); // Keep only projectId as it's needed for creation
 
-  // --- Effect to Attach/Detach Event Listeners ---
-  useEffect(() => {
-    const currentService = serviceRef.current; // Capture ref value for effect closure
-    if (!currentService) {
-      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
-      return;
-    }
-
-    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");
-
-    // Define handlers
-    const handleInitialized: WalletConnectServiceEvents[ServiceEvents.Initialized] = ({ success, instance }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
+  // --- Event Handlers (wrapped in useCallback) ---
+  const handleInitialized = useCallback<WalletConnectServiceEvents[ServiceEvents.Initialized]>(
+    ({ success, instance }) => {
+      console.log(`%cProvider Handler: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
       setIsInitialized(success);
       setWalletKitInstance(success ? instance : null);
-      if (currentService) setActiveSessions(currentService.getActiveSessions());
+      // Check serviceRef directly instead of captured value, as it might change over time if remount occurs
+      if (serviceRef.current) setActiveSessions(serviceRef.current.getActiveSessions());
       setIsInitializing(false);
       if (!success && !error) setError("Initialization failed via event");
-    };
-    const handlePairStatus: WalletConnectServiceEvents[ServiceEvents.PairStatus] = ({ status, message }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
-      setIsPairing(status === "pairing");
-      if (status === "error") {
-        setError(message || "Pairing failed");
-        setIsPairing(false);
-      } else if (status !== "pairing") {
-        setError(null);
-      }
-    };
-    const handleSessionProposal: WalletConnectServiceEvents[ServiceEvents.SessionProposal] = ({ proposal }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
-      setPendingProposal(proposal);
-      setIsPairing(false);
-      setError(null);
-    };
-    const handleSessionConnect: WalletConnectServiceEvents[ServiceEvents.SessionConnect] = ({ session }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
-      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
+    },
+    [error],
+  ); // Dependency: error (to avoid setting error if one already exists)
+
+  const handlePairStatus = useCallback<WalletConnectServiceEvents[ServiceEvents.PairStatus]>(({ status, message }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
+    setIsPairing(status === "pairing");
+    if (status === "error") {
+      setError(message || "Pairing failed");
       setIsPairing(false);
+    } else if (status !== "pairing") {
       setError(null);
-      setPendingProposal(null);
-    };
-    // This now handles PEER disconnects or SDK internal cleanup events
-    const handleSessionDelete: WalletConnectServiceEvents[ServiceEvents.SessionDelete] = ({ topic }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
+    }
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionProposal = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionProposal]>(({ proposal }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
+    setPendingProposal(proposal);
+    setIsPairing(false);
+    setError(null);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionConnect = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionConnect]>(({ session }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
+    setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
+    setIsPairing(false);
+    setError(null);
+    setPendingProposal(null);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionDelete = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionDelete]>(
+    ({ topic }) => {
+      console.log(`%cProvider Handler: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
       setActiveSessions((prev) => {
         if (!prev[topic]) return prev;
+        // eslint-disable-next-line @typescript-eslint/no-unused-vars
         const { [topic]: _removed, ...rest } = prev;
         console.log(`%cProvider State: Removing session ${topic} based on SDK/PEER event.`, "color: brown");
         return rest;
       });
       setIsPairing(false);
+      // Need pendingProposal to check pairingTopic
       if (pendingProposal && pendingProposal.params.pairingTopic === topic) {
         console.log("%cProvider: Clearing pending proposal due to SDK/peer session delete event.", "color: brown");
         setPendingProposal(null);
       }
-    };
-    const handleSessionsUpdated: WalletConnectServiceEvents[ServiceEvents.SessionsUpdated] = ({ sessions }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
-      setActiveSessions(sessions);
-    };
-    const handleSessionRequest: WalletConnectServiceEvents[ServiceEvents.SessionRequest] = ({ request }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
-      if (request.params.request.method === "eth_sendTransaction") {
-        setPendingRequest(request);
-        setError(null);
-      } else {
-        console.warn(`%cProvider Listener: Received unhandled request method: ${request.params.request.method}`, "color: orange");
-      }
-    };
-    const handleError: WalletConnectServiceEvents[ServiceEvents.Error] = ({ message }) => {
-      console.error(`%cProvider Listener: ${ServiceEvents.Error} received:`, "color: red", message);
-      setError(message);
-      setIsPairing(false);
-      setIsProcessingAction(false);
-    };
-    const handleIsLoading: WalletConnectServiceEvents[ServiceEvents.IS_LOADING] = ({ isLoading }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
-      setIsProcessingAction(isLoading);
-    };
-    const handleIsPairing: WalletConnectServiceEvents[ServiceEvents.IS_PAIRING] = ({ isPairing }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
-      setIsPairing(isPairing);
-    };
+    },
+    [pendingProposal],
+  ); // Dependency: pendingProposal
+
+  const handleSessionsUpdated = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionsUpdated]>(({ sessions }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
+    setActiveSessions(sessions);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionRequest = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionRequest]>(({ request }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
+    if (request.params.request.method === "eth_sendTransaction") {
+      setPendingRequest(request);
+      setError(null);
+    } else {
+      console.warn(`%cProvider Handler: Received unhandled request method: ${request.params.request.method}`, "color: orange");
+      // Maybe respond with an error here automatically?
+      // respondRequest({ id: request.id, jsonrpc: '2.0', error: { code: -32601, message: 'Method not supported' } });
+    }
+  }, []); // Dependency: respondRequest (if adding automatic error response)
+
+  const handleError = useCallback<WalletConnectServiceEvents[ServiceEvents.Error]>(({ message }) => {
+    console.error(`%cProvider Handler: ${ServiceEvents.Error} received:`, "color: red", message);
+    setError(message);
+    setIsPairing(false);
+    setIsProcessingAction(false);
+  }, []); // No dependencies needed here as it only calls setters
 
-    // Attach listeners
+  const handleIsLoading = useCallback<WalletConnectServiceEvents[ServiceEvents.IS_LOADING]>(({ isLoading }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
+    setIsProcessingAction(isLoading);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleIsPairing = useCallback<WalletConnectServiceEvents[ServiceEvents.IS_PAIRING]>(({ isPairing }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
+    setIsPairing(isPairing);
+  }, []); // No dependencies needed here as it only calls setters
+
+  // --- Effect to Attach/Detach Event Listeners ---
+  useEffect(() => {
+    const currentService = serviceRef.current; // Capture ref value
+    if (!currentService) {
+      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
+      return;
+    }
+
+    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");
+
+    // Attach the useCallback handlers
     currentService.on(ServiceEvents.Initialized, handleInitialized);
     currentService.on(ServiceEvents.PairStatus, handlePairStatus);
     currentService.on(ServiceEvents.SessionProposal, handleSessionProposal);
@@ -200,11 +220,10 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
     currentService.on(ServiceEvents.IS_PAIRING, handleIsPairing);
     currentService.on(ServiceEvents.SessionRequest, handleSessionRequest);
 
-    // Cleanup function
+    // Cleanup function using the same stable handlers
     return () => {
-      console.log("%cWalletConnectProvider Mount Effect: Cleaning up listeners.", "color: orange");
+      console.log("%cWalletConnectProvider Listener Effect: Cleaning up listeners.", "color: orange");
       if (currentService) {
-        // Use the captured variable
         console.log("%cDetaching listeners from service instance in ref.", "color: orange");
         currentService.off(ServiceEvents.Initialized, handleInitialized);
         currentService.off(ServiceEvents.PairStatus, handlePairStatus);
@@ -218,7 +237,21 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
         currentService.off(ServiceEvents.SessionRequest, handleSessionRequest);
       }
     };
-  }, []);
+  }, [
+    // Dependencies are the stable handler functions themselves
+    handleInitialized,
+    handlePairStatus,
+    handleSessionProposal,
+    handleSessionConnect,
+    handleSessionDelete,
+    handleSessionsUpdated,
+    handleError,
+    handleIsLoading,
+    handleIsPairing,
+    handleSessionRequest,
+    // Also include isInitialized or serviceRef.current? Let's try without first.
+    // If listeners aren't attached correctly after init, add isInitialized.
+  ]);
 
   // --- Context Methods ---
   const pair = useCallback(
@@ -228,15 +261,29 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
       setError(null);
       await serviceRef.current.pair(uri);
     },
-    [isInitialized],
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+    [isInitialized], // Keep isInitialized here
   );
 
   const approveSession = useCallback(async () => {
-    if (!serviceRef.current?.isInitialized() || !pendingProposal || !lensAccountAddress) {
-      const reason = !isInitialized ? "Service not ready." : !pendingProposal ? "No proposal." : "No Lens address.";
+    if (!serviceRef.current?.isInitialized() || !pendingProposal) {
+      const reason = !isInitialized ? "Service not ready." : "No proposal.";
       setError(`Cannot approve: ${reason}`);
       return;
     }
+
+    if (pendingProposal.params.expiryTimestamp && isExpired(pendingProposal.params.expiryTimestamp)) {
+      console.warn(`Attempted to approve expired proposal ${pendingProposal.id}.`);
+      setError("Connection proposal expired. Please try again.");
+      setPendingProposal(null);
+      return;
+    }
+
+    if (!lensAccountAddress) {
+      setError("Cannot approve: Lens Account address is missing.");
+      return;
+    }
+
     console.log(`%cWalletConnectProvider: approveSession called for proposal ${pendingProposal.id}`, "color: cyan");
     setError(null);
 
@@ -261,8 +308,6 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
 
       const session = await serviceRef.current.approveSession(pendingProposal, approvedNamespaces);
       console.log(`%cWalletConnectProvider: approveSession successful, received session:`, "color: green", session);
-      // Manually update state since event might not fire from SDK
-      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
       setPendingProposal(null);
       setIsPairing(false);
       setError(null);
@@ -287,7 +332,6 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
     }
   }, [isInitialized, pendingProposal]);
 
-  // >>>>>>>> REVERTED disconnect callback <<<<<<<<
   const disconnect = useCallback(
     async (topic: string) => {
       if (!serviceRef.current?.isInitialized()) {
@@ -308,24 +352,27 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
             console.warn(`%cWalletConnectProvider: Tried to remove non-existent session ${topic} from state.`, "color: orange");
             return prev;
           }
+          // eslint-disable-next-line @typescript-eslint/no-unused-vars
           const { [topic]: _removed, ...rest } = prev;
           console.log(`%cWalletConnectProvider: Manually removing session ${topic} from state.`, "color: brown");
           return rest;
         });
-        // Ensure other related states are cleared
+
+        // ---> KEEP This State Clearing Logic <---
+        setPendingProposal(null);
+        setPendingRequest(null); // Clear pending requests too
         setIsPairing(false);
-        if (pendingProposal?.params?.pairingTopic === topic) {
-          console.log(`%cWalletConnectProvider: Clearing pending proposal during manual disconnect cleanup for topic ${topic}.`, "color: brown");
-          setPendingProposal(null);
-        }
+        setError(null);
+        // ---> End State Clearing Logic <---
       } catch (e) {
         console.error(`%cWalletConnectProvider: disconnect failed for topic ${topic}:`, "color: red", e);
         setError((e as Error)?.message || "Disconnect failed");
       }
     },
-    [pendingProposal], // isInitialized was correctly removed previously
+    // Add dependencies if they are used *inside* the logic before the service call,
+    // but since it primarily relies on the `topic` argument, `[]` is okay here.
+    [],
   );
-  // >>>>>>>> ----------------------------- <<<<<<<<
 
   const respondRequest = useCallback(
     async (response: JsonRpcResponse) => {
diff --git a/src/services/walletConnectService.ts b/src/services/walletConnectService.ts
index 226b7b6..2f496ce 100644
--- a/src/services/walletConnectService.ts
+++ b/src/services/walletConnectService.ts
@@ -254,19 +254,27 @@ export class WalletConnectService extends EventEmitter {
   }
   // -------------------------------------------
 
-  // Typed EventEmitter methods (keep as before)
+  // Typed EventEmitter methods (Apply this pattern to on, once, off, removeListener)
   on<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.on(event, listener as (...args: any[]) => void);
   }
+
   once<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.once(event, listener as (...args: any[]) => void);
   }
+
   off<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.off(event, listener as (...args: any[]) => void);
   }
+
   removeListener<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     return super.removeListener(event, listener as (...args: any[]) => void);
   }
+
   emit<E extends keyof WalletConnectServiceEvents>(event: E, ...args: Parameters<WalletConnectServiceEvents[E]>): boolean {
     return super.emit(event, ...args);
   }
</file>

<file path="src/components/ConnectOwnerButton.tsx">
// components/ConnectOwnerButton.tsx
"use client";

import { ConnectKitButton } from "connectkit";

export function ConnectOwnerButton() {
  return (
    <div className="flex justify-center">
      <ConnectKitButton />
    </div>
  );
}
</file>

<file path="src/hooks/useDebounce.ts">
// hooks/useDebounce.ts
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Update debounced value after delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cancel the timeout if value changes (also on delay change or unmount)
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]); // Only re-call effect if value or delay changes

  return debouncedValue;
}
</file>

<file path="src/styles/globals.css">
@import "tailwindcss" source("../**/*.{js,ts,jsx,tsx,mdx}");

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
} */

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".prettierrc">
{
  "printWidth": 150
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
# Lens Account Web Interface

This project is a web application designed to provide an interface for interacting with a custom EVM Smart Account, specifically the "Lens Account". It allows the account owner to connect their controlling EOA wallet, view basic account information, and interact with external dApps _through_ the Lens Account using WalletConnect v2 via Reown WalletKit.

This is the Minimum Viable Product (MVP) focusing on core functionality as outlined in the project specifications.

## Tech Stack

- **Framework:** Next.js 15+ (App Router)
- **Language:** TypeScript
- **Styling:** Tailwind CSS
- **Package Manager:** pnpm
- **Core Web3 Libraries:**
  - Wagmi
  - Viem
  - ConnectKit
  - @reown/walletkit (for WalletConnect v2 Wallet functionality)
  - @tanstack/react-query (peer dependency for Wagmi)

## Prerequisites

- Node.js (v18.17 or later recommended)
- pnpm

## Getting Started

1.  **Clone the repository (if applicable):**

    ```bash
    git clone <repository-url>
    cd lens-account-interface
    ```

2.  **Install dependencies:**

    ```bash
    pnpm install
    ```

3.  **Set up Environment Variables:**
    Create a `.env.local` file in the root of the project. You **must** obtain a Project ID from [WalletConnect Cloud](https://cloud.walletconnect.com/).

    ```plaintext [.env.local]
    # Get your ID from https://cloud.walletconnect.com/
    NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=YOUR_WALLETCONNECT_PROJECT_ID_HERE
    ```

    Replace `YOUR_WALLETCONNECT_PROJECT_ID_HERE` with your actual Project ID.

4.  **Run the development server:**
    ```bash
    pnpm dev
    ```
    Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Available Scripts

In the project directory, you can run:

- `pnpm dev`: Runs the app in development mode. Open [http://localhost:3000](http://localhost:3000).
- `pnpm build`: Builds the app for production.
- `pnpm start`: Starts the production server.
- `pnpm lint`: Runs ESLint.

## Project Structure

The project uses the Next.js App Router. Key directories will include:

- `app/`: Contains application routes and layouts.
- `components/`: Reusable React components.
- `contexts/`: React Context providers for managing shared state.
- `hooks/`: Custom React Hooks for specific logic.
- `lib/`: Configuration files (Wagmi, constants) and utility functions.
- `services/`: Abstraction layers for external SDKs (e.g., Reown WalletKit).
- `styles/`: Global styles and Tailwind configuration.

_(Refer to the Technical Specification for a more detailed proposed structure)._

## Contributing

_(Placeholder: Add contribution guidelines here when applicable)._

## License

_(Placeholder: Add license information here when applicable)._
</file>

<file path="Spec.functional.md">
# Functional Specification: Lens Account Web Interface - MVP (Iteration 1)

## 1. Introduction

This document outlines the functional requirements for the Minimum Viable Product (MVP) of a web interface designed to interact with a custom EVM Smart Accoun - Lens Account. Users (Owners) will be able to identify their Lens Account, connect their controlling EOA wallet, view a basic balance, and use WalletConnect v2 to interact with external dApps _through_ the Lens Account.

## 2. Target Audience

This specification is intended for developers, QA testers, and product managers involved in building the MVP.

## 3. Key Concepts

- **Lens Account:** The EVM smart contract wallet being managed. It has a single `owner()` address.
- **Owner EOA:** The Externally Owned Account (e.g., MetaMask, hardware wallet address) designated as the `owner()` of the Lens Account. This wallet is used to authorize actions _for_ the Lens Account.
- **Lens Username:** A username potentially linked to a Lens Account address via the `LensGlobalNamespace` contract.
- **WalletConnect (WC):** A protocol allowing wallets (in this case, our interface acting _as_ a wallet for the Lens Account) to connect to dApps.
- **Lens Chain:** The specific blockchain (ID 232) where the Lens Account and related contracts reside.

## 4. Core Scenarios (MVP)

### Scenario 1: Account Discovery and Owner Login

**Goal:** The user identifies their target Lens Account using either a Lens username or the account address and connects their corresponding Owner EOA wallet, ensuring they are on the correct network.

**Steps:**

1.  **Initial View:** The user accesses the web application's main entry page (`/`).
2.  **Input Fields:** The user is presented with two input fields:
    - "Lens Username"
    - "Account Address"
3.  **Username Input (User Action):**
    - The user types a Lens username into the "Lens Username" field.
    - **(App Action):** As the user types (debounced), the application queries the `LensGlobalNamespace` contract on the Lens Chain using the `accountOf(string calldata name)` function.
    - **(Outcome):**
      - If an address is returned, the "Account Address" field is automatically populated with the resolved address.
      - If no address is found (or an error occurs), the "Account Address" field remains empty or clears, and subtle feedback may be shown (e.g., input border color change).
4.  **Address Input (User Action):**
    - The user types or pastes an address into the "Account Address" field.
    - **(App Action):** As the user types/pastes, the application checks until address length & format is correct (0x + 20 chars) and queries the `LensGlobalNamespace` contract on the Lens Chain using the `usernameOf(address user)` function.
    - **(Outcome):**
      - If a username is returned, the "Lens Username" field is populated.
      - If no username is found, the "Lens Username" field remains empty or clears.
5.  **Owner Verification (App Action):**
    - Once a valid address exists in the "Account Address" field, the application queries the Lens Account contract at that address using the `owner()` function.
    - The application stores the returned `owner` address internally as the _expected owner_.
6.  **Wallet Connection (User Action):**
    - A "Connect Wallet" button becomes enabled/visible once an Account Address is determined.
    - The expected owner is also displayed above the Connect Wallet button with some text (something like "To Login - connect with this Owner wallet:" but proper).
    - The user clicks "Connect Wallet".
    - **(App Action):** A standard wallet connection modal (e.g., RainbowKit) appears, prompting the user to choose and connect their Owner EOA wallet.
    - **(App Action):** The application checks if the connected Owner EOA wallet is currently on the **Lens Chain (ID: 232)**.
    - **(Outcome - Chain Mismatch):**
      - If the wallet is on a different chain, the application (via `wagmi`/`RainbowKit`) prompts the user to switch to the Lens Chain.
      - If the Lens Chain is not configured in the user's wallet, the application prompts the user to add it.
      - The connection process pauses until the wallet is successfully connected to the Lens Chain.
    - **(App Action):** Once the Owner EOA is connected and on the Lens Chain, the application compares the connected wallet's address with the _expected owner_ address stored in step 5.b.
    - **(Outcome - Owner Mismatch):**
      - If the addresses do _not_ match, an error message is displayed clearly indicating the mismatch (e.g., "Incorrect owner connected. Please connect with address: `0x...{expectedOwnerAddress}`").
      - The user remains on the login/discovery page and can attempt to connect a different wallet.
    - **(Outcome - Success):**
      - If the addresses _match_ and the wallet is on the Lens Chain, the user is authenticated for this session.
      - The application navigates the user to the main Dashboard page (e.g., `/dashboard`).

### Scenario 2: Viewing Dashboard & Initiating WalletConnect Pairing

**Goal:** The user views basic account information and connects the Lens Account to an external dApp using a WalletConnect URI.

**Preconditions:**

- User has successfully completed Scenario 1.
- Owner EOA wallet is connected and verified.
- User is on the Dashboard page.

**Steps:**

1.  **Dashboard View:** The user sees the Dashboard.
2.  **Account Info Display (App Action):**
    - The Lens Account address is displayed.
    - The WGHO token balance for the Lens Account is fetched and displayed (formatted).
3.  **WalletConnect Input:** The user sees a dedicated section/component for WalletConnect containing:
    - An input field labeled "Paste WalletConnect Code".
    - A "Connect" button next to the input field.
4.  **Obtain WC URI (User Action):** The user navigates to an external dApp (e.g., Aave) and initiates a WalletConnect connection, copying the generated WC v2 URI (e.g., `wc:abc...`).
5.  **Paste & Connect (User Action):**
    - The user pastes the WC URI into the input field in _this_ web app.
    - The user clicks the "Connect" button.
6.  **Pairing & Session (App Action):**
    - The application uses the `@walletconnect/web3wallet` SDK to initiate pairing with the provided URI.
    - The SDK emits a `session_proposal` event.
    - The application automatically approves the session proposal using the Lens Account's address, enforcing Lens Chain (ID: 232) as the only supported chain regardless of dApp's requested chains.
    - The WalletConnect session is established between this interface (acting for the Lens Account) and the external dApp.
    - The input field clears and the WalletConnect section updates to show:
      - A prominent "Connected" status indicator in green
      - Connected dApp information from the session data:
        - dApp name and icon
        - Website URL
        - Connected chain (should always show Lens Chain)
        - Session ID (for debugging purposes)

### Scenario 3: Handling WalletConnect Transaction Requests

**Goal:** The user receives a transaction request from a connected external dApp and authorizes its execution via their Owner EOA.

**Preconditions:**

- User has successfully completed Scenario 1 & 2.
- An active WalletConnect session exists between the Lens Account interface and an external dApp.

**Steps:**

1.  **Request Initiation (External Action):** The user performs an action on the external dApp that requires a transaction (e.g., depositing collateral on Aave).
2.  **Request Reception (App Action):**
    a. The external dApp sends a request (typically `eth_sendTransaction` containing `to`, `value`, `data`) over the established WC session.
    b. The `@walletconnect/web3wallet` SDK listener in the application receives the `session_request` event.
3.  **Request Display:**
    - The application updates its state to indicate a pending request.
    - A dedicated component (`WcRequestDisplay`) appears on the Dashboard, showing:
      - The requesting dApp's name/icon (from session metadata).
      - The transaction details:
        - **Target Address (`to`):** The contract the Lens Account will call.
        - **Value (`value`):** Amount of native currency (GHO) to send (formatted).
        - **Data (`data`):** The raw calldata for the transaction. (MVP: Display raw hex data. Decoding can be added later).
      - A "Send Transaction" button.
      - A "Reject" button (optional for MVP, but good practice).
4.  **User Review & Action:**
    - The user reviews the displayed transaction details.
    - **(Option A - Send):** The user clicks "Send Transaction".
    - **(App Action - Execute):**
      - The application prepares the call to the Lens Account's `executeTransaction(address target, uint256 value, bytes calldata data)` function, using the parameters from the WC request.
      - It triggers the transaction using `wagmi`.
      - The connected **Owner EOA wallet** (MetaMask, etc.) prompts the user to confirm _this_ transaction (the one calling `executeTransaction` on the Lens Account).
      - **(User Action):** The user confirms the transaction in their EOA wallet.
      - The transaction is sent to the Lens Chain network.
      - The application waits for the transaction hash.
      - Upon receiving the hash, the application sends a _success response_ containing the transaction hash back to the external dApp via the WalletConnect session (`web3wallet.respondSessionRequest`).
      - The `WcRequestDisplay` component is hidden or updated.
      - A success indicator (e.g., checkmark, brief message "Transaction Submitted") is displayed on the dashboard.
    - **(Option B - Reject):** The user clicks "Reject" (if implemented).
    - **(App Action - Reject):**
      - The application sends an _error response_ (e.g., user rejection error) back to the external dApp via the WalletConnect session.
      - The `WcRequestDisplay` component is hidden.

### Scenario 4: Handling Errors during WC Request Execution

**Goal:** Inform the user and the external dApp if an error occurs during the authorization or sending of a WC transaction request.

**Steps (Owner Rejection):**

1.  Follow Scenario 3 up to step 4.c.iii (Owner EOA wallet prompt).
2.  **User Action:** User explicitly rejects the transaction in their wallet.
3.  **(App Action):** The `wagmi` transaction hook/promise rejects with a user rejection error.
4.  The application sends an _error response_ (user rejection) back to the external dApp via WalletConnect.
5.  The `WcRequestDisplay` component is hidden.
6.  An error message is displayed on the dashboard (e.g., "Transaction rejected by user").

**Steps (Blockchain Error):**

1.  Follow Scenario 3 up to step 4.c.v (Transaction sent).
2.  **(Blockchain Action):** The transaction execution _fails_ on the Lens Chain (e.g., reverts).
3.  **(App Action):** The `wagmi` transaction hook/promise resolves with a failed status (or requires checking the receipt).
4.  The application sends an _error response_ (generic execution error) back to the external dApp via WalletConnect.
5.  The `WcRequestDisplay` component is hidden.
6.  An error message is displayed on the dashboard (e.g., "Transaction failed on-chain").

## 5. Non-Functional Requirements (MVP)

- **Target Network:** The application MUST operate exclusively on the Lens Chain Mainnet (ID: 232). Network configuration should reflect this.
- **Responsiveness:** The UI should be usable on standard desktop browsers. Mobile responsiveness is secondary for the MVP.
- **Error Handling:** Basic error messages should be displayed for contract call failures, lookup failures, WC connection issues, and incorrect owner connections.
- **Performance:** Interactions (lookups, balance fetches) should feel reasonably responsive. Debouncing should be used for inputs triggering lookups.

## 6. Out of Scope (MVP - Iteration 1)

- Displaying Transaction History or Queue (beyond the currently active WC request).
- Initiating _new_ transactions (e.g., Send ETH/Token) directly from the UI.
- Managing Lens Account settings (Owners, Threshold).
- Detailed decoding of transaction data within the WC request display.
- Address Book functionality.
- NFT display or management.
- Advanced WalletConnect session management (listing active sessions, manual disconnection).
- Gas controls or advanced transaction parameters.
- Support for multiple Lens Account types or versions beyond the specific one targeted.
- Account Manager roles.
- Push notifications or complex real-time updates beyond basic WC request handling.

## 7. Lens Chain Details

- **Chain Type:** ZkSync-based L2, EVM-compatible
- **Network Name:** Lens Chain Mainnet
- **New RPC URL:** https://rpc.lens.xyz
- **Chain ID:** 232
- **Currency Symbol:** GHO
- **Block Explorer URL:** https://explorer.lens.xyz
</file>

<file path="src/components/DiscoveryForm.tsx">
// components/DiscoveryForm.tsx
"use client";

import React, { useState, useEffect } from "react";
import { useReadContract } from "wagmi";
import { isAddress } from "viem";
import { useDebounce } from "@/hooks/useDebounce";
import { LENS_CHAIN_ID, LENS_GLOBAL_NAMESPACE_ADDRESS, LENS_GLOBAL_NAMESPACE_ABI } from "@/lib/constants";

interface DiscoveryFormProps {
  // Allow empty string or null when no valid address is found
  onAccountAddressFound: (address: `0x${string}` | "") => void; // Changed type
  initialUsername?: string;
  initialAddress?: string;
}

export function DiscoveryForm({ onAccountAddressFound, initialUsername = "", initialAddress = "" }: DiscoveryFormProps) {
  const [username, setUsername] = useState(initialUsername);
  const [address, setAddress] = useState(initialAddress);
  const [lookupError, setLookupError] = useState<string | null>(null);

  const [lastEdited, setLastEdited] = useState<"username" | "address" | null>(initialUsername ? "username" : initialAddress ? "address" : null);

  const debouncedUsername = useDebounce(username, 500);
  const debouncedAddress = useDebounce(address, 500);

  const {
    data: addressFromUsername,
    isLoading: isLoadingAddress,
    error: addressError,
    refetch: refetchAddress,
  } = useReadContract({
    address: LENS_GLOBAL_NAMESPACE_ADDRESS,
    abi: LENS_GLOBAL_NAMESPACE_ABI,
    functionName: "accountOf",
    args: [debouncedUsername || ""],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: false,
    },
  });

  const {
    data: usernameFromAddress,
    isLoading: isLoadingUsername,
    error: usernameError,
    refetch: refetchUsername,
  } = useReadContract({
    address: LENS_GLOBAL_NAMESPACE_ADDRESS,
    abi: LENS_GLOBAL_NAMESPACE_ABI,
    functionName: "usernameOf",
    args: [debouncedAddress as `0x${string}`],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: false,
    },
  });

  useEffect(() => {
    if (debouncedUsername && lastEdited === "username") {
      setLookupError(null);
      console.log(`Looking up address for username: ${debouncedUsername}`);
      refetchAddress();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedUsername, lastEdited]);

  useEffect(() => {
    if (debouncedAddress && isAddress(debouncedAddress) && lastEdited === "address") {
      setLookupError(null);
      console.log(`Looking up username for address: ${debouncedAddress}`);
      refetchUsername();
    } else if (debouncedAddress && !isAddress(debouncedAddress) && lastEdited === "address") {
      setLookupError("Invalid address format");
      onAccountAddressFound(""); // Use empty string
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedAddress, lastEdited]);

  useEffect(() => {
    if (addressFromUsername && isAddress(addressFromUsername) && lastEdited === "username") {
      if (addressFromUsername === "0x0000000000000000000000000000000000000000") {
        setLookupError(`No account found for username "${debouncedUsername}"`);
        setAddress("");
        onAccountAddressFound(""); // Use empty string
      } else {
        console.log(`Found address: ${addressFromUsername}`);
        setAddress(addressFromUsername);
        onAccountAddressFound(addressFromUsername);
        setLookupError(null);
      }
    } else if (addressError && lastEdited === "username") {
      console.error("Error fetching address:", addressError);
      setLookupError("Error fetching address. Check console.");
      onAccountAddressFound(""); // Use empty string
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [addressFromUsername, addressError, lastEdited]);

  useEffect(() => {
    if (usernameFromAddress && lastEdited === "address") {
      console.log(`Found username: ${usernameFromAddress}`);
      setUsername(usernameFromAddress);
      if (isAddress(debouncedAddress)) {
        // Ensure address is still valid
        onAccountAddressFound(debouncedAddress as `0x${string}`);
      }
      setLookupError(null);
    } else if (usernameError && lastEdited === "address") {
      console.log("No primary username found for address or error:", usernameError.message);
      setUsername("");
      if (isAddress(debouncedAddress)) {
        onAccountAddressFound(debouncedAddress as `0x${string}`);
      }
      setLookupError(null);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [usernameFromAddress, usernameError, lastEdited, debouncedAddress]);

  const handleUsernameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setUsername(e.target.value);
    setLastEdited("username");
    if (lastEdited !== "address") setAddress("");
    onAccountAddressFound(""); // Use empty string
    setLookupError(null);
  };

  const handleAddressChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setAddress(value);
    setLastEdited("address");
    if (lastEdited !== "username") setUsername("");
    if (!isAddress(value) && value !== "") {
      setLookupError("Invalid address format");
      onAccountAddressFound(""); // Use empty string
    } else {
      setLookupError(null);
      if (isAddress(value)) {
        onAccountAddressFound(value as `0x${string}`);
      } else {
        onAccountAddressFound(""); // Use empty string
      }
    }
  };

  const isLoading = isLoadingAddress || isLoadingUsername;

  return (
    <div className="space-y-4">
      <div>
        <label htmlFor="username" className="block text-sm font-medium text-gray-700 mb-1">
          Lens Username
        </label>
        <input
          id="username"
          name="username"
          type="text"
          value={username}
          onChange={handleUsernameChange}
          placeholder="e.g. stani"
          className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
          aria-describedby="username-status"
          disabled={isLoading && lastEdited === "address"}
        />
      </div>

      <div>
        <label htmlFor="address" className="block text-sm font-medium text-gray-700 mb-1">
          Account Address
        </label>
        <input
          id="address"
          name="address"
          type="text"
          value={address}
          onChange={handleAddressChange}
          placeholder="0x..."
          className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 ${
            !lookupError && isAddress(address) ? "border-green-500" : address && !isAddress(address) ? "border-red-500" : "border-gray-300"
          }`}
          aria-describedby="address-status"
          disabled={isLoading && lastEdited === "username"}
        />
      </div>
      <div id="username-status" aria-live="polite" className="text-sm h-5">
        {isLoading && lastEdited === "username" && <span className="text-gray-500">Checking username...</span>}
      </div>
      <div id="address-status" aria-live="polite" className="text-sm h-5">
        {isLoading && lastEdited === "address" && <span className="text-gray-500">Checking address...</span>}
        {lookupError && <span className="text-red-600">{lookupError}</span>}
        {!lookupError && isAddress(address) && lastEdited !== "username" && <span className="text-green-600">Valid Address</span>}
      </div>
    </div>
  );
}
</file>

<file path="src/contexts/LensAccountContext.tsx">
// contexts/LensAccountContext.tsx
"use client";

import React, { createContext, useState, useContext, ReactNode } from "react";
import { type Address } from "viem";

interface LensAccountState {
  lensAccountAddress: Address | null;
  ownerAddress: Address | null;
  setVerifiedAccount: (lensAddress: Address, ownerAddress: Address) => void;
  clearAccount: () => void;
}

const LensAccountContext = createContext<LensAccountState | undefined>(undefined);

interface LensAccountProviderProps {
  children: ReactNode;
}

export function LensAccountProvider({ children }: LensAccountProviderProps) {
  const [lensAccountAddress, setLensAccountAddress] = useState<Address | null>(null);
  const [ownerAddress, setOwnerAddress] = useState<Address | null>(null);

  const setVerifiedAccount = (lensAddress: Address, verifiedOwnerAddress: Address) => {
    setLensAccountAddress(lensAddress);
    setOwnerAddress(verifiedOwnerAddress);
    console.log("Context Updated: Lens Account Set ->", lensAddress);
    console.log("Context Updated: Owner Set ->", verifiedOwnerAddress);
  };

  const clearAccount = () => {
    setLensAccountAddress(null);
    setOwnerAddress(null);
    console.log("Context Updated: Account Cleared");
  };

  const value = {
    lensAccountAddress,
    ownerAddress,
    setVerifiedAccount,
    clearAccount,
  };

  return <LensAccountContext.Provider value={value}>{children}</LensAccountContext.Provider>;
}

// Custom hook to use the context
export function useLensAccount() {
  const context = useContext(LensAccountContext);
  if (context === undefined) {
    throw new Error("useLensAccount must be used within a LensAccountProvider");
  }
  return context;
}
</file>

<file path="src/lib/wagmi.ts">
// lib/wagmi.ts
import { http, createConfig } from "wagmi";
import { getDefaultConfig } from "connectkit"; // Correct import
import { lensChain } from "./constants";

const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;

if (!projectId) {
  throw new Error("NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID is not set in .env.local");
}

export const config = createConfig(
  // Use ConnectKit's getDefaultConfig
  getDefaultConfig({
    // Correct function name
    // Required API Keys
    walletConnectProjectId: projectId,

    // Required App Info
    appName: "Lens Account Interface",
    appDescription: "Interact with your Lens Account",
    appUrl: typeof window !== "undefined" ? window.location.origin : "https://example.com",
    appIcon: "/favicon.ico",

    // Chains to support
    chains: [lensChain],

    // Transports (ensure http is configured for your chain)
    transports: {
      [lensChain.id]: http(lensChain.rpcUrls.default.http[0]),
    },

    // ssr: true, // Keep commented unless SSR hydration with cookies is needed
  }),
);

// Optional: Register config for global type inference
// declare module 'wagmi' {
//   interface Register {
//     config: typeof config
//   }
// }
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactStrictMode: false,
};

export default nextConfig;
</file>

<file path="Spec.technical.md">
# Technical Specification: Lens Account Web Interface - MVP (Iteration 1)

**Version:** 1.0
**Date:** 2024-10-27

---

## 1. Introduction

### 1.1. Purpose

This document provides the technical details necessary for the development of the Minimum Viable Product (MVP) of the Lens Account Web Interface. It outlines the technology stack, architecture, key components, APIs, data structures, and implementation details derived from the Functional Specification (`Spec.functional.md`).

### 1.2. Scope

The scope of this MVP is limited to the core scenarios defined in the Functional Specification:

1.  **Account Discovery & Owner Login:** Identifying a Lens Account via username or address, connecting the Owner EOA wallet, and verifying ownership on the Lens Chain.
2.  **Dashboard & WalletConnect Pairing:** Displaying basic Lens Account info (address, balance) and initiating WalletConnect v2 pairings with external dApps.
3.  **WalletConnect Transaction Handling:** Receiving transaction requests from dApps via WalletConnect and facilitating their execution through the Lens Account via the Owner EOA.
4.  **Basic Error Handling:** Managing connection and transaction errors.

Features listed as "Out of Scope" in the Functional Specification are not included in this technical plan.

---

## 2. Technology Stack

- **Framework:** Next.js 15+ (App Router recommended)
- **Language:** TypeScript
- **Core Web3 Libraries:**
  - **Wagmi:** v2.x - For React hooks interacting with Ethereum (account state, contract interaction via Owner EOA, chain state, ENS lookups if adapted).
  - **Viem:** v2.x - Used internally by Wagmi for low-level Ethereum operations (encoding, decoding, RPC calls, utilities). May be used directly for specific utilities if needed.
  - **ConnectKit:** Latest compatible version - For the Owner EOA wallet connection UI and simplifying the `useConnect` flow from Wagmi.
  - **@walletconnect/web3wallet:** Latest v2 compatible version - **Crucially**, this SDK is required for the application to act _as a wallet_ on behalf of the Lens Account when interacting with external dApps via WalletConnect. ConnectKit/Wagmi handle connecting the _Owner EOA_ to _this_ app; `@walletconnect/web3wallet` handles connecting _this_ app (representing the Lens Account) to _other_ dApps.
- **UI/Styling:**
  - **Tailwind CSS:** Recommended for utility-first styling to maintain simplicity and avoid heavy UI library dependencies for the MVP. Basic HTML elements (`input`, `button`, `div`, `p`, etc.) styled with Tailwind will suffice. No complex UI component library is necessary initially.
- **State Management:** React Context API / `useState` / `useReducer` for managing application state (e.g., connected owner, target Lens Account, WC sessions/requests). Avoid Redux/Zustand for MVP complexity unless state becomes unmanageable.
- **Linting/Formatting:** ESLint, Prettier (Standard Next.js setup).

**Note on EthersJS:** While Wagmi v1 used EthersJS, Wagmi v2 (used by ConnectKit) uses **Viem**. EthersJS is **not** expected to be a required dependency for this project based on the chosen stack. We will proceed assuming Viem is the primary low-level library.

---

## 3. Architecture

### 3.1. Overview

The application will be a single-page application (SPA) built with Next.js. The core logic will reside within React components and custom hooks.

- **Client-Side Rendering:** Given the heavy reliance on wallet interactions and real-time state, the application will primarily be client-side rendered. Server components might be used for static layout elements if desired, but core functionality requires client components (`"use client"`).
- **Wallet Connection Management:**
  - **Owner EOA Connection:** Managed by ConnectKit, utilizing Wagmi hooks (`useAccount`, `useConnect`, `useDisconnect`, `useSwitchChain`). State will be accessible via Wagmi's context/hooks.
  - **Lens Account WC Connection (Acting as Wallet):** Managed by a dedicated service/context (`WalletConnectService`) wrapping the `@walletconnect/web3wallet` SDK. This service will handle pairing, session proposals/approvals, request handling, and responses.
- **Contract Interaction:**
  - Reading Lens Account `owner()`: Uses Wagmi's `useReadContract`.
  - Reading `LensGlobalNamespace` (`accountOf`, `usernameOf`): Uses Wagmi's `useReadContract`.
  - Reading WGHO Balance: Uses Wagmi's `useReadContract` (ERC20 `balanceOf`).
  - Executing Lens Account Transactions (via Owner EOA): Uses Wagmi's `useWriteContract` targeting the Lens Account's `executeTransaction`.
- **State Management:** A combination of Wagmi's built-in state, local React component state (`useState`), and potentially 1-2 specific React Contexts (e.g., `WalletConnectContext` for managing WC sessions/requests, `LensAccountContext` for holding the target Lens Account address and owner).

### 3.2. Key Modules/Services

- **Wagmi Config (`lib/wagmi.ts`):** Central configuration for Wagmi/ConnectKit (chains, connectors, transports).
- **WalletConnect Service (`services/walletConnectService.ts`):** Singleton or context-provided class encapsulating `@walletconnect/web3wallet` logic (initialization, pairing, event listeners, session management, request/response handling).
- **Lens Contract Service (`services/lensService.ts`):** Optional utility functions abstracting the direct `useReadContract` calls for Lens Account `owner()`, `LensGlobalNamespace` lookups, and WGHO balance.

---

## 4. Project Structure (App Router Example)

```
src/
 app/
    dashboard/             # Dashboard page (requires auth)
       page.tsx
    layout.tsx             # Root layout (WagmiProvider, etc.)
    page.tsx               # Root page (Login/Discovery View)
 components/
    layout/                # Header, Footer, etc.
    ui/                    # Basic UI elements (Button, Input - if abstracting)
    AccountDisplay.tsx     # Shows Lens Account Address/Balance
    ConnectOwnerButton.tsx # Uses ConnectKit button/logic
    DiscoveryForm.tsx      # Username/Address input fields
    WcConnect.tsx          # WC URI input and connection status
    WcRequestDisplay.tsx   # Displays incoming WC requests
 contexts/
    WalletConnectProvider.tsx # Manages WC state/service
    LensAccountProvider.tsx   # Manages target Lens Account state
 hooks/
    useLensLookup.ts       # Custom hook for username/address lookups
    useWcRequestHandler.ts # Custom hook for handling WC requests
 services/
    walletConnectService.ts # Wrapper around @walletconnect/web3wallet
    lensService.ts          # (Optional) Utilities for Lens contract reads
 lib/
    wagmi.ts               # Wagmi/ConnectKit config
    constants.ts           # Chain info, contract addresses, ABIs
    utils.ts               # Helper functions
 public/
    ...                    # Static assets
 styles/
    globals.css            # Tailwind directives
 .env.local                 # Environment variables (WC Project ID)
 next.config.mjs
 package.json
 tailwind.config.ts
 tsconfig.json
```

---

## 5. Core Components & Logic Implementation

### 5.1. Scenario 1: Account Discovery and Owner Login (`/app/page.tsx`, `DiscoveryForm.tsx`, `ConnectOwnerButton.tsx`)

- **UI:** `DiscoveryForm.tsx` contains two `<input>` fields styled with Tailwind. `ConnectOwnerButton.tsx` wraps ConnectKit's logic.
- **State:** Local state (`useState`) in `DiscoveryForm.tsx` for input values. A shared state (Context or prop drilling from `page.tsx`) for the determined Lens Account address and expected owner address.
- **Logic (`useLensLookup.ts`, `DiscoveryForm.tsx`):**
  - Use `React.useEffect` with debouncing for input changes.
  - Inside `useEffect`, call `useReadContract` (Wagmi) targeting `LensGlobalNamespace` (`accountOf` or `usernameOf`). **Important:** Need to configure `useReadContract` specifically for Lens Chain (ID 232). Pass the `chainId` parameter.
  - Update the corresponding input field based on lookup results.
  - Once an address is confirmed, call `useReadContract` targeting the Lens Account address for the `owner()` function. Store the result as `expectedOwner`.
  - Display `expectedOwner` near the connect button.
- **Owner Connection (`ConnectOwnerButton.tsx`, `page.tsx`):**
  - Use `ConnectKitButton` component or `useConnect` (Wagmi) + `useAccount` (Wagmi). ConnectKit is simpler.
  - The `wagmi.ts` config must include the Lens Chain definition. ConnectKit/Wagmi will handle prompting the user to add/switch to the Lens Chain.
  - After connection, use `useAccount` hook (Wagmi) to get the `address` and `chainId`.
  - Compare `address` with `expectedOwner`.
  - If match and `chainId === 232`, navigate to `/dashboard` (e.g., using `next/navigation`'s `useRouter`). Store the Lens Account address and Owner EOA address in Context/State for the dashboard.
  - If mismatch, display an error message.

### 5.2. Scenario 2: Viewing Dashboard & Initiating WalletConnect Pairing (`/app/dashboard/page.tsx`, `AccountDisplay.tsx`, `WcConnect.tsx`, `WalletConnectProvider.tsx`, `services/walletConnectService.ts`)

- **UI:** `AccountDisplay.tsx` shows Lens address (from Context/State) and balance. `WcConnect.tsx` shows WC URI input/button initially, then connected dApp info.
- **State:** `WalletConnectContext` manages `Web3Wallet` instance, active sessions, and pairing state.
- **Logic:**
  - Fetch WGHO balance using `useReadContract` (Wagmi) targeting the ERC20 contract with the Lens Account address. Format using Viem's `formatUnits`.
  - In `WalletConnectProvider.tsx` (or on component mount):
    - Initialize `Web3Wallet` from `@walletconnect/web3wallet` using `projectId` from `.env.local`. Store the instance.
    - Set up listeners (`web3wallet.on('session_proposal', ...)` etc.) defined in `walletConnectService.ts`.
  - **Pairing (`WcConnect.tsx`, `walletConnectService.ts`):**
    - On "Connect" button click with URI: Call `web3wallet.core.pairing.pair({ uri })`.
  - **Session Approval (`walletConnectService.ts` listener):**
    - On `session_proposal` event:
      - Construct approved `namespaces` containing **only** the Lens Chain (`eip155:232`) and the Lens Account address (`eip155:232:0x...`). Include standard methods (`eth_sendTransaction`, `personal_sign`, etc.).
      - Call `web3wallet.approveSession({ id: proposal.id, namespaces })`.
      - Store the resulting session details in the `WalletConnectContext`.
      - Update UI state in `WcConnect.tsx` to show connected dApp info.

### 5.3. Scenario 3 & 4: Handling WalletConnect Transaction Requests (`/app/dashboard/page.tsx`, `WcRequestDisplay.tsx`, `useWcRequestHandler.ts`, `services/walletConnectService.ts`)

- **UI:** `WcRequestDisplay.tsx` conditionally renders when a request is pending in `WalletConnectContext`. Displays request details and Approve/Reject buttons.
- **State:** `WalletConnectContext` stores the current pending `session_request` event payload.
- **Logic:**
  - **Request Listener (`walletConnectService.ts`):**
    - On `session_request` event: Store the event payload (`topic`, `params`, `id`) in `WalletConnectContext` state.
  - **Transaction Execution (`WcRequestDisplay.tsx`, `useWcRequestHandler.ts`):**
    - On "Send Transaction" click:
      - Retrieve request details (`to`, `value`, `data`) from the context state.
      - Use Viem's `encodeFunctionData` to prepare the calldata for the Lens Account's `executeTransaction(address target, uint256 value, bytes calldata data)` function.
      - Call the `writeContract` mutation function returned by `useWriteContract` (Wagmi), providing:
        - `address`: The Lens Account address (from Context/State).
        - `abi`: The Lens Account ABI (including `executeTransaction`).
        - `functionName`: `'executeTransaction'`.
        - `args`: `[to, value, data]`.
        - `account`: The connected Owner EOA address (from `useAccount`).
        - `chainId`: Must be Lens Chain ID (232).
      - Handle `useWriteContract`'s `isPending`, `isSuccess`, `error` states.
      - If `isPending`, show loading state.
      - If `error`, call `web3wallet.respondSessionRequest` with an appropriate error payload (e.g., `{ code: 5000, message: 'User Rejected' }` or a generic error). Display error in UI. Clear the pending request state.
      - If `isSuccess` (meaning the _Owner EOA_ transaction was submitted), wait for the transaction receipt using `useWaitForTransactionReceipt` (Wagmi).
        - If the receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`. Display success in UI. Clear the pending request state.
        - If the receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a generic execution error payload. Display error in UI. Clear the pending request state.
    - On "Reject" button click:
      - Call `web3wallet.respondSessionRequest` with a user rejection error payload.
      - Clear the pending request state.

---

## 6. State Management

- **Wagmi:** Manages Owner EOA connection state (address, chainId, connector, connection status) and provides TanStack Query caching for reads.
- **LensAccountContext:** Stores the identified Lens Account address and the verified Owner EOA address upon successful login.
- **WalletConnectContext:** Stores the `@walletconnect/web3wallet` instance, active WC sessions (list/map), current pending WC request payload, and connection/pairing status flags.
- **Local Component State:** Used for form inputs, UI loading/error states within specific components.

---

## 7. Styling

- Utilize **Tailwind CSS** for styling all components.
- Keep styling minimal and functional for the MVP.
- Ensure basic layout structure (header, main content area).

---

## 8. Error Handling

- Implement `try...catch` blocks around critical operations (WC pairing, session approval, request responses).
- Utilize the `error` states returned by Wagmi hooks (`useReadContract`, `useWriteContract`, `useWaitForTransactionReceipt`).
- Display user-friendly error messages for common issues (network mismatch, incorrect owner, transaction rejection, WC errors, contract reverts). Log detailed errors to the console for debugging.
- Specifically handle WalletConnect SDK errors during pairing and session proposals.

---

## 9. Constants & Configuration

- **`lib/constants.ts`:**
  - `LENS_CHAIN_ID = 232`
  - `LENS_CHAIN_RPC_URL = 'https://rpc.lens.xyz'`
  - `LENS_CHAIN_EXPLORER_URL = 'https://explorer.lens.xyz'`
  - `LENS_CHAIN_CURRENCY = { name: 'GHO', symbol: 'GHO', decimals: 18 }`
  - `LENS_GLOBAL_NAMESPACE_ADDRESS = '0x1aA55B9042f08f45825dC4b651B64c9F98Af4615'`
  - `WGHO_TOKEN_ADDRESS = '0x6bDc36E20D267Ff0dd6097799f82e78907105e2F'` (Actual Address Needed)
  - `LENS_ACCOUNT_ABI = [...]` (Include `owner()`, `executeTransaction()`)
  - `LENS_GLOBAL_NAMESPACE_ABI = [...]` (Include `accountOf(string)`, `usernameOf(address)`)
  - `ERC20_ABI = [...]` (Include `balanceOf(address)`)
- **`lib/wagmi.ts`:**
  - Define the `lensChain` object using Viem's `defineChain`.
  - Configure `createConfig` (Wagmi) with `chains: [lensChain]`, necessary connectors (e.g., `injected`, `walletConnect`), and transports.
- **`.env.local`:**
  - `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=<Your_WC_Project_ID>` (Obtain from [cloud.walletconnect.com](https://cloud.walletconnect.com/))

---

## 10. Deployment

- Standard Next.js deployment process (e.g., Vercel, Netlify).
- Ensure environment variables (like `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`) are configured in the deployment environment.

---

## 11. Future Considerations (Post-MVP)

- Support for multiple Lens Account types/versions.
- Transaction history display.
- Direct sending of GHO/WGHO from the UI.
- More detailed transaction decoding for WC requests.
- Advanced error handling and user feedback.
- Mobile responsiveness improvements.
- Session management UI (disconnecting specific WC sessions).
- Support for additional WC methods (e.g., `personal_sign`).
- Potential integration of Safe SDKs if the Lens Account implements Safe compatibility layers.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/dashboard/layout.tsx">
// src/app/dashboard/layout.tsx
"use client"; // Context providers require client components

import { WalletConnectProvider } from "@/contexts/WalletConnectProvider";
// No need to import useLensAccount here if it's not used directly in this layout

// This layout wraps the content of `/dashboard/page.tsx` and any other
// potential pages under the /dashboard route (e.g., /dashboard/settings).

// Add the default export
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  // We assume LensAccountProvider is already wrapping the RootLayout
  // in src/app/layout.tsx via src/app/providers.tsx.
  // Therefore, we only need to add the WalletConnectProvider here.
  return <WalletConnectProvider>{children}</WalletConnectProvider>;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import "@/styles/globals.css";
import { Geist, Geist_Mono } from "next/font/google";
import { Providers } from "./providers"; // Import the Providers component

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Lens Account Interface", // Updated title
  description: "Manage your Lens Account", // Updated description
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // If using SSR hydration, you would get initialState here from headers/cookies
  // const initialState = cookieToInitialState(...) etc.

  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} min-h-screen`}>
        {/* Wrap children with Providers */}
        <Providers /*initialState={initialState}*/>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/components/AccountDisplay.tsx">
// components/AccountDisplay.tsx
"use client";

import React from "react";
import { useReadContract, useBalance } from "wagmi"; // Import useBalance
import { formatUnits, type BaseError, type Address } from "viem";
import { useLensAccount } from "@/contexts/LensAccountContext";
import {
  ERC20_ABI,
  WGHO_TOKEN_ADDRESS,
  LENS_CHAIN_ID,
  lensChain, // Import the chain definition
} from "@/lib/constants";

export function AccountDisplay() {
  const { lensAccountAddress } = useLensAccount();

  // Fetch native GHO balance
  const {
    data: nativeBalanceData,
    error: nativeBalanceError,
    isLoading: isLoadingNativeBalance,
  } = useBalance({
    address: lensAccountAddress as Address | undefined, // useBalance needs Address | undefined
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: !!lensAccountAddress,
      // Enable watching for updates (refetches on new blocks)
      refetchInterval: 5000, // Optional: Adjust polling interval if needed
      refetchOnWindowFocus: true,
    },
  });

  // Fetch WGHO (ERC20) balance
  const {
    data: wghoBalanceData,
    error: wghoBalanceError,
    isLoading: isLoadingWghoBalance,
  } = useReadContract({
    address: WGHO_TOKEN_ADDRESS as Address, // Add type assertion if needed or ensure it's typed correctly in constants
    abi: ERC20_ABI,
    functionName: "balanceOf",
    args: [lensAccountAddress!],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: !!lensAccountAddress,
      // Enable watching for updates (refetches on new blocks)
      refetchInterval: 5000, // Optional: Adjust polling interval if needed
      refetchOnWindowFocus: true,
    },
  });

  // Format balances safely
  const formattedNativeBalance =
    nativeBalanceData?.value !== undefined
      ? parseFloat(formatUnits(nativeBalanceData.value, lensChain.nativeCurrency.decimals)).toFixed(4)
      : "0.0000";

  const formattedWghoBalance =
    typeof wghoBalanceData === "bigint"
      ? parseFloat(formatUnits(wghoBalanceData, 18)).toFixed(4) // Assuming WGHO also has 18 decimals
      : "0.0000";

  const isLoading = isLoadingNativeBalance || isLoadingWghoBalance;

  return (
    <div className="p-4 border rounded-md bg-gray-50">
      <h2 className="text-lg font-semibold mb-3 text-gray-700">Account Balances</h2>
      {isLoading && <p className="text-gray-500 text-sm">Loading balances...</p>}

      {/* Native GHO Balance */}
      <div className="mb-2">
        {nativeBalanceError && !isLoadingNativeBalance && (
          <p className="text-red-600 text-sm">
            Error loading GHO balance: {(nativeBalanceError as BaseError).shortMessage || nativeBalanceError.message}
          </p>
        )}
        {!nativeBalanceError && !isLoadingNativeBalance && lensAccountAddress && (
          <p className="text-gray-800">
            <span className="font-medium">Native GHO:</span> <span className="font-mono text-lg">{formattedNativeBalance}</span>{" "}
            {lensChain.nativeCurrency.symbol}
          </p>
        )}
      </div>

      {/* WGHO Balance */}
      <div>
        {wghoBalanceError && !isLoadingWghoBalance && (
          <p className="text-red-600 text-sm">
            Error loading WGHO balance: {(wghoBalanceError as BaseError).shortMessage || wghoBalanceError.message}
          </p>
        )}
        {!wghoBalanceError && !isLoadingWghoBalance && lensAccountAddress && (
          <p className="text-gray-800">
            <span className="font-medium">WGHO Token:</span> <span className="font-mono text-lg">{formattedWghoBalance}</span> GHO
          </p>
        )}
      </div>

      {!lensAccountAddress && !isLoading && <p className="text-gray-500 text-sm mt-2">Cannot fetch balances without Lens Account address.</p>}
    </div>
  );
}
</file>

<file path="src/components/WcRequestDisplay.tsx">
// src/components/WcRequestDisplay.tsx
"use client";

import React, { useState, useEffect, useCallback, useRef } from "react";
import { useWalletConnect } from "@/contexts/WalletConnectProvider";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { formatUnits, type Hash } from "viem";
import { getSdkError } from "@walletconnect/utils";
import { formatJsonRpcError, formatJsonRpcResult, JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, lensChain } from "@/lib/constants";

// Basic Fallback Icon Component
const FallbackIcon = ({ size = 30 }: { size?: number }) => (
  <div
    style={{ width: `${size}px`, height: `${size}px` }}
    className="rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs"
  >
    ?
  </div>
);

export function WcRequestDisplay() {
  const { pendingRequest, respondRequest, error: wcError, isLoading: isWcLoading } = useWalletConnect();
  const { lensAccountAddress } = useLensAccount();
  const { address: ownerAddress, chainId: ownerChainId } = useAccount();

  // State related to the write *initiation*
  const { data: hash, error: writeError, isPending: isWritePending, writeContractAsync, reset: resetWriteContract } = useWriteContract();
  // State related to the *confirmation* of the hash from write initiation
  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
    data: receipt,
  } = useWaitForTransactionReceipt({ hash, chainId: LENS_CHAIN_ID });

  const [localError, setLocalError] = useState<string | null>(null);
  const [localLoadingMessage, setLocalLoadingMessage] = useState<string | null>(null);
  // Store the ID of the request currently being actively processed
  const processingRequestId = useRef<number | null>(null);
  // Store the hash associated with the *currently processed* request ID
  const processingRequestHash = useRef<Hash | null>(null);

  // --- Log Component Render ---
  console.log(
    `%cWcRequestDisplay Render: pendingReqId=${pendingRequest?.id ?? "null"}, currentProcessingId=${processingRequestId.current}, currentProcessingHash=${processingRequestHash.current ?? "null"}, hookHash=${hash ?? "null"}, isWritePending=${isWritePending}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, writeError=${!!writeError}, receiptError=${!!receiptError}`,
    "color: magenta",
  );
  // --------------------------

  // --- Effect to Reset State When a NEW Request Arrives ---
  useEffect(() => {
    const incomingRequestId = pendingRequest?.id ?? null;
    const currentProcessing = processingRequestId.current;

    console.log(
      `%cWcRequestDisplay ResetEffect: Running. Incoming ID: ${incomingRequestId}, Current Processing ID: ${currentProcessing}`,
      "color: teal",
    );

    if (incomingRequestId !== null) {
      if (currentProcessing !== incomingRequestId) {
        console.log(`%cWcRequestDisplay ResetEffect: New request ${incomingRequestId} detected. Resetting state.`, "color: teal");
        resetWriteContract();
        setLocalError(null);
        setLocalLoadingMessage(null);
        processingRequestId.current = incomingRequestId;
        processingRequestHash.current = null; // Reset hash ref
      } else {
        console.log(
          `%cWcRequestDisplay ResetEffect: Incoming ID ${incomingRequestId} matches current Processing ID. No reset needed.`,
          "color: teal",
        );
      }
    } else {
      if (currentProcessing !== null) {
        console.log(`%cWcRequestDisplay ResetEffect: No pending request. Resetting state.`, "color: teal");
        resetWriteContract();
        setLocalError(null);
        setLocalLoadingMessage(null);
        processingRequestId.current = null;
        processingRequestHash.current = null; // Reset hash ref
      } else {
        console.log(`%cWcRequestDisplay ResetEffect: No pending request and nothing processing. No reset needed.`, "color: teal");
      }
    }
  }, [pendingRequest, resetWriteContract]); // Now depends on pendingRequest object itself

  // --- Effect to track the hash associated with the current request ---
  useEffect(() => {
    if (hash && processingRequestId.current && !processingRequestHash.current) {
      console.log(`%cWcRequestDisplay HashTrackEffect: Associating hash ${hash} with request ID ${processingRequestId.current}`, "color: purple");
      processingRequestHash.current = hash; // Store the hash for the request we are processing
    }
  }, [hash, processingRequestId]); // Run when hash changes and we have a processing ID

  // --- Centralized Respond Function ---
  const handleRespond = useCallback(
    (response: JsonRpcResponse) => {
      const currentId = processingRequestId.current;
      if (currentId !== null && currentId === response.id) {
        console.log(`%cWcRequestDisplay handleRespond: Responding for request ID: ${response.id}`, "color: darkmagenta", response);
        respondRequest(response);
        // Reset processing state *after* responding
        processingRequestId.current = null;
        processingRequestHash.current = null; // Reset hash ref
        setLocalLoadingMessage(null);
        resetWriteContract(); // Try resetting here too
      } else {
        console.warn(
          `%cWcRequestDisplay handleRespond: Ignoring response attempt for stale/mismatched request ID: ${response.id} (Current Processing: ${currentId})`,
          "color: orange",
        );
      }
    },
    [respondRequest, resetWriteContract],
  ); // Add resetWriteContract

  // --- Effect to Handle Transaction Submission Result ---
  useEffect(() => {
    const currentProcessingId = processingRequestId.current;
    const currentReqHash = processingRequestHash.current; // Use the hash we stored for this request

    console.log(
      `%cWcRequestDisplay ReceiptEffect: Running. CurrentProcessingId=${currentProcessingId}, CurrentReqHash=${currentReqHash ?? "null"}, HookHash=${hash ?? "null"}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, receiptError=${!!receiptError}`,
      "color: #2ECC71",
    );

    // Guards:
    // 1. Must be processing a request.
    // 2. Must have a specific hash associated with *this* request attempt.
    // 3. The confirmation process must be finished (or errored).
    // 4. The hook's current hash must match the hash associated with our request.
    if (!currentProcessingId || !currentReqHash || isConfirming || hash !== currentReqHash) {
      console.log(
        `%cWcRequestDisplay ReceiptEffect: Bailing out (ProcessingID: ${currentProcessingId}, CurrentReqHash: ${currentReqHash}, HookHash: ${hash}, Confirming: ${isConfirming})`,
        "color: gray",
      );
      return;
    }

    // Now check receipt and errors, ensuring they match the currentReqHash
    if (receipt && receipt.transactionHash === currentReqHash) {
      console.log(`%cWcRequestDisplay ReceiptEffect: Receipt received for current hash ${currentReqHash}`, "color: #2ECC71");
      setLocalLoadingMessage(null);
      if (receipt.status === "success") {
        console.log(
          `%cWcRequestDisplay ReceiptEffect: Transaction successful, calling handleRespond for ID ${currentProcessingId}`,
          "color: #2ECC71",
        );
        handleRespond(formatJsonRpcResult(currentProcessingId, receipt.transactionHash));
      } else {
        console.error(
          `%cWcRequestDisplay ReceiptEffect: Transaction reverted, calling handleRespond for ID ${currentProcessingId}`,
          "color: red",
          receipt,
        );
        setLocalError("Transaction reverted on chain.");
        handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction reverted" }));
      }
    } else if (receiptError) {
      console.error(
        `%cWcRequestDisplay ReceiptEffect: Transaction Receipt Error for hash ${currentReqHash}, calling handleRespond for ID ${currentProcessingId}`,
        "color: red",
        receiptError,
      );
      setLocalError(`Transaction failed: ${receiptError.message}`);
      handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction Failed on chain" }));
    } else if (isConfirmed && !receipt) {
      console.warn(
        `%cWcRequestDisplay ReceiptEffect: isConfirmed is true but receipt is still null/undefined for hash ${currentReqHash}. Waiting.`,
        "color: orange",
      );
    } else {
      console.log(`%cWcRequestDisplay ReceiptEffect: No definitive action taken for hash ${currentReqHash}`, "color: gray");
    }
  }, [isConfirming, isConfirmed, receiptError, receipt, hash, handleRespond]); // Keep dependencies

  // --- Effect to Handle Direct Write Errors ---
  useEffect(() => {
    const currentProcessingId = processingRequestId.current;
    console.log(`%cWcRequestDisplay WriteErrorEffect: Running. writeError=${!!writeError}, currentProcessingId=${currentProcessingId}`, "color: red");
    if (writeError && currentProcessingId) {
      console.error("WcRequestDisplay WriteErrorEffect: Write Contract Error detected:", writeError);
      setLocalError(`Transaction rejected or failed to send: ${writeError.message}`);
      handleRespond(formatJsonRpcError(currentProcessingId, getSdkError("USER_REJECTED")));
    }
  }, [writeError, handleRespond]);

  const handleApprove = async () => {
    if (!pendingRequest) return setLocalError("No request to approve.");
    if (!lensAccountAddress) return setLocalError("Lens Account address missing.");
    if (!ownerAddress) return setLocalError("Owner wallet not connected.");
    if (!writeContractAsync) return setLocalError("Transaction function not ready.");
    if (ownerChainId !== LENS_CHAIN_ID) return setLocalError("Owner wallet not on Lens Chain.");

    // Reset local state AND ensure we reset wagmi state *before* initiating write
    console.log(`%cWcRequestDisplay handleApprove: Resetting state before write for request ID: ${pendingRequest.id}`, "color: blueviolet");
    resetWriteContract(); // Reset here as well
    processingRequestId.current = pendingRequest.id; // Mark immediately
    processingRequestHash.current = null; // Clear previous hash
    setLocalError(null);
    setLocalLoadingMessage("Please confirm in your wallet...");

    const { method, params } = pendingRequest.params.request;
    if (method !== "eth_sendTransaction") {
      const errorMsg = `Unsupported method: ${method}`;
      setLocalError(errorMsg);
      handleRespond(formatJsonRpcError(pendingRequest.id, { code: 4200, message: "Method not supported" }));
      return;
    }

    const tx = params[0] as { to?: `0x${string}`; value?: string; data?: `0x${string}` };
    const targetAddress = tx.to;
    const value = tx.value ? BigInt(tx.value) : 0n;
    const data = tx.data || "0x";

    if (!targetAddress) {
      const errorMsg = "Transaction 'to' address is missing.";
      setLocalError(errorMsg);
      handleRespond(formatJsonRpcError(pendingRequest.id, { code: -32602, message: "Invalid parameters: missing 'to' address" }));
      return;
    }

    try {
      console.log("%cWcRequestDisplay handleApprove: Calling writeContractAsync...", "color: blueviolet");
      // Call async, the hash state update will trigger the HashTrackEffect
      await writeContractAsync({
        address: lensAccountAddress,
        abi: LENS_ACCOUNT_ABI,
        functionName: "executeTransaction",
        args: [targetAddress, value, data],
        account: ownerAddress,
        chainId: LENS_CHAIN_ID,
      });
      console.log("%cWcRequestDisplay handleApprove: writeContractAsync call submitted.", "color: blueviolet");
    } catch (error) {
      console.error("WcRequestDisplay handleApprove: Error calling writeContractAsync:", error);
      if (!writeError && processingRequestId.current) {
        // Check current ID before responding
        const errorMsg = `Failed to initiate transaction: ${(error as Error).message}`;
        setLocalError(errorMsg);
        handleRespond(formatJsonRpcError(processingRequestId.current, getSdkError("USER_REJECTED")));
      }
    }
  };

  const handleReject = () => {
    if (!pendingRequest) return;
    processingRequestId.current = pendingRequest.id; // Mark which request we are rejecting
    setLocalError(null);
    setLocalLoadingMessage(null);
    console.log("WcRequestDisplay handleReject: Rejecting request:", pendingRequest.id);
    handleRespond(formatJsonRpcError(pendingRequest.id, getSdkError("USER_REJECTED")));
  };

  // --- Render Logic ---
  if (!pendingRequest) {
    return (
      <div className="p-4 border rounded-md bg-gray-50">
        <p className="text-gray-600 text-center italic">No pending WalletConnect requests.</p>
      </div>
    );
  }

  // Extract request details safely
  const { request, chainId } = pendingRequest.params;
  const txDetails = request.params?.[0] as { to?: string; value?: string; data?: string } | undefined;
  const dAppName = pendingRequest.verifyContext?.verified.origin || "Unknown dApp";
  const dAppUrl = pendingRequest.verifyContext?.verified.origin;
  const formattedValue = txDetails?.value
    ? `${formatUnits(BigInt(txDetails.value), lensChain.nativeCurrency.decimals)} ${lensChain.nativeCurrency.symbol}`
    : `0 ${lensChain.nativeCurrency.symbol}`;
  const isLoading = isWritePending || isConfirming || isWcLoading;

  return (
    <div className="p-4 border-2 border-blue-300 rounded-md bg-blue-50 shadow-md space-y-4">
      <h3 className="text-md font-semibold text-blue-800">WalletConnect Request</h3>
      <div className="flex items-center space-x-3 mb-3 pb-3 border-b border-blue-200">
        <FallbackIcon size={30} />
        <div>
          <p className="text-sm font-medium text-gray-800">{dAppName}</p>
          {dAppUrl && <p className="text-xs text-gray-500">{dAppUrl}</p>}
        </div>
      </div>

      <div className="space-y-2 text-sm">
        <p>
          <strong className="text-gray-600">Method:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{request.method}</span>
        </p>
        <p>
          <strong className="text-gray-600">Chain:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{chainId}</span>
        </p>
        <p>
          <strong className="text-gray-600">Target (to):</strong> <span className="font-mono text-xs break-all">{txDetails?.to ?? "N/A"}</span>
        </p>
        <p>
          <strong className="text-gray-600">Value:</strong> <span className="font-mono">{formattedValue}</span>
        </p>
        <div>
          <strong className="text-gray-600">Data:</strong>
          <textarea
            readOnly
            value={txDetails?.data ?? "0x"}
            className="mt-1 w-full h-20 p-1 border border-gray-300 rounded text-xs font-mono bg-gray-50"
          />
        </div>
      </div>

      {/* Status Display */}
      {localLoadingMessage && <p className="text-sm text-center text-indigo-600 animate-pulse">{localLoadingMessage}</p>}
      {localError && <p className="text-sm text-center text-red-600">{localError}</p>}
      {wcError && !localError && <p className="text-sm text-center text-red-600">WC Error: {wcError}</p>}

      {/* Action Buttons */}
      <div className="flex space-x-3 pt-2">
        <button
          onClick={handleApprove}
          disabled={isLoading}
          className="flex-1 px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
        >
          {isWritePending ? "Check Wallet..." : isConfirming ? "Confirming..." : "Approve & Send"}
        </button>
        <button
          onClick={handleReject}
          disabled={isLoading}
          className="flex-1 px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-md shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
        >
          Reject
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/lib/constants.ts">
// lib/constants.ts
import { defineChain, parseAbi } from "viem";

export const LENS_CHAIN_ID = 232;

export const lensChain = defineChain({
  id: LENS_CHAIN_ID,
  name: "Lens Chain",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"],
    },
  },
  blockExplorers: {
    default: { name: "Lens Explorer", url: "https://explorer.lens.xyz" },
  },
  testnet: false,
});

// --- Contract Addresses ---
export const LENS_GLOBAL_NAMESPACE_ADDRESS = "0x1aA55B9042f08f45825dC4b651B64c9F98Af4615";

// --- ABIs ---
export const LENS_GLOBAL_NAMESPACE_ABI = parseAbi([
  "function accountOf(string calldata name) view returns (address)",
  "function usernameOf(address user) view returns (string)",
]);

// Added owner() function
export const LENS_ACCOUNT_ABI = parseAbi([
  "function owner() view returns (address)",
  "function executeTransaction(address target, uint256 value, bytes calldata data)",
]);

export const WGHO_TOKEN_ADDRESS = "0x6bDc36E20D267Ff0dd6097799f82e78907105e2F";
export const ERC20_ABI = parseAbi(["function balanceOf(address owner) view returns (uint256)"]);
</file>

<file path="src/app/providers.tsx">
// src/app/providers.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import { ConnectKitProvider } from "connectkit";
import { config } from "@/lib/wagmi";
import React, { useState } from "react";
import { LensAccountProvider } from "@/contexts/LensAccountContext";

type Props = {
  children: React.ReactNode;
};

export function Providers({ children }: Props) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <ConnectKitProvider>
          {/* Wrap with LensAccountProvider */}
          <LensAccountProvider>
            {/* Wrap with WalletConnectProvider */}
            {children}
          </LensAccountProvider>
        </ConnectKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
</file>

<file path="src/app/page.tsx">
// src/app/page.tsx
"use client";

import { DiscoveryForm } from "@/components/DiscoveryForm";
import { ConnectOwnerButton } from "@/components/ConnectOwnerButton";
import { useState, useEffect } from "react";
import { useAccount, useReadContract } from "wagmi"; // Import useAccount
import { useRouter } from "next/navigation"; // Import useRouter
import { type Address, isAddress } from "viem";
import { useLensAccount } from "@/contexts/LensAccountContext"; // Import the context hook
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID } from "@/lib/constants";

export default function Home() {
  const [lensAccountAddress, setLensAccountAddress] = useState<Address | "">("");
  const [expectedOwner, setExpectedOwner] = useState<Address | null>(null);
  const [ownerFetchError, setOwnerFetchError] = useState<string | null>(null);
  const [verificationError, setVerificationError] = useState<string | null>(null); // State for verification errors

  const {
    address: connectedAddress,
    chainId: connectedChainId,
    isConnected,
    // isConnecting, // REMOVED - Unused
    // isReconnecting, // REMOVED - Unused
  } = useAccount(); // Get connected account info
  const router = useRouter(); // Initialize router
  const { setVerifiedAccount, clearAccount: clearContext } = useLensAccount(); // Get context actions

  const handleAccountFound = (address: Address | "") => {
    console.log("Account Address Updated in Parent:", address);
    setLensAccountAddress(address);
    setExpectedOwner(null); // Reset owner when lens account changes
    setOwnerFetchError(null);
    setVerificationError(null); // Reset verification error
    clearContext(); // Clear context if lens account changes
  };

  const {
    data: ownerData,
    error: ownerError,
    isLoading: isLoadingOwner,
  } = useReadContract({
    address: lensAccountAddress || undefined,
    abi: LENS_ACCOUNT_ABI,
    functionName: "owner",
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: isAddress(lensAccountAddress),
    },
  });

  // Effect to update expectedOwner state
  useEffect(() => {
    if (ownerData) {
      setExpectedOwner(ownerData);
      setOwnerFetchError(null);
      console.log("Fetched Expected Owner:", ownerData);
    }
  }, [ownerData]);

  // Effect to handle owner fetch errors
  useEffect(() => {
    if (ownerError) {
      console.error("Error fetching owner:", ownerError);
      setOwnerFetchError("Could not fetch account owner. Ensure the address is correct and on Lens Chain.");
      setExpectedOwner(null);
    } else if (isAddress(lensAccountAddress)) {
      setOwnerFetchError(null);
    }
  }, [ownerError, lensAccountAddress]);

  // Effect for Owner Verification and Navigation
  useEffect(() => {
    // Clear verification error on disconnect
    if (!isConnected) {
      setVerificationError(null);
      clearContext(); // Also clear context on disconnect
      return;
    }

    if (connectedAddress && expectedOwner && isAddress(lensAccountAddress)) {
      // Check if on the correct chain first
      if (connectedChainId !== LENS_CHAIN_ID) {
        // Wagmi/ConnectKit handles the switch prompt, maybe show a generic message here
        setVerificationError("Please switch to the Lens Chain in your wallet.");
        clearContext();
        return; // Don't proceed further if chain is wrong
      }

      // Now check if the address matches
      if (connectedAddress.toLowerCase() === expectedOwner.toLowerCase()) {
        console.log("Owner verified! Navigating to dashboard...");
        setVerificationError(null); // Clear error on success
        // Set the verified account details in context before navigating
        setVerifiedAccount(lensAccountAddress, connectedAddress);
        router.push("/dashboard");
      } else {
        console.log("Owner mismatch:", {
          connected: connectedAddress,
          expected: expectedOwner,
        });
        setVerificationError(`Incorrect owner connected. Please connect with wallet: ${expectedOwner}`);
        clearContext();
      }
    }
  }, [connectedAddress, connectedChainId, expectedOwner, lensAccountAddress, isConnected, router, setVerifiedAccount, clearContext]);

  const showConnectButton = expectedOwner && !isLoadingOwner && !ownerFetchError;
  // const connectButtonDisabled = // REMOVED - Unused
  //   !!verificationError || connectedChainId !== LENS_CHAIN_ID;

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-6 md:p-24 bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50">
      <div className="w-full max-w-lg p-8 space-y-6 bg-white rounded-xl shadow-lg">
        <h1 className="text-2xl font-bold text-center text-gray-800">Lens Account Interface</h1>
        <p className="text-center text-gray-600">Find your Lens Account by username or address.</p>

        <DiscoveryForm onAccountAddressFound={handleAccountFound} />

        <div className="mt-6 text-center space-y-3">
          {isAddress(lensAccountAddress) && isLoadingOwner && <p className="text-gray-500">Fetching owner...</p>}

          {ownerFetchError && !isLoadingOwner && <p className="text-red-600">{ownerFetchError}</p>}

          {expectedOwner && !isLoadingOwner && !ownerFetchError && (
            <div className="p-3 bg-blue-50 border border-blue-200 rounded-md">
              <p className="text-sm font-medium text-blue-800">Identified Account Owner:</p>
              <p className="text-xs text-blue-700 break-words font-mono">{expectedOwner}</p>
              {!isConnected && <p className="text-xs text-blue-600 mt-1">Connect this wallet to proceed.</p>}
            </div>
          )}

          {/* Verification Error Display */}
          {verificationError && <p className="text-sm text-red-600 mt-2">{verificationError}</p>}

          {/* Only show Connect Button when expected owner is loaded and no fetch error */}
          {showConnectButton && (
            <div className="pt-2">
              {/* ConnectKit handles its own disabled state based on connection status */}
              <ConnectOwnerButton />
              {isConnected && connectedChainId !== LENS_CHAIN_ID && <p className="text-xs text-orange-600 mt-1">Waiting for network switch...</p>}
            </div>
          )}

          {!isAddress(lensAccountAddress) && !expectedOwner && !isLoadingOwner && (
            <p className="text-sm text-gray-500">Enter a Lens username or account address above to find the owner.</p>
          )}
        </div>
      </div>
    </main>
  );
}
</file>

<file path="src/components/WcConnect.tsx">
// src/components/WcConnect.tsx
"use client";

import React, { useState, useEffect } from "react";
import { useWalletConnect } from "@/contexts/WalletConnectProvider"; // Ensure correct path
import Image from "next/image";

// Default/Fallback Icon
const FallbackIcon = () => <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs">?</div>;

// Helper function to resolve icon URL
const resolveIconUrl = (iconPath: string | null | undefined, baseUrl: string | null | undefined): string | undefined => {
  if (!iconPath) return undefined;

  try {
    // Handle absolute URLs
    if (iconPath.startsWith("http://") || iconPath.startsWith("https://")) {
      return iconPath;
    }
    // Handle root-relative paths if base URL exists
    if (iconPath.startsWith("/") && baseUrl) {
      const origin = new URL(baseUrl).origin;
      return `${origin}${iconPath}`;
    }
    console.warn("Invalid icon URL format:", iconPath);
    return undefined;
  } catch (e) {
    console.warn("Error resolving icon URL:", e);
    return undefined;
  }
};

// Icon component with error handling
const DAppIcon = ({ iconUrl, name, size = 40 }: { iconUrl?: string; name: string; size?: number }) => {
  const [hasError, setHasError] = useState(false);

  if (!iconUrl || hasError) return <FallbackIcon />;

  return (
    <Image
      src={iconUrl}
      alt={`${name} icon`}
      width={size}
      height={size}
      className="rounded-full"
      unoptimized
      onError={() => {
        console.warn("Failed to load icon:", iconUrl);
        setHasError(true);
      }}
    />
  );
};

export function WcConnect() {
  // Destructure states from the refactored provider, including isInitializing
  const {
    activeSessions,
    pair,
    disconnect,
    isLoading, // Use the combined loading state
    isPairing,
    error,
    isInitialized, // Use the service readiness flag
    pendingProposal, // Get the pending proposal
    approveSession, // Get approve action
    rejectSession, // Get reject action
    isInitializing, // <<<--- ADDED isInitializing HERE ---<<<
  } = useWalletConnect();
  const [uri, setUri] = useState("");

  const activeSessionTopic = Object.keys(activeSessions)[0]; // Assuming only one session for MVP
  const connectedSession = activeSessionTopic ? activeSessions[activeSessionTopic] : null;

  // --- Add this useEffect ---
  useEffect(() => {
    // If there's no connected session (either initially or after disconnect),
    // clear the URI input field.
    if (!connectedSession) {
      setUri("");
    }
  }, [connectedSession]); // Run this effect when connectedSession changes
  // -------------------------

  const handleConnect = () => {
    if (!uri || !isInitialized || isLoading) return; // Check initialization and combined loading state
    pair(uri);
  };

  const handleDisconnect = () => {
    if (connectedSession && isInitialized && !isLoading) {
      // Check initialization and combined loading state
      disconnect(connectedSession.topic);
    }
  };

  const handleApprove = () => {
    if (pendingProposal && !isLoading) {
      approveSession();
    }
  };

  const handleReject = () => {
    if (pendingProposal && !isLoading) {
      rejectSession();
    }
  };

  // Display loading states more granularly if needed, otherwise use `isLoading`
  const connectButtonText = isPairing ? "Pairing..." : isLoading ? "Working..." : "Connect";
  const disconnectButtonText = isLoading ? "Working..." : "Disconnect";
  const approveButtonText = isLoading ? "Working..." : "Approve Session";
  const rejectButtonText = isLoading ? "Working..." : "Reject Session";

  // Resolve icon URLs
  const connectedDAppIconUrl = connectedSession
    ? resolveIconUrl(connectedSession.peer.metadata.icons?.[0] ?? undefined, connectedSession.peer.metadata.url ?? undefined)
    : undefined;

  const proposalIconUrl = pendingProposal
    ? resolveIconUrl(pendingProposal.params.proposer.metadata.icons?.[0] ?? undefined, pendingProposal.params.proposer.metadata.url ?? undefined)
    : undefined;

  return (
    <div className="p-4 border rounded-md bg-gray-50 space-y-4">
      <h3 className="text-md font-semibold text-gray-700">Connect to dApp (via Lens Account)</h3>

      {/* --- Session Proposal Modal (Simplified Inline) --- */}
      {pendingProposal && (
        <div className="p-3 border border-yellow-300 bg-yellow-50 rounded-md space-y-2">
          <p className="text-sm font-medium text-yellow-800">Connection Request from:</p>
          <div className="flex items-center space-x-2">
            <DAppIcon iconUrl={proposalIconUrl} name={pendingProposal.params.proposer.metadata.name} size={30} />
            <span className="text-sm text-gray-700">{pendingProposal.params.proposer.metadata.name}</span>
          </div>
          {/* TODO: Display requested permissions details if needed */}
          <div className="flex space-x-2 pt-2">
            <button
              onClick={handleApprove}
              disabled={isLoading || !isInitialized}
              className="flex-1 px-3 py-1 bg-green-500 text-white text-xs font-medium rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {approveButtonText}
            </button>
            <button
              onClick={handleReject}
              disabled={isLoading || !isInitialized}
              className="flex-1 px-3 py-1 bg-red-500 text-white text-xs font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {rejectButtonText}
            </button>
          </div>
        </div>
      )}

      {/* --- Connected Session Display --- */}
      {connectedSession && !pendingProposal && (
        <div className="space-y-3 p-3 bg-green-50 border border-green-200 rounded-md">
          {/* Display connected dApp info */}
          <p className="text-green-800 font-medium">Connected to:</p>
          <div className="flex items-center space-x-3">
            <DAppIcon iconUrl={connectedDAppIconUrl} name={connectedSession.peer.metadata.name} size={40} />
            <div>
              <p className="text-sm font-semibold text-gray-900">{connectedSession.peer.metadata.name}</p>
              <p className="text-xs text-gray-600 break-all">{connectedSession.peer.metadata.url}</p>
            </div>
          </div>
          <p className="text-xs text-gray-500">
            Topic: <span className="font-mono break-all">{connectedSession.topic}</span>
          </p>
          <button
            onClick={handleDisconnect}
            disabled={isLoading || !isInitialized} // Use combined loading state
            className="w-full px-4 py-2 mt-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
          >
            {disconnectButtonText}
          </button>
        </div>
      )}

      {/* --- Pairing/Connection Form --- */}
      {!connectedSession && !pendingProposal && (
        <div className="space-y-2">
          <label htmlFor="wc-uri" className="block text-sm font-medium text-gray-700">
            Paste WalletConnect URI
          </label>
          <div className="flex space-x-2">
            <input
              id="wc-uri"
              name="wc-uri"
              type="text"
              value={uri}
              onChange={(e) => setUri(e.target.value)}
              placeholder="wc:..."
              className="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm disabled:bg-gray-100"
              disabled={isLoading || !isInitialized} // Use combined loading state
            />
            <button
              onClick={handleConnect}
              disabled={!uri || isLoading || !isInitialized} // Use combined loading state
              className="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {connectButtonText}
            </button>
          </div>
        </div>
      )}

      {/* --- Status/Error Messages --- */}
      {error && !isLoading && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
      {isPairing && <p className="text-indigo-600 text-sm mt-2">Pairing initiated, check dApp/wallet if needed...</p>}
      {/* Check both flags here now */}
      {!isInitialized && !isInitializing && !error && <p className="text-orange-600 text-sm mt-2">WalletConnect service not ready.</p>}
      {/* And display initializing message correctly */}
      {isInitializing && <p className="text-gray-500 text-sm mt-2">Initializing WalletConnect...</p>}
    </div>
  );
}
</file>

<file path="src/services/walletConnectService.ts">
// src/services/walletConnectService.ts
import { WalletKit, IWalletKit, WalletKitTypes } from "@reown/walletkit";
import { Core } from "@walletconnect/core";
import { ICore, SessionTypes, SignClientTypes } from "@walletconnect/types";
import { ErrorResponse, JsonRpcResponse } from "@walletconnect/jsonrpc-utils"; // Import JsonRpcResponse
import EventEmitter from "events";

// --- Export Enums and Interfaces ---
export enum ServiceEvents {
  Initialized = "initialized",
  PairStatus = "pair_status",
  SessionProposal = "session_proposal",
  SessionConnect = "session_connect",
  SessionDelete = "session_delete",
  SessionRequest = "session_request", // <<<--- ADDED
  Error = "error",
  SessionsUpdated = "sessions_updated",
  IS_LOADING = "is_loading",
  IS_PAIRING = "is_pairing",
}

export interface WalletConnectServiceEvents {
  [ServiceEvents.Initialized]: (payload: { success: boolean; instance: IWalletKit | null }) => void;
  [ServiceEvents.PairStatus]: (payload: { status: "pairing" | "paired" | "error"; message?: string }) => void;
  [ServiceEvents.SessionProposal]: (payload: { proposal: WalletKitTypes.SessionProposal }) => void;
  [ServiceEvents.SessionConnect]: (payload: { session: SessionTypes.Struct }) => void;
  [ServiceEvents.SessionDelete]: (payload: { topic: string }) => void;
  [ServiceEvents.SessionRequest]: (payload: { request: WalletKitTypes.SessionRequest }) => void; // <<<--- ADDED
  [ServiceEvents.Error]: (payload: { message: string }) => void;
  [ServiceEvents.SessionsUpdated]: (payload: { sessions: Record<string, SessionTypes.Struct> }) => void;
  [ServiceEvents.IS_LOADING]: (payload: { isLoading: boolean }) => void;
  [ServiceEvents.IS_PAIRING]: (payload: { isPairing: boolean }) => void;
}
// ------------------------------------

// --- Export the Class Definition ---
export class WalletConnectService extends EventEmitter {
  private core: ICore | undefined;
  private walletKit: IWalletKit | undefined;
  private projectId: string;
  private metadata: WalletKitTypes.Metadata;
  private _isInitialized = false;
  private _isInitializing = false;
  private initPromise: Promise<IWalletKit> | null = null;

  constructor(projectId: string, metadata: WalletKitTypes.Metadata) {
    super();
    if (!projectId) {
      throw new Error("WalletConnectService: Project ID is required.");
    }
    this.projectId = projectId;
    this.metadata = JSON.parse(JSON.stringify(metadata));
    console.log("WalletConnectService: NEW Instance created (by Provider).");
  }

  // --- Getters (keep as before) ---
  public isInitialized(): boolean {
    return this._isInitialized;
  }
  public isInitializing(): boolean {
    return this._isInitializing;
  }
  public getWalletKitInstance(): IWalletKit | undefined {
    return this.walletKit;
  }
  public getActiveSessions(): Record<string, SessionTypes.Struct> {
    return this.walletKit?.getActiveSessions() || {};
  }

  // --- Core Initialization (Idempotent) ---
  async init(): Promise<IWalletKit> {
    if (this._isInitialized && this.walletKit) {
      console.log("WalletConnectService Instance: Init called but already initialized.");
      this.emit(ServiceEvents.Initialized, { success: true, instance: this.walletKit });
      return this.walletKit;
    }
    if (this._isInitializing && this.initPromise) {
      console.log("WalletConnectService Instance: Init called while already initializing. Returning existing promise.");
      return this.initPromise;
    }
    console.log("WalletConnectService Instance: Starting initialization (init)...");
    this._isInitializing = true;
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    this.initPromise = (async () => {
      try {
        console.log("WalletConnectService Instance: Initializing WalletConnect Core...");
        process.env.DISABLE_GLOBAL_CORE = "true";
        this.core = new Core({ projectId: this.projectId });
        process.env.DISABLE_GLOBAL_CORE = "false";
        console.log("WalletConnectService Instance: Initializing WalletKit...");
        this.walletKit = await WalletKit.init({ core: this.core, metadata: this.metadata });
        this.setupInternalListeners();
        this._isInitialized = true;
        console.log("WalletConnectService Instance: Initialization successful.");
        this.emit(ServiceEvents.Initialized, { success: true, instance: this.walletKit });
        this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
        return this.walletKit;
      } catch (error: unknown) {
        console.error("WalletConnectService Instance: Initialization failed:", error);
        this._isInitialized = false;
        this.emit(ServiceEvents.Initialized, { success: false, instance: null });
        this.emit(ServiceEvents.Error, { message: `Initialization failed: ${(error as Error).message}` });
        throw error;
      } finally {
        this._isInitializing = false;
        this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
        this.initPromise = null;
      }
    })();
    return this.initPromise;
  }

  private setupInternalListeners() {
    if (!this.walletKit) {
      console.error("WalletConnectService: Cannot setup listeners, WalletKit not ready.");
      return;
    }
    console.log("WalletConnectService: Setting up internal event listeners...");

    this.walletKit.off("session_proposal", this.handleSessionProposal);
    this.walletKit.on("session_proposal", this.handleSessionProposal);

    if (this.walletKit.engine?.signClient?.events) {
      this.walletKit.engine.signClient.events.off("session_connect", this.handleSessionConnect);
      this.walletKit.engine.signClient.events.on("session_connect", this.handleSessionConnect);
    } else {
      console.warn("WalletConnectService: SignClient events not available for session_connect listener.");
    }

    this.walletKit.off("session_delete", this.handleSessionDelete);
    this.walletKit.on("session_delete", this.handleSessionDelete);

    // --- Add session_request Listener ---
    this.walletKit.off("session_request", this.handleSessionRequest); // <<<--- ADDED
    this.walletKit.on("session_request", this.handleSessionRequest); // <<<--- ADDED
    // ------------------------------------

    console.log("WalletConnectService: Internal listeners attached.");
  }

  // --- Event Handlers (bound methods) ---
  private handleSessionProposal = (proposal: WalletKitTypes.SessionProposal) => {
    console.log("Service Handler: session_proposal", proposal.id);
    this.emit(ServiceEvents.SessionProposal, { proposal });
    this.emit(ServiceEvents.IS_PAIRING, { isPairing: false });
  };

  private handleSessionConnect = (sessionArgs: SignClientTypes.EventArguments["session_connect"]) => {
    console.log("Service Handler: session_connect", sessionArgs.session.topic);
    this.emit(ServiceEvents.SessionConnect, { session: sessionArgs.session });
    this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
  };

  private handleSessionDelete = (event: { id: number; topic: string }) => {
    console.log("Service Handler: session_delete", event.topic);
    this.emit(ServiceEvents.SessionDelete, { topic: event.topic });
    this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
  };

  // --- Handler for Session Request ---
  private handleSessionRequest = (request: WalletKitTypes.SessionRequest) => {
    // <<<--- ADDED
    console.log("Service Handler: session_request", request.id, request.params.request.method);
    this.emit(ServiceEvents.SessionRequest, { request });
  };
  // -----------------------------------

  // --- Public Methods ---
  async pair(uri: string): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot pair.");
    console.log("Service: Attempting to pair with URI:", uri);
    this.emit(ServiceEvents.IS_PAIRING, { isPairing: true });
    this.emit(ServiceEvents.PairStatus, { status: "pairing" });
    try {
      await this.walletKit.pair({ uri });
      console.log("Service: Pairing initiated for URI:", uri);
    } catch (error: unknown) {
      console.error("Service: Pairing failed:", error);
      const message = (error as Error).message || "Pairing failed";
      this.emit(ServiceEvents.PairStatus, { status: "error", message });
      this.emit(ServiceEvents.IS_PAIRING, { isPairing: false });
      this.emit(ServiceEvents.Error, { message });
      throw error;
    }
  }

  async approveSession(proposal: WalletKitTypes.SessionProposal, approvedNamespaces: SessionTypes.Namespaces): Promise<SessionTypes.Struct> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot approve session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Approving session:", proposal.id);
      const session = await this.walletKit.approveSession({ id: proposal.id, namespaces: approvedNamespaces });
      console.log("Service: Session approved via approveSession:", session.topic);
      return session;
    } catch (error: unknown) {
      console.error("Service: Failed to approve session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to approve session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  async rejectSession(proposal: WalletKitTypes.SessionProposal, reason: ErrorResponse): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot reject session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Rejecting session:", proposal.id);
      await this.walletKit.rejectSession({ id: proposal.id, reason: reason });
      console.log("Service: Session rejected:", proposal.id);
    } catch (error: unknown) {
      console.error("Service: Failed to reject session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to reject session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  async disconnectSession(topic: string, reason: ErrorResponse): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot disconnect session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Disconnecting session:", topic);
      await this.walletKit.disconnectSession({ topic: topic, reason: reason });
      console.log("Service: Disconnect call successful for topic:", topic);
    } catch (error: unknown) {
      console.error("Service: Failed to disconnect session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to disconnect session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  // --- Method to Respond to Session Requests ---
  async respondSessionRequest(topic: string, response: JsonRpcResponse): Promise<void> {
    // <<<--- ADDED
    if (!this._isInitialized || !this.walletKit) {
      throw new Error("WalletConnectService: Not initialized. Cannot respond to request.");
    }
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Responding to session request:", response.id, "on topic:", topic);
      await this.walletKit.respondSessionRequest({ topic, response });
      console.log("Service: Response sent for request:", response.id);
    } catch (error: unknown) {
      console.error("Service: Failed to respond to session request:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to respond to request" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }
  // -------------------------------------------

  // Typed EventEmitter methods (keep as before)
  on<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    return super.on(event, listener as (...args: any[]) => void);
  }
  once<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    return super.once(event, listener as (...args: any[]) => void);
  }
  off<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    return super.off(event, listener as (...args: any[]) => void);
  }
  removeListener<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    return super.removeListener(event, listener as (...args: any[]) => void);
  }
  emit<E extends keyof WalletConnectServiceEvents>(event: E, ...args: Parameters<WalletConnectServiceEvents[E]>): boolean {
    return super.emit(event, ...args);
  }
}
</file>

<file path="package.json">
{
  "name": "lens-account-interface4",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prepare": "husky",
    "generate-llms": "repomix --include \"*.*,src\" --ignore \"llms.txt\" -o llms.txt",
    "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,css,md,json}\"",
    "format:check": "prettier --check \"src/**/*.{js,jsx,ts,tsx,css,md,json}\""
  },
  "dependencies": {
    "@reown/walletkit": "^1.2.3",
    "@tanstack/react-query": "^5.74.4",
    "@walletconnect/core": "^2.20.0",
    "@walletconnect/jsonrpc-utils": "^1.0.8",
    "@walletconnect/utils": "^2.20.0",
    "connectkit": "^1.9.0",
    "next": "15.3.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "viem": "^2.27.2",
    "wagmi": "^2.14.16"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/webpack": "^5.28.5",
    "@walletconnect/types": "^2.20.0",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "husky": "^9.1.7",
    "pino-pretty": "^13.0.0",
    "prettier": "^3.5.3",
    "repomix": "^0.3.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="src/app/dashboard/page.tsx">
// src/app/dashboard/page.tsx
"use client";

import { useLensAccount } from "@/contexts/LensAccountContext";
import { useAccount, useDisconnect } from "wagmi";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import { AccountDisplay } from "@/components/AccountDisplay";
import { WcConnect } from "@/components/WcConnect";
import { WcRequestDisplay } from "@/components/WcRequestDisplay"; // <<<--- IMPORTED

export default function Dashboard() {
  const { lensAccountAddress, ownerAddress, clearAccount } = useLensAccount();
  const { isConnected } = useAccount();
  const { disconnect: disconnectOwnerWallet } = useDisconnect();
  const router = useRouter();

  useEffect(() => {
    if (!isConnected || !lensAccountAddress || !ownerAddress) {
      console.log("Redirecting to home: not connected or missing context");
      if (!lensAccountAddress || !ownerAddress) {
        clearAccount();
      }
      router.replace("/");
    }
  }, [isConnected, lensAccountAddress, ownerAddress, router, clearAccount]);

  const handleLogout = () => {
    disconnectOwnerWallet();
    clearAccount();
    console.log("Logout initiated");
  };

  if (!isConnected || !lensAccountAddress || !ownerAddress) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <p>Loading or redirecting...</p>
      </div>
    );
  }

  return (
    <main className="flex min-h-screen flex-col items-center p-6 md:p-24">
      <div className="w-full max-w-4xl p-8 bg-white rounded-xl shadow-lg relative">
        <button
          onClick={handleLogout}
          className="absolute top-4 right-4 px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
        >
          {" "}
          Logout Owner{" "}
        </button>
        <h1 className="text-2xl font-bold mb-4 text-center">Dashboard</h1>
        <div className="space-y-6">
          <div className="p-3 bg-gray-50 border border-gray-200 rounded-md">
            <p className="text-sm font-medium text-gray-700">Connected Owner Wallet:</p>
            <p className="text-xs text-gray-600 break-words font-mono">{ownerAddress}</p>
          </div>
          <div className="p-3 bg-blue-50 border border-blue-200 rounded-md">
            <p className="text-sm font-medium text-blue-800">Managing Lens Account:</p>
            <p className="text-xs text-blue-700 break-words font-mono">{lensAccountAddress}</p>
          </div>
          <AccountDisplay />
          <WcConnect />
          {/* --- Render the Request Display Component --- */}
          <WcRequestDisplay /> {/* <<<--- ADDED */}
          {/* ------------------------------------------- */}
        </div>
      </div>
    </main>
  );
}
</file>

<file path="DEVELOPMENT_PLAN.md">
**Version:** 1.0
**Date:** 2025-04-19

## 1. Introduction

This document outlines the phased development plan for building the Minimum Viable Product (MVP) of the Lens Account Web Interface. It breaks down the work into manageable stages, aligning with the Functional Specification (`Spec.functional.md`) and Technical Specification (`TECHNICAL_SPEC.md`).

## 2. Methodology

We will follow an incremental development approach, building and verifying core features stage by stage. Each stage should result in a testable piece of functionality.

## 3. Development Stages

### Stage 0: Project Setup & Base Configuration (Completed via Setup)

- [x] Initialize Next.js 15+ project with TypeScript, Tailwind CSS, App Router.
- [x] Install pnpm as the package manager.
- [x] Install core dependencies: `wagmi`, `viem`, `@tanstack/react-query`, `connectkit`, `@reown/walletkit`, `@walletconnect/core`, `@walletconnect/utils`.
- [x] Set up basic ESLint and Prettier configuration.
- [x] Create `.env.local` with `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID` placeholder.
- [x] Configure `WagmiProvider` and `QueryClientProvider` in the root layout (`app/layout.tsx`).
  - **Check:** Development server runs (`pnpm dev`) without errors. Base Next.js page loads.

### Stage 1: Account Discovery & Chain Read Interaction

**Goal:** Implement the username/address input fields and the logic to look up corresponding data from the `LensGlobalNamespace` contract on the Lens Chain. Verify basic read operations work.

- **Tasks:**
  - [x] **Create Constants:** Define Lens Chain details (ID 232, RPC URL, etc.), `LensGlobalNamespace` address, and its partial ABI (`accountOf(string)`, `usernameOf(address)`) in `lib/constants.ts`.
  - [x] **Update Wagmi Config:** Ensure the `lensChain` object is defined using `defineChain` and included in the `createConfig` call in `lib/wagmi.ts`.
  - [x] **Create DiscoveryForm Component:** Build `components/DiscoveryForm.tsx` with two controlled input fields (Username, Account Address) styled with Tailwind.
  - [x] **Implement Lookup Logic:**
    - [x] Inside `DiscoveryForm.tsx` or a custom hook (`hooks/useLensLookup.ts`), use `useState` for input values.
    - [x] Use `useEffect` with a debounce utility (e.g., from `lodash.debounce` or simple `setTimeout`) to trigger lookups on input change.
    - [x] Call `useReadContract` (Wagmi) within the debounced effect:
      - Target `LensGlobalNamespace` address.
      - Use the appropriate function (`accountOf` or `usernameOf`) based on which input changed.
      - **Crucially:** Pass `chainId: LENS_CHAIN_ID` to ensure the call targets the correct network.
      - Handle loading and error states from `useReadContract`.
    - [x] Update the _other_ input field's state based on the successful result from `useReadContract`.
  - [x] **Integrate Form:** Place `DiscoveryForm.tsx` onto the root page (`app/page.tsx`).
- **Verification:**
  - [x] Typing a known Lens username (e.g., `stani`) correctly populates the Account Address field.
  - [x] Typing/pasting a known Lens Account address correctly populates the Lens Username field (if one exists).
  - [x] Invalid inputs show no result or subtle error indication.
  - [x] Check browser developer console for any Wagmi/Viem errors related to contract reads. Network tab should show RPC calls to the Lens Chain RPC URL.

### Stage 2: Owner EOA Connection & Verification

**Goal:** Integrate the "Connect Wallet" functionality, fetch the Lens Account owner, verify it against the connected EOA, handle chain switching, and navigate to the dashboard.

- **Tasks:**
  - [x] **Add Owner ABI:** Include the `owner()` function signature in the `LENS_ACCOUNT_ABI` within `lib/constants.ts`.
  - [x] **Create Connect Button:** Build `components/ConnectOwnerButton.tsx`. Use ConnectKit's `<ConnectKitButton />` or its underlying hooks (`useModal`, etc.) for the UI.
  - [x] **Fetch Expected Owner:**
    - In `app/page.tsx`, once a valid Lens Account address is determined (from Stage 1 state), use `useReadContract` to call `owner()` on the Lens Account address.
    - Pass `chainId: LENS_CHAIN_ID`.
    - Store the result in state (`expectedOwner`).
  - [x] **Display Expected Owner:** Show the `expectedOwner` address clearly near the `ConnectOwnerButton`.
  - [x] **Integrate Connect Button:** Add `ConnectOwnerButton` to `app/page.tsx`, potentially disabling it until `expectedOwner` is fetched.
  - [x] **Implement Verification Logic:**
    - In `app/page.tsx`, use `useAccount` (Wagmi) to get the connected EOA's `address` and `chainId`.
    - Use `useEffect` to monitor changes in the connected `address`, `chainId`, and the `expectedOwner`.
    - Inside the effect:
      - If `address` and `expectedOwner` exist:
        - If `chainId !== LENS_CHAIN_ID`, do nothing (ConnectKit/Wagmi handle switch prompt).
        - If `address.toLowerCase() === expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, proceed to navigation.
        - If `address.toLowerCase() !== expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, set an error state ("Incorrect owner connected...").
      - If `address` is disconnected, clear any error state.
  - [x] **Implement Navigation:**
    - Use `useRouter` from `next/navigation`.
    - When verification passes (addresses match, correct chain), call `router.push('/dashboard')`.
  - [x] **Create Context (Optional but Recommended):** Create `contexts/LensAccountProvider.tsx` to store the verified `lensAccountAddress` and `ownerAddress` so the dashboard can access them. Wrap the root layout or dashboard layout with this provider. Update `app/page.tsx` to set context values upon successful verification before navigating.
- **Verification:**
  - [x] "Connect Wallet" button appears/enables only when a Lens Account address is set and `owner()` has been potentially fetched. Expected owner address is displayed.
  - [x] Clicking "Connect Wallet" opens the ConnectKit modal.
  - [x] Connecting the _correct_ Owner EOA wallet on the wrong network prompts a "Switch Network" request to Lens Chain.
  - [x] Connecting the _correct_ Owner EOA wallet on the Lens Chain navigates the user to `/dashboard`.
  - [x] Connecting an _incorrect_ EOA wallet (not the owner) on the Lens Chain displays a clear error message and _does not_ navigate.
  - [x] Disconnecting the wallet returns the user to the login/discovery state or clears the owner state.

### Stage 3: Basic Dashboard Display

**Goal:** Create the dashboard page and display the Lens Account address and its WGHO balance.

- **Tasks:**
  - [x] **Create Dashboard Page:** Create `app/dashboard/page.tsx`. Ensure it's protected or redirects if owner/lens account state (from Context) is missing.
  - [x] **Add WGHO Constants:** Define `WGHO_TOKEN_ADDRESS` and `ERC20_ABI` (with `balanceOf(address)`) in `lib/constants.ts`.
  - [x] **Create AccountDisplay Component:** Build `components/AccountDisplay.tsx`.
  - [x] **Fetch/Display Data:**
    - In `AccountDisplay.tsx`, retrieve the `lensAccountAddress` from context (e.g., `useContext(LensAccountContext)`).
    - Use `useReadContract` (Wagmi) to call `balanceOf(lensAccountAddress)` on the `WGHO_TOKEN_ADDRESS`.
    - Pass `chainId: LENS_CHAIN_ID`.
    - Use Viem's `formatUnits` to format the returned balance (assuming WGHO has 18 decimals).
    - Display the `lensAccountAddress` and the formatted WGHO balance. Handle loading/error states for the balance fetch.
  - [x] **Integrate Component:** Add `AccountDisplay` to the dashboard page.
  - [x] Do the same for native GHO
- **Verification:**
  - [x] Navigating to `/dashboard` after successful login shows the correct Lens Account address.
  - [x] The GHO/WGHO balance for the Lens Account is fetched and displayed correctly (or shows loading/error state).

### Stage 4: WalletConnect v2 Pairing (Act as Wallet)

**Goal:** Implement the WalletConnect URI input and pairing logic, allowing the web app (representing the Lens Account) to connect to external dApps.

- **Tasks:**
  - [x] **Create WC Service:** Set up `services/walletConnectService.ts`. Include an `init` method that creates a `Web3Wallet` instance from `@reown/walletkit` using the `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`. Store the instance.
  - [x] **Create WC Context:** Set up `contexts/WalletConnectProvider.tsx`. Initialize the `walletConnectService` on mount. Provide the `web3wallet` instance, active sessions state (`useState`), pairing state (`useState`), and pending request state (`useState`) via context.
  - [x] **Wrap Layout:** Wrap the relevant part of the application (e.g., dashboard layout or root layout) with `WalletConnectProvider`.
  - [x] **Create WcConnect Component:** Build `components/WcConnect.tsx`.
    - Include an `<input>` for the WC URI and a `<button>` ("Connect").
    - Add state for the input value.
    - On button click, call a `pair` function provided by the `WalletConnectContext`.
  - [x] **Implement Pairing Logic:**
    - In `WalletConnectProvider` (or the service), define the `pair(uri)` function. Call `web3wallet.core.pairing.pair({ uri })`. Handle potential errors.
    - Set up the `session_proposal` listener (`web3wallet.on('session_proposal', handleSessionProposal)`).
  - [x] **Implement Session Approval:**
    - Define `handleSessionProposal(proposal)` in the service/provider.
    - Retrieve the `lensAccountAddress` and `LENS_CHAIN_ID` from state/constants.
    - Construct the `approvedNamespaces` object containing only the `eip155` namespace, with the `LENS_CHAIN_ID`, the Lens Account address (formatted as `eip155:232:0x...`), required methods (`eth_sendTransaction`, `personal_sign`, etc.), and events (`chainChanged`, `accountsChanged`).
    - Call `web3wallet.approveSession({ id: proposal.id, namespaces: approvedNamespaces })`.
    - On success, update the `activeSessions` state in the context.
    - Handle potential errors during approval.
  - [x] **Update UI:** Modify `WcConnect.tsx` to:
    - Conditionally render the input/button form OR the connected dApp info based on `activeSessions` state from context.
    - Display dApp metadata (name, icon, url) from the active session.
- **Verification:**
  - [x] Open the dashboard page. The WC input form is visible.
  - [x] Go to a test dApp (e.g., Reown's React Dapp Example) and generate a WC v2 URI.
  - [x] Paste the URI into the input field in _this_ app and click "Connect".
  - [x] The connection should establish successfully (no prompt needed in the Owner EOA wallet for pairing/session _approval_ in this flow).
  - [x] The `WcConnect.tsx` component should update to show the connected dApp's information. Check the dApp, it should also show a successful connection to the _Lens Account address_.

### Stage 5: WalletConnect v2 Transaction Request Handling

**Goal:** Handle incoming `eth_sendTransaction` requests from the connected dApp, prompt the Owner EOA for approval via the Lens Account's `executeTransaction`, and relay the result.

- **Tasks:**
  - [ ] **Create WcRequestDisplay Component:** Build `components/WcRequestDisplay.tsx`. It should conditionally render based on the `pendingRequest` state from `WalletConnectContext`. Display request details (`to`, `value`, `data` hex string) and "Send Transaction" / "Reject" buttons.
  - [ ] **Implement Request Listener:**
    - In `WalletConnectProvider` (or service), set up the `session_request` listener (`web3wallet.on('session_request', handleSessionRequest)`).
    - Define `handleSessionRequest(event)`: Store the `event.topic`, `event.id`, and `event.params.request` (`{ method, params }`) in the `pendingRequest` state of the context. Only handle `eth_sendTransaction` for MVP.
  - [ ] **Implement Transaction Execution Logic:**
    - Create `hooks/useWcRequestHandler.ts` or add logic to `WcRequestDisplay.tsx`.
    - On "Send Transaction" click:
      - Get `lensAccountAddress`, `ownerAddress` from relevant contexts.
      - Get `topic`, `id`, `request` (`method`, `params`) from `WalletConnectContext.pendingRequest`.
      - Extract `to`, `value`, `data` from `request.params[0]`.
      - Call `useWriteContract` (Wagmi) hook configured for the `executeTransaction` function on the `LENS_ACCOUNT_ABI` and `lensAccountAddress`.
      - The `args` for `executeTransaction` will be `[to, value || 0n, data || '0x']`.
      - Pass `account: ownerAddress` and `chainId: LENS_CHAIN_ID` to `useWriteContract`'s mutation function.
      - Use `useWaitForTransactionReceipt` to wait for the transaction hash returned by `writeContract`.
  - [ ] **Implement Response Logic:**
    - Modify the "Send Transaction" click handler:
      - On `writeContract` success: Wait for the receipt. If receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`.
      - If receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a JSON-RPC error payload (e.g., `{ id, jsonrpc: '2.0', error: { code: -32000, message: 'Transaction reverted' } }`).
      - On `writeContract` error (e.g., user rejection in EOA wallet): Call `web3wallet.respondSessionRequest` with a user rejection error payload (`{ id, jsonrpc: '2.0', error: { code: 5000, message: 'User Rejected' } }`).
    - On "Reject" click: Call `web3wallet.respondSessionRequest` with a user rejection error payload.
    - After responding (success or error), clear the `pendingRequest` state in the context.
  - [ ] **Integrate Component:** Add `WcRequestDisplay` to the dashboard page.
- **Verification:**
  - [ ] Connect to a test dApp (e.g., Aave testnet interface pointed to Lens Chain RPC, or a simple custom test page).
  - [ ] Initiate a transaction on the test dApp (e.g., a simple contract call or ETH transfer _if possible via the dApp_).
  - [ ] The `WcRequestDisplay` component should appear in _this_ app showing the request details.
  - [ ] Clicking "Reject" should send an error to the dApp and hide the request display.
  - [ ] Clicking "Send Transaction" should:
    - Prompt the _Owner EOA wallet_ (MetaMask, etc.) to confirm the `executeTransaction` call on the Lens Account.
    - Rejecting in the Owner EOA wallet sends an error to the dApp.
    - Confirming in the Owner EOA wallet sends the transaction.
    - Upon successful mining, the transaction hash is sent back to the dApp, and the request display hides. Success feedback is shown.
    - If the on-chain execution reverts, an error is sent back to the dApp, and the request display hides. Error feedback is shown.

## 4. Post-MVP Considerations

- Implement handling for other WalletConnect methods (`personal_sign`, etc.).
- Add UI for managing active WalletConnect sessions (viewing, disconnecting).
- Improve transaction data decoding in the request display.
- Enhance error messages and user feedback.
- Refine UI/UX, add loading states more granularly.
- Mobile responsiveness.
</file>

<file path="src/contexts/WalletConnectProvider.tsx">
// src/contexts/WalletConnectProvider.tsx
"use client";

import React, { createContext, useState, useContext, ReactNode, useEffect, useCallback, useMemo, useRef } from "react";
// Import the CLASS and types
import { WalletConnectService, ServiceEvents, type WalletConnectServiceEvents } from "@/services/walletConnectService";
import { SessionTypes } from "@walletconnect/types";
import { IWalletKit, WalletKitTypes } from "@reown/walletkit";
import { buildApprovedNamespaces, getSdkError } from "@walletconnect/utils";
import { useLensAccount } from "./LensAccountContext";
import { LENS_CHAIN_ID } from "@/lib/constants";
import { JsonRpcResponse } from "@walletconnect/jsonrpc-utils";

// Keep the context state definition
interface WalletConnectContextState {
  walletKitInstance: IWalletKit | null;
  activeSessions: Record<string, SessionTypes.Struct>;
  pendingProposal: WalletKitTypes.SessionProposal | null;
  pendingRequest: WalletKitTypes.SessionRequest | null;
  pair: (uri: string) => Promise<void>;
  disconnect: (topic: string) => Promise<void>;
  approveSession: () => Promise<void>;
  rejectSession: () => Promise<void>;
  respondRequest: (response: JsonRpcResponse) => Promise<void>;
  isLoading: boolean;
  isInitializing: boolean;
  isPairing: boolean;
  isProcessingAction: boolean;
  error: string | null;
  isInitialized: boolean;
}

const WalletConnectContext = createContext<WalletConnectContextState | undefined>(undefined);

interface WalletConnectProviderProps {
  children: ReactNode;
}

const DAPP_METADATA: WalletKitTypes.Metadata = {
  name: "Lens Account Interface",
  description: "Interface for managing Lens Account via WalletConnect",
  url: typeof window !== "undefined" ? window.location.origin : "http://localhost:3000",
  icons: ["/favicon.ico"],
};

// --- WalletConnectProvider Component ---
export function WalletConnectProvider({ children }: WalletConnectProviderProps) {
  const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;

  // --- State Management ---
  const serviceRef = useRef<WalletConnectService | null>(null);
  const [walletKitInstance, setWalletKitInstance] = useState<IWalletKit | null>(null);
  const [activeSessions, setActiveSessions] = useState<Record<string, SessionTypes.Struct>>({});
  const [pendingProposal, setPendingProposal] = useState<WalletKitTypes.SessionProposal | null>(null);
  const [pendingRequest, setPendingRequest] = useState<WalletKitTypes.SessionRequest | null>(null);
  const [isInitializing, setIsInitializing] = useState(true);
  const [isPairing, setIsPairing] = useState(false);
  const [isProcessingAction, setIsProcessingAction] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  const { lensAccountAddress } = useLensAccount();

  console.log(
    `%cWalletConnectProvider Render: isInitialized=${isInitialized}, isInitializing=${isInitializing}, isPairing=${isPairing}, isProcessing=${isProcessingAction}, serviceExists=${!!serviceRef.current}, pendingProposal=${!!pendingProposal}, pendingRequest=${!!pendingRequest}`,
    "color: blue",
  );

  // --- Effect to Create Instance, Initialize ONCE ---
  useEffect(() => {
    if (!projectId) {
      console.error("WalletConnectProvider: Project ID missing. Cannot initialize service.");
      setError("WalletConnect Project ID is missing.");
      setIsInitializing(false);
      setIsInitialized(false);
      return;
    }
    // Prevent re-initialization if instance already exists in ref
    if (serviceRef.current) {
      console.log(
        `%cWalletConnectProvider Mount Effect: Service instance already exists in ref. Skipping creation/init. isInitialized=${serviceRef.current.isInitialized()}`,
        "color: yellow",
      );
      // Sync state if needed (e.g. HMR occurred after init finished)
      if (serviceRef.current.isInitialized() && !isInitialized) {
        setIsInitialized(true);
        setIsInitializing(false);
        setWalletKitInstance(serviceRef.current.getWalletKitInstance() ?? null);
        setActiveSessions(serviceRef.current.getActiveSessions());
      } else if (serviceRef.current.isInitializing() && !isInitializing) {
        setIsInitializing(true);
      }
    } else {
      console.log(`%cWalletConnectProvider Mount Effect: Creating NEW service instance and initializing...`, "color: orange");
      setIsInitializing(true);
      setError(null);
      const service = new WalletConnectService(projectId, DAPP_METADATA);
      serviceRef.current = service; // Store the instance in the ref

      service.init().catch((initError: Error | unknown) => {
        console.error("WalletConnectProvider Mount Effect: service.init() rejected.", initError);
      });
    }
  }, [projectId]); // Add projectId dependency

  // --- Effect to Attach/Detach Event Listeners ---
  useEffect(() => {
    const currentService = serviceRef.current; // Capture ref value for effect closure
    if (!currentService) {
      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
      return;
    }

    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");

    // Define handlers
    const handleInitialized: WalletConnectServiceEvents[ServiceEvents.Initialized] = ({ success, instance }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
      setIsInitialized(success);
      setWalletKitInstance(success ? instance : null);
      if (currentService) setActiveSessions(currentService.getActiveSessions());
      setIsInitializing(false);
      if (!success && !error) setError("Initialization failed via event");
    };
    const handlePairStatus: WalletConnectServiceEvents[ServiceEvents.PairStatus] = ({ status, message }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
      setIsPairing(status === "pairing");
      if (status === "error") {
        setError(message || "Pairing failed");
        setIsPairing(false);
      } else if (status !== "pairing") {
        setError(null);
      }
    };
    const handleSessionProposal: WalletConnectServiceEvents[ServiceEvents.SessionProposal] = ({ proposal }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
      setPendingProposal(proposal);
      setIsPairing(false);
      setError(null);
    };
    const handleSessionConnect: WalletConnectServiceEvents[ServiceEvents.SessionConnect] = ({ session }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
      setIsPairing(false);
      setError(null);
      setPendingProposal(null);
    };
    // This now handles PEER disconnects or SDK internal cleanup events
    const handleSessionDelete: WalletConnectServiceEvents[ServiceEvents.SessionDelete] = ({ topic }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
      setActiveSessions((prev) => {
        if (!prev[topic]) return prev;
        const { [topic]: _removed, ...rest } = prev;
        console.log(`%cProvider State: Removing session ${topic} based on SDK/PEER event.`, "color: brown");
        return rest;
      });
      setIsPairing(false);
      if (pendingProposal && pendingProposal.params.pairingTopic === topic) {
        console.log("%cProvider: Clearing pending proposal due to SDK/peer session delete event.", "color: brown");
        setPendingProposal(null);
      }
    };
    const handleSessionsUpdated: WalletConnectServiceEvents[ServiceEvents.SessionsUpdated] = ({ sessions }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
      setActiveSessions(sessions);
    };
    const handleSessionRequest: WalletConnectServiceEvents[ServiceEvents.SessionRequest] = ({ request }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
      if (request.params.request.method === "eth_sendTransaction") {
        setPendingRequest(request);
        setError(null);
      } else {
        console.warn(`%cProvider Listener: Received unhandled request method: ${request.params.request.method}`, "color: orange");
      }
    };
    const handleError: WalletConnectServiceEvents[ServiceEvents.Error] = ({ message }) => {
      console.error(`%cProvider Listener: ${ServiceEvents.Error} received:`, "color: red", message);
      setError(message);
      setIsPairing(false);
      setIsProcessingAction(false);
    };
    const handleIsLoading: WalletConnectServiceEvents[ServiceEvents.IS_LOADING] = ({ isLoading }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
      setIsProcessingAction(isLoading);
    };
    const handleIsPairing: WalletConnectServiceEvents[ServiceEvents.IS_PAIRING] = ({ isPairing }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
      setIsPairing(isPairing);
    };

    // Attach listeners
    currentService.on(ServiceEvents.Initialized, handleInitialized);
    currentService.on(ServiceEvents.PairStatus, handlePairStatus);
    currentService.on(ServiceEvents.SessionProposal, handleSessionProposal);
    currentService.on(ServiceEvents.SessionConnect, handleSessionConnect);
    currentService.on(ServiceEvents.SessionDelete, handleSessionDelete);
    currentService.on(ServiceEvents.SessionsUpdated, handleSessionsUpdated);
    currentService.on(ServiceEvents.Error, handleError);
    currentService.on(ServiceEvents.IS_LOADING, handleIsLoading);
    currentService.on(ServiceEvents.IS_PAIRING, handleIsPairing);
    currentService.on(ServiceEvents.SessionRequest, handleSessionRequest);

    // Cleanup function
    return () => {
      console.log("%cWalletConnectProvider Mount Effect: Cleaning up listeners.", "color: orange");
      if (currentService) {
        // Use the captured variable
        console.log("%cDetaching listeners from service instance in ref.", "color: orange");
        currentService.off(ServiceEvents.Initialized, handleInitialized);
        currentService.off(ServiceEvents.PairStatus, handlePairStatus);
        currentService.off(ServiceEvents.SessionProposal, handleSessionProposal);
        currentService.off(ServiceEvents.SessionConnect, handleSessionConnect);
        currentService.off(ServiceEvents.SessionDelete, handleSessionDelete);
        currentService.off(ServiceEvents.SessionsUpdated, handleSessionsUpdated);
        currentService.off(ServiceEvents.Error, handleError);
        currentService.off(ServiceEvents.IS_LOADING, handleIsLoading);
        currentService.off(ServiceEvents.IS_PAIRING, handleIsPairing);
        currentService.off(ServiceEvents.SessionRequest, handleSessionRequest);
      }
    };
  }, []);

  // --- Context Methods ---
  const pair = useCallback(
    async (uri: string) => {
      if (!serviceRef.current?.isInitialized()) return setError("Service not initialized");
      console.log(`%cWalletConnectProvider: pair called`, "color: cyan");
      setError(null);
      await serviceRef.current.pair(uri);
    },
    [isInitialized],
  );

  const approveSession = useCallback(async () => {
    if (!serviceRef.current?.isInitialized() || !pendingProposal || !lensAccountAddress) {
      const reason = !isInitialized ? "Service not ready." : !pendingProposal ? "No proposal." : "No Lens address.";
      setError(`Cannot approve: ${reason}`);
      return;
    }
    console.log(`%cWalletConnectProvider: approveSession called for proposal ${pendingProposal.id}`, "color: cyan");
    setError(null);

    try {
      const requiredNamespaces = pendingProposal.params.requiredNamespaces || {};
      const optionalNamespaces = pendingProposal.params.optionalNamespaces || {};
      const requestedMethods = [...(requiredNamespaces.eip155?.methods || []), ...(optionalNamespaces.eip155?.methods || [])];
      const requestedEvents = [...(requiredNamespaces.eip155?.events || []), ...(optionalNamespaces.eip155?.events || [])];
      const methods = requestedMethods.length > 0 ? requestedMethods : ["eth_sendTransaction", "personal_sign", "eth_signTypedData_v4"];
      const events = requestedEvents.length > 0 ? requestedEvents : ["chainChanged", "accountsChanged"];
      const approvedNamespaces = buildApprovedNamespaces({
        proposal: pendingProposal.params,
        supportedNamespaces: {
          eip155: {
            chains: [`eip155:${LENS_CHAIN_ID}`],
            methods: methods,
            events: events,
            accounts: [`eip155:${LENS_CHAIN_ID}:${lensAccountAddress}`],
          },
        },
      });

      const session = await serviceRef.current.approveSession(pendingProposal, approvedNamespaces);
      console.log(`%cWalletConnectProvider: approveSession successful, received session:`, "color: green", session);
      // Manually update state since event might not fire from SDK
      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
      setPendingProposal(null);
      setIsPairing(false);
      setError(null);
    } catch (e) {
      console.error(`%cWalletConnectProvider: approveSession failed:`, "color: red", e);
    }
  }, [isInitialized, pendingProposal, lensAccountAddress]);

  const rejectSession = useCallback(async () => {
    if (!serviceRef.current?.isInitialized() || !pendingProposal) {
      const reason = !isInitialized ? "Service not ready." : "No proposal.";
      setError(`Cannot reject: ${reason}`);
      return;
    }
    console.log(`%cWalletConnectProvider: rejectSession called for proposal ${pendingProposal.id}`, "color: cyan");
    setError(null);
    try {
      await serviceRef.current.rejectSession(pendingProposal, getSdkError("USER_REJECTED"));
      setPendingProposal(null); // Clear proposal state immediately
    } catch (e) {
      console.error(`%cWalletConnectProvider: rejectSession failed:`, "color: red", e);
    }
  }, [isInitialized, pendingProposal]);

  // >>>>>>>> REVERTED disconnect callback <<<<<<<<
  const disconnect = useCallback(
    async (topic: string) => {
      if (!serviceRef.current?.isInitialized()) {
        setError("Service not initialized");
        console.error("WalletConnectProvider: disconnect called before service initialized.");
        return;
      }
      console.log(`%cWalletConnectProvider: disconnect called for topic ${topic}`, "color: cyan");
      setError(null);

      try {
        await serviceRef.current.disconnectSession(topic, getSdkError("USER_DISCONNECTED"));
        console.log(`%cWalletConnectProvider: disconnect service call succeeded for topic ${topic}`, "color: green");

        // Manually update the Provider's state AFTER successful call
        setActiveSessions((prev) => {
          if (!prev[topic]) {
            console.warn(`%cWalletConnectProvider: Tried to remove non-existent session ${topic} from state.`, "color: orange");
            return prev;
          }
          const { [topic]: _removed, ...rest } = prev;
          console.log(`%cWalletConnectProvider: Manually removing session ${topic} from state.`, "color: brown");
          return rest;
        });
        // Ensure other related states are cleared
        setIsPairing(false);
        if (pendingProposal?.params?.pairingTopic === topic) {
          console.log(`%cWalletConnectProvider: Clearing pending proposal during manual disconnect cleanup for topic ${topic}.`, "color: brown");
          setPendingProposal(null);
        }
      } catch (e) {
        console.error(`%cWalletConnectProvider: disconnect failed for topic ${topic}:`, "color: red", e);
        setError((e as Error)?.message || "Disconnect failed");
      }
    },
    [pendingProposal], // isInitialized was correctly removed previously
  );
  // >>>>>>>> ----------------------------- <<<<<<<<

  const respondRequest = useCallback(
    async (response: JsonRpcResponse) => {
      if (!serviceRef.current?.isInitialized() || !pendingRequest) {
        setError("Service not initialized or no pending request.");
        console.error("WalletConnectProvider: respondRequest called incorrectly.");
        return;
      }
      console.log(`%cWalletConnectProvider: respondRequest called for ID ${response.id}`, "color: cyan", response);
      setError(null);

      try {
        await serviceRef.current.respondSessionRequest(pendingRequest.topic, response);
        console.log(`%cWalletConnectProvider: response sent successfully for request ${response.id}`, "color: green");
      } catch (e) {
        console.error(`%cWalletConnectProvider: respondRequest failed for ID ${response.id}:`, "color: red", e);
        setError((e as Error)?.message || "Failed to send response");
      } finally {
        setPendingRequest(null);
      }
    },
    [pendingRequest], // Remove isInitialized
  );

  // --- Context Value Memoization ---
  const contextValue = useMemo(
    () => ({
      walletKitInstance,
      activeSessions,
      pendingProposal,
      pendingRequest,
      pair,
      disconnect, // Pass the reverted disconnect function
      approveSession,
      rejectSession,
      respondRequest,
      isLoading: isInitializing || isPairing || isProcessingAction,
      isInitializing,
      isPairing,
      isProcessingAction,
      error,
      isInitialized,
    }),
    [
      walletKitInstance,
      activeSessions,
      pendingProposal,
      pendingRequest,
      pair,
      disconnect, // Include reverted disconnect
      approveSession,
      rejectSession,
      respondRequest,
      isInitializing,
      isPairing,
      isProcessingAction,
      error,
      isInitialized,
    ],
  );

  if (!projectId) {
    throw new Error("WalletConnect projectId is required. Please set NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID in your environment variables.");
  }

  return projectId ? (
    <WalletConnectContext.Provider value={contextValue}>{children}</WalletConnectContext.Provider>
  ) : (
    <div>Error: WalletConnect Project ID is missing. Cannot initialize WalletConnect.</div>
  );
}

// Keep hook
export function useWalletConnect() {
  const context = useContext(WalletConnectContext);
  if (context === undefined) {
    throw new Error("useWalletConnect must be used within a WalletConnectProvider");
  }
  return context;
}

// Export the context for direct usage if needed
export { WalletConnectContext };
</file>

</files>
