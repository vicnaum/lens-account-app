This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: *.*, src
- Files matching these patterns are excluded: llms.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  app/
    dashboard/
      layout.tsx
      page.tsx
    layout.tsx
    page.tsx
    providers.tsx
  components/
    AccountDisplay.tsx
    ConnectOwnerButton.tsx
    DiscoveryForm.tsx
    WcConnect.tsx
    WcRequestDisplay.tsx
  contexts/
    LensAccountContext.tsx
    WalletConnectProvider.tsx
  hooks/
    useDebounce.ts
  lib/
    constants.ts
    wagmi.ts
  services/
    walletConnectService.ts
  styles/
    globals.css
.dockerignore
.gitignore
.prettierrc
DEVELOPMENT_PLAN.md
diff.txt
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
Spec.functional.md
Spec.technical.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="diff.txt">
diff --git a/src/components/WcConnect.tsx b/src/components/WcConnect.tsx
index 7893d18..49ea3cc 100644
--- a/src/components/WcConnect.tsx
+++ b/src/components/WcConnect.tsx
@@ -1,9 +1,10 @@
 // src/components/WcConnect.tsx
 "use client";
 
-import React, { useState, useEffect } from "react";
+import React, { useState, useEffect, useCallback, useMemo } from "react";
 import { useWalletConnect } from "@/contexts/WalletConnectProvider"; // Ensure correct path
 import Image from "next/image";
+import { isExpired } from "@walletconnect/utils"; // <-- Import isExpired utility
 
 // Default/Fallback Icon
 const FallbackIcon = () => <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs">?</div>;
@@ -65,52 +66,75 @@ export function WcConnect() {
     pendingProposal, // Get the pending proposal
     approveSession, // Get approve action
     rejectSession, // Get reject action
-    isInitializing, // <<<--- ADDED isInitializing HERE ---<<<
+    isInitializing,
   } = useWalletConnect();
   const [uri, setUri] = useState("");
+  const [isSubmitting, setIsSubmitting] = useState(false);
 
   const activeSessionTopic = Object.keys(activeSessions)[0]; // Assuming only one session for MVP
   const connectedSession = activeSessionTopic ? activeSessions[activeSessionTopic] : null;
 
-  // --- Add this useEffect ---
+  // ---> Check if proposal is expired for UI state <--- //
+  const isProposalExpired = useMemo(() => {
+    if (!pendingProposal?.params?.expiryTimestamp) return false; // No timestamp means can't determine expiry this way
+    return isExpired(pendingProposal.params.expiryTimestamp);
+  }, [pendingProposal]); // Re-calculate only when proposal changes
+  // ---> End Expiry Check <--- //
+
   useEffect(() => {
-    // If there's no connected session (either initially or after disconnect),
-    // clear the URI input field.
     if (!connectedSession) {
       setUri("");
     }
-  }, [connectedSession]); // Run this effect when connectedSession changes
-  // -------------------------
-
-  const handleConnect = () => {
-    if (!uri || !isInitialized || isLoading) return; // Check initialization and combined loading state
-    pair(uri);
-  };
-
-  const handleDisconnect = () => {
-    if (connectedSession && isInitialized && !isLoading) {
-      // Check initialization and combined loading state
-      disconnect(connectedSession.topic);
+  }, [connectedSession]);
+
+  const handleConnect = useCallback(() => {
+    if (!uri || !isInitialized || isLoading || isSubmitting) return;
+    setIsSubmitting(true);
+    pair(uri).finally(() => setIsSubmitting(false));
+  }, [uri, isInitialized, isLoading, isSubmitting, pair]);
+
+  const handleDisconnect = useCallback(() => {
+    if (connectedSession && isInitialized && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      disconnect(connectedSession.topic).finally(() => setIsSubmitting(false));
     }
-  };
-
-  const handleApprove = () => {
-    if (pendingProposal && !isLoading) {
-      approveSession();
+  }, [connectedSession, isInitialized, isLoading, isSubmitting, disconnect]);
+
+  const handleApprove = useCallback(async () => {
+    if (pendingProposal && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      try {
+        await approveSession();
+      } catch (err) {
+        console.error("Approval failed:", err);
+      } finally {
+        setIsSubmitting(false);
+      }
     }
-  };
-
-  const handleReject = () => {
-    if (pendingProposal && !isLoading) {
-      rejectSession();
+  }, [pendingProposal, isLoading, isSubmitting, approveSession]);
+
+  const handleReject = useCallback(async () => {
+    if (pendingProposal && !isLoading && !isSubmitting) {
+      setIsSubmitting(true);
+      try {
+        await rejectSession();
+      } catch (err) {
+        console.error("Rejection failed:", err);
+      } finally {
+        setIsSubmitting(false);
+      }
     }
-  };
+  }, [pendingProposal, isLoading, isSubmitting, rejectSession]);
+
+  // Combined loading state (context is loading OR local component is submitting)
+  const isDisabled = isLoading || isSubmitting || !isInitialized;
+  const approveDisabled = isDisabled || isProposalExpired; // <-- Disable approve if expired
 
   // Display loading states more granularly if needed, otherwise use `isLoading`
-  const connectButtonText = isPairing ? "Pairing..." : isLoading ? "Working..." : "Connect";
-  const disconnectButtonText = isLoading ? "Working..." : "Disconnect";
-  const approveButtonText = isLoading ? "Working..." : "Approve Session";
-  const rejectButtonText = isLoading ? "Working..." : "Reject Session";
+  const connectButtonText = isPairing ? "Pairing..." : isSubmitting ? "Connecting..." : isLoading ? "Working..." : "Connect";
+  const disconnectButtonText = isSubmitting ? "Working..." : isLoading ? "Working..." : "Disconnect";
+  const approveButtonText = isSubmitting ? "Approving..." : isLoading ? "Working..." : "Approve Session";
+  const rejectButtonText = isSubmitting ? "Rejecting..." : isLoading ? "Working..." : "Reject Session";
 
   // Resolve icon URLs
   const connectedDAppIconUrl = connectedSession
@@ -134,17 +158,24 @@ export function WcConnect() {
             <span className="text-sm text-gray-700">{pendingProposal.params.proposer.metadata.name}</span>
           </div>
           {/* TODO: Display requested permissions details if needed */}
+          {/* ---> Add Expiry Message <--- */}
+          {isProposalExpired && (
+            <p className="text-sm font-medium text-red-600 text-center">
+              This connection proposal has expired. Please generate a new one from the dApp.
+            </p>
+          )}
+          {/* ---> End Expiry Message <--- */}
           <div className="flex space-x-2 pt-2">
             <button
               onClick={handleApprove}
-              disabled={isLoading || !isInitialized}
+              disabled={approveDisabled} // <--- Use specific disabled state
               className="flex-1 px-3 py-1 bg-green-500 text-white text-xs font-medium rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {approveButtonText}
             </button>
             <button
               onClick={handleReject}
-              disabled={isLoading || !isInitialized}
+              disabled={isDisabled} // Reject might still be possible even if expired, or disable too: `disabled={isDisabled || isProposalExpired}`
               className="flex-1 px-3 py-1 bg-red-500 text-white text-xs font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {rejectButtonText}
@@ -170,7 +201,7 @@ export function WcConnect() {
           </p>
           <button
             onClick={handleDisconnect}
-            disabled={isLoading || !isInitialized} // Use combined loading state
+            disabled={isDisabled}
             className="w-full px-4 py-2 mt-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
           >
             {disconnectButtonText}
@@ -193,11 +224,11 @@ export function WcConnect() {
               onChange={(e) => setUri(e.target.value)}
               placeholder="wc:..."
               className="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm disabled:bg-gray-100"
-              disabled={isLoading || !isInitialized} // Use combined loading state
+              disabled={isDisabled}
             />
             <button
               onClick={handleConnect}
-              disabled={!uri || isLoading || !isInitialized} // Use combined loading state
+              disabled={!uri || isDisabled}
               className="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
             >
               {connectButtonText}
@@ -207,11 +238,9 @@ export function WcConnect() {
       )}
 
       {/* --- Status/Error Messages --- */}
-      {error && !isLoading && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
+      {error && !isLoading && !isSubmitting && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
       {isPairing && <p className="text-indigo-600 text-sm mt-2">Pairing initiated, check dApp/wallet if needed...</p>}
-      {/* Check both flags here now */}
       {!isInitialized && !isInitializing && !error && <p className="text-orange-600 text-sm mt-2">WalletConnect service not ready.</p>}
-      {/* And display initializing message correctly */}
       {isInitializing && <p className="text-gray-500 text-sm mt-2">Initializing WalletConnect...</p>}
     </div>
   );
diff --git a/src/contexts/WalletConnectProvider.tsx b/src/contexts/WalletConnectProvider.tsx
index 0c1e8f6..7ac07c1 100644
--- a/src/contexts/WalletConnectProvider.tsx
+++ b/src/contexts/WalletConnectProvider.tsx
@@ -6,7 +6,7 @@ import React, { createContext, useState, useContext, ReactNode, useEffect, useCa
 import { WalletConnectService, ServiceEvents, type WalletConnectServiceEvents } from "@/services/walletConnectService";
 import { SessionTypes } from "@walletconnect/types";
 import { IWalletKit, WalletKitTypes } from "@reown/walletkit";
-import { buildApprovedNamespaces, getSdkError } from "@walletconnect/utils";
+import { buildApprovedNamespaces, getSdkError, isExpired } from "@walletconnect/utils";
 import { useLensAccount } from "./LensAccountContext";
 import { LENS_CHAIN_ID } from "@/lib/constants";
 import { JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
@@ -101,94 +101,114 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
         console.error("WalletConnectProvider Mount Effect: service.init() rejected.", initError);
       });
     }
-  }, [projectId]); // Add projectId dependency
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [projectId]); // Keep only projectId as it's needed for creation
 
-  // --- Effect to Attach/Detach Event Listeners ---
-  useEffect(() => {
-    const currentService = serviceRef.current; // Capture ref value for effect closure
-    if (!currentService) {
-      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
-      return;
-    }
-
-    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");
-
-    // Define handlers
-    const handleInitialized: WalletConnectServiceEvents[ServiceEvents.Initialized] = ({ success, instance }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
+  // --- Event Handlers (wrapped in useCallback) ---
+  const handleInitialized = useCallback<WalletConnectServiceEvents[ServiceEvents.Initialized]>(
+    ({ success, instance }) => {
+      console.log(`%cProvider Handler: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
       setIsInitialized(success);
       setWalletKitInstance(success ? instance : null);
-      if (currentService) setActiveSessions(currentService.getActiveSessions());
+      // Check serviceRef directly instead of captured value, as it might change over time if remount occurs
+      if (serviceRef.current) setActiveSessions(serviceRef.current.getActiveSessions());
       setIsInitializing(false);
       if (!success && !error) setError("Initialization failed via event");
-    };
-    const handlePairStatus: WalletConnectServiceEvents[ServiceEvents.PairStatus] = ({ status, message }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
-      setIsPairing(status === "pairing");
-      if (status === "error") {
-        setError(message || "Pairing failed");
-        setIsPairing(false);
-      } else if (status !== "pairing") {
-        setError(null);
-      }
-    };
-    const handleSessionProposal: WalletConnectServiceEvents[ServiceEvents.SessionProposal] = ({ proposal }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
-      setPendingProposal(proposal);
-      setIsPairing(false);
-      setError(null);
-    };
-    const handleSessionConnect: WalletConnectServiceEvents[ServiceEvents.SessionConnect] = ({ session }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
-      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
+    },
+    [error],
+  ); // Dependency: error (to avoid setting error if one already exists)
+
+  const handlePairStatus = useCallback<WalletConnectServiceEvents[ServiceEvents.PairStatus]>(({ status, message }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
+    setIsPairing(status === "pairing");
+    if (status === "error") {
+      setError(message || "Pairing failed");
       setIsPairing(false);
+    } else if (status !== "pairing") {
       setError(null);
-      setPendingProposal(null);
-    };
-    // This now handles PEER disconnects or SDK internal cleanup events
-    const handleSessionDelete: WalletConnectServiceEvents[ServiceEvents.SessionDelete] = ({ topic }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
+    }
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionProposal = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionProposal]>(({ proposal }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
+    setPendingProposal(proposal);
+    setIsPairing(false);
+    setError(null);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionConnect = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionConnect]>(({ session }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
+    setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
+    setIsPairing(false);
+    setError(null);
+    setPendingProposal(null);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionDelete = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionDelete]>(
+    ({ topic }) => {
+      console.log(`%cProvider Handler: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
       setActiveSessions((prev) => {
         if (!prev[topic]) return prev;
+        // eslint-disable-next-line @typescript-eslint/no-unused-vars
         const { [topic]: _removed, ...rest } = prev;
         console.log(`%cProvider State: Removing session ${topic} based on SDK/PEER event.`, "color: brown");
         return rest;
       });
       setIsPairing(false);
+      // Need pendingProposal to check pairingTopic
       if (pendingProposal && pendingProposal.params.pairingTopic === topic) {
         console.log("%cProvider: Clearing pending proposal due to SDK/peer session delete event.", "color: brown");
         setPendingProposal(null);
       }
-    };
-    const handleSessionsUpdated: WalletConnectServiceEvents[ServiceEvents.SessionsUpdated] = ({ sessions }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
-      setActiveSessions(sessions);
-    };
-    const handleSessionRequest: WalletConnectServiceEvents[ServiceEvents.SessionRequest] = ({ request }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
-      if (request.params.request.method === "eth_sendTransaction") {
-        setPendingRequest(request);
-        setError(null);
-      } else {
-        console.warn(`%cProvider Listener: Received unhandled request method: ${request.params.request.method}`, "color: orange");
-      }
-    };
-    const handleError: WalletConnectServiceEvents[ServiceEvents.Error] = ({ message }) => {
-      console.error(`%cProvider Listener: ${ServiceEvents.Error} received:`, "color: red", message);
-      setError(message);
-      setIsPairing(false);
-      setIsProcessingAction(false);
-    };
-    const handleIsLoading: WalletConnectServiceEvents[ServiceEvents.IS_LOADING] = ({ isLoading }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
-      setIsProcessingAction(isLoading);
-    };
-    const handleIsPairing: WalletConnectServiceEvents[ServiceEvents.IS_PAIRING] = ({ isPairing }) => {
-      console.log(`%cProvider Listener: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
-      setIsPairing(isPairing);
-    };
+    },
+    [pendingProposal],
+  ); // Dependency: pendingProposal
+
+  const handleSessionsUpdated = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionsUpdated]>(({ sessions }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
+    setActiveSessions(sessions);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleSessionRequest = useCallback<WalletConnectServiceEvents[ServiceEvents.SessionRequest]>(({ request }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
+    if (request.params.request.method === "eth_sendTransaction") {
+      setPendingRequest(request);
+      setError(null);
+    } else {
+      console.warn(`%cProvider Handler: Received unhandled request method: ${request.params.request.method}`, "color: orange");
+      // Maybe respond with an error here automatically?
+      // respondRequest({ id: request.id, jsonrpc: '2.0', error: { code: -32601, message: 'Method not supported' } });
+    }
+  }, []); // Dependency: respondRequest (if adding automatic error response)
+
+  const handleError = useCallback<WalletConnectServiceEvents[ServiceEvents.Error]>(({ message }) => {
+    console.error(`%cProvider Handler: ${ServiceEvents.Error} received:`, "color: red", message);
+    setError(message);
+    setIsPairing(false);
+    setIsProcessingAction(false);
+  }, []); // No dependencies needed here as it only calls setters
 
-    // Attach listeners
+  const handleIsLoading = useCallback<WalletConnectServiceEvents[ServiceEvents.IS_LOADING]>(({ isLoading }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
+    setIsProcessingAction(isLoading);
+  }, []); // No dependencies needed here as it only calls setters
+
+  const handleIsPairing = useCallback<WalletConnectServiceEvents[ServiceEvents.IS_PAIRING]>(({ isPairing }) => {
+    console.log(`%cProvider Handler: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
+    setIsPairing(isPairing);
+  }, []); // No dependencies needed here as it only calls setters
+
+  // --- Effect to Attach/Detach Event Listeners ---
+  useEffect(() => {
+    const currentService = serviceRef.current; // Capture ref value
+    if (!currentService) {
+      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
+      return;
+    }
+
+    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");
+
+    // Attach the useCallback handlers
     currentService.on(ServiceEvents.Initialized, handleInitialized);
     currentService.on(ServiceEvents.PairStatus, handlePairStatus);
     currentService.on(ServiceEvents.SessionProposal, handleSessionProposal);
@@ -200,11 +220,10 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
     currentService.on(ServiceEvents.IS_PAIRING, handleIsPairing);
     currentService.on(ServiceEvents.SessionRequest, handleSessionRequest);
 
-    // Cleanup function
+    // Cleanup function using the same stable handlers
     return () => {
-      console.log("%cWalletConnectProvider Mount Effect: Cleaning up listeners.", "color: orange");
+      console.log("%cWalletConnectProvider Listener Effect: Cleaning up listeners.", "color: orange");
       if (currentService) {
-        // Use the captured variable
         console.log("%cDetaching listeners from service instance in ref.", "color: orange");
         currentService.off(ServiceEvents.Initialized, handleInitialized);
         currentService.off(ServiceEvents.PairStatus, handlePairStatus);
@@ -218,7 +237,21 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
         currentService.off(ServiceEvents.SessionRequest, handleSessionRequest);
       }
     };
-  }, []);
+  }, [
+    // Dependencies are the stable handler functions themselves
+    handleInitialized,
+    handlePairStatus,
+    handleSessionProposal,
+    handleSessionConnect,
+    handleSessionDelete,
+    handleSessionsUpdated,
+    handleError,
+    handleIsLoading,
+    handleIsPairing,
+    handleSessionRequest,
+    // Also include isInitialized or serviceRef.current? Let's try without first.
+    // If listeners aren't attached correctly after init, add isInitialized.
+  ]);
 
   // --- Context Methods ---
   const pair = useCallback(
@@ -228,15 +261,29 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
       setError(null);
       await serviceRef.current.pair(uri);
     },
-    [isInitialized],
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+    [isInitialized], // Keep isInitialized here
   );
 
   const approveSession = useCallback(async () => {
-    if (!serviceRef.current?.isInitialized() || !pendingProposal || !lensAccountAddress) {
-      const reason = !isInitialized ? "Service not ready." : !pendingProposal ? "No proposal." : "No Lens address.";
+    if (!serviceRef.current?.isInitialized() || !pendingProposal) {
+      const reason = !isInitialized ? "Service not ready." : "No proposal.";
       setError(`Cannot approve: ${reason}`);
       return;
     }
+
+    if (pendingProposal.params.expiryTimestamp && isExpired(pendingProposal.params.expiryTimestamp)) {
+      console.warn(`Attempted to approve expired proposal ${pendingProposal.id}.`);
+      setError("Connection proposal expired. Please try again.");
+      setPendingProposal(null);
+      return;
+    }
+
+    if (!lensAccountAddress) {
+      setError("Cannot approve: Lens Account address is missing.");
+      return;
+    }
+
     console.log(`%cWalletConnectProvider: approveSession called for proposal ${pendingProposal.id}`, "color: cyan");
     setError(null);
 
@@ -261,8 +308,6 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
 
       const session = await serviceRef.current.approveSession(pendingProposal, approvedNamespaces);
       console.log(`%cWalletConnectProvider: approveSession successful, received session:`, "color: green", session);
-      // Manually update state since event might not fire from SDK
-      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
       setPendingProposal(null);
       setIsPairing(false);
       setError(null);
@@ -287,7 +332,6 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
     }
   }, [isInitialized, pendingProposal]);
 
-  // >>>>>>>> REVERTED disconnect callback <<<<<<<<
   const disconnect = useCallback(
     async (topic: string) => {
       if (!serviceRef.current?.isInitialized()) {
@@ -308,24 +352,27 @@ export function WalletConnectProvider({ children }: WalletConnectProviderProps)
             console.warn(`%cWalletConnectProvider: Tried to remove non-existent session ${topic} from state.`, "color: orange");
             return prev;
           }
+          // eslint-disable-next-line @typescript-eslint/no-unused-vars
           const { [topic]: _removed, ...rest } = prev;
           console.log(`%cWalletConnectProvider: Manually removing session ${topic} from state.`, "color: brown");
           return rest;
         });
-        // Ensure other related states are cleared
+
+        // ---> KEEP This State Clearing Logic <---
+        setPendingProposal(null);
+        setPendingRequest(null); // Clear pending requests too
         setIsPairing(false);
-        if (pendingProposal?.params?.pairingTopic === topic) {
-          console.log(`%cWalletConnectProvider: Clearing pending proposal during manual disconnect cleanup for topic ${topic}.`, "color: brown");
-          setPendingProposal(null);
-        }
+        setError(null);
+        // ---> End State Clearing Logic <---
       } catch (e) {
         console.error(`%cWalletConnectProvider: disconnect failed for topic ${topic}:`, "color: red", e);
         setError((e as Error)?.message || "Disconnect failed");
       }
     },
-    [pendingProposal], // isInitialized was correctly removed previously
+    // Add dependencies if they are used *inside* the logic before the service call,
+    // but since it primarily relies on the `topic` argument, `[]` is okay here.
+    [],
   );
-  // >>>>>>>> ----------------------------- <<<<<<<<
 
   const respondRequest = useCallback(
     async (response: JsonRpcResponse) => {
</file>

<file path="src/components/ConnectOwnerButton.tsx">
// components/ConnectOwnerButton.tsx
"use client";

import { ConnectKitButton } from "connectkit";

export function ConnectOwnerButton() {
  return (
    <div className="flex justify-center">
      <ConnectKitButton />
    </div>
  );
}
</file>

<file path="src/hooks/useDebounce.ts">
// hooks/useDebounce.ts
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Update debounced value after delay
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cancel the timeout if value changes (also on delay change or unmount)
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]); // Only re-call effect if value or delay changes

  return debouncedValue;
}
</file>

<file path="src/styles/globals.css">
@import "tailwindcss" source("../**/*.{js,ts,jsx,tsx,mdx}");

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
} */

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path=".dockerignore">
.git
.gitignore
.next
.husky
node_modules
README.md
.env*
npm-debug.log*
pnpm-debug.log*
.DS_Store
.vscode
*.pem
.cursor
tsconfig.tsbuildinfo
llms
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path=".prettierrc">
{
  "printWidth": 150
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
# Lens Account Web Interface

This project is a web application designed to provide an interface for interacting with a custom EVM Smart Account, specifically the "Lens Account". It allows the account owner to connect their controlling EOA wallet, view basic account information, and interact with external dApps _through_ the Lens Account using WalletConnect v2 via Reown WalletKit.

This is the Minimum Viable Product (MVP) focusing on core functionality as outlined in the project specifications.

## Tech Stack

- **Framework:** Next.js 15+ (App Router)
- **Language:** TypeScript
- **Styling:** Tailwind CSS
- **Package Manager:** pnpm
- **Core Web3 Libraries:**
  - Wagmi
  - Viem
  - ConnectKit
  - @reown/walletkit (for WalletConnect v2 Wallet functionality)
  - @tanstack/react-query (peer dependency for Wagmi)

## Prerequisites

- Node.js (v18.17 or later recommended)
- pnpm

## Getting Started

1.  **Clone the repository (if applicable):**

    ```bash
    git clone <repository-url>
    cd lens-account-interface
    ```

2.  **Install dependencies:**

    ```bash
    pnpm install
    ```

3.  **Set up Environment Variables:**
    Create a `.env.local` file in the root of the project. You **must** obtain a Project ID from [WalletConnect Cloud](https://cloud.walletconnect.com/).

    ```plaintext [.env.local]
    # Get your ID from https://cloud.walletconnect.com/
    NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=YOUR_WALLETCONNECT_PROJECT_ID_HERE
    ```

    Replace `YOUR_WALLETCONNECT_PROJECT_ID_HERE` with your actual Project ID.

4.  **Run the development server:**
    ```bash
    pnpm dev
    ```
    Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Available Scripts

In the project directory, you can run:

- `pnpm dev`: Runs the app in development mode. Open [http://localhost:3000](http://localhost:3000).
- `pnpm build`: Builds the app for production.
- `pnpm start`: Starts the production server.
- `pnpm lint`: Runs ESLint.

## Project Structure

The project uses the Next.js App Router. Key directories will include:

- `app/`: Contains application routes and layouts.
- `components/`: Reusable React components.
- `contexts/`: React Context providers for managing shared state.
- `hooks/`: Custom React Hooks for specific logic.
- `lib/`: Configuration files (Wagmi, constants) and utility functions.
- `services/`: Abstraction layers for external SDKs (e.g., Reown WalletKit).
- `styles/`: Global styles and Tailwind configuration.

_(Refer to the Technical Specification for a more detailed proposed structure)._

## Contributing

_(Placeholder: Add contribution guidelines here when applicable)._

## License

_(Placeholder: Add license information here when applicable)._
</file>

<file path="Spec.functional.md">
# Functional Specification: Lens Account Web Interface - MVP (Iteration 1)

## 1. Introduction

This document outlines the functional requirements for the Minimum Viable Product (MVP) of a web interface designed to interact with a custom EVM Smart Accoun - Lens Account. Users (Owners) will be able to identify their Lens Account, connect their controlling EOA wallet, view a basic balance, and use WalletConnect v2 to interact with external dApps _through_ the Lens Account.

## 2. Target Audience

This specification is intended for developers, QA testers, and product managers involved in building the MVP.

## 3. Key Concepts

- **Lens Account:** The EVM smart contract wallet being managed. It has a single `owner()` address.
- **Owner EOA:** The Externally Owned Account (e.g., MetaMask, hardware wallet address) designated as the `owner()` of the Lens Account. This wallet is used to authorize actions _for_ the Lens Account.
- **Lens Username:** A username potentially linked to a Lens Account address via the `LensGlobalNamespace` contract.
- **WalletConnect (WC):** A protocol allowing wallets (in this case, our interface acting _as_ a wallet for the Lens Account) to connect to dApps.
- **Lens Chain:** The specific blockchain (ID 232) where the Lens Account and related contracts reside.

## 4. Core Scenarios (MVP)

### Scenario 1: Account Discovery and Owner Login

**Goal:** The user identifies their target Lens Account using either a Lens username or the account address and connects their corresponding Owner EOA wallet, ensuring they are on the correct network.

**Steps:**

1.  **Initial View:** The user accesses the web application's main entry page (`/`).
2.  **Input Fields:** The user is presented with two input fields:
    - "Lens Username"
    - "Account Address"
3.  **Username Input (User Action):**
    - The user types a Lens username into the "Lens Username" field.
    - **(App Action):** As the user types (debounced), the application queries the `LensGlobalNamespace` contract on the Lens Chain using the `accountOf(string calldata name)` function.
    - **(Outcome):**
      - If an address is returned, the "Account Address" field is automatically populated with the resolved address.
      - If no address is found (or an error occurs), the "Account Address" field remains empty or clears, and subtle feedback may be shown (e.g., input border color change).
4.  **Address Input (User Action):**
    - The user types or pastes an address into the "Account Address" field.
    - **(App Action):** As the user types/pastes, the application checks until address length & format is correct (0x + 20 chars) and queries the `LensGlobalNamespace` contract on the Lens Chain using the `usernameOf(address user)` function.
    - **(Outcome):**
      - If a username is returned, the "Lens Username" field is populated.
      - If no username is found, the "Lens Username" field remains empty or clears.
5.  **Owner Verification (App Action):**
    - Once a valid address exists in the "Account Address" field, the application queries the Lens Account contract at that address using the `owner()` function.
    - The application stores the returned `owner` address internally as the _expected owner_.
6.  **Wallet Connection (User Action):**
    - A "Connect Wallet" button becomes enabled/visible once an Account Address is determined.
    - The expected owner is also displayed above the Connect Wallet button with some text (something like "To Login - connect with this Owner wallet:" but proper).
    - The user clicks "Connect Wallet".
    - **(App Action):** A standard wallet connection modal (e.g., RainbowKit) appears, prompting the user to choose and connect their Owner EOA wallet.
    - **(App Action):** The application checks if the connected Owner EOA wallet is currently on the **Lens Chain (ID: 232)**.
    - **(Outcome - Chain Mismatch):**
      - If the wallet is on a different chain, the application (via `wagmi`/`RainbowKit`) prompts the user to switch to the Lens Chain.
      - If the Lens Chain is not configured in the user's wallet, the application prompts the user to add it.
      - The connection process pauses until the wallet is successfully connected to the Lens Chain.
    - **(App Action):** Once the Owner EOA is connected and on the Lens Chain, the application compares the connected wallet's address with the _expected owner_ address stored in step 5.b.
    - **(Outcome - Owner Mismatch):**
      - If the addresses do _not_ match, an error message is displayed clearly indicating the mismatch (e.g., "Incorrect owner connected. Please connect with address: `0x...{expectedOwnerAddress}`").
      - The user remains on the login/discovery page and can attempt to connect a different wallet.
    - **(Outcome - Success):**
      - If the addresses _match_ and the wallet is on the Lens Chain, the user is authenticated for this session.
      - The application navigates the user to the main Dashboard page (e.g., `/dashboard`).

### Scenario 2: Viewing Dashboard & Initiating WalletConnect Pairing

**Goal:** The user views basic account information and connects the Lens Account to an external dApp using a WalletConnect URI.

**Preconditions:**

- User has successfully completed Scenario 1.
- Owner EOA wallet is connected and verified.
- User is on the Dashboard page.

**Steps:**

1.  **Dashboard View:** The user sees the Dashboard.
2.  **Account Info Display (App Action):**
    - The Lens Account address is displayed.
    - The WGHO token balance for the Lens Account is fetched and displayed (formatted).
3.  **WalletConnect Input:** The user sees a dedicated section/component for WalletConnect containing:
    - An input field labeled "Paste WalletConnect Code".
    - A "Connect" button next to the input field.
4.  **Obtain WC URI (User Action):** The user navigates to an external dApp (e.g., Aave) and initiates a WalletConnect connection, copying the generated WC v2 URI (e.g., `wc:abc...`).
5.  **Paste & Connect (User Action):**
    - The user pastes the WC URI into the input field in _this_ web app.
    - The user clicks the "Connect" button.
6.  **Pairing & Session (App Action):**
    - The application uses the `@walletconnect/web3wallet` SDK to initiate pairing with the provided URI.
    - The SDK emits a `session_proposal` event.
    - The application automatically approves the session proposal using the Lens Account's address, enforcing Lens Chain (ID: 232) as the only supported chain regardless of dApp's requested chains.
    - The WalletConnect session is established between this interface (acting for the Lens Account) and the external dApp.
    - The input field clears and the WalletConnect section updates to show:
      - A prominent "Connected" status indicator in green
      - Connected dApp information from the session data:
        - dApp name and icon
        - Website URL
        - Connected chain (should always show Lens Chain)
        - Session ID (for debugging purposes)

### Scenario 3: Handling WalletConnect Transaction Requests

**Goal:** The user receives a transaction request from a connected external dApp and authorizes its execution via their Owner EOA.

**Preconditions:**

- User has successfully completed Scenario 1 & 2.
- An active WalletConnect session exists between the Lens Account interface and an external dApp.

**Steps:**

1.  **Request Initiation (External Action):** The user performs an action on the external dApp that requires a transaction (e.g., depositing collateral on Aave).
2.  **Request Reception (App Action):**
    a. The external dApp sends a request (typically `eth_sendTransaction` containing `to`, `value`, `data`) over the established WC session.
    b. The `@walletconnect/web3wallet` SDK listener in the application receives the `session_request` event.
3.  **Request Display:**
    - The application updates its state to indicate a pending request.
    - A dedicated component (`WcRequestDisplay`) appears on the Dashboard, showing:
      - The requesting dApp's name/icon (from session metadata).
      - The transaction details:
        - **Target Address (`to`):** The contract the Lens Account will call.
        - **Value (`value`):** Amount of native currency (GHO) to send (formatted).
        - **Data (`data`):** The raw calldata for the transaction. (MVP: Display raw hex data. Decoding can be added later).
      - A "Send Transaction" button.
      - A "Reject" button (optional for MVP, but good practice).
4.  **User Review & Action:**
    - The user reviews the displayed transaction details.
    - **(Option A - Send):** The user clicks "Send Transaction".
    - **(App Action - Execute):**
      - The application prepares the call to the Lens Account's `executeTransaction(address target, uint256 value, bytes calldata data)` function, using the parameters from the WC request.
      - It triggers the transaction using `wagmi`.
      - The connected **Owner EOA wallet** (MetaMask, etc.) prompts the user to confirm _this_ transaction (the one calling `executeTransaction` on the Lens Account).
      - **(User Action):** The user confirms the transaction in their EOA wallet.
      - The transaction is sent to the Lens Chain network.
      - The application waits for the transaction hash.
      - Upon receiving the hash, the application sends a _success response_ containing the transaction hash back to the external dApp via the WalletConnect session (`web3wallet.respondSessionRequest`).
      - The `WcRequestDisplay` component is hidden or updated.
      - A success indicator (e.g., checkmark, brief message "Transaction Submitted") is displayed on the dashboard.
    - **(Option B - Reject):** The user clicks "Reject" (if implemented).
    - **(App Action - Reject):**
      - The application sends an _error response_ (e.g., user rejection error) back to the external dApp via the WalletConnect session.
      - The `WcRequestDisplay` component is hidden.

### Scenario 4: Handling Errors during WC Request Execution

**Goal:** Inform the user and the external dApp if an error occurs during the authorization or sending of a WC transaction request.

**Steps (Owner Rejection):**

1.  Follow Scenario 3 up to step 4.c.iii (Owner EOA wallet prompt).
2.  **User Action:** User explicitly rejects the transaction in their wallet.
3.  **(App Action):** The `wagmi` transaction hook/promise rejects with a user rejection error.
4.  The application sends an _error response_ (user rejection) back to the external dApp via WalletConnect.
5.  The `WcRequestDisplay` component is hidden.
6.  An error message is displayed on the dashboard (e.g., "Transaction rejected by user").

**Steps (Blockchain Error):**

1.  Follow Scenario 3 up to step 4.c.v (Transaction sent).
2.  **(Blockchain Action):** The transaction execution _fails_ on the Lens Chain (e.g., reverts).
3.  **(App Action):** The `wagmi` transaction hook/promise resolves with a failed status (or requires checking the receipt).
4.  The application sends an _error response_ (generic execution error) back to the external dApp via WalletConnect.
5.  The `WcRequestDisplay` component is hidden.
6.  An error message is displayed on the dashboard (e.g., "Transaction failed on-chain").

## 5. Non-Functional Requirements (MVP)

- **Target Network:** The application MUST operate exclusively on the Lens Chain Mainnet (ID: 232). Network configuration should reflect this.
- **Responsiveness:** The UI should be usable on standard desktop browsers. Mobile responsiveness is secondary for the MVP.
- **Error Handling:** Basic error messages should be displayed for contract call failures, lookup failures, WC connection issues, and incorrect owner connections.
- **Performance:** Interactions (lookups, balance fetches) should feel reasonably responsive. Debouncing should be used for inputs triggering lookups.

## 6. Out of Scope (MVP - Iteration 1)

- Displaying Transaction History or Queue (beyond the currently active WC request).
- Initiating _new_ transactions (e.g., Send ETH/Token) directly from the UI.
- Managing Lens Account settings (Owners, Threshold).
- Detailed decoding of transaction data within the WC request display.
- Address Book functionality.
- NFT display or management.
- Advanced WalletConnect session management (listing active sessions, manual disconnection).
- Gas controls or advanced transaction parameters.
- Support for multiple Lens Account types or versions beyond the specific one targeted.
- Account Manager roles.
- Push notifications or complex real-time updates beyond basic WC request handling.

## 7. Lens Chain Details

- **Chain Type:** ZkSync-based L2, EVM-compatible
- **Network Name:** Lens Chain Mainnet
- **New RPC URL:** https://rpc.lens.xyz
- **Chain ID:** 232
- **Currency Symbol:** GHO
- **Block Explorer URL:** https://explorer.lens.xyz
</file>

<file path="src/contexts/LensAccountContext.tsx">
// contexts/LensAccountContext.tsx
"use client";

import React, { createContext, useState, useContext, ReactNode } from "react";
import { type Address } from "viem";

interface LensAccountState {
  lensAccountAddress: Address | null;
  ownerAddress: Address | null;
  setVerifiedAccount: (lensAddress: Address, ownerAddress: Address) => void;
  clearAccount: () => void;
}

const LensAccountContext = createContext<LensAccountState | undefined>(undefined);

interface LensAccountProviderProps {
  children: ReactNode;
}

export function LensAccountProvider({ children }: LensAccountProviderProps) {
  const [lensAccountAddress, setLensAccountAddress] = useState<Address | null>(null);
  const [ownerAddress, setOwnerAddress] = useState<Address | null>(null);

  const setVerifiedAccount = (lensAddress: Address, verifiedOwnerAddress: Address) => {
    setLensAccountAddress(lensAddress);
    setOwnerAddress(verifiedOwnerAddress);
    console.log("Context Updated: Lens Account Set ->", lensAddress);
    console.log("Context Updated: Owner Set ->", verifiedOwnerAddress);
  };

  const clearAccount = () => {
    setLensAccountAddress(null);
    setOwnerAddress(null);
    console.log("Context Updated: Account Cleared");
  };

  const value = {
    lensAccountAddress,
    ownerAddress,
    setVerifiedAccount,
    clearAccount,
  };

  return <LensAccountContext.Provider value={value}>{children}</LensAccountContext.Provider>;
}

// Custom hook to use the context
export function useLensAccount() {
  const context = useContext(LensAccountContext);
  if (context === undefined) {
    throw new Error("useLensAccount must be used within a LensAccountProvider");
  }
  return context;
}
</file>

<file path="src/lib/wagmi.ts">
// lib/wagmi.ts
import { http, createConfig } from "wagmi";
import { getDefaultConfig } from "connectkit"; // Correct import
import { lensChain } from "./constants";

const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;

if (!projectId) {
  throw new Error("NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID is not set in .env.local");
}

export const config = createConfig(
  // Use ConnectKit's getDefaultConfig
  getDefaultConfig({
    // Correct function name
    // Required API Keys
    walletConnectProjectId: projectId,

    // Required App Info
    appName: "Lens Account Interface",
    appDescription: "Interact with your Lens Account",
    appUrl: typeof window !== "undefined" ? window.location.origin : "https://example.com",
    appIcon: "/favicon.ico",

    // Chains to support
    chains: [lensChain],

    // Transports (ensure http is configured for your chain)
    transports: {
      [lensChain.id]: http(lensChain.rpcUrls.default.http[0]),
    },

    // ssr: true, // Keep commented unless SSR hydration with cookies is needed
  }),
);

// Optional: Register config for global type inference
// declare module 'wagmi' {
//   interface Register {
//     config: typeof config
//   }
// }
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactStrictMode: false,
};

export default nextConfig;
</file>

<file path="Spec.technical.md">
# Technical Specification: Lens Account Web Interface - MVP (Iteration 1)

**Version:** 1.0
**Date:** 2024-10-27

---

## 1. Introduction

### 1.1. Purpose

This document provides the technical details necessary for the development of the Minimum Viable Product (MVP) of the Lens Account Web Interface. It outlines the technology stack, architecture, key components, APIs, data structures, and implementation details derived from the Functional Specification (`Spec.functional.md`).

### 1.2. Scope

The scope of this MVP is limited to the core scenarios defined in the Functional Specification:

1.  **Account Discovery & Owner Login:** Identifying a Lens Account via username or address, connecting the Owner EOA wallet, and verifying ownership on the Lens Chain.
2.  **Dashboard & WalletConnect Pairing:** Displaying basic Lens Account info (address, balance) and initiating WalletConnect v2 pairings with external dApps.
3.  **WalletConnect Transaction Handling:** Receiving transaction requests from dApps via WalletConnect and facilitating their execution through the Lens Account via the Owner EOA.
4.  **Basic Error Handling:** Managing connection and transaction errors.

Features listed as "Out of Scope" in the Functional Specification are not included in this technical plan.

---

## 2. Technology Stack

- **Framework:** Next.js 15+ (App Router recommended)
- **Language:** TypeScript
- **Core Web3 Libraries:**
  - **Wagmi:** v2.x - For React hooks interacting with Ethereum (account state, contract interaction via Owner EOA, chain state, ENS lookups if adapted).
  - **Viem:** v2.x - Used internally by Wagmi for low-level Ethereum operations (encoding, decoding, RPC calls, utilities). May be used directly for specific utilities if needed.
  - **ConnectKit:** Latest compatible version - For the Owner EOA wallet connection UI and simplifying the `useConnect` flow from Wagmi.
  - **@walletconnect/web3wallet:** Latest v2 compatible version - **Crucially**, this SDK is required for the application to act _as a wallet_ on behalf of the Lens Account when interacting with external dApps via WalletConnect. ConnectKit/Wagmi handle connecting the _Owner EOA_ to _this_ app; `@walletconnect/web3wallet` handles connecting _this_ app (representing the Lens Account) to _other_ dApps.
- **UI/Styling:**
  - **Tailwind CSS:** Recommended for utility-first styling to maintain simplicity and avoid heavy UI library dependencies for the MVP. Basic HTML elements (`input`, `button`, `div`, `p`, etc.) styled with Tailwind will suffice. No complex UI component library is necessary initially.
- **State Management:** React Context API / `useState` / `useReducer` for managing application state (e.g., connected owner, target Lens Account, WC sessions/requests). Avoid Redux/Zustand for MVP complexity unless state becomes unmanageable.
- **Linting/Formatting:** ESLint, Prettier (Standard Next.js setup).

**Note on EthersJS:** While Wagmi v1 used EthersJS, Wagmi v2 (used by ConnectKit) uses **Viem**. EthersJS is **not** expected to be a required dependency for this project based on the chosen stack. We will proceed assuming Viem is the primary low-level library.

---

## 3. Architecture

### 3.1. Overview

The application will be a single-page application (SPA) built with Next.js. The core logic will reside within React components and custom hooks.

- **Client-Side Rendering:** Given the heavy reliance on wallet interactions and real-time state, the application will primarily be client-side rendered. Server components might be used for static layout elements if desired, but core functionality requires client components (`"use client"`).
- **Wallet Connection Management:**
  - **Owner EOA Connection:** Managed by ConnectKit, utilizing Wagmi hooks (`useAccount`, `useConnect`, `useDisconnect`, `useSwitchChain`). State will be accessible via Wagmi's context/hooks.
  - **Lens Account WC Connection (Acting as Wallet):** Managed by a dedicated service/context (`WalletConnectService`) wrapping the `@walletconnect/web3wallet` SDK. This service will handle pairing, session proposals/approvals, request handling, and responses.
- **Contract Interaction:**
  - Reading Lens Account `owner()`: Uses Wagmi's `useReadContract`.
  - Reading `LensGlobalNamespace` (`accountOf`, `usernameOf`): Uses Wagmi's `useReadContract`.
  - Reading WGHO Balance: Uses Wagmi's `useReadContract` (ERC20 `balanceOf`).
  - Executing Lens Account Transactions (via Owner EOA): Uses Wagmi's `useWriteContract` targeting the Lens Account's `executeTransaction`.
- **State Management:** A combination of Wagmi's built-in state, local React component state (`useState`), and potentially 1-2 specific React Contexts (e.g., `WalletConnectContext` for managing WC sessions/requests, `LensAccountContext` for holding the target Lens Account address and owner).

### 3.2. Key Modules/Services

- **Wagmi Config (`lib/wagmi.ts`):** Central configuration for Wagmi/ConnectKit (chains, connectors, transports).
- **WalletConnect Service (`services/walletConnectService.ts`):** Singleton or context-provided class encapsulating `@walletconnect/web3wallet` logic (initialization, pairing, event listeners, session management, request/response handling).
- **Lens Contract Service (`services/lensService.ts`):** Optional utility functions abstracting the direct `useReadContract` calls for Lens Account `owner()`, `LensGlobalNamespace` lookups, and WGHO balance.

---

## 4. Project Structure (App Router Example)

```
src/
├── app/
│   ├── dashboard/             # Dashboard page (requires auth)
│   │   └── page.tsx
│   ├── layout.tsx             # Root layout (WagmiProvider, etc.)
│   └── page.tsx               # Root page (Login/Discovery View)
├── components/
│   ├── layout/                # Header, Footer, etc.
│   ├── ui/                    # Basic UI elements (Button, Input - if abstracting)
│   ├── AccountDisplay.tsx     # Shows Lens Account Address/Balance
│   ├── ConnectOwnerButton.tsx # Uses ConnectKit button/logic
│   ├── DiscoveryForm.tsx      # Username/Address input fields
│   ├── WcConnect.tsx          # WC URI input and connection status
│   └── WcRequestDisplay.tsx   # Displays incoming WC requests
├── contexts/
│   ├── WalletConnectProvider.tsx # Manages WC state/service
│   └── LensAccountProvider.tsx   # Manages target Lens Account state
├── hooks/
│   ├── useLensLookup.ts       # Custom hook for username/address lookups
│   └── useWcRequestHandler.ts # Custom hook for handling WC requests
├── services/
│   ├── walletConnectService.ts # Wrapper around @walletconnect/web3wallet
│   └── lensService.ts          # (Optional) Utilities for Lens contract reads
├── lib/
│   ├── wagmi.ts               # Wagmi/ConnectKit config
│   ├── constants.ts           # Chain info, contract addresses, ABIs
│   └── utils.ts               # Helper functions
├── public/
│   └── ...                    # Static assets
├── styles/
│   └── globals.css            # Tailwind directives
├── .env.local                 # Environment variables (WC Project ID)
├── next.config.mjs
├── package.json
├── tailwind.config.ts
└── tsconfig.json
```

---

## 5. Core Components & Logic Implementation

### 5.1. Scenario 1: Account Discovery and Owner Login (`/app/page.tsx`, `DiscoveryForm.tsx`, `ConnectOwnerButton.tsx`)

- **UI:** `DiscoveryForm.tsx` contains two `<input>` fields styled with Tailwind. `ConnectOwnerButton.tsx` wraps ConnectKit's logic.
- **State:** Local state (`useState`) in `DiscoveryForm.tsx` for input values. A shared state (Context or prop drilling from `page.tsx`) for the determined Lens Account address and expected owner address.
- **Logic (`useLensLookup.ts`, `DiscoveryForm.tsx`):**
  - Use `React.useEffect` with debouncing for input changes.
  - Inside `useEffect`, call `useReadContract` (Wagmi) targeting `LensGlobalNamespace` (`accountOf` or `usernameOf`). **Important:** Need to configure `useReadContract` specifically for Lens Chain (ID 232). Pass the `chainId` parameter.
  - Update the corresponding input field based on lookup results.
  - Once an address is confirmed, call `useReadContract` targeting the Lens Account address for the `owner()` function. Store the result as `expectedOwner`.
  - Display `expectedOwner` near the connect button.
- **Owner Connection (`ConnectOwnerButton.tsx`, `page.tsx`):**
  - Use `ConnectKitButton` component or `useConnect` (Wagmi) + `useAccount` (Wagmi). ConnectKit is simpler.
  - The `wagmi.ts` config must include the Lens Chain definition. ConnectKit/Wagmi will handle prompting the user to add/switch to the Lens Chain.
  - After connection, use `useAccount` hook (Wagmi) to get the `address` and `chainId`.
  - Compare `address` with `expectedOwner`.
  - If match and `chainId === 232`, navigate to `/dashboard` (e.g., using `next/navigation`'s `useRouter`). Store the Lens Account address and Owner EOA address in Context/State for the dashboard.
  - If mismatch, display an error message.

### 5.2. Scenario 2: Viewing Dashboard & Initiating WalletConnect Pairing (`/app/dashboard/page.tsx`, `AccountDisplay.tsx`, `WcConnect.tsx`, `WalletConnectProvider.tsx`, `services/walletConnectService.ts`)

- **UI:** `AccountDisplay.tsx` shows Lens address (from Context/State) and balance. `WcConnect.tsx` shows WC URI input/button initially, then connected dApp info.
- **State:** `WalletConnectContext` manages `Web3Wallet` instance, active sessions, and pairing state.
- **Logic:**
  - Fetch WGHO balance using `useReadContract` (Wagmi) targeting the ERC20 contract with the Lens Account address. Format using Viem's `formatUnits`.
  - In `WalletConnectProvider.tsx` (or on component mount):
    - Initialize `Web3Wallet` from `@walletconnect/web3wallet` using `projectId` from `.env.local`. Store the instance.
    - Set up listeners (`web3wallet.on('session_proposal', ...)` etc.) defined in `walletConnectService.ts`.
  - **Pairing (`WcConnect.tsx`, `walletConnectService.ts`):**
    - On "Connect" button click with URI: Call `web3wallet.core.pairing.pair({ uri })`.
  - **Session Approval (`walletConnectService.ts` listener):**
    - On `session_proposal` event:
      - Construct approved `namespaces` containing **only** the Lens Chain (`eip155:232`) and the Lens Account address (`eip155:232:0x...`). Include standard methods (`eth_sendTransaction`, `personal_sign`, etc.).
      - Call `web3wallet.approveSession({ id: proposal.id, namespaces })`.
      - Store the resulting session details in the `WalletConnectContext`.
      - Update UI state in `WcConnect.tsx` to show connected dApp info.

### 5.3. Scenario 3 & 4: Handling WalletConnect Transaction Requests (`/app/dashboard/page.tsx`, `WcRequestDisplay.tsx`, `useWcRequestHandler.ts`, `services/walletConnectService.ts`)

- **UI:** `WcRequestDisplay.tsx` conditionally renders when a request is pending in `WalletConnectContext`. Displays request details and Approve/Reject buttons.
- **State:** `WalletConnectContext` stores the current pending `session_request` event payload.
- **Logic:**
  - **Request Listener (`walletConnectService.ts`):**
    - On `session_request` event: Store the event payload (`topic`, `params`, `id`) in `WalletConnectContext` state.
  - **Transaction Execution (`WcRequestDisplay.tsx`, `useWcRequestHandler.ts`):**
    - On "Send Transaction" click:
      - Retrieve request details (`to`, `value`, `data`) from the context state.
      - Use Viem's `encodeFunctionData` to prepare the calldata for the Lens Account's `executeTransaction(address target, uint256 value, bytes calldata data)` function.
      - Call the `writeContract` mutation function returned by `useWriteContract` (Wagmi), providing:
        - `address`: The Lens Account address (from Context/State).
        - `abi`: The Lens Account ABI (including `executeTransaction`).
        - `functionName`: `'executeTransaction'`.
        - `args`: `[to, value, data]`.
        - `account`: The connected Owner EOA address (from `useAccount`).
        - `chainId`: Must be Lens Chain ID (232).
      - Handle `useWriteContract`'s `isPending`, `isSuccess`, `error` states.
      - If `isPending`, show loading state.
      - If `error`, call `web3wallet.respondSessionRequest` with an appropriate error payload (e.g., `{ code: 5000, message: 'User Rejected' }` or a generic error). Display error in UI. Clear the pending request state.
      - If `isSuccess` (meaning the _Owner EOA_ transaction was submitted), wait for the transaction receipt using `useWaitForTransactionReceipt` (Wagmi).
        - If the receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`. Display success in UI. Clear the pending request state.
        - If the receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a generic execution error payload. Display error in UI. Clear the pending request state.
    - On "Reject" button click:
      - Call `web3wallet.respondSessionRequest` with a user rejection error payload.
      - Clear the pending request state.

---

## 6. State Management

- **Wagmi:** Manages Owner EOA connection state (address, chainId, connector, connection status) and provides TanStack Query caching for reads.
- **LensAccountContext:** Stores the identified Lens Account address and the verified Owner EOA address upon successful login.
- **WalletConnectContext:** Stores the `@walletconnect/web3wallet` instance, active WC sessions (list/map), current pending WC request payload, and connection/pairing status flags.
- **Local Component State:** Used for form inputs, UI loading/error states within specific components.

---

## 7. Styling

- Utilize **Tailwind CSS** for styling all components.
- Keep styling minimal and functional for the MVP.
- Ensure basic layout structure (header, main content area).

---

## 8. Error Handling

- Implement `try...catch` blocks around critical operations (WC pairing, session approval, request responses).
- Utilize the `error` states returned by Wagmi hooks (`useReadContract`, `useWriteContract`, `useWaitForTransactionReceipt`).
- Display user-friendly error messages for common issues (network mismatch, incorrect owner, transaction rejection, WC errors, contract reverts). Log detailed errors to the console for debugging.
- Specifically handle WalletConnect SDK errors during pairing and session proposals.

---

## 9. Constants & Configuration

- **`lib/constants.ts`:**
  - `LENS_CHAIN_ID = 232`
  - `LENS_CHAIN_RPC_URL = 'https://rpc.lens.xyz'`
  - `LENS_CHAIN_EXPLORER_URL = 'https://explorer.lens.xyz'`
  - `LENS_CHAIN_CURRENCY = { name: 'GHO', symbol: 'GHO', decimals: 18 }`
  - `LENS_GLOBAL_NAMESPACE_ADDRESS = '0x1aA55B9042f08f45825dC4b651B64c9F98Af4615'`
  - `WGHO_TOKEN_ADDRESS = '0x6bDc36E20D267Ff0dd6097799f82e78907105e2F'` (Actual Address Needed)
  - `LENS_ACCOUNT_ABI = [...]` (Include `owner()`, `executeTransaction()`)
  - `LENS_GLOBAL_NAMESPACE_ABI = [...]` (Include `accountOf(string)`, `usernameOf(address)`)
  - `ERC20_ABI = [...]` (Include `balanceOf(address)`)
- **`lib/wagmi.ts`:**
  - Define the `lensChain` object using Viem's `defineChain`.
  - Configure `createConfig` (Wagmi) with `chains: [lensChain]`, necessary connectors (e.g., `injected`, `walletConnect`), and transports.
- **`.env.local`:**
  - `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID=<Your_WC_Project_ID>` (Obtain from [cloud.walletconnect.com](https://cloud.walletconnect.com/))

---

## 10. Deployment

- Standard Next.js deployment process (e.g., Vercel, Netlify).
- Ensure environment variables (like `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`) are configured in the deployment environment.

---

## 11. Future Considerations (Post-MVP)

- Support for multiple Lens Account types/versions.
- Transaction history display.
- Direct sending of GHO/WGHO from the UI.
- More detailed transaction decoding for WC requests.
- Advanced error handling and user feedback.
- Mobile responsiveness improvements.
- Session management UI (disconnecting specific WC sessions).
- Support for additional WC methods (e.g., `personal_sign`).
- Potential integration of Safe SDKs if the Lens Account implements Safe compatibility layers.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/dashboard/layout.tsx">
// src/app/dashboard/layout.tsx
"use client"; // Context providers require client components

import { WalletConnectProvider } from "@/contexts/WalletConnectProvider";
// No need to import useLensAccount here if it's not used directly in this layout

// This layout wraps the content of `/dashboard/page.tsx` and any other
// potential pages under the /dashboard route (e.g., /dashboard/settings).

// Add the default export
export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  // We assume LensAccountProvider is already wrapping the RootLayout
  // in src/app/layout.tsx via src/app/providers.tsx.
  // Therefore, we only need to add the WalletConnectProvider here.
  return <WalletConnectProvider>{children}</WalletConnectProvider>;
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import "@/styles/globals.css";
import { Geist, Geist_Mono } from "next/font/google";
import { Providers } from "./providers"; // Import the Providers component

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Lens Account Interface", // Updated title
  description: "Manage your Lens Account", // Updated description
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // If using SSR hydration, you would get initialState here from headers/cookies
  // const initialState = cookieToInitialState(...) etc.

  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} min-h-screen`}>
        {/* Wrap children with Providers */}
        <Providers /*initialState={initialState}*/>{children}</Providers>
      </body>
    </html>
  );
}
</file>

<file path="src/components/AccountDisplay.tsx">
// components/AccountDisplay.tsx
"use client";

import React from "react";
import { useReadContract, useBalance } from "wagmi"; // Import useBalance
import { formatUnits, type BaseError, type Address } from "viem";
import { useLensAccount } from "@/contexts/LensAccountContext";
import {
  ERC20_ABI,
  WGHO_TOKEN_ADDRESS,
  LENS_CHAIN_ID,
  lensChain, // Import the chain definition
} from "@/lib/constants";

export function AccountDisplay() {
  const { lensAccountAddress } = useLensAccount();

  // Fetch native GHO balance
  const {
    data: nativeBalanceData,
    error: nativeBalanceError,
    isLoading: isLoadingNativeBalance,
  } = useBalance({
    address: lensAccountAddress as Address | undefined, // useBalance needs Address | undefined
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: !!lensAccountAddress,
      // Enable watching for updates (refetches on new blocks)
      refetchInterval: 5000, // Optional: Adjust polling interval if needed
      refetchOnWindowFocus: true,
    },
  });

  // Fetch WGHO (ERC20) balance
  const {
    data: wghoBalanceData,
    error: wghoBalanceError,
    isLoading: isLoadingWghoBalance,
  } = useReadContract({
    address: WGHO_TOKEN_ADDRESS as Address, // Add type assertion if needed or ensure it's typed correctly in constants
    abi: ERC20_ABI,
    functionName: "balanceOf",
    args: [lensAccountAddress!],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: !!lensAccountAddress,
      // Enable watching for updates (refetches on new blocks)
      refetchInterval: 5000, // Optional: Adjust polling interval if needed
      refetchOnWindowFocus: true,
    },
  });

  // Format balances safely
  const formattedNativeBalance =
    nativeBalanceData?.value !== undefined
      ? parseFloat(formatUnits(nativeBalanceData.value, lensChain.nativeCurrency.decimals)).toFixed(4)
      : "0.0000";

  const formattedWghoBalance =
    typeof wghoBalanceData === "bigint"
      ? parseFloat(formatUnits(wghoBalanceData, 18)).toFixed(4) // Assuming WGHO also has 18 decimals
      : "0.0000";

  const isLoading = isLoadingNativeBalance || isLoadingWghoBalance;

  return (
    <div className="p-4 border rounded-md bg-gray-50">
      <h2 className="text-lg font-semibold mb-3 text-gray-700">Account Balances</h2>
      {isLoading && <p className="text-gray-500 text-sm">Loading balances...</p>}

      {/* Native GHO Balance */}
      <div className="mb-2">
        {nativeBalanceError && !isLoadingNativeBalance && (
          <p className="text-red-600 text-sm">
            Error loading GHO balance: {(nativeBalanceError as BaseError).shortMessage || nativeBalanceError.message}
          </p>
        )}
        {!nativeBalanceError && !isLoadingNativeBalance && lensAccountAddress && (
          <p className="text-gray-800">
            <span className="font-medium">Native GHO:</span> <span className="font-mono text-lg">{formattedNativeBalance}</span>{" "}
            {lensChain.nativeCurrency.symbol}
          </p>
        )}
      </div>

      {/* WGHO Balance */}
      <div>
        {wghoBalanceError && !isLoadingWghoBalance && (
          <p className="text-red-600 text-sm">
            Error loading WGHO balance: {(wghoBalanceError as BaseError).shortMessage || wghoBalanceError.message}
          </p>
        )}
        {!wghoBalanceError && !isLoadingWghoBalance && lensAccountAddress && (
          <p className="text-gray-800">
            <span className="font-medium">WGHO Token:</span> <span className="font-mono text-lg">{formattedWghoBalance}</span> GHO
          </p>
        )}
      </div>

      {!lensAccountAddress && !isLoading && <p className="text-gray-500 text-sm mt-2">Cannot fetch balances without Lens Account address.</p>}
    </div>
  );
}
</file>

<file path="src/components/WcRequestDisplay.tsx">
// src/components/WcRequestDisplay.tsx
"use client";

import React, { useState, useEffect, useCallback, useRef } from "react";
import { useWalletConnect } from "@/contexts/WalletConnectProvider";
import { useLensAccount } from "@/contexts/LensAccountContext";
import { useAccount, useWriteContract, useWaitForTransactionReceipt } from "wagmi";
import { formatUnits, type Hash } from "viem";
import { getSdkError } from "@walletconnect/utils";
import { formatJsonRpcError, formatJsonRpcResult, JsonRpcResponse } from "@walletconnect/jsonrpc-utils";
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID, lensChain } from "@/lib/constants";

// Basic Fallback Icon Component
const FallbackIcon = ({ size = 30 }: { size?: number }) => (
  <div
    style={{ width: `${size}px`, height: `${size}px` }}
    className="rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs"
  >
    ?
  </div>
);

export function WcRequestDisplay() {
  const { pendingRequest, respondRequest, error: wcError, isLoading: isWcLoading } = useWalletConnect();
  const { lensAccountAddress } = useLensAccount();
  const { address: ownerAddress, chainId: ownerChainId } = useAccount();

  // State related to the write *initiation*
  const { data: hash, error: writeError, isPending: isWritePending, writeContractAsync, reset: resetWriteContract } = useWriteContract();
  // State related to the *confirmation* of the hash from write initiation
  const {
    isLoading: isConfirming,
    isSuccess: isConfirmed,
    error: receiptError,
    data: receipt,
  } = useWaitForTransactionReceipt({ hash, chainId: LENS_CHAIN_ID });

  const [localError, setLocalError] = useState<string | null>(null);
  const [localLoadingMessage, setLocalLoadingMessage] = useState<string | null>(null);
  // Store the ID of the request currently being actively processed
  const processingRequestId = useRef<number | null>(null);
  // Store the hash associated with the *currently processed* request ID
  const processingRequestHash = useRef<Hash | null>(null);

  // --- Log Component Render ---
  console.log(
    `%cWcRequestDisplay Render: pendingReqId=${pendingRequest?.id ?? "null"}, currentProcessingId=${processingRequestId.current}, currentProcessingHash=${processingRequestHash.current ?? "null"}, hookHash=${hash ?? "null"}, isWritePending=${isWritePending}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, writeError=${!!writeError}, receiptError=${!!receiptError}`,
    "color: magenta",
  );
  // --------------------------

  // --- Effect to Reset State When a NEW Request Arrives ---
  useEffect(() => {
    const incomingRequestId = pendingRequest?.id ?? null;
    const currentProcessing = processingRequestId.current;

    console.log(
      `%cWcRequestDisplay ResetEffect: Running. Incoming ID: ${incomingRequestId}, Current Processing ID: ${currentProcessing}`,
      "color: teal",
    );

    if (incomingRequestId !== null) {
      if (currentProcessing !== incomingRequestId) {
        console.log(`%cWcRequestDisplay ResetEffect: New request ${incomingRequestId} detected. Resetting state.`, "color: teal");
        resetWriteContract();
        setLocalError(null);
        setLocalLoadingMessage(null);
        processingRequestId.current = incomingRequestId;
        processingRequestHash.current = null; // Reset hash ref
      } else {
        console.log(
          `%cWcRequestDisplay ResetEffect: Incoming ID ${incomingRequestId} matches current Processing ID. No reset needed.`,
          "color: teal",
        );
      }
    } else {
      if (currentProcessing !== null) {
        console.log(`%cWcRequestDisplay ResetEffect: No pending request. Resetting state.`, "color: teal");
        resetWriteContract();
        setLocalError(null);
        setLocalLoadingMessage(null);
        processingRequestId.current = null;
        processingRequestHash.current = null; // Reset hash ref
      } else {
        console.log(`%cWcRequestDisplay ResetEffect: No pending request and nothing processing. No reset needed.`, "color: teal");
      }
    }
  }, [pendingRequest, resetWriteContract]); // Now depends on pendingRequest object itself

  // --- Effect to track the hash associated with the current request ---
  useEffect(() => {
    if (hash && processingRequestId.current && !processingRequestHash.current) {
      console.log(`%cWcRequestDisplay HashTrackEffect: Associating hash ${hash} with request ID ${processingRequestId.current}`, "color: purple");
      processingRequestHash.current = hash; // Store the hash for the request we are processing
    }
  }, [hash, processingRequestId]); // Run when hash changes and we have a processing ID

  // --- Centralized Respond Function ---
  const handleRespond = useCallback(
    (response: JsonRpcResponse) => {
      const currentId = processingRequestId.current;
      if (currentId !== null && currentId === response.id) {
        console.log(`%cWcRequestDisplay handleRespond: Responding for request ID: ${response.id}`, "color: darkmagenta", response);
        respondRequest(response);
        // Reset processing state *after* responding
        processingRequestId.current = null;
        processingRequestHash.current = null; // Reset hash ref
        setLocalLoadingMessage(null);
        resetWriteContract(); // Try resetting here too
      } else {
        console.warn(
          `%cWcRequestDisplay handleRespond: Ignoring response attempt for stale/mismatched request ID: ${response.id} (Current Processing: ${currentId})`,
          "color: orange",
        );
      }
    },
    [respondRequest, resetWriteContract],
  ); // Add resetWriteContract

  // --- Effect to Handle Transaction Submission Result ---
  useEffect(() => {
    const currentProcessingId = processingRequestId.current;
    const currentReqHash = processingRequestHash.current; // Use the hash we stored for this request

    console.log(
      `%cWcRequestDisplay ReceiptEffect: Running. CurrentProcessingId=${currentProcessingId}, CurrentReqHash=${currentReqHash ?? "null"}, HookHash=${hash ?? "null"}, isConfirming=${isConfirming}, isConfirmed=${isConfirmed}, receiptHash=${receipt?.transactionHash ?? "null"}, receiptError=${!!receiptError}`,
      "color: #2ECC71",
    );

    // Guards:
    // 1. Must be processing a request.
    // 2. Must have a specific hash associated with *this* request attempt.
    // 3. The confirmation process must be finished (or errored).
    // 4. The hook's current hash must match the hash associated with our request.
    if (!currentProcessingId || !currentReqHash || isConfirming || hash !== currentReqHash) {
      console.log(
        `%cWcRequestDisplay ReceiptEffect: Bailing out (ProcessingID: ${currentProcessingId}, CurrentReqHash: ${currentReqHash}, HookHash: ${hash}, Confirming: ${isConfirming})`,
        "color: gray",
      );
      return;
    }

    // Now check receipt and errors, ensuring they match the currentReqHash
    if (receipt && receipt.transactionHash === currentReqHash) {
      console.log(`%cWcRequestDisplay ReceiptEffect: Receipt received for current hash ${currentReqHash}`, "color: #2ECC71");
      setLocalLoadingMessage(null);
      if (receipt.status === "success") {
        console.log(
          `%cWcRequestDisplay ReceiptEffect: Transaction successful, calling handleRespond for ID ${currentProcessingId}`,
          "color: #2ECC71",
        );
        handleRespond(formatJsonRpcResult(currentProcessingId, receipt.transactionHash));
      } else {
        console.error(
          `%cWcRequestDisplay ReceiptEffect: Transaction reverted, calling handleRespond for ID ${currentProcessingId}`,
          "color: red",
          receipt,
        );
        setLocalError("Transaction reverted on chain.");
        handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction reverted" }));
      }
    } else if (receiptError) {
      console.error(
        `%cWcRequestDisplay ReceiptEffect: Transaction Receipt Error for hash ${currentReqHash}, calling handleRespond for ID ${currentProcessingId}`,
        "color: red",
        receiptError,
      );
      setLocalError(`Transaction failed: ${receiptError.message}`);
      handleRespond(formatJsonRpcError(currentProcessingId, { code: -32000, message: "Transaction Failed on chain" }));
    } else if (isConfirmed && !receipt) {
      console.warn(
        `%cWcRequestDisplay ReceiptEffect: isConfirmed is true but receipt is still null/undefined for hash ${currentReqHash}. Waiting.`,
        "color: orange",
      );
    } else {
      console.log(`%cWcRequestDisplay ReceiptEffect: No definitive action taken for hash ${currentReqHash}`, "color: gray");
    }
  }, [isConfirming, isConfirmed, receiptError, receipt, hash, handleRespond]); // Keep dependencies

  // --- Effect to Handle Direct Write Errors ---
  useEffect(() => {
    const currentProcessingId = processingRequestId.current;
    console.log(`%cWcRequestDisplay WriteErrorEffect: Running. writeError=${!!writeError}, currentProcessingId=${currentProcessingId}`, "color: red");
    if (writeError && currentProcessingId) {
      console.error("WcRequestDisplay WriteErrorEffect: Write Contract Error detected:", writeError);
      setLocalError(`Transaction rejected or failed to send: ${writeError.message}`);
      handleRespond(formatJsonRpcError(currentProcessingId, getSdkError("USER_REJECTED")));
    }
  }, [writeError, handleRespond]);

  const handleApprove = async () => {
    if (!pendingRequest) return setLocalError("No request to approve.");
    if (!lensAccountAddress) return setLocalError("Lens Account address missing.");
    if (!ownerAddress) return setLocalError("Owner wallet not connected.");
    if (!writeContractAsync) return setLocalError("Transaction function not ready.");
    if (ownerChainId !== LENS_CHAIN_ID) return setLocalError("Owner wallet not on Lens Chain.");

    // Reset local state AND ensure we reset wagmi state *before* initiating write
    console.log(`%cWcRequestDisplay handleApprove: Resetting state before write for request ID: ${pendingRequest.id}`, "color: blueviolet");
    resetWriteContract(); // Reset here as well
    processingRequestId.current = pendingRequest.id; // Mark immediately
    processingRequestHash.current = null; // Clear previous hash
    setLocalError(null);
    setLocalLoadingMessage("Please confirm in your wallet...");

    const { method, params } = pendingRequest.params.request;
    if (method !== "eth_sendTransaction") {
      const errorMsg = `Unsupported method: ${method}`;
      setLocalError(errorMsg);
      handleRespond(formatJsonRpcError(pendingRequest.id, { code: 4200, message: "Method not supported" }));
      return;
    }

    const tx = params[0] as { to?: `0x${string}`; value?: string; data?: `0x${string}` };
    const targetAddress = tx.to;
    const value = tx.value ? BigInt(tx.value) : 0n;
    const data = tx.data || "0x";

    if (!targetAddress) {
      const errorMsg = "Transaction 'to' address is missing.";
      setLocalError(errorMsg);
      handleRespond(formatJsonRpcError(pendingRequest.id, { code: -32602, message: "Invalid parameters: missing 'to' address" }));
      return;
    }

    try {
      console.log("%cWcRequestDisplay handleApprove: Calling writeContractAsync...", "color: blueviolet");
      // Call async, the hash state update will trigger the HashTrackEffect
      await writeContractAsync({
        address: lensAccountAddress,
        abi: LENS_ACCOUNT_ABI,
        functionName: "executeTransaction",
        args: [targetAddress, value, data],
        account: ownerAddress,
        chainId: LENS_CHAIN_ID,
      });
      console.log("%cWcRequestDisplay handleApprove: writeContractAsync call submitted.", "color: blueviolet");
    } catch (error) {
      console.error("WcRequestDisplay handleApprove: Error calling writeContractAsync:", error);
      if (!writeError && processingRequestId.current) {
        // Check current ID before responding
        const errorMsg = `Failed to initiate transaction: ${(error as Error).message}`;
        setLocalError(errorMsg);
        handleRespond(formatJsonRpcError(processingRequestId.current, getSdkError("USER_REJECTED")));
      }
    }
  };

  const handleReject = () => {
    if (!pendingRequest) return;
    processingRequestId.current = pendingRequest.id; // Mark which request we are rejecting
    setLocalError(null);
    setLocalLoadingMessage(null);
    console.log("WcRequestDisplay handleReject: Rejecting request:", pendingRequest.id);
    handleRespond(formatJsonRpcError(pendingRequest.id, getSdkError("USER_REJECTED")));
  };

  // --- Render Logic ---
  if (!pendingRequest) {
    return (
      <div className="p-4 border rounded-md bg-gray-50">
        <p className="text-gray-600 text-center italic">No pending WalletConnect requests.</p>
      </div>
    );
  }

  // Extract request details safely
  const { request, chainId } = pendingRequest.params;
  const txDetails = request.params?.[0] as { to?: string; value?: string; data?: string } | undefined;
  const dAppName = pendingRequest.verifyContext?.verified.origin || "Unknown dApp";
  const dAppUrl = pendingRequest.verifyContext?.verified.origin;
  const formattedValue = txDetails?.value
    ? `${formatUnits(BigInt(txDetails.value), lensChain.nativeCurrency.decimals)} ${lensChain.nativeCurrency.symbol}`
    : `0 ${lensChain.nativeCurrency.symbol}`;
  const isLoading = isWritePending || isConfirming || isWcLoading;

  return (
    <div className="p-4 border-2 border-blue-300 rounded-md bg-blue-50 shadow-md space-y-4">
      <h3 className="text-md font-semibold text-blue-800">WalletConnect Request</h3>
      <div className="flex items-center space-x-3 mb-3 pb-3 border-b border-blue-200">
        <FallbackIcon size={30} />
        <div>
          <p className="text-sm font-medium text-gray-800">{dAppName}</p>
          {dAppUrl && <p className="text-xs text-gray-500">{dAppUrl}</p>}
        </div>
      </div>

      <div className="space-y-2 text-sm">
        <p>
          <strong className="text-gray-600">Method:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{request.method}</span>
        </p>
        <p>
          <strong className="text-gray-600">Chain:</strong> <span className="font-mono bg-gray-100 px-1 rounded">{chainId}</span>
        </p>
        <p>
          <strong className="text-gray-600">Target (to):</strong> <span className="font-mono text-xs break-all">{txDetails?.to ?? "N/A"}</span>
        </p>
        <p>
          <strong className="text-gray-600">Value:</strong> <span className="font-mono">{formattedValue}</span>
        </p>
        <div>
          <strong className="text-gray-600">Data:</strong>
          <textarea
            readOnly
            value={txDetails?.data ?? "0x"}
            className="mt-1 w-full h-20 p-1 border border-gray-300 rounded text-xs font-mono bg-gray-50"
          />
        </div>
      </div>

      {/* Status Display */}
      {localLoadingMessage && <p className="text-sm text-center text-indigo-600 animate-pulse">{localLoadingMessage}</p>}
      {localError && <p className="text-sm text-center text-red-600">{localError}</p>}
      {wcError && !localError && <p className="text-sm text-center text-red-600">WC Error: {wcError}</p>}

      {/* Action Buttons */}
      <div className="flex space-x-3 pt-2">
        <button
          onClick={handleApprove}
          disabled={isLoading}
          className="flex-1 px-4 py-2 bg-green-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
        >
          {isWritePending ? "Check Wallet..." : isConfirming ? "Confirming..." : "Approve & Send"}
        </button>
        <button
          onClick={handleReject}
          disabled={isLoading}
          className="flex-1 px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-md shadow-sm hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
        >
          Reject
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/app/providers.tsx">
// src/app/providers.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import { ConnectKitProvider } from "connectkit";
import { config } from "@/lib/wagmi";
import React, { useState } from "react";
import { LensAccountProvider } from "@/contexts/LensAccountContext";

type Props = {
  children: React.ReactNode;
};

export function Providers({ children }: Props) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <ConnectKitProvider>
          {/* Wrap with LensAccountProvider */}
          <LensAccountProvider>
            {/* Wrap with WalletConnectProvider */}
            {children}
          </LensAccountProvider>
        </ConnectKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
</file>

<file path="src/lib/constants.ts">
// lib/constants.ts
import { defineChain, parseAbi } from "viem";

export const LENS_CHAIN_ID = 232;

export const lensChain = defineChain({
  id: LENS_CHAIN_ID,
  name: "Lens Chain",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"],
    },
  },
  blockExplorers: {
    default: { name: "Lens Explorer", url: "https://explorer.lens.xyz" },
  },
  testnet: false,
});

// --- Contract Addresses ---
export const LENS_GLOBAL_NAMESPACE_ADDRESS = "0x1aA55B9042f08f45825dC4b651B64c9F98Af4615";

// --- ABIs ---
export const LENS_GLOBAL_NAMESPACE_ABI = parseAbi([
  "function accountOf(string calldata name) view returns (address)",
  "function usernameOf(address user) view returns (string)",
  "error DoesNotExist()",
]);

// Added owner() function
export const LENS_ACCOUNT_ABI = parseAbi([
  "function owner() view returns (address)",
  "function executeTransaction(address target, uint256 value, bytes calldata data)",
]);

export const WGHO_TOKEN_ADDRESS = "0x6bDc36E20D267Ff0dd6097799f82e78907105e2F";
export const ERC20_ABI = parseAbi(["function balanceOf(address owner) view returns (uint256)"]);
</file>

<file path="src/components/DiscoveryForm.tsx">
// components/DiscoveryForm.tsx
"use client";

import React, { useState, useEffect } from "react";
import { useReadContract } from "wagmi";
import { isAddress } from "viem";
import { useDebounce } from "@/hooks/useDebounce";
import { LENS_CHAIN_ID, LENS_GLOBAL_NAMESPACE_ADDRESS, LENS_GLOBAL_NAMESPACE_ABI } from "@/lib/constants";

// Import icons from Heroicons
import { CheckCircleIcon, ExclamationTriangleIcon, ArrowPathIcon } from "@heroicons/react/24/solid";

interface DiscoveryFormProps {
  // Allow empty string or null when no valid address is found
  onAccountAddressFound: (address: `0x${string}` | "") => void; // Changed type
  initialUsername?: string;
  initialAddress?: string;
}

// Add a StatusMessage component for consistent styling
function StatusMessage({ type, message }: { type: "loading" | "error" | "success"; message: string }) {
  return (
    <div
      className={`flex items-center justify-center gap-2 text-sm font-medium ${
        type === "loading" ? "text-indigo-600" : type === "error" ? "text-red-600" : "text-green-600"
      }`}
    >
      {type === "loading" && <ArrowPathIcon className="w-4 h-4 animate-spin" />}
      {type === "error" && <ExclamationTriangleIcon className="w-4 h-4" />}
      {type === "success" && <CheckCircleIcon className="w-4 h-4" />}
      <span>{message}</span>
    </div>
  );
}

export function DiscoveryForm({ onAccountAddressFound, initialUsername = "", initialAddress = "" }: DiscoveryFormProps) {
  const [username, setUsername] = useState(initialUsername);
  const [address, setAddress] = useState(initialAddress);
  const [lookupError, setLookupError] = useState<string | null>(null);

  const [lastEdited, setLastEdited] = useState<"username" | "address" | null>(initialUsername ? "username" : initialAddress ? "address" : null);

  const debouncedUsername = useDebounce(username, 500);
  const debouncedAddress = useDebounce(address, 500);

  const {
    data: addressFromUsername,
    isLoading: isLoadingAddress,
    error: addressError,
    refetch: refetchAddress,
  } = useReadContract({
    address: LENS_GLOBAL_NAMESPACE_ADDRESS,
    abi: LENS_GLOBAL_NAMESPACE_ABI,
    functionName: "accountOf",
    args: [debouncedUsername || ""],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: false,
    },
  });

  const {
    data: usernameFromAddress,
    isLoading: isLoadingUsername,
    error: usernameError,
    refetch: refetchUsername,
  } = useReadContract({
    address: LENS_GLOBAL_NAMESPACE_ADDRESS,
    abi: LENS_GLOBAL_NAMESPACE_ABI,
    functionName: "usernameOf",
    args: [debouncedAddress as `0x${string}`],
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: false,
    },
  });

  useEffect(() => {
    if (debouncedUsername && lastEdited === "username") {
      setLookupError(null);
      console.log(`Looking up address for username: ${debouncedUsername}`);
      refetchAddress();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedUsername, lastEdited]);

  useEffect(() => {
    if (debouncedAddress && isAddress(debouncedAddress) && lastEdited === "address") {
      setLookupError(null);
      console.log(`Looking up username for address: ${debouncedAddress}`);
      refetchUsername();
    } else if (debouncedAddress && !isAddress(debouncedAddress) && lastEdited === "address") {
      setLookupError("Invalid address format");
      onAccountAddressFound(""); // Use empty string
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedAddress, lastEdited]);

  useEffect(() => {
    if (addressFromUsername && isAddress(addressFromUsername) && lastEdited === "username") {
      if (addressFromUsername === "0x0000000000000000000000000000000000000000") {
        setLookupError(`No account found for username "${debouncedUsername}"`);
        setAddress("");
        onAccountAddressFound(""); // Use empty string
      } else {
        console.log(`Found address: ${addressFromUsername}`);
        setAddress(addressFromUsername);
        onAccountAddressFound(addressFromUsername);
        setLookupError(null);
      }
    } else if (addressError && lastEdited === "username") {
      console.error("Error fetching address:", addressError);
      // Check if it's a DoesNotExist error
      if (addressError.message.includes("0xb0ce7591") || addressError.message.includes("DoesNotExist")) {
        setLookupError(`Username "${debouncedUsername}" does not exist`);
      } else {
        setLookupError("Error fetching address. Please try again.");
      }
      onAccountAddressFound(""); // Use empty string
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [addressFromUsername, addressError, lastEdited]);

  useEffect(() => {
    if (usernameFromAddress && lastEdited === "address") {
      console.log(`Found username: ${usernameFromAddress}`);
      setUsername(usernameFromAddress);
      if (isAddress(debouncedAddress)) {
        // Ensure address is still valid
        onAccountAddressFound(debouncedAddress as `0x${string}`);
      }
      setLookupError(null);
    } else if (usernameError && lastEdited === "address") {
      console.log("No primary username found for address or error:", usernameError.message);
      setUsername("");
      if (isAddress(debouncedAddress)) {
        onAccountAddressFound(debouncedAddress as `0x${string}`);
      }
      setLookupError(null);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [usernameFromAddress, usernameError, lastEdited, debouncedAddress]);

  const handleUsernameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const cleanValue = e.target.value.replace(/\s+/g, ""); // Remove all spaces
    setUsername(cleanValue);
    setLastEdited("username");
    if (lastEdited !== "address") setAddress("");
    onAccountAddressFound(""); // Use empty string
    setLookupError(null);
  };

  const handleAddressChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const cleanValue = e.target.value.replace(/\s+/g, ""); // Remove all spaces
    setAddress(cleanValue);
    setLastEdited("address");
    if (lastEdited !== "username") setUsername("");
    if (!isAddress(cleanValue) && cleanValue !== "") {
      setLookupError("Invalid address format");
      onAccountAddressFound(""); // Use empty string
    } else {
      setLookupError(null);
      if (isAddress(cleanValue)) {
        onAccountAddressFound(cleanValue as `0x${string}`);
      } else {
        onAccountAddressFound(""); // Use empty string
      }
    }
  };

  const isLoading = isLoadingAddress || isLoadingUsername;

  return (
    <div className="w-full max-w-md mx-auto space-y-8">
      <div className="text-center space-y-2">
        <p className="text-lg text-gray-600 font-light">To login, please enter your</p>
      </div>

      <div className="space-y-6">
        <div>
          <label htmlFor="username" className="block text-lg font-medium text-gray-700 mb-2">
            Lens Username
          </label>
          <input
            id="username"
            name="username"
            type="text"
            value={username}
            onChange={handleUsernameChange}
            placeholder="e.g. stani"
            className="w-full px-4 py-3 border border-gray-200 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition duration-200"
            aria-describedby="username-status"
            disabled={isLoading && lastEdited === "address"}
          />
        </div>

        <div className="flex items-center justify-center space-x-4">
          <div className="h-px bg-gray-200 w-20"></div>
          <span className="text-xl font-semibold text-gray-400">OR</span>
          <div className="h-px bg-gray-200 w-20"></div>
        </div>

        <div>
          <label htmlFor="address" className="block text-lg font-medium text-gray-700 mb-2">
            Lens Account Address
          </label>
          <input
            id="address"
            name="address"
            type="text"
            value={address}
            onChange={handleAddressChange}
            placeholder="0x..."
            className={`w-full px-4 py-3 border rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition duration-200 ${
              !lookupError && isAddress(address) ? "border-green-500" : address && !isAddress(address) ? "border-red-500" : "border-gray-200"
            }`}
            aria-describedby="address-status"
            disabled={isLoading && lastEdited === "username"}
          />
        </div>
      </div>

      {/* Status messages with improved styling */}
      <div className="min-h-[28px] flex justify-center">
        {isLoading && lastEdited === "username" && <StatusMessage type="loading" message="Checking username..." />}
        {isLoading && lastEdited === "address" && <StatusMessage type="loading" message="Checking address..." />}
        {lookupError && <StatusMessage type="error" message={lookupError} />}
        {!lookupError && isAddress(address) && lastEdited !== "username" && <StatusMessage type="success" message="Valid Address" />}
      </div>
    </div>
  );
}
</file>

<file path="src/components/WcConnect.tsx">
// src/components/WcConnect.tsx
"use client";

import React, { useState, useEffect } from "react";
import { useWalletConnect } from "@/contexts/WalletConnectProvider"; // Ensure correct path
import Image from "next/image";

// Default/Fallback Icon
const FallbackIcon = () => <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-500 text-xs">?</div>;

// Helper function to resolve icon URL
const resolveIconUrl = (iconPath: string | null | undefined, baseUrl: string | null | undefined): string | undefined => {
  if (!iconPath) return undefined;

  try {
    // Handle absolute URLs
    if (iconPath.startsWith("http://") || iconPath.startsWith("https://")) {
      return iconPath;
    }
    // Handle root-relative paths if base URL exists
    if (iconPath.startsWith("/") && baseUrl) {
      const origin = new URL(baseUrl).origin;
      return `${origin}${iconPath}`;
    }
    console.warn("Invalid icon URL format:", iconPath);
    return undefined;
  } catch (e) {
    console.warn("Error resolving icon URL:", e);
    return undefined;
  }
};

// Icon component with error handling
const DAppIcon = ({ iconUrl, name, size = 40 }: { iconUrl?: string; name: string; size?: number }) => {
  const [hasError, setHasError] = useState(false);

  if (!iconUrl || hasError) return <FallbackIcon />;

  return (
    <Image
      src={iconUrl}
      alt={`${name} icon`}
      width={size}
      height={size}
      className="rounded-full"
      unoptimized
      onError={() => {
        console.warn("Failed to load icon:", iconUrl);
        setHasError(true);
      }}
    />
  );
};

export function WcConnect() {
  // Destructure states from the refactored provider, including isInitializing
  const {
    activeSessions,
    pair,
    disconnect,
    isLoading, // Use the combined loading state
    isPairing,
    error,
    isInitialized, // Use the service readiness flag
    pendingProposal, // Get the pending proposal
    approveSession, // Get approve action
    rejectSession, // Get reject action
    isInitializing, // <<<--- ADDED isInitializing HERE ---<<<
  } = useWalletConnect();
  const [uri, setUri] = useState("");

  const activeSessionTopic = Object.keys(activeSessions)[0]; // Assuming only one session for MVP
  const connectedSession = activeSessionTopic ? activeSessions[activeSessionTopic] : null;

  // --- Add this useEffect ---
  useEffect(() => {
    // If there's no connected session (either initially or after disconnect),
    // clear the URI input field.
    if (!connectedSession) {
      setUri("");
    }
  }, [connectedSession]); // Run this effect when connectedSession changes
  // -------------------------

  const handleConnect = () => {
    if (!uri || !isInitialized || isLoading) return; // Check initialization and combined loading state
    pair(uri);
  };

  const handleDisconnect = () => {
    if (connectedSession && isInitialized && !isLoading) {
      // Check initialization and combined loading state
      disconnect(connectedSession.topic);
    }
  };

  const handleApprove = () => {
    if (pendingProposal && !isLoading) {
      approveSession();
    }
  };

  const handleReject = () => {
    if (pendingProposal && !isLoading) {
      rejectSession();
    }
  };

  // Display loading states more granularly if needed, otherwise use `isLoading`
  const connectButtonText = isPairing ? "Pairing..." : isLoading ? "Working..." : "Connect";
  const disconnectButtonText = isLoading ? "Working..." : "Disconnect";
  const approveButtonText = isLoading ? "Working..." : "Approve Session";
  const rejectButtonText = isLoading ? "Working..." : "Reject Session";

  // Resolve icon URLs
  const connectedDAppIconUrl = connectedSession
    ? resolveIconUrl(connectedSession.peer.metadata.icons?.[0] ?? undefined, connectedSession.peer.metadata.url ?? undefined)
    : undefined;

  const proposalIconUrl = pendingProposal
    ? resolveIconUrl(pendingProposal.params.proposer.metadata.icons?.[0] ?? undefined, pendingProposal.params.proposer.metadata.url ?? undefined)
    : undefined;

  return (
    <div className="p-4 border rounded-md bg-gray-50 space-y-4">
      <h3 className="text-md font-semibold text-gray-700">Connect to dApp (via Lens Account)</h3>

      {/* --- Session Proposal Modal (Simplified Inline) --- */}
      {pendingProposal && (
        <div className="p-3 border border-yellow-300 bg-yellow-50 rounded-md space-y-2">
          <p className="text-sm font-medium text-yellow-800">Connection Request from:</p>
          <div className="flex items-center space-x-2">
            <DAppIcon iconUrl={proposalIconUrl} name={pendingProposal.params.proposer.metadata.name} size={30} />
            <span className="text-sm text-gray-700">{pendingProposal.params.proposer.metadata.name}</span>
          </div>
          {/* TODO: Display requested permissions details if needed */}
          <div className="flex space-x-2 pt-2">
            <button
              onClick={handleApprove}
              disabled={isLoading || !isInitialized}
              className="flex-1 px-3 py-1 bg-green-500 text-white text-xs font-medium rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {approveButtonText}
            </button>
            <button
              onClick={handleReject}
              disabled={isLoading || !isInitialized}
              className="flex-1 px-3 py-1 bg-red-500 text-white text-xs font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {rejectButtonText}
            </button>
          </div>
        </div>
      )}

      {/* --- Connected Session Display --- */}
      {connectedSession && !pendingProposal && (
        <div className="space-y-3 p-3 bg-green-50 border border-green-200 rounded-md">
          {/* Display connected dApp info */}
          <p className="text-green-800 font-medium">Connected to:</p>
          <div className="flex items-center space-x-3">
            <DAppIcon iconUrl={connectedDAppIconUrl} name={connectedSession.peer.metadata.name} size={40} />
            <div>
              <p className="text-sm font-semibold text-gray-900">{connectedSession.peer.metadata.name}</p>
              <p className="text-xs text-gray-600 break-all">{connectedSession.peer.metadata.url}</p>
            </div>
          </div>
          <p className="text-xs text-gray-500">
            Topic: <span className="font-mono break-all">{connectedSession.topic}</span>
          </p>
          <button
            onClick={handleDisconnect}
            disabled={isLoading || !isInitialized} // Use combined loading state
            className="w-full px-4 py-2 mt-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 disabled:opacity-50"
          >
            {disconnectButtonText}
          </button>
        </div>
      )}

      {/* --- Pairing/Connection Form --- */}
      {!connectedSession && !pendingProposal && (
        <div className="space-y-2">
          <label htmlFor="wc-uri" className="block text-sm font-medium text-gray-700">
            Paste WalletConnect URI
          </label>
          <div className="flex space-x-2">
            <input
              id="wc-uri"
              name="wc-uri"
              type="text"
              value={uri}
              onChange={(e) => setUri(e.target.value)}
              placeholder="wc:..."
              className="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm disabled:bg-gray-100"
              disabled={isLoading || !isInitialized} // Use combined loading state
            />
            <button
              onClick={handleConnect}
              disabled={!uri || isLoading || !isInitialized} // Use combined loading state
              className="px-4 py-2 bg-indigo-600 text-white text-sm font-medium rounded-md shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
            >
              {connectButtonText}
            </button>
          </div>
        </div>
      )}

      {/* --- Status/Error Messages --- */}
      {error && !isLoading && <p className="text-red-600 text-sm mt-2">Error: {error}</p>}
      {isPairing && <p className="text-indigo-600 text-sm mt-2">Pairing initiated, check dApp/wallet if needed...</p>}
      {/* Check both flags here now */}
      {!isInitialized && !isInitializing && !error && <p className="text-orange-600 text-sm mt-2">WalletConnect service not ready.</p>}
      {/* And display initializing message correctly */}
      {isInitializing && <p className="text-gray-500 text-sm mt-2">Initializing WalletConnect...</p>}
    </div>
  );
}
</file>

<file path="src/app/dashboard/page.tsx">
// src/app/dashboard/page.tsx
"use client";

import { useLensAccount } from "@/contexts/LensAccountContext";
import { useAccount, useDisconnect } from "wagmi";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import { AccountDisplay } from "@/components/AccountDisplay";
import { WcConnect } from "@/components/WcConnect";
import { WcRequestDisplay } from "@/components/WcRequestDisplay"; // <<<--- IMPORTED

export default function Dashboard() {
  const { lensAccountAddress, ownerAddress, clearAccount } = useLensAccount();
  const { isConnected } = useAccount();
  const { disconnect: disconnectOwnerWallet } = useDisconnect();
  const router = useRouter();

  useEffect(() => {
    if (!isConnected || !lensAccountAddress || !ownerAddress) {
      console.log("Redirecting to home: not connected or missing context");
      if (!lensAccountAddress || !ownerAddress) {
        clearAccount();
      }
      router.replace("/");
    }
  }, [isConnected, lensAccountAddress, ownerAddress, router, clearAccount]);

  const handleLogout = () => {
    disconnectOwnerWallet();
    clearAccount();
    console.log("Logout initiated");
  };

  if (!isConnected || !lensAccountAddress || !ownerAddress) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <p>Loading or redirecting...</p>
      </div>
    );
  }

  return (
    <main className="flex min-h-screen flex-col items-center p-6 md:p-24">
      <div className="w-full max-w-4xl p-8 bg-white rounded-xl shadow-lg relative">
        <button
          onClick={handleLogout}
          className="absolute top-4 right-4 px-4 py-2 bg-red-500 text-white text-sm font-medium rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
        >
          {" "}
          Logout Owner{" "}
        </button>
        <h1 className="text-2xl font-bold mb-4 text-center">Dashboard</h1>
        <div className="space-y-6">
          <div className="p-3 bg-gray-50 border border-gray-200 rounded-md">
            <p className="text-sm font-medium text-gray-700">Connected Owner Wallet:</p>
            <p className="text-xs text-gray-600 break-words font-mono">{ownerAddress}</p>
          </div>
          <div className="p-3 bg-blue-50 border border-blue-200 rounded-md">
            <p className="text-sm font-medium text-blue-800">Managing Lens Account:</p>
            <p className="text-xs text-blue-700 break-words font-mono">{lensAccountAddress}</p>
          </div>
          <AccountDisplay />
          <WcConnect />
          {/* --- Render the Request Display Component --- */}
          <WcRequestDisplay /> {/* <<<--- ADDED */}
          {/* ------------------------------------------- */}
        </div>
      </div>
    </main>
  );
}
</file>

<file path="src/app/page.tsx">
// src/app/page.tsx
"use client";

import { DiscoveryForm } from "@/components/DiscoveryForm";
import { ConnectOwnerButton } from "@/components/ConnectOwnerButton";
import { useState, useEffect } from "react";
import { useAccount, useReadContract } from "wagmi"; // Import useAccount
import { useRouter } from "next/navigation"; // Import useRouter
import { type Address, isAddress } from "viem";
import { useLensAccount } from "@/contexts/LensAccountContext"; // Import the context hook
import { LENS_ACCOUNT_ABI, LENS_CHAIN_ID } from "@/lib/constants";

export default function Home() {
  const [lensAccountAddress, setLensAccountAddress] = useState<Address | "">("");
  const [expectedOwner, setExpectedOwner] = useState<Address | null>(null);
  const [ownerFetchError, setOwnerFetchError] = useState<string | null>(null);
  const [verificationError, setVerificationError] = useState<string | null>(null); // State for verification errors

  const {
    address: connectedAddress,
    chainId: connectedChainId,
    isConnected,
    // isConnecting, // REMOVED - Unused
    // isReconnecting, // REMOVED - Unused
  } = useAccount(); // Get connected account info
  const router = useRouter(); // Initialize router
  const { setVerifiedAccount, clearAccount: clearContext } = useLensAccount(); // Get context actions

  const handleAccountFound = (address: Address | "") => {
    console.log("Account Address Updated in Parent:", address);
    setLensAccountAddress(address);
    setExpectedOwner(null); // Reset owner when lens account changes
    setOwnerFetchError(null);
    setVerificationError(null); // Reset verification error
    clearContext(); // Clear context if lens account changes
  };

  const {
    data: ownerData,
    error: ownerError,
    isLoading: isLoadingOwner,
  } = useReadContract({
    address: lensAccountAddress || undefined,
    abi: LENS_ACCOUNT_ABI,
    functionName: "owner",
    chainId: LENS_CHAIN_ID,
    query: {
      enabled: isAddress(lensAccountAddress),
    },
  });

  // Effect to update expectedOwner state
  useEffect(() => {
    if (ownerData) {
      setExpectedOwner(ownerData);
      setOwnerFetchError(null);
      console.log("Fetched Expected Owner:", ownerData);
    }
  }, [ownerData]);

  // Effect to handle owner fetch errors
  useEffect(() => {
    if (ownerError) {
      console.error("Error fetching owner:", ownerError);
      setOwnerFetchError("Could not fetch account owner. Ensure the address is correct and on Lens Chain.");
      setExpectedOwner(null);
    } else if (isAddress(lensAccountAddress)) {
      setOwnerFetchError(null);
    }
  }, [ownerError, lensAccountAddress]);

  // Effect for Owner Verification and Navigation
  useEffect(() => {
    // Clear verification error on disconnect
    if (!isConnected) {
      setVerificationError(null);
      clearContext(); // Also clear context on disconnect
      return;
    }

    if (connectedAddress && expectedOwner && isAddress(lensAccountAddress)) {
      // Check if on the correct chain first
      if (connectedChainId !== LENS_CHAIN_ID) {
        // Wagmi/ConnectKit handles the switch prompt, maybe show a generic message here
        setVerificationError("Please switch to the Lens Chain in your wallet.");
        clearContext();
        return; // Don't proceed further if chain is wrong
      }

      // Now check if the address matches
      if (connectedAddress.toLowerCase() === expectedOwner.toLowerCase()) {
        console.log("Owner verified! Navigating to dashboard...");
        setVerificationError(null); // Clear error on success
        // Set the verified account details in context before navigating
        setVerifiedAccount(lensAccountAddress, connectedAddress);
        router.push("/dashboard");
      } else {
        console.log("Owner mismatch:", {
          connected: connectedAddress,
          expected: expectedOwner,
        });
        setVerificationError(`Incorrect owner connected. Please connect with wallet: ${expectedOwner}`);
        clearContext();
      }
    }
  }, [connectedAddress, connectedChainId, expectedOwner, lensAccountAddress, isConnected, router, setVerifiedAccount, clearContext]);

  const showConnectButton = expectedOwner && !isLoadingOwner && !ownerFetchError;
  // const connectButtonDisabled = // REMOVED - Unused
  //   !!verificationError || connectedChainId !== LENS_CHAIN_ID;

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-6 md:p-24 bg-gradient-to-br from-purple-50 via-pink-50 to-blue-50">
      <h1 className="text-4xl font-bold text-gray-800 mb-12">Lens Account Dashboard</h1>

      <div className="w-full max-w-lg p-8 space-y-8 bg-white rounded-xl shadow-lg">
        <DiscoveryForm onAccountAddressFound={handleAccountFound} />

        <div className="space-y-4">
          {isAddress(lensAccountAddress) && isLoadingOwner && <p className="text-center text-indigo-600">Fetching owner...</p>}

          {ownerFetchError && !isLoadingOwner && <p className="text-center text-red-600">{ownerFetchError}</p>}

          {expectedOwner && !isLoadingOwner && !ownerFetchError && (
            <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
              <p className="text-sm font-medium text-blue-800 mb-1">Identified Account Owner:</p>
              <p className="text-xs text-blue-700 break-words font-mono">{expectedOwner}</p>
              {!isConnected && <p className="text-xs text-blue-600 mt-2">Connect this wallet to proceed.</p>}
            </div>
          )}

          {verificationError && <p className="text-sm text-center text-red-600">{verificationError}</p>}

          {showConnectButton && (
            <div className="flex flex-col items-center gap-2">
              <ConnectOwnerButton />
              {isConnected && connectedChainId !== LENS_CHAIN_ID && <p className="text-xs text-orange-600">Waiting for network switch...</p>}
            </div>
          )}
        </div>
      </div>
    </main>
  );
}
</file>

<file path="src/services/walletConnectService.ts">
// src/services/walletConnectService.ts
import { WalletKit, IWalletKit, WalletKitTypes } from "@reown/walletkit";
import { Core } from "@walletconnect/core";
import { ICore, SessionTypes, SignClientTypes } from "@walletconnect/types";
import { ErrorResponse, JsonRpcResponse } from "@walletconnect/jsonrpc-utils"; // Import JsonRpcResponse
import EventEmitter from "events";

// --- Export Enums and Interfaces ---
export enum ServiceEvents {
  Initialized = "initialized",
  PairStatus = "pair_status",
  SessionProposal = "session_proposal",
  SessionConnect = "session_connect",
  SessionDelete = "session_delete",
  SessionRequest = "session_request", // <<<--- ADDED
  Error = "error",
  SessionsUpdated = "sessions_updated",
  IS_LOADING = "is_loading",
  IS_PAIRING = "is_pairing",
}

export interface WalletConnectServiceEvents {
  [ServiceEvents.Initialized]: (payload: { success: boolean; instance: IWalletKit | null }) => void;
  [ServiceEvents.PairStatus]: (payload: { status: "pairing" | "paired" | "error"; message?: string }) => void;
  [ServiceEvents.SessionProposal]: (payload: { proposal: WalletKitTypes.SessionProposal }) => void;
  [ServiceEvents.SessionConnect]: (payload: { session: SessionTypes.Struct }) => void;
  [ServiceEvents.SessionDelete]: (payload: { topic: string }) => void;
  [ServiceEvents.SessionRequest]: (payload: { request: WalletKitTypes.SessionRequest }) => void; // <<<--- ADDED
  [ServiceEvents.Error]: (payload: { message: string }) => void;
  [ServiceEvents.SessionsUpdated]: (payload: { sessions: Record<string, SessionTypes.Struct> }) => void;
  [ServiceEvents.IS_LOADING]: (payload: { isLoading: boolean }) => void;
  [ServiceEvents.IS_PAIRING]: (payload: { isPairing: boolean }) => void;
}
// ------------------------------------

// --- Export the Class Definition ---
export class WalletConnectService extends EventEmitter {
  private core: ICore | undefined;
  private walletKit: IWalletKit | undefined;
  private projectId: string;
  private metadata: WalletKitTypes.Metadata;
  private _isInitialized = false;
  private _isInitializing = false;
  private initPromise: Promise<IWalletKit> | null = null;

  constructor(projectId: string, metadata: WalletKitTypes.Metadata) {
    super();
    if (!projectId) {
      throw new Error("WalletConnectService: Project ID is required.");
    }
    this.projectId = projectId;
    this.metadata = JSON.parse(JSON.stringify(metadata));
    console.log("WalletConnectService: NEW Instance created (by Provider).");
  }

  // --- Getters (keep as before) ---
  public isInitialized(): boolean {
    return this._isInitialized;
  }
  public isInitializing(): boolean {
    return this._isInitializing;
  }
  public getWalletKitInstance(): IWalletKit | undefined {
    return this.walletKit;
  }
  public getActiveSessions(): Record<string, SessionTypes.Struct> {
    return this.walletKit?.getActiveSessions() || {};
  }

  // --- Core Initialization (Idempotent) ---
  async init(): Promise<IWalletKit> {
    if (this._isInitialized && this.walletKit) {
      console.log("WalletConnectService Instance: Init called but already initialized.");
      this.emit(ServiceEvents.Initialized, { success: true, instance: this.walletKit });
      return this.walletKit;
    }
    if (this._isInitializing && this.initPromise) {
      console.log("WalletConnectService Instance: Init called while already initializing. Returning existing promise.");
      return this.initPromise;
    }
    console.log("WalletConnectService Instance: Starting initialization (init)...");
    this._isInitializing = true;
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    this.initPromise = (async () => {
      try {
        console.log("WalletConnectService Instance: Initializing WalletConnect Core...");
        process.env.DISABLE_GLOBAL_CORE = "true";
        this.core = new Core({ projectId: this.projectId });
        process.env.DISABLE_GLOBAL_CORE = "false";
        console.log("WalletConnectService Instance: Initializing WalletKit...");
        this.walletKit = await WalletKit.init({ core: this.core, metadata: this.metadata });
        this.setupInternalListeners();
        this._isInitialized = true;
        console.log("WalletConnectService Instance: Initialization successful.");
        this.emit(ServiceEvents.Initialized, { success: true, instance: this.walletKit });
        this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
        return this.walletKit;
      } catch (error: unknown) {
        console.error("WalletConnectService Instance: Initialization failed:", error);
        this._isInitialized = false;
        this.emit(ServiceEvents.Initialized, { success: false, instance: null });
        this.emit(ServiceEvents.Error, { message: `Initialization failed: ${(error as Error).message}` });
        throw error;
      } finally {
        this._isInitializing = false;
        this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
        this.initPromise = null;
      }
    })();
    return this.initPromise;
  }

  private setupInternalListeners() {
    if (!this.walletKit) {
      console.error("WalletConnectService: Cannot setup listeners, WalletKit not ready.");
      return;
    }
    console.log("WalletConnectService: Setting up internal event listeners...");

    this.walletKit.off("session_proposal", this.handleSessionProposal);
    this.walletKit.on("session_proposal", this.handleSessionProposal);

    if (this.walletKit.engine?.signClient?.events) {
      this.walletKit.engine.signClient.events.off("session_connect", this.handleSessionConnect);
      this.walletKit.engine.signClient.events.on("session_connect", this.handleSessionConnect);
    } else {
      console.warn("WalletConnectService: SignClient events not available for session_connect listener.");
    }

    this.walletKit.off("session_delete", this.handleSessionDelete);
    this.walletKit.on("session_delete", this.handleSessionDelete);

    // --- Add session_request Listener ---
    this.walletKit.off("session_request", this.handleSessionRequest); // <<<--- ADDED
    this.walletKit.on("session_request", this.handleSessionRequest); // <<<--- ADDED
    // ------------------------------------

    console.log("WalletConnectService: Internal listeners attached.");
  }

  // --- Event Handlers (bound methods) ---
  private handleSessionProposal = (proposal: WalletKitTypes.SessionProposal) => {
    console.log("Service Handler: session_proposal", proposal.id);
    this.emit(ServiceEvents.SessionProposal, { proposal });
    this.emit(ServiceEvents.IS_PAIRING, { isPairing: false });
  };

  private handleSessionConnect = (sessionArgs: SignClientTypes.EventArguments["session_connect"]) => {
    console.log("Service Handler: session_connect", sessionArgs.session.topic);
    this.emit(ServiceEvents.SessionConnect, { session: sessionArgs.session });
    this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
  };

  private handleSessionDelete = (event: { id: number; topic: string }) => {
    console.log("Service Handler: session_delete", event.topic);
    this.emit(ServiceEvents.SessionDelete, { topic: event.topic });
    this.emit(ServiceEvents.SessionsUpdated, { sessions: this.getActiveSessions() });
  };

  // --- Handler for Session Request ---
  private handleSessionRequest = (request: WalletKitTypes.SessionRequest) => {
    // <<<--- ADDED
    console.log("Service Handler: session_request", request.id, request.params.request.method);
    this.emit(ServiceEvents.SessionRequest, { request });
  };
  // -----------------------------------

  // --- Public Methods ---
  async pair(uri: string): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot pair.");
    console.log("Service: Attempting to pair with URI:", uri);
    this.emit(ServiceEvents.IS_PAIRING, { isPairing: true });
    this.emit(ServiceEvents.PairStatus, { status: "pairing" });
    try {
      await this.walletKit.pair({ uri });
      console.log("Service: Pairing initiated for URI:", uri);
    } catch (error: unknown) {
      console.error("Service: Pairing failed:", error);
      const message = (error as Error).message || "Pairing failed";
      this.emit(ServiceEvents.PairStatus, { status: "error", message });
      this.emit(ServiceEvents.IS_PAIRING, { isPairing: false });
      this.emit(ServiceEvents.Error, { message });
      throw error;
    }
  }

  async approveSession(proposal: WalletKitTypes.SessionProposal, approvedNamespaces: SessionTypes.Namespaces): Promise<SessionTypes.Struct> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot approve session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Approving session:", proposal.id);
      const session = await this.walletKit.approveSession({ id: proposal.id, namespaces: approvedNamespaces });
      console.log("Service: Session approved via approveSession:", session.topic);
      return session;
    } catch (error: unknown) {
      console.error("Service: Failed to approve session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to approve session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  async rejectSession(proposal: WalletKitTypes.SessionProposal, reason: ErrorResponse): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot reject session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Rejecting session:", proposal.id);
      await this.walletKit.rejectSession({ id: proposal.id, reason: reason });
      console.log("Service: Session rejected:", proposal.id);
    } catch (error: unknown) {
      console.error("Service: Failed to reject session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to reject session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  async disconnectSession(topic: string, reason: ErrorResponse): Promise<void> {
    if (!this._isInitialized || !this.walletKit) throw new Error("WalletConnectService: Not initialized. Cannot disconnect session.");
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Disconnecting session:", topic);
      await this.walletKit.disconnectSession({ topic: topic, reason: reason });
      console.log("Service: Disconnect call successful for topic:", topic);
    } catch (error: unknown) {
      console.error("Service: Failed to disconnect session:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to disconnect session" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }

  // --- Method to Respond to Session Requests ---
  async respondSessionRequest(topic: string, response: JsonRpcResponse): Promise<void> {
    // <<<--- ADDED
    if (!this._isInitialized || !this.walletKit) {
      throw new Error("WalletConnectService: Not initialized. Cannot respond to request.");
    }
    this.emit(ServiceEvents.IS_LOADING, { isLoading: true });
    try {
      console.log("Service: Responding to session request:", response.id, "on topic:", topic);
      await this.walletKit.respondSessionRequest({ topic, response });
      console.log("Service: Response sent for request:", response.id);
    } catch (error: unknown) {
      console.error("Service: Failed to respond to session request:", error);
      this.emit(ServiceEvents.Error, { message: (error as Error).message || "Failed to respond to request" });
      throw error;
    } finally {
      this.emit(ServiceEvents.IS_LOADING, { isLoading: false });
    }
  }
  // -------------------------------------------

  // Typed EventEmitter methods (Apply this pattern to on, once, off, removeListener)
  on<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.on(event, listener as (...args: any[]) => void);
  }

  once<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.once(event, listener as (...args: any[]) => void);
  }

  off<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.off(event, listener as (...args: any[]) => void);
  }

  removeListener<E extends keyof WalletConnectServiceEvents>(event: E, listener: WalletConnectServiceEvents[E]): this {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return super.removeListener(event, listener as (...args: any[]) => void);
  }

  emit<E extends keyof WalletConnectServiceEvents>(event: E, ...args: Parameters<WalletConnectServiceEvents[E]>): boolean {
    return super.emit(event, ...args);
  }
}
</file>

<file path="package.json">
{
  "name": "lens-account-interface4",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prepare": "husky",
    "generate-llms": "repomix --include \"*.*,src\" --ignore \"llms.txt\" -o llms.txt",
    "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,css,md,json}\"",
    "format:check": "prettier --check \"src/**/*.{js,jsx,ts,tsx,css,md,json}\""
  },
  "dependencies": {
    "@heroicons/react": "^2.2.0",
    "@reown/walletkit": "^1.2.3",
    "@tanstack/react-query": "^5.74.4",
    "@walletconnect/core": "^2.20.0",
    "@walletconnect/jsonrpc-utils": "^1.0.8",
    "@walletconnect/utils": "^2.20.0",
    "connectkit": "^1.9.0",
    "next": "15.3.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "viem": "^2.27.2",
    "wagmi": "^2.14.16"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/webpack": "^5.28.5",
    "@walletconnect/types": "^2.20.0",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "husky": "^9.1.7",
    "pino-pretty": "^13.0.0",
    "prettier": "^3.5.3",
    "repomix": "^0.3.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="DEVELOPMENT_PLAN.md">
**Version:** 1.0
**Date:** 2025-04-19

## 1. Introduction

This document outlines the phased development plan for building the Minimum Viable Product (MVP) of the Lens Account Web Interface. It breaks down the work into manageable stages, aligning with the Functional Specification (`Spec.functional.md`) and Technical Specification (`TECHNICAL_SPEC.md`).

## 2. Methodology

We will follow an incremental development approach, building and verifying core features stage by stage. Each stage should result in a testable piece of functionality.

## 3. Development Stages

### Stage 0: Project Setup & Base Configuration (Completed via Setup)

- [x] Initialize Next.js 15+ project with TypeScript, Tailwind CSS, App Router.
- [x] Install pnpm as the package manager.
- [x] Install core dependencies: `wagmi`, `viem`, `@tanstack/react-query`, `connectkit`, `@reown/walletkit`, `@walletconnect/core`, `@walletconnect/utils`.
- [x] Set up basic ESLint and Prettier configuration.
- [x] Create `.env.local` with `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID` placeholder.
- [x] Configure `WagmiProvider` and `QueryClientProvider` in the root layout (`app/layout.tsx`).
  - **Check:** Development server runs (`pnpm dev`) without errors. Base Next.js page loads.

### Stage 1: Account Discovery & Chain Read Interaction

**Goal:** Implement the username/address input fields and the logic to look up corresponding data from the `LensGlobalNamespace` contract on the Lens Chain. Verify basic read operations work.

- **Tasks:**
  - [x] **Create Constants:** Define Lens Chain details (ID 232, RPC URL, etc.), `LensGlobalNamespace` address, and its partial ABI (`accountOf(string)`, `usernameOf(address)`) in `lib/constants.ts`.
  - [x] **Update Wagmi Config:** Ensure the `lensChain` object is defined using `defineChain` and included in the `createConfig` call in `lib/wagmi.ts`.
  - [x] **Create DiscoveryForm Component:** Build `components/DiscoveryForm.tsx` with two controlled input fields (Username, Account Address) styled with Tailwind.
  - [x] **Implement Lookup Logic:**
    - [x] Inside `DiscoveryForm.tsx` or a custom hook (`hooks/useLensLookup.ts`), use `useState` for input values.
    - [x] Use `useEffect` with a debounce utility (e.g., from `lodash.debounce` or simple `setTimeout`) to trigger lookups on input change.
    - [x] Call `useReadContract` (Wagmi) within the debounced effect:
      - Target `LensGlobalNamespace` address.
      - Use the appropriate function (`accountOf` or `usernameOf`) based on which input changed.
      - **Crucially:** Pass `chainId: LENS_CHAIN_ID` to ensure the call targets the correct network.
      - Handle loading and error states from `useReadContract`.
    - [x] Update the _other_ input field's state based on the successful result from `useReadContract`.
  - [x] **Integrate Form:** Place `DiscoveryForm.tsx` onto the root page (`app/page.tsx`).
- **Verification:**
  - [x] Typing a known Lens username (e.g., `stani`) correctly populates the Account Address field.
  - [x] Typing/pasting a known Lens Account address correctly populates the Lens Username field (if one exists).
  - [x] Invalid inputs show no result or subtle error indication.
  - [x] Check browser developer console for any Wagmi/Viem errors related to contract reads. Network tab should show RPC calls to the Lens Chain RPC URL.

### Stage 2: Owner EOA Connection & Verification

**Goal:** Integrate the "Connect Wallet" functionality, fetch the Lens Account owner, verify it against the connected EOA, handle chain switching, and navigate to the dashboard.

- **Tasks:**
  - [x] **Add Owner ABI:** Include the `owner()` function signature in the `LENS_ACCOUNT_ABI` within `lib/constants.ts`.
  - [x] **Create Connect Button:** Build `components/ConnectOwnerButton.tsx`. Use ConnectKit's `<ConnectKitButton />` or its underlying hooks (`useModal`, etc.) for the UI.
  - [x] **Fetch Expected Owner:**
    - In `app/page.tsx`, once a valid Lens Account address is determined (from Stage 1 state), use `useReadContract` to call `owner()` on the Lens Account address.
    - Pass `chainId: LENS_CHAIN_ID`.
    - Store the result in state (`expectedOwner`).
  - [x] **Display Expected Owner:** Show the `expectedOwner` address clearly near the `ConnectOwnerButton`.
  - [x] **Integrate Connect Button:** Add `ConnectOwnerButton` to `app/page.tsx`, potentially disabling it until `expectedOwner` is fetched.
  - [x] **Implement Verification Logic:**
    - In `app/page.tsx`, use `useAccount` (Wagmi) to get the connected EOA's `address` and `chainId`.
    - Use `useEffect` to monitor changes in the connected `address`, `chainId`, and the `expectedOwner`.
    - Inside the effect:
      - If `address` and `expectedOwner` exist:
        - If `chainId !== LENS_CHAIN_ID`, do nothing (ConnectKit/Wagmi handle switch prompt).
        - If `address.toLowerCase() === expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, proceed to navigation.
        - If `address.toLowerCase() !== expectedOwner.toLowerCase()` and `chainId === LENS_CHAIN_ID`, set an error state ("Incorrect owner connected...").
      - If `address` is disconnected, clear any error state.
  - [x] **Implement Navigation:**
    - Use `useRouter` from `next/navigation`.
    - When verification passes (addresses match, correct chain), call `router.push('/dashboard')`.
  - [x] **Create Context (Optional but Recommended):** Create `contexts/LensAccountProvider.tsx` to store the verified `lensAccountAddress` and `ownerAddress` so the dashboard can access them. Wrap the root layout or dashboard layout with this provider. Update `app/page.tsx` to set context values upon successful verification before navigating.
- **Verification:**
  - [x] "Connect Wallet" button appears/enables only when a Lens Account address is set and `owner()` has been potentially fetched. Expected owner address is displayed.
  - [x] Clicking "Connect Wallet" opens the ConnectKit modal.
  - [x] Connecting the _correct_ Owner EOA wallet on the wrong network prompts a "Switch Network" request to Lens Chain.
  - [x] Connecting the _correct_ Owner EOA wallet on the Lens Chain navigates the user to `/dashboard`.
  - [x] Connecting an _incorrect_ EOA wallet (not the owner) on the Lens Chain displays a clear error message and _does not_ navigate.
  - [x] Disconnecting the wallet returns the user to the login/discovery state or clears the owner state.

### Stage 3: Basic Dashboard Display

**Goal:** Create the dashboard page and display the Lens Account address and its WGHO balance.

- **Tasks:**
  - [x] **Create Dashboard Page:** Create `app/dashboard/page.tsx`. Ensure it's protected or redirects if owner/lens account state (from Context) is missing.
  - [x] **Add WGHO Constants:** Define `WGHO_TOKEN_ADDRESS` and `ERC20_ABI` (with `balanceOf(address)`) in `lib/constants.ts`.
  - [x] **Create AccountDisplay Component:** Build `components/AccountDisplay.tsx`.
  - [x] **Fetch/Display Data:**
    - In `AccountDisplay.tsx`, retrieve the `lensAccountAddress` from context (e.g., `useContext(LensAccountContext)`).
    - Use `useReadContract` (Wagmi) to call `balanceOf(lensAccountAddress)` on the `WGHO_TOKEN_ADDRESS`.
    - Pass `chainId: LENS_CHAIN_ID`.
    - Use Viem's `formatUnits` to format the returned balance (assuming WGHO has 18 decimals).
    - Display the `lensAccountAddress` and the formatted WGHO balance. Handle loading/error states for the balance fetch.
  - [x] **Integrate Component:** Add `AccountDisplay` to the dashboard page.
  - [x] Do the same for native GHO
- **Verification:**
  - [x] Navigating to `/dashboard` after successful login shows the correct Lens Account address.
  - [x] The GHO/WGHO balance for the Lens Account is fetched and displayed correctly (or shows loading/error state).

### Stage 4: WalletConnect v2 Pairing (Act as Wallet)

**Goal:** Implement the WalletConnect URI input and pairing logic, allowing the web app (representing the Lens Account) to connect to external dApps.

- **Tasks:**
  - [x] **Create WC Service:** Set up `services/walletConnectService.ts`. Include an `init` method that creates a `Web3Wallet` instance from `@reown/walletkit` using the `NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID`. Store the instance.
  - [x] **Create WC Context:** Set up `contexts/WalletConnectProvider.tsx`. Initialize the `walletConnectService` on mount. Provide the `web3wallet` instance, active sessions state (`useState`), pairing state (`useState`), and pending request state (`useState`) via context.
  - [x] **Wrap Layout:** Wrap the relevant part of the application (e.g., dashboard layout or root layout) with `WalletConnectProvider`.
  - [x] **Create WcConnect Component:** Build `components/WcConnect.tsx`.
    - Include an `<input>` for the WC URI and a `<button>` ("Connect").
    - Add state for the input value.
    - On button click, call a `pair` function provided by the `WalletConnectContext`.
  - [x] **Implement Pairing Logic:**
    - In `WalletConnectProvider` (or the service), define the `pair(uri)` function. Call `web3wallet.core.pairing.pair({ uri })`. Handle potential errors.
    - Set up the `session_proposal` listener (`web3wallet.on('session_proposal', handleSessionProposal)`).
  - [x] **Implement Session Approval:**
    - Define `handleSessionProposal(proposal)` in the service/provider.
    - Retrieve the `lensAccountAddress` and `LENS_CHAIN_ID` from state/constants.
    - Construct the `approvedNamespaces` object containing only the `eip155` namespace, with the `LENS_CHAIN_ID`, the Lens Account address (formatted as `eip155:232:0x...`), required methods (`eth_sendTransaction`, `personal_sign`, etc.), and events (`chainChanged`, `accountsChanged`).
    - Call `web3wallet.approveSession({ id: proposal.id, namespaces: approvedNamespaces })`.
    - On success, update the `activeSessions` state in the context.
    - Handle potential errors during approval.
  - [x] **Update UI:** Modify `WcConnect.tsx` to:
    - Conditionally render the input/button form OR the connected dApp info based on `activeSessions` state from context.
    - Display dApp metadata (name, icon, url) from the active session.
- **Verification:**
  - [x] Open the dashboard page. The WC input form is visible.
  - [x] Go to a test dApp (e.g., Reown's React Dapp Example) and generate a WC v2 URI.
  - [x] Paste the URI into the input field in _this_ app and click "Connect".
  - [x] The connection should establish successfully (no prompt needed in the Owner EOA wallet for pairing/session _approval_ in this flow).
  - [x] The `WcConnect.tsx` component should update to show the connected dApp's information. Check the dApp, it should also show a successful connection to the _Lens Account address_.

### Stage 5: WalletConnect v2 Transaction Request Handling

**Goal:** Handle incoming `eth_sendTransaction` requests from the connected dApp, prompt the Owner EOA for approval via the Lens Account's `executeTransaction`, and relay the result.

- **Tasks:**
  - [ ] **Create WcRequestDisplay Component:** Build `components/WcRequestDisplay.tsx`. It should conditionally render based on the `pendingRequest` state from `WalletConnectContext`. Display request details (`to`, `value`, `data` hex string) and "Send Transaction" / "Reject" buttons.
  - [ ] **Implement Request Listener:**
    - In `WalletConnectProvider` (or service), set up the `session_request` listener (`web3wallet.on('session_request', handleSessionRequest)`).
    - Define `handleSessionRequest(event)`: Store the `event.topic`, `event.id`, and `event.params.request` (`{ method, params }`) in the `pendingRequest` state of the context. Only handle `eth_sendTransaction` for MVP.
  - [ ] **Implement Transaction Execution Logic:**
    - Create `hooks/useWcRequestHandler.ts` or add logic to `WcRequestDisplay.tsx`.
    - On "Send Transaction" click:
      - Get `lensAccountAddress`, `ownerAddress` from relevant contexts.
      - Get `topic`, `id`, `request` (`method`, `params`) from `WalletConnectContext.pendingRequest`.
      - Extract `to`, `value`, `data` from `request.params[0]`.
      - Call `useWriteContract` (Wagmi) hook configured for the `executeTransaction` function on the `LENS_ACCOUNT_ABI` and `lensAccountAddress`.
      - The `args` for `executeTransaction` will be `[to, value || 0n, data || '0x']`.
      - Pass `account: ownerAddress` and `chainId: LENS_CHAIN_ID` to `useWriteContract`'s mutation function.
      - Use `useWaitForTransactionReceipt` to wait for the transaction hash returned by `writeContract`.
  - [ ] **Implement Response Logic:**
    - Modify the "Send Transaction" click handler:
      - On `writeContract` success: Wait for the receipt. If receipt status is `'success'`, call `web3wallet.respondSessionRequest({ topic, response: { id, result: receipt.transactionHash, jsonrpc: '2.0' } })`.
      - If receipt status is `'reverted'`, call `web3wallet.respondSessionRequest` with a JSON-RPC error payload (e.g., `{ id, jsonrpc: '2.0', error: { code: -32000, message: 'Transaction reverted' } }`).
      - On `writeContract` error (e.g., user rejection in EOA wallet): Call `web3wallet.respondSessionRequest` with a user rejection error payload (`{ id, jsonrpc: '2.0', error: { code: 5000, message: 'User Rejected' } }`).
    - On "Reject" click: Call `web3wallet.respondSessionRequest` with a user rejection error payload.
    - After responding (success or error), clear the `pendingRequest` state in the context.
  - [ ] **Integrate Component:** Add `WcRequestDisplay` to the dashboard page.
- **Verification:**
  - [ ] Connect to a test dApp (e.g., Aave testnet interface pointed to Lens Chain RPC, or a simple custom test page).
  - [ ] Initiate a transaction on the test dApp (e.g., a simple contract call or ETH transfer _if possible via the dApp_).
  - [ ] The `WcRequestDisplay` component should appear in _this_ app showing the request details.
  - [ ] Clicking "Reject" should send an error to the dApp and hide the request display.
  - [ ] Clicking "Send Transaction" should:
    - Prompt the _Owner EOA wallet_ (MetaMask, etc.) to confirm the `executeTransaction` call on the Lens Account.
    - Rejecting in the Owner EOA wallet sends an error to the dApp.
    - Confirming in the Owner EOA wallet sends the transaction.
    - Upon successful mining, the transaction hash is sent back to the dApp, and the request display hides. Success feedback is shown.
    - If the on-chain execution reverts, an error is sent back to the dApp, and the request display hides. Error feedback is shown.

## 4. Post-MVP Considerations

- Implement handling for other WalletConnect methods (`personal_sign`, etc.).
- Add UI for managing active WalletConnect sessions (viewing, disconnecting).
- Improve transaction data decoding in the request display.
- Enhance error messages and user feedback.
- Refine UI/UX, add loading states more granularly.
- Mobile responsiveness.
</file>

<file path="src/contexts/WalletConnectProvider.tsx">
// src/contexts/WalletConnectProvider.tsx
"use client";

import React, { createContext, useState, useContext, ReactNode, useEffect, useCallback, useMemo, useRef } from "react";
// Import the CLASS and types
import { WalletConnectService, ServiceEvents, type WalletConnectServiceEvents } from "@/services/walletConnectService";
import { SessionTypes } from "@walletconnect/types";
import { IWalletKit, WalletKitTypes } from "@reown/walletkit";
import { buildApprovedNamespaces, getSdkError } from "@walletconnect/utils";
import { useLensAccount } from "./LensAccountContext";
import { LENS_CHAIN_ID } from "@/lib/constants";
import { JsonRpcResponse } from "@walletconnect/jsonrpc-utils";

// Keep the context state definition
interface WalletConnectContextState {
  walletKitInstance: IWalletKit | null;
  activeSessions: Record<string, SessionTypes.Struct>;
  pendingProposal: WalletKitTypes.SessionProposal | null;
  pendingRequest: WalletKitTypes.SessionRequest | null;
  pair: (uri: string) => Promise<void>;
  disconnect: (topic: string) => Promise<void>;
  approveSession: () => Promise<void>;
  rejectSession: () => Promise<void>;
  respondRequest: (response: JsonRpcResponse) => Promise<void>;
  isLoading: boolean;
  isInitializing: boolean;
  isPairing: boolean;
  isProcessingAction: boolean;
  error: string | null;
  isInitialized: boolean;
}

const WalletConnectContext = createContext<WalletConnectContextState | undefined>(undefined);

interface WalletConnectProviderProps {
  children: ReactNode;
}

const DAPP_METADATA: WalletKitTypes.Metadata = {
  name: "Lens Account Interface",
  description: "Interface for managing Lens Account via WalletConnect",
  url: typeof window !== "undefined" ? window.location.origin : "http://localhost:3000",
  icons: ["/favicon.ico"],
};

// --- WalletConnectProvider Component ---
export function WalletConnectProvider({ children }: WalletConnectProviderProps) {
  const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID;

  // --- State Management ---
  const serviceRef = useRef<WalletConnectService | null>(null);
  const [walletKitInstance, setWalletKitInstance] = useState<IWalletKit | null>(null);
  const [activeSessions, setActiveSessions] = useState<Record<string, SessionTypes.Struct>>({});
  const [pendingProposal, setPendingProposal] = useState<WalletKitTypes.SessionProposal | null>(null);
  const [pendingRequest, setPendingRequest] = useState<WalletKitTypes.SessionRequest | null>(null);
  const [isInitializing, setIsInitializing] = useState(true);
  const [isPairing, setIsPairing] = useState(false);
  const [isProcessingAction, setIsProcessingAction] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  const { lensAccountAddress } = useLensAccount();

  console.log(
    `%cWalletConnectProvider Render: isInitialized=${isInitialized}, isInitializing=${isInitializing}, isPairing=${isPairing}, isProcessing=${isProcessingAction}, serviceExists=${!!serviceRef.current}, pendingProposal=${!!pendingProposal}, pendingRequest=${!!pendingRequest}`,
    "color: blue",
  );

  // --- Effect to Create Instance, Initialize ONCE ---
  useEffect(() => {
    if (!projectId) {
      console.error("WalletConnectProvider: Project ID missing. Cannot initialize service.");
      setError("WalletConnect Project ID is missing.");
      setIsInitializing(false);
      setIsInitialized(false);
      return;
    }
    // Prevent re-initialization if instance already exists in ref
    if (serviceRef.current) {
      console.log(
        `%cWalletConnectProvider Mount Effect: Service instance already exists in ref. Skipping creation/init. isInitialized=${serviceRef.current.isInitialized()}`,
        "color: yellow",
      );
      // Sync state if needed (e.g. HMR occurred after init finished)
      if (serviceRef.current.isInitialized() && !isInitialized) {
        setIsInitialized(true);
        setIsInitializing(false);
        setWalletKitInstance(serviceRef.current.getWalletKitInstance() ?? null);
        setActiveSessions(serviceRef.current.getActiveSessions());
      } else if (serviceRef.current.isInitializing() && !isInitializing) {
        setIsInitializing(true);
      }
    } else {
      console.log(`%cWalletConnectProvider Mount Effect: Creating NEW service instance and initializing...`, "color: orange");
      setIsInitializing(true);
      setError(null);
      const service = new WalletConnectService(projectId, DAPP_METADATA);
      serviceRef.current = service; // Store the instance in the ref

      service.init().catch((initError: Error | unknown) => {
        console.error("WalletConnectProvider Mount Effect: service.init() rejected.", initError);
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [projectId]); // Add projectId dependency

  // --- Effect to Attach/Detach Event Listeners ---
  useEffect(() => {
    const currentService = serviceRef.current; // Capture ref value for effect closure
    if (!currentService) {
      console.log(`%cWalletConnectProvider Listener Effect: Skipping setup, no service instance.`, "color: purple");
      return;
    }

    console.log(`%cWalletConnectProvider Listener Effect: Attaching listeners to service instance.`, "color: purple");

    // Define handlers
    const handleInitialized: WalletConnectServiceEvents[ServiceEvents.Initialized] = ({ success, instance }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.Initialized} received (success=${success})`, "color: purple");
      setIsInitialized(success);
      setWalletKitInstance(success ? instance : null);
      if (currentService) setActiveSessions(currentService.getActiveSessions());
      setIsInitializing(false);
      if (!success && !error) setError("Initialization failed via event");
    };
    const handlePairStatus: WalletConnectServiceEvents[ServiceEvents.PairStatus] = ({ status, message }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.PairStatus} received: ${status}`, "color: purple", message);
      setIsPairing(status === "pairing");
      if (status === "error") {
        setError(message || "Pairing failed");
        setIsPairing(false);
      } else if (status !== "pairing") {
        setError(null);
      }
    };
    const handleSessionProposal: WalletConnectServiceEvents[ServiceEvents.SessionProposal] = ({ proposal }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionProposal} received:`, "color: purple", proposal.id);
      setPendingProposal(proposal);
      setIsPairing(false);
      setError(null);
    };
    const handleSessionConnect: WalletConnectServiceEvents[ServiceEvents.SessionConnect] = ({ session }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionConnect} received:`, "color: purple", session.topic);
      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
      setIsPairing(false);
      setError(null);
      setPendingProposal(null);
    };
    // This now handles PEER disconnects or SDK internal cleanup events
    const handleSessionDelete: WalletConnectServiceEvents[ServiceEvents.SessionDelete] = ({ topic }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionDelete} received (likely from PEER) for topic:`, "color: purple", topic);
      setActiveSessions((prev) => {
        if (!prev[topic]) return prev;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { [topic]: _removed, ...rest } = prev;
        console.log(`%cProvider State: Removing session ${topic} based on SDK/PEER event.`, "color: brown");
        return rest;
      });
      setIsPairing(false);
      if (pendingProposal && pendingProposal.params.pairingTopic === topic) {
        console.log("%cProvider: Clearing pending proposal due to SDK/peer session delete event.", "color: brown");
        setPendingProposal(null);
      }
    };
    const handleSessionsUpdated: WalletConnectServiceEvents[ServiceEvents.SessionsUpdated] = ({ sessions }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionsUpdated} received`, "color: purple", sessions);
      setActiveSessions(sessions);
    };
    const handleSessionRequest: WalletConnectServiceEvents[ServiceEvents.SessionRequest] = ({ request }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.SessionRequest} received:`, "color: purple", request.id, request.params.request.method);
      if (request.params.request.method === "eth_sendTransaction") {
        setPendingRequest(request);
        setError(null);
      } else {
        console.warn(`%cProvider Listener: Received unhandled request method: ${request.params.request.method}`, "color: orange");
      }
    };
    const handleError: WalletConnectServiceEvents[ServiceEvents.Error] = ({ message }) => {
      console.error(`%cProvider Listener: ${ServiceEvents.Error} received:`, "color: red", message);
      setError(message);
      setIsPairing(false);
      setIsProcessingAction(false);
    };
    const handleIsLoading: WalletConnectServiceEvents[ServiceEvents.IS_LOADING] = ({ isLoading }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.IS_LOADING} received: ${isLoading}`, "color: purple");
      setIsProcessingAction(isLoading);
    };
    const handleIsPairing: WalletConnectServiceEvents[ServiceEvents.IS_PAIRING] = ({ isPairing }) => {
      console.log(`%cProvider Listener: ${ServiceEvents.IS_PAIRING} received: ${isPairing}`, "color: purple");
      setIsPairing(isPairing);
    };

    // Attach listeners
    currentService.on(ServiceEvents.Initialized, handleInitialized);
    currentService.on(ServiceEvents.PairStatus, handlePairStatus);
    currentService.on(ServiceEvents.SessionProposal, handleSessionProposal);
    currentService.on(ServiceEvents.SessionConnect, handleSessionConnect);
    currentService.on(ServiceEvents.SessionDelete, handleSessionDelete);
    currentService.on(ServiceEvents.SessionsUpdated, handleSessionsUpdated);
    currentService.on(ServiceEvents.Error, handleError);
    currentService.on(ServiceEvents.IS_LOADING, handleIsLoading);
    currentService.on(ServiceEvents.IS_PAIRING, handleIsPairing);
    currentService.on(ServiceEvents.SessionRequest, handleSessionRequest);

    // Cleanup function
    return () => {
      console.log("%cWalletConnectProvider Mount Effect: Cleaning up listeners.", "color: orange");
      if (currentService) {
        // Use the captured variable
        console.log("%cDetaching listeners from service instance in ref.", "color: orange");
        currentService.off(ServiceEvents.Initialized, handleInitialized);
        currentService.off(ServiceEvents.PairStatus, handlePairStatus);
        currentService.off(ServiceEvents.SessionProposal, handleSessionProposal);
        currentService.off(ServiceEvents.SessionConnect, handleSessionConnect);
        currentService.off(ServiceEvents.SessionDelete, handleSessionDelete);
        currentService.off(ServiceEvents.SessionsUpdated, handleSessionsUpdated);
        currentService.off(ServiceEvents.Error, handleError);
        currentService.off(ServiceEvents.IS_LOADING, handleIsLoading);
        currentService.off(ServiceEvents.IS_PAIRING, handleIsPairing);
        currentService.off(ServiceEvents.SessionRequest, handleSessionRequest);
      }
    };
  }, [error, pendingProposal]);

  // --- Context Methods ---
  const pair = useCallback(async (uri: string) => {
    if (!serviceRef.current?.isInitialized()) return setError("Service not initialized");
    console.log(`%cWalletConnectProvider: pair called`, "color: cyan");
    setError(null);
    await serviceRef.current.pair(uri);
  }, []);

  const approveSession = useCallback(async () => {
    if (!serviceRef.current?.isInitialized() || !pendingProposal || !lensAccountAddress) {
      const reason = !isInitialized ? "Service not ready." : !pendingProposal ? "No proposal." : "No Lens address.";
      setError(`Cannot approve: ${reason}`);
      return;
    }
    console.log(`%cWalletConnectProvider: approveSession called for proposal ${pendingProposal.id}`, "color: cyan");
    setError(null);

    try {
      const requiredNamespaces = pendingProposal.params.requiredNamespaces || {};
      const optionalNamespaces = pendingProposal.params.optionalNamespaces || {};
      const requestedMethods = [...(requiredNamespaces.eip155?.methods || []), ...(optionalNamespaces.eip155?.methods || [])];
      const requestedEvents = [...(requiredNamespaces.eip155?.events || []), ...(optionalNamespaces.eip155?.events || [])];
      const methods = requestedMethods.length > 0 ? requestedMethods : ["eth_sendTransaction", "personal_sign", "eth_signTypedData_v4"];
      const events = requestedEvents.length > 0 ? requestedEvents : ["chainChanged", "accountsChanged"];
      const approvedNamespaces = buildApprovedNamespaces({
        proposal: pendingProposal.params,
        supportedNamespaces: {
          eip155: {
            chains: [`eip155:${LENS_CHAIN_ID}`],
            methods: methods,
            events: events,
            accounts: [`eip155:${LENS_CHAIN_ID}:${lensAccountAddress}`],
          },
        },
      });

      const session = await serviceRef.current.approveSession(pendingProposal, approvedNamespaces);
      console.log(`%cWalletConnectProvider: approveSession successful, received session:`, "color: green", session);
      // Manually update state since event might not fire from SDK
      setActiveSessions((prev) => ({ ...prev, [session.topic]: session }));
      setPendingProposal(null);
      setIsPairing(false);
      setError(null);
    } catch (e) {
      console.error(`%cWalletConnectProvider: approveSession failed:`, "color: red", e);
    }
  }, [isInitialized, pendingProposal, lensAccountAddress]);

  const rejectSession = useCallback(async () => {
    if (!serviceRef.current?.isInitialized() || !pendingProposal) {
      const reason = !isInitialized ? "Service not ready." : "No proposal.";
      setError(`Cannot reject: ${reason}`);
      return;
    }
    console.log(`%cWalletConnectProvider: rejectSession called for proposal ${pendingProposal.id}`, "color: cyan");
    setError(null);
    try {
      await serviceRef.current.rejectSession(pendingProposal, getSdkError("USER_REJECTED"));
      setPendingProposal(null); // Clear proposal state immediately
    } catch (e) {
      console.error(`%cWalletConnectProvider: rejectSession failed:`, "color: red", e);
    }
  }, [isInitialized, pendingProposal]);

  // >>>>>>>> REVERTED disconnect callback <<<<<<<<
  const disconnect = useCallback(
    async (topic: string) => {
      if (!serviceRef.current?.isInitialized()) {
        setError("Service not initialized");
        console.error("WalletConnectProvider: disconnect called before service initialized.");
        return;
      }
      console.log(`%cWalletConnectProvider: disconnect called for topic ${topic}`, "color: cyan");
      setError(null);

      try {
        await serviceRef.current.disconnectSession(topic, getSdkError("USER_DISCONNECTED"));
        console.log(`%cWalletConnectProvider: disconnect service call succeeded for topic ${topic}`, "color: green");

        // Manually update the Provider's state AFTER successful call
        setActiveSessions((prev) => {
          if (!prev[topic]) {
            console.warn(`%cWalletConnectProvider: Tried to remove non-existent session ${topic} from state.`, "color: orange");
            return prev;
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          const { [topic]: _removed, ...rest } = prev;
          console.log(`%cWalletConnectProvider: Manually removing session ${topic} from state.`, "color: brown");
          return rest;
        });
        // Ensure other related states are cleared
        setIsPairing(false);
        if (pendingProposal?.params?.pairingTopic === topic) {
          console.log(`%cWalletConnectProvider: Clearing pending proposal during manual disconnect cleanup for topic ${topic}.`, "color: brown");
          setPendingProposal(null);
        }
      } catch (e) {
        console.error(`%cWalletConnectProvider: disconnect failed for topic ${topic}:`, "color: red", e);
        setError((e as Error)?.message || "Disconnect failed");
      }
    },
    [pendingProposal], // isInitialized was correctly removed previously
  );
  // >>>>>>>> ----------------------------- <<<<<<<<

  const respondRequest = useCallback(
    async (response: JsonRpcResponse) => {
      if (!serviceRef.current?.isInitialized() || !pendingRequest) {
        setError("Service not initialized or no pending request.");
        console.error("WalletConnectProvider: respondRequest called incorrectly.");
        return;
      }
      console.log(`%cWalletConnectProvider: respondRequest called for ID ${response.id}`, "color: cyan", response);
      setError(null);

      try {
        await serviceRef.current.respondSessionRequest(pendingRequest.topic, response);
        console.log(`%cWalletConnectProvider: response sent successfully for request ${response.id}`, "color: green");
      } catch (e) {
        console.error(`%cWalletConnectProvider: respondRequest failed for ID ${response.id}:`, "color: red", e);
        setError((e as Error)?.message || "Failed to send response");
      } finally {
        setPendingRequest(null);
      }
    },
    [pendingRequest], // Remove isInitialized
  );

  // --- Context Value Memoization ---
  const contextValue = useMemo(
    () => ({
      walletKitInstance,
      activeSessions,
      pendingProposal,
      pendingRequest,
      pair,
      disconnect, // Pass the reverted disconnect function
      approveSession,
      rejectSession,
      respondRequest,
      isLoading: isInitializing || isPairing || isProcessingAction,
      isInitializing,
      isPairing,
      isProcessingAction,
      error,
      isInitialized,
    }),
    [
      walletKitInstance,
      activeSessions,
      pendingProposal,
      pendingRequest,
      pair,
      disconnect, // Include reverted disconnect
      approveSession,
      rejectSession,
      respondRequest,
      isInitializing,
      isPairing,
      isProcessingAction,
      error,
      isInitialized,
    ],
  );

  if (!projectId) {
    throw new Error("WalletConnect projectId is required. Please set NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID in your environment variables.");
  }

  return projectId ? (
    <WalletConnectContext.Provider value={contextValue}>{children}</WalletConnectContext.Provider>
  ) : (
    <div>Error: WalletConnect Project ID is missing. Cannot initialize WalletConnect.</div>
  );
}

// Keep hook
export function useWalletConnect() {
  const context = useContext(WalletConnectContext);
  if (context === undefined) {
    throw new Error("useWalletConnect must be used within a WalletConnectProvider");
  }
  return context;
}

// Export the context for direct usage if needed
export { WalletConnectContext };
</file>

</files>
